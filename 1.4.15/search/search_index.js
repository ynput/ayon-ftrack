var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"ftrack integration for AYON","text":"<p>This project provides three elements for the AYON pipeline:  * server - The AYON backend Addon.  * client - The AYON desktop integration.  * services - Standalone dockerized daemons that act based on events (aka <code>leecher</code> and <code>processors</code>).</p> <p>There is a common code that can be re-used for <code>server</code>, <code>client</code> and <code>services</code>. Is located inside client code for developer mode <code>./client/ayon_ftrack/common/</code>.</p>"},{"location":"index.html#server","title":"Server","text":"<p>Once loaded into the backend, restart your server to update addons, ftrack addon will care about creation of attributes for entities. Addon must be enabled in Addon versions the plugin itself can be configured from the Project Settings page: <code>{ayon_url}/projectManager/projectSettings</code>, where you can specify your ftrack instance URL.</p>"},{"location":"index.html#settings","title":"Settings","text":"<p>Settings for services and client.</p>"},{"location":"index.html#public","title":"Public","text":"<p>Contains publicly available content, like icons. Icons are used by ftrack server to display action icons. A public is used as it does not require authentication.</p>"},{"location":"index.html#private","title":"Private","text":"<p>Primarily for client code downloadable file.</p>"},{"location":"index.html#client","title":"Client","text":"<p>Contains ftrack integration used in ayon launcher application. Contains publish plugins with logic to integrate content to ftrack like reviewables. Also contains ftrack server for user with actions that are executed inside ayon launcher application, like delivery creation, applications launch etc.</p>"},{"location":"index.html#services","title":"Services","text":"<p>Currently, there is <code>leecher</code> which stores ftrack events, <code>processor</code> which is processing them and <code>transmitter</code> which propagates changes from AYON to ftrack. Separation of <code>leecher</code> and <code>processor</code> allows to restart <code>processor</code> without loosing any events that happened meanwhile. The <code>processer</code> has nothing to process without running <code>leecher</code>. There can be multiple services running at the same time, but they all should be using same version and settings variant.</p>"},{"location":"index.html#create-package","title":"Create package","text":"<p>To create a \"server-ready\" package of the <code>server</code> folder, on a terminal, run <code>python create_package.py</code>. That will create <code>./package/ftrack {version}.zip</code> file that can be uploaded to the server.</p>"},{"location":"index.html#services_1","title":"Services","text":"<p>As mentioned there are 2 services <code>leecher</code> and <code>processor</code>. Both services have docker images that can be started from AYON server. For that there must be running a docker worker called ASH (AYON service host). Once ASH is running you can run services from AYON web UI. This is recommended approach how to run services in production.</p> <p>To run services locally (recommended only for development purposes), there are 2 possible approaches. One is by running docker image, or using prepared service tools.</p> <ul> <li><code>leecher</code> - Service that listens to ftrack events and stores them in the AYON database.</li> <li><code>processor</code> - Service that is processing ftrack events stored in the AYON database. Only one event is processed at a time.</li> </ul>"},{"location":"index.html#processor","title":"Processor","text":"<p>Processor contains multiple event handlers that handle synchronization or basic automations helpers. It also provides a way to add custom event handlers from other addons. The addon must be loaded into the server, and must be available in bundle based on variant that service is running in (\"production\", \"staging\" or dev bundle). The addon also must have prepared archive file that can be downloaded from the server.</p>"},{"location":"index.html#archive-file","title":"Archive file","text":"<p>The archive file can be a zip or tar, must contain <code>manifest.json</code> file that describes the content. The archive file must be uploaded to the server and must be available for download. The addon must implement <code>get_custom_ftrack_handlers_endpoint</code> method that returns URL to the archive file.</p> <pre><code>class SomeAddon(BaseServerAddon):\n    name = \"some_addon\"\n    version = \"1.0.0\"\n\n    def get_custom_ftrack_handlers_endpoint(self) -&gt; str:\n        return \"addons/{self.name}/{self.version}/private/ftrack_handlers.tar.gz\"\n</code></pre>"},{"location":"index.html#manifest-file","title":"Manifest file","text":"<p>Manifest file is a JSON file that describes the content of the archive file. It is used to load the content of the archive file into the processor. The file must be named <code>manifest.json</code> and must be in the root of the archive file.</p> <pre><code>{\n    \"version\": \"1.0.0\",\n    \"handler_subfolders\": [\n        \"event_handlers\"\n    ],\n    \"python_path_subfolders\": [\n        \"common\"\n    ]\n}\n</code></pre> <p>Content of manifect may change in future, to be able to track changes and keep backwards compatibilit a <code>\"version\"</code> was added. Current version is <code>\"1.0.0\"</code>.</p> <p>1.0.0 - <code>handler_subfolders</code> - List of subfolder, relative to manifest.json where files with event handlers can be found. Processor will go through all of the subfolders and import all python files that are in the subfolder. It is recommended to have only one subfolder. - <code>python_path_subfolders</code> - Optional list of subfolders, relative to manifest.json. These paths are added to <code>sys.path</code> so content inside can be imported. Can be used for \"common\" code for the event handlers. It is not recommended to add python modules because of possible conflicts with other addons, but is possible.</p>"},{"location":"index.html#start-as-docker","title":"Start as docker","text":"<p>Both services have prepared scripts to build and run docker images. There are 2 scripts <code>manage.ps1</code> for Windows and <code>Makefile</code> for Linux. Both scripts are doing the same thing and have same commands.</p>"},{"location":"index.html#commands","title":"Commands:","text":"<ul> <li><code>build</code> - Build docker image</li> <li><code>dev</code> - Run docker image in development mode (uses .env file to define AYON server credentials)</li> <li><code>dist</code> - Push docker image to docker hub (don't use this command please)</li> </ul>"},{"location":"index.html#docker-compose","title":"Docker compose","text":"<p>There are also <code>docker-compose.yml</code> files that will create a docker stack if you run <code>docker-compose up -d</code>. But run <code>build</code> command first so the image is available. </p>"},{"location":"index.html#start-with-prepared-tools-development-testing","title":"Start with prepared tools (Development &amp; Testing)","text":"<p>Tools require to have available Python 3.9. Prepared scripts can be found in <code>./service_tools</code> directory. There are 2 scripts <code>start.ps1</code> for Windows and <code>Makefile</code> for Linux. Both scripts are doing the same thing and have same commands.</p> <p>Make sure you run <code>make install</code> (linux) or <code>./start.ps1 install</code> before running any other command.</p> <p>For more information check README.</p>"},{"location":"index.html#development-testing","title":"Development &amp; Testing","text":"<p>Development and testing of this addon is complicated.</p>"},{"location":"index.html#server_1","title":"Server","text":"<p>Server code must be uploaded (like with all other addons). Run <code>python create_package.py</code> to create package that can be uploaded to the server.</p>"},{"location":"index.html#client_1","title":"Client","text":"<p>Point dev path to <code>./client/</code> folder inside the repository.</p>"},{"location":"index.html#services_2","title":"Services","text":"<p>Services can be tested in 2 ways. One is by running them locally using prepared service tools (see above).</p> <p>Second is by running them as docker containers. For that you need to have running ASH (AYON service host). Once ASH is running you can run services from AYON web UI. This is recommended approach how to run services in production. But for testing of Pull requests it is required to build the docker image manually instead of using images from docker hub. Images must be built for all services.</p>"},{"location":"index.html#windows","title":"Windows","text":"<pre><code>cd ./services/leecher\n./manage.ps1 build\n\ncd ../processor\n./manage.ps1 build\n</code></pre>"},{"location":"index.html#linux","title":"Linux","text":"<pre><code>cd ./services/leecher\nmake build\n\ncd ../processor\nmake build\n</code></pre>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_ftrack<ul> <li>common<ul> <li>constants</li> <li>custom_attributes</li> <li>event_handlers<ul> <li>ftrack_action_handler</li> <li>ftrack_base_handler</li> <li>ftrack_event_handler</li> </ul> </li> <li>exceptions</li> <li>ftrack_server</li> <li>lib</li> <li>python_module_tools</li> <li>users</li> <li>utils</li> </ul> </li> <li>event_handlers_to_convert<ul> <li>action_delete_old_versions</li> <li>action_fill_workfile_attr</li> <li>action_store_thumbnails_to_avalon</li> </ul> </li> <li>event_handlers_user<ul> <li>action_applications</li> <li>action_batch_task_creation</li> <li>action_clean_hierarchical_attributes</li> <li>action_client_review_sort</li> <li>action_component_open</li> <li>action_create_cust_attrs</li> <li>action_create_folders</li> <li>action_create_project_structure</li> <li>action_delivery</li> <li>action_download_reviews</li> <li>action_job_killer</li> <li>action_multiple_notes</li> <li>action_test</li> <li>action_thumbnail_to_childern</li> <li>action_thumbnail_to_parent</li> <li>action_where_run_ask</li> </ul> </li> <li>ftrack_addon</li> <li>launch_hooks<ul> <li>post_ftrack_changes</li> </ul> </li> <li>lib<ul> <li>credentials</li> <li>utils</li> </ul> </li> <li>pipeline<ul> <li>plugin</li> </ul> </li> <li>plugins<ul> <li>_unused_publish<ul> <li>integrate_ftrack_comments</li> </ul> </li> <li>launcher_actions<ul> <li>show_in_ftrack</li> </ul> </li> <li>publish<ul> <li>collect_custom_attributes_data</li> <li>collect_farm_env_variables</li> <li>collect_ftrack_api</li> <li>collect_ftrack_family</li> <li>collect_local_ftrack_creds</li> <li>collect_webpublisher_credentials</li> <li>integrate_ftrack_api</li> <li>integrate_ftrack_component_overwrite</li> <li>integrate_ftrack_description</li> <li>integrate_ftrack_farm_status</li> <li>integrate_ftrack_instances</li> <li>integrate_ftrack_status</li> <li>integrate_hierarchy_ftrack</li> <li>validate_custom_ftrack_attributes</li> </ul> </li> </ul> </li> <li>resources</li> <li>scripts<ul> <li>sub_user_server</li> </ul> </li> <li>tray<ul> <li>ftrack_tray</li> <li>login_dialog</li> <li>login_tools</li> <li>user_server</li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>ftrack_session</li> <li>settings<ul> <li>common</li> <li>conversions</li> <li>custom_attributes</li> <li>desktopapp_handlers</li> <li>main</li> <li>publish_plugins</li> <li>service_handlers</li> </ul> </li> </ul> </li> <li>service_tools<ul> <li>main</li> </ul> </li> <li>services<ul> <li>leecher<ul> <li>leecher<ul> <li>__main__</li> <li>listener</li> </ul> </li> </ul> </li> <li>processor<ul> <li>processor<ul> <li>__main__</li> <li>default_handlers<ul> <li>action_clone_review_session</li> <li>action_create_lists</li> <li>action_delete_entities</li> <li>action_multiple_notes</li> <li>action_prepare_project</li> <li>action_private_project_detection</li> <li>action_project_component_sizes</li> <li>action_push_frame_values_to_task</li> <li>action_sync_from_ftrack</li> <li>action_sync_users</li> <li>action_tranfer_hierarchical_values</li> <li>event_first_version_status</li> <li>event_next_task_update</li> <li>event_push_frame_values_to_task</li> <li>event_sync_comments</li> <li>event_sync_from_ftrack</li> <li>event_task_to_parent_status</li> <li>event_task_to_version_status</li> <li>event_thumbnail_updates</li> <li>event_users_sync_from_ftrack</li> <li>event_version_to_task_statuses</li> </ul> </li> <li>download_utils</li> <li>ftrack_session</li> <li>handlers_to_convert<ul> <li>action_create_review_session</li> <li>event_del_avalon_id_from_new</li> <li>event_sync_to_avalon</li> </ul> </li> <li>lib<ul> <li>sync_from_ftrack</li> </ul> </li> <li>server</li> </ul> </li> </ul> </li> <li>transmitter<ul> <li>transmitter<ul> <li>__main__</li> <li>logic</li> <li>service</li> <li>structures</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_ftrack/index.html","title":"ayon_ftrack","text":""},{"location":"autoapi/client/ayon_ftrack/index.html#client.ayon_ftrack.FtrackAddon","title":"<code>FtrackAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>ITrayAddon</code>, <code>IPluginPaths</code></p> Source code in <code>client/ayon_ftrack/ftrack_addon.py</code> <pre><code>class FtrackAddon(\n    AYONAddon,\n    ITrayAddon,\n    IPluginPaths,\n):\n    name = \"ftrack\"\n    version = __version__\n\n    def initialize(self, settings):\n        ftrack_settings = settings[self.name]\n\n        self._settings_ftrack_url = ftrack_settings[\"ftrack_server\"]\n        self._ftrack_url = _URL_NOT_SET\n\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n\n        # User event handler paths\n        user_event_handlers_paths = [\n            os.path.join(current_dir, \"event_handlers_user\")\n        ]\n\n        # Prepare attribute\n        self.user_event_handlers_paths = user_event_handlers_paths\n        self._tray_wrapper = None\n\n        # TimersManager connection\n        self.timers_manager_connector = None\n        self._timers_manager_addon = None\n\n    def webserver_initialization(self, web_manager):\n        self._tray_wrapper.webserver_initialization(web_manager)\n\n    def get_ftrack_url(self):\n        \"\"\"Resolved ftrack url.\n\n        Resolving is trying to fill missing information in url and tried to\n        connect to the server.\n\n        Returns:\n            Union[str, None]: Final variant of url or None if url could not be\n                reached.\n        \"\"\"\n\n        if self._ftrack_url is _URL_NOT_SET:\n            self._ftrack_url = resolve_ftrack_url(\n                self._settings_ftrack_url,\n                logger=self.log\n            )\n        return self._ftrack_url\n\n    ftrack_url = property(get_ftrack_url)\n\n    @property\n    def settings_ftrack_url(self):\n        \"\"\"ftrack url from settings in a format as it is.\n\n        Returns:\n            str: ftrack url from settings.\n        \"\"\"\n\n        return self._settings_ftrack_url\n\n    def get_global_environments(self):\n        \"\"\"ftrack's global environments.\"\"\"\n\n        return {\n            \"FTRACK_SERVER\": self.ftrack_url\n        }\n\n    def get_plugin_paths(self):\n        \"\"\"ftrack plugin paths.\"\"\"\n        plugins_dir = os.path.join(FTRACK_ADDON_DIR, \"plugins\")\n        return {\n            \"actions\": [os.path.join(plugins_dir, \"launcher_actions\")],\n            \"publish\": [os.path.join(plugins_dir, \"publish\")]\n        }\n\n    def get_launch_hook_paths(self):\n        \"\"\"Implementation for applications launch hooks.\"\"\"\n\n        return os.path.join(FTRACK_ADDON_DIR, \"launch_hooks\")\n\n    def connect_with_addons(self, enabled_addons):\n        for addon in enabled_addons:\n            if not hasattr(addon, \"get_ftrack_event_handler_paths\"):\n                continue\n\n            try:\n                paths_by_type = addon.get_ftrack_event_handler_paths()\n            except Exception:\n                continue\n\n            if not isinstance(paths_by_type, dict):\n                continue\n\n            for key, value in paths_by_type.items():\n                if not value:\n                    continue\n\n                if key not in (\"server\", \"user\"):\n                    self.log.warning(\n                        \"Unknown event handlers key \\\"{}\\\" skipping.\".format(\n                            key\n                        )\n                    )\n                    continue\n\n                if not isinstance(value, (list, tuple, set)):\n                    value = [value]\n\n                if key == \"user\":\n                    self.user_event_handlers_paths.extend(value)\n\n    def create_ftrack_session(self, **session_kwargs):\n        import ftrack_api\n\n        if \"server_url\" not in session_kwargs:\n            session_kwargs[\"server_url\"] = self.ftrack_url\n\n        api_key = session_kwargs.get(\"api_key\")\n        api_user = session_kwargs.get(\"api_user\")\n        # First look into environments\n        # - both AYON tray and ftrack event server should have set them\n        # - ftrack event server may crash when credentials are tried to load\n        #   from keyring\n        if not api_key or not api_user:\n            api_key = os.environ.get(\"FTRACK_API_KEY\")\n            api_user = os.environ.get(\"FTRACK_API_USER\")\n\n        if not api_key or not api_user:\n            cred = get_credentials()\n            api_user = cred.get(\"username\")\n            api_key = cred.get(\"api_key\")\n\n        session_kwargs[\"api_user\"] = api_user\n        session_kwargs[\"api_key\"] = api_key\n        return ftrack_api.Session(**session_kwargs)\n\n    def tray_init(self):\n        from .tray import FtrackTrayWrapper\n\n        self._tray_wrapper = FtrackTrayWrapper(self)\n        # Addon is it's own connector to TimersManager\n        self.timers_manager_connector = self\n\n    def tray_menu(self, parent_menu):\n        return self._tray_wrapper.tray_menu(parent_menu)\n\n    def tray_start(self):\n        return self._tray_wrapper.validate()\n\n    def tray_exit(self):\n        self._tray_wrapper.tray_exit()\n\n    def set_credentials_to_env(self, username, api_key):\n        os.environ[\"FTRACK_API_USER\"] = username or \"\"\n        os.environ[\"FTRACK_API_KEY\"] = api_key or \"\"\n\n    # --- TimersManager connection methods ---\n    def start_timer(self, data):\n        if self._tray_wrapper:\n            self._tray_wrapper.start_timer_manager(data)\n\n    def stop_timer(self):\n        if self._tray_wrapper:\n            self._tray_wrapper.stop_timer_manager()\n\n    def ensure_is_process_ready(self, context):\n        \"\"\"Ensure addon is ready for process.\n\n        Args:\n            context (ProcessContext): Process context.\n\n        \"\"\"\n        # Safe to support older ayon-core without 'ProcessPreparationError'\n        from ayon_core.addon import ProcessPreparationError\n        from ayon_ftrack.common import is_ftrack_enabled_in_settings\n\n        # Do not continue if ftrack is not enabled in settings\n        if context.project_name:\n            settings = get_project_settings(context.project_name)\n        else:\n            settings = get_studio_settings()\n\n        if not is_ftrack_enabled_in_settings(settings):\n            return\n\n        # Not sure if this should crash or silently continue?\n        server_url = self.get_ftrack_url()\n        if not server_url:\n            return\n\n        username = os.getenv(\"FTRACK_API_USER\")\n        api_key = os.getenv(\"FTRACK_API_KEY\")\n\n        if (\n            username and api_key\n            and check_credentials(username, api_key, server_url)\n        ):\n            self.set_credentials_to_env(username, api_key)\n            return\n\n        username, api_key = self.get_credentials()\n        if (\n            username and api_key\n            and check_credentials(username, api_key, server_url)\n        ):\n            self.set_credentials_to_env(username, api_key)\n            return\n\n        if context.headless:\n            raise ProcessPreparationError(\n                \"ftrack login details are missing. Unable to proceed\"\n                \" without a user interface.\"\n            )\n\n        username, api_key = self._ask_for_credentials(server_url)\n        if username and api_key:\n            self.set_credentials_to_env(username, api_key)\n            # Send the credentials to the running tray\n            save_credentials(username, api_key, self.get_ftrack_url())\n            tray_url = get_tray_server_url()\n            if tray_url:\n                requests.post(\n                    f\"{tray_url}/addons/ftrack/credentials\",\n                    json={\"username\": username, \"api_key\": api_key},\n                )\n            return\n\n        raise ProcessPreparationError(\n            \"Unable to connect to ftrack. The process cannot proceed\"\n            \" without this connection.\"\n        )\n\n    def register_timers_manager(self, timers_manager_addon):\n        self._timers_manager_addon = timers_manager_addon\n\n    def timer_started(self, data):\n        if self._timers_manager_addon is not None:\n            self._timers_manager_addon.timer_started(self.id, data)\n\n    def timer_stopped(self):\n        if self._timers_manager_addon is not None:\n            self._timers_manager_addon.timer_stopped(self.id)\n\n    def get_task_time(self, project_name, folder_path, task_name):\n        folder_entity = ayon_api.get_folder_by_path(project_name, folder_path)\n        if not folder_entity:\n            return 0\n        ftrack_id = folder_entity[\"attrib\"].get(\"ftrackId\")\n        if not ftrack_id:\n            return 0\n\n        session = self.create_ftrack_session()\n        query = (\n            'select time_logged from Task where name is \"{}\"'\n            ' and parent_id is \"{}\"'\n            ' and project.full_name is \"{}\"'\n        ).format(task_name, ftrack_id, project_name)\n        task_entity = session.query(query).first()\n        if not task_entity:\n            return 0\n        hours_logged = (task_entity[\"time_logged\"] / 60) / 60\n        return hours_logged\n\n    def get_credentials(self):\n        # type: () -&gt; tuple\n        \"\"\"Get local ftrack credentials.\"\"\"\n\n        cred = get_credentials(self.ftrack_url)\n        return cred.get(\"username\"), cred.get(\"api_key\")\n\n    @staticmethod\n    def _ask_for_credentials(ftrack_url):\n        login_script = os.path.join(\n            FTRACK_ADDON_DIR, \"tray\", \"login_dialog.py\"\n        )\n        with tempfile.NamedTemporaryFile(\n            mode=\"w\", prefix=\"ay_ftrack\", suffix=\".json\", delete=False\n        ) as tmp:\n            json_path = tmp.name\n            json.dump({\"server_url\": ftrack_url}, tmp.file)\n\n        run_ayon_launcher_process(\n            \"--skip-bootstrap\",\n            login_script, json_path,\n            add_sys_paths=True,\n            creationflags=0,\n\n        )\n\n        with open(json_path, \"r\") as stream:\n            data = json.load(stream)\n        return data.get(\"username\"), data.get(\"api_key\")\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/index.html#client.ayon_ftrack.FtrackAddon.settings_ftrack_url","title":"<code>settings_ftrack_url</code>  <code>property</code>","text":"<p>ftrack url from settings in a format as it is.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>ftrack url from settings.</p>"},{"location":"autoapi/client/ayon_ftrack/index.html#client.ayon_ftrack.FtrackAddon.ensure_is_process_ready","title":"<code>ensure_is_process_ready(context)</code>","text":"<p>Ensure addon is ready for process.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>ProcessContext</code> <p>Process context.</p> required Source code in <code>client/ayon_ftrack/ftrack_addon.py</code> <pre><code>def ensure_is_process_ready(self, context):\n    \"\"\"Ensure addon is ready for process.\n\n    Args:\n        context (ProcessContext): Process context.\n\n    \"\"\"\n    # Safe to support older ayon-core without 'ProcessPreparationError'\n    from ayon_core.addon import ProcessPreparationError\n    from ayon_ftrack.common import is_ftrack_enabled_in_settings\n\n    # Do not continue if ftrack is not enabled in settings\n    if context.project_name:\n        settings = get_project_settings(context.project_name)\n    else:\n        settings = get_studio_settings()\n\n    if not is_ftrack_enabled_in_settings(settings):\n        return\n\n    # Not sure if this should crash or silently continue?\n    server_url = self.get_ftrack_url()\n    if not server_url:\n        return\n\n    username = os.getenv(\"FTRACK_API_USER\")\n    api_key = os.getenv(\"FTRACK_API_KEY\")\n\n    if (\n        username and api_key\n        and check_credentials(username, api_key, server_url)\n    ):\n        self.set_credentials_to_env(username, api_key)\n        return\n\n    username, api_key = self.get_credentials()\n    if (\n        username and api_key\n        and check_credentials(username, api_key, server_url)\n    ):\n        self.set_credentials_to_env(username, api_key)\n        return\n\n    if context.headless:\n        raise ProcessPreparationError(\n            \"ftrack login details are missing. Unable to proceed\"\n            \" without a user interface.\"\n        )\n\n    username, api_key = self._ask_for_credentials(server_url)\n    if username and api_key:\n        self.set_credentials_to_env(username, api_key)\n        # Send the credentials to the running tray\n        save_credentials(username, api_key, self.get_ftrack_url())\n        tray_url = get_tray_server_url()\n        if tray_url:\n            requests.post(\n                f\"{tray_url}/addons/ftrack/credentials\",\n                json={\"username\": username, \"api_key\": api_key},\n            )\n        return\n\n    raise ProcessPreparationError(\n        \"Unable to connect to ftrack. The process cannot proceed\"\n        \" without this connection.\"\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/index.html#client.ayon_ftrack.FtrackAddon.get_credentials","title":"<code>get_credentials()</code>","text":"<p>Get local ftrack credentials.</p> Source code in <code>client/ayon_ftrack/ftrack_addon.py</code> <pre><code>def get_credentials(self):\n    # type: () -&gt; tuple\n    \"\"\"Get local ftrack credentials.\"\"\"\n\n    cred = get_credentials(self.ftrack_url)\n    return cred.get(\"username\"), cred.get(\"api_key\")\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/index.html#client.ayon_ftrack.FtrackAddon.get_ftrack_url","title":"<code>get_ftrack_url()</code>","text":"<p>Resolved ftrack url.</p> <p>Resolving is trying to fill missing information in url and tried to connect to the server.</p> <p>Returns:</p> Type Description <p>Union[str, None]: Final variant of url or None if url could not be reached.</p> Source code in <code>client/ayon_ftrack/ftrack_addon.py</code> <pre><code>def get_ftrack_url(self):\n    \"\"\"Resolved ftrack url.\n\n    Resolving is trying to fill missing information in url and tried to\n    connect to the server.\n\n    Returns:\n        Union[str, None]: Final variant of url or None if url could not be\n            reached.\n    \"\"\"\n\n    if self._ftrack_url is _URL_NOT_SET:\n        self._ftrack_url = resolve_ftrack_url(\n            self._settings_ftrack_url,\n            logger=self.log\n        )\n    return self._ftrack_url\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/index.html#client.ayon_ftrack.FtrackAddon.get_global_environments","title":"<code>get_global_environments()</code>","text":"<p>ftrack's global environments.</p> Source code in <code>client/ayon_ftrack/ftrack_addon.py</code> <pre><code>def get_global_environments(self):\n    \"\"\"ftrack's global environments.\"\"\"\n\n    return {\n        \"FTRACK_SERVER\": self.ftrack_url\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/index.html#client.ayon_ftrack.FtrackAddon.get_launch_hook_paths","title":"<code>get_launch_hook_paths()</code>","text":"<p>Implementation for applications launch hooks.</p> Source code in <code>client/ayon_ftrack/ftrack_addon.py</code> <pre><code>def get_launch_hook_paths(self):\n    \"\"\"Implementation for applications launch hooks.\"\"\"\n\n    return os.path.join(FTRACK_ADDON_DIR, \"launch_hooks\")\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/index.html#client.ayon_ftrack.FtrackAddon.get_plugin_paths","title":"<code>get_plugin_paths()</code>","text":"<p>ftrack plugin paths.</p> Source code in <code>client/ayon_ftrack/ftrack_addon.py</code> <pre><code>def get_plugin_paths(self):\n    \"\"\"ftrack plugin paths.\"\"\"\n    plugins_dir = os.path.join(FTRACK_ADDON_DIR, \"plugins\")\n    return {\n        \"actions\": [os.path.join(plugins_dir, \"launcher_actions\")],\n        \"publish\": [os.path.join(plugins_dir, \"publish\")]\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/index.html#client.ayon_ftrack.resolve_ftrack_url","title":"<code>resolve_ftrack_url(url, logger=None)</code>","text":"<p>Checks if ftrack server is responding.</p> Source code in <code>client/ayon_ftrack/ftrack_addon.py</code> <pre><code>def resolve_ftrack_url(url, logger=None):\n    \"\"\"Checks if ftrack server is responding.\"\"\"\n\n    if logger is None:\n        logger = Logger.get_logger(__name__)\n\n    url = url.strip(\"/ \")\n    if not url:\n        logger.error(\"ftrack URL is not set!\")\n        return None\n\n    if not url.startswith(\"http\"):\n        url = \"https://\" + url\n\n    ftrack_url = None\n    if url and _check_ftrack_url(url):\n        ftrack_url = url\n\n    if not ftrack_url and not url.endswith(\"ftrackapp.com\"):\n        ftrackapp_url = url + \".ftrackapp.com\"\n        if _check_ftrack_url(ftrackapp_url):\n            ftrack_url = ftrackapp_url\n\n    if not ftrack_url and _check_ftrack_url(url):\n        ftrack_url = url\n\n    if ftrack_url:\n        logger.debug(\"ftrack server \\\"{}\\\" is accessible.\".format(ftrack_url))\n\n    else:\n        logger.error(\"ftrack server \\\"{}\\\" is not accessible!\".format(url))\n\n    return ftrack_url\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/ftrack_addon.html","title":"ftrack_addon","text":""},{"location":"autoapi/client/ayon_ftrack/ftrack_addon.html#client.ayon_ftrack.ftrack_addon.FtrackAddon","title":"<code>FtrackAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>ITrayAddon</code>, <code>IPluginPaths</code></p> Source code in <code>client/ayon_ftrack/ftrack_addon.py</code> <pre><code>class FtrackAddon(\n    AYONAddon,\n    ITrayAddon,\n    IPluginPaths,\n):\n    name = \"ftrack\"\n    version = __version__\n\n    def initialize(self, settings):\n        ftrack_settings = settings[self.name]\n\n        self._settings_ftrack_url = ftrack_settings[\"ftrack_server\"]\n        self._ftrack_url = _URL_NOT_SET\n\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n\n        # User event handler paths\n        user_event_handlers_paths = [\n            os.path.join(current_dir, \"event_handlers_user\")\n        ]\n\n        # Prepare attribute\n        self.user_event_handlers_paths = user_event_handlers_paths\n        self._tray_wrapper = None\n\n        # TimersManager connection\n        self.timers_manager_connector = None\n        self._timers_manager_addon = None\n\n    def webserver_initialization(self, web_manager):\n        self._tray_wrapper.webserver_initialization(web_manager)\n\n    def get_ftrack_url(self):\n        \"\"\"Resolved ftrack url.\n\n        Resolving is trying to fill missing information in url and tried to\n        connect to the server.\n\n        Returns:\n            Union[str, None]: Final variant of url or None if url could not be\n                reached.\n        \"\"\"\n\n        if self._ftrack_url is _URL_NOT_SET:\n            self._ftrack_url = resolve_ftrack_url(\n                self._settings_ftrack_url,\n                logger=self.log\n            )\n        return self._ftrack_url\n\n    ftrack_url = property(get_ftrack_url)\n\n    @property\n    def settings_ftrack_url(self):\n        \"\"\"ftrack url from settings in a format as it is.\n\n        Returns:\n            str: ftrack url from settings.\n        \"\"\"\n\n        return self._settings_ftrack_url\n\n    def get_global_environments(self):\n        \"\"\"ftrack's global environments.\"\"\"\n\n        return {\n            \"FTRACK_SERVER\": self.ftrack_url\n        }\n\n    def get_plugin_paths(self):\n        \"\"\"ftrack plugin paths.\"\"\"\n        plugins_dir = os.path.join(FTRACK_ADDON_DIR, \"plugins\")\n        return {\n            \"actions\": [os.path.join(plugins_dir, \"launcher_actions\")],\n            \"publish\": [os.path.join(plugins_dir, \"publish\")]\n        }\n\n    def get_launch_hook_paths(self):\n        \"\"\"Implementation for applications launch hooks.\"\"\"\n\n        return os.path.join(FTRACK_ADDON_DIR, \"launch_hooks\")\n\n    def connect_with_addons(self, enabled_addons):\n        for addon in enabled_addons:\n            if not hasattr(addon, \"get_ftrack_event_handler_paths\"):\n                continue\n\n            try:\n                paths_by_type = addon.get_ftrack_event_handler_paths()\n            except Exception:\n                continue\n\n            if not isinstance(paths_by_type, dict):\n                continue\n\n            for key, value in paths_by_type.items():\n                if not value:\n                    continue\n\n                if key not in (\"server\", \"user\"):\n                    self.log.warning(\n                        \"Unknown event handlers key \\\"{}\\\" skipping.\".format(\n                            key\n                        )\n                    )\n                    continue\n\n                if not isinstance(value, (list, tuple, set)):\n                    value = [value]\n\n                if key == \"user\":\n                    self.user_event_handlers_paths.extend(value)\n\n    def create_ftrack_session(self, **session_kwargs):\n        import ftrack_api\n\n        if \"server_url\" not in session_kwargs:\n            session_kwargs[\"server_url\"] = self.ftrack_url\n\n        api_key = session_kwargs.get(\"api_key\")\n        api_user = session_kwargs.get(\"api_user\")\n        # First look into environments\n        # - both AYON tray and ftrack event server should have set them\n        # - ftrack event server may crash when credentials are tried to load\n        #   from keyring\n        if not api_key or not api_user:\n            api_key = os.environ.get(\"FTRACK_API_KEY\")\n            api_user = os.environ.get(\"FTRACK_API_USER\")\n\n        if not api_key or not api_user:\n            cred = get_credentials()\n            api_user = cred.get(\"username\")\n            api_key = cred.get(\"api_key\")\n\n        session_kwargs[\"api_user\"] = api_user\n        session_kwargs[\"api_key\"] = api_key\n        return ftrack_api.Session(**session_kwargs)\n\n    def tray_init(self):\n        from .tray import FtrackTrayWrapper\n\n        self._tray_wrapper = FtrackTrayWrapper(self)\n        # Addon is it's own connector to TimersManager\n        self.timers_manager_connector = self\n\n    def tray_menu(self, parent_menu):\n        return self._tray_wrapper.tray_menu(parent_menu)\n\n    def tray_start(self):\n        return self._tray_wrapper.validate()\n\n    def tray_exit(self):\n        self._tray_wrapper.tray_exit()\n\n    def set_credentials_to_env(self, username, api_key):\n        os.environ[\"FTRACK_API_USER\"] = username or \"\"\n        os.environ[\"FTRACK_API_KEY\"] = api_key or \"\"\n\n    # --- TimersManager connection methods ---\n    def start_timer(self, data):\n        if self._tray_wrapper:\n            self._tray_wrapper.start_timer_manager(data)\n\n    def stop_timer(self):\n        if self._tray_wrapper:\n            self._tray_wrapper.stop_timer_manager()\n\n    def ensure_is_process_ready(self, context):\n        \"\"\"Ensure addon is ready for process.\n\n        Args:\n            context (ProcessContext): Process context.\n\n        \"\"\"\n        # Safe to support older ayon-core without 'ProcessPreparationError'\n        from ayon_core.addon import ProcessPreparationError\n        from ayon_ftrack.common import is_ftrack_enabled_in_settings\n\n        # Do not continue if ftrack is not enabled in settings\n        if context.project_name:\n            settings = get_project_settings(context.project_name)\n        else:\n            settings = get_studio_settings()\n\n        if not is_ftrack_enabled_in_settings(settings):\n            return\n\n        # Not sure if this should crash or silently continue?\n        server_url = self.get_ftrack_url()\n        if not server_url:\n            return\n\n        username = os.getenv(\"FTRACK_API_USER\")\n        api_key = os.getenv(\"FTRACK_API_KEY\")\n\n        if (\n            username and api_key\n            and check_credentials(username, api_key, server_url)\n        ):\n            self.set_credentials_to_env(username, api_key)\n            return\n\n        username, api_key = self.get_credentials()\n        if (\n            username and api_key\n            and check_credentials(username, api_key, server_url)\n        ):\n            self.set_credentials_to_env(username, api_key)\n            return\n\n        if context.headless:\n            raise ProcessPreparationError(\n                \"ftrack login details are missing. Unable to proceed\"\n                \" without a user interface.\"\n            )\n\n        username, api_key = self._ask_for_credentials(server_url)\n        if username and api_key:\n            self.set_credentials_to_env(username, api_key)\n            # Send the credentials to the running tray\n            save_credentials(username, api_key, self.get_ftrack_url())\n            tray_url = get_tray_server_url()\n            if tray_url:\n                requests.post(\n                    f\"{tray_url}/addons/ftrack/credentials\",\n                    json={\"username\": username, \"api_key\": api_key},\n                )\n            return\n\n        raise ProcessPreparationError(\n            \"Unable to connect to ftrack. The process cannot proceed\"\n            \" without this connection.\"\n        )\n\n    def register_timers_manager(self, timers_manager_addon):\n        self._timers_manager_addon = timers_manager_addon\n\n    def timer_started(self, data):\n        if self._timers_manager_addon is not None:\n            self._timers_manager_addon.timer_started(self.id, data)\n\n    def timer_stopped(self):\n        if self._timers_manager_addon is not None:\n            self._timers_manager_addon.timer_stopped(self.id)\n\n    def get_task_time(self, project_name, folder_path, task_name):\n        folder_entity = ayon_api.get_folder_by_path(project_name, folder_path)\n        if not folder_entity:\n            return 0\n        ftrack_id = folder_entity[\"attrib\"].get(\"ftrackId\")\n        if not ftrack_id:\n            return 0\n\n        session = self.create_ftrack_session()\n        query = (\n            'select time_logged from Task where name is \"{}\"'\n            ' and parent_id is \"{}\"'\n            ' and project.full_name is \"{}\"'\n        ).format(task_name, ftrack_id, project_name)\n        task_entity = session.query(query).first()\n        if not task_entity:\n            return 0\n        hours_logged = (task_entity[\"time_logged\"] / 60) / 60\n        return hours_logged\n\n    def get_credentials(self):\n        # type: () -&gt; tuple\n        \"\"\"Get local ftrack credentials.\"\"\"\n\n        cred = get_credentials(self.ftrack_url)\n        return cred.get(\"username\"), cred.get(\"api_key\")\n\n    @staticmethod\n    def _ask_for_credentials(ftrack_url):\n        login_script = os.path.join(\n            FTRACK_ADDON_DIR, \"tray\", \"login_dialog.py\"\n        )\n        with tempfile.NamedTemporaryFile(\n            mode=\"w\", prefix=\"ay_ftrack\", suffix=\".json\", delete=False\n        ) as tmp:\n            json_path = tmp.name\n            json.dump({\"server_url\": ftrack_url}, tmp.file)\n\n        run_ayon_launcher_process(\n            \"--skip-bootstrap\",\n            login_script, json_path,\n            add_sys_paths=True,\n            creationflags=0,\n\n        )\n\n        with open(json_path, \"r\") as stream:\n            data = json.load(stream)\n        return data.get(\"username\"), data.get(\"api_key\")\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/ftrack_addon.html#client.ayon_ftrack.ftrack_addon.FtrackAddon.settings_ftrack_url","title":"<code>settings_ftrack_url</code>  <code>property</code>","text":"<p>ftrack url from settings in a format as it is.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>ftrack url from settings.</p>"},{"location":"autoapi/client/ayon_ftrack/ftrack_addon.html#client.ayon_ftrack.ftrack_addon.FtrackAddon.ensure_is_process_ready","title":"<code>ensure_is_process_ready(context)</code>","text":"<p>Ensure addon is ready for process.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>ProcessContext</code> <p>Process context.</p> required Source code in <code>client/ayon_ftrack/ftrack_addon.py</code> <pre><code>def ensure_is_process_ready(self, context):\n    \"\"\"Ensure addon is ready for process.\n\n    Args:\n        context (ProcessContext): Process context.\n\n    \"\"\"\n    # Safe to support older ayon-core without 'ProcessPreparationError'\n    from ayon_core.addon import ProcessPreparationError\n    from ayon_ftrack.common import is_ftrack_enabled_in_settings\n\n    # Do not continue if ftrack is not enabled in settings\n    if context.project_name:\n        settings = get_project_settings(context.project_name)\n    else:\n        settings = get_studio_settings()\n\n    if not is_ftrack_enabled_in_settings(settings):\n        return\n\n    # Not sure if this should crash or silently continue?\n    server_url = self.get_ftrack_url()\n    if not server_url:\n        return\n\n    username = os.getenv(\"FTRACK_API_USER\")\n    api_key = os.getenv(\"FTRACK_API_KEY\")\n\n    if (\n        username and api_key\n        and check_credentials(username, api_key, server_url)\n    ):\n        self.set_credentials_to_env(username, api_key)\n        return\n\n    username, api_key = self.get_credentials()\n    if (\n        username and api_key\n        and check_credentials(username, api_key, server_url)\n    ):\n        self.set_credentials_to_env(username, api_key)\n        return\n\n    if context.headless:\n        raise ProcessPreparationError(\n            \"ftrack login details are missing. Unable to proceed\"\n            \" without a user interface.\"\n        )\n\n    username, api_key = self._ask_for_credentials(server_url)\n    if username and api_key:\n        self.set_credentials_to_env(username, api_key)\n        # Send the credentials to the running tray\n        save_credentials(username, api_key, self.get_ftrack_url())\n        tray_url = get_tray_server_url()\n        if tray_url:\n            requests.post(\n                f\"{tray_url}/addons/ftrack/credentials\",\n                json={\"username\": username, \"api_key\": api_key},\n            )\n        return\n\n    raise ProcessPreparationError(\n        \"Unable to connect to ftrack. The process cannot proceed\"\n        \" without this connection.\"\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/ftrack_addon.html#client.ayon_ftrack.ftrack_addon.FtrackAddon.get_credentials","title":"<code>get_credentials()</code>","text":"<p>Get local ftrack credentials.</p> Source code in <code>client/ayon_ftrack/ftrack_addon.py</code> <pre><code>def get_credentials(self):\n    # type: () -&gt; tuple\n    \"\"\"Get local ftrack credentials.\"\"\"\n\n    cred = get_credentials(self.ftrack_url)\n    return cred.get(\"username\"), cred.get(\"api_key\")\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/ftrack_addon.html#client.ayon_ftrack.ftrack_addon.FtrackAddon.get_ftrack_url","title":"<code>get_ftrack_url()</code>","text":"<p>Resolved ftrack url.</p> <p>Resolving is trying to fill missing information in url and tried to connect to the server.</p> <p>Returns:</p> Type Description <p>Union[str, None]: Final variant of url or None if url could not be reached.</p> Source code in <code>client/ayon_ftrack/ftrack_addon.py</code> <pre><code>def get_ftrack_url(self):\n    \"\"\"Resolved ftrack url.\n\n    Resolving is trying to fill missing information in url and tried to\n    connect to the server.\n\n    Returns:\n        Union[str, None]: Final variant of url or None if url could not be\n            reached.\n    \"\"\"\n\n    if self._ftrack_url is _URL_NOT_SET:\n        self._ftrack_url = resolve_ftrack_url(\n            self._settings_ftrack_url,\n            logger=self.log\n        )\n    return self._ftrack_url\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/ftrack_addon.html#client.ayon_ftrack.ftrack_addon.FtrackAddon.get_global_environments","title":"<code>get_global_environments()</code>","text":"<p>ftrack's global environments.</p> Source code in <code>client/ayon_ftrack/ftrack_addon.py</code> <pre><code>def get_global_environments(self):\n    \"\"\"ftrack's global environments.\"\"\"\n\n    return {\n        \"FTRACK_SERVER\": self.ftrack_url\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/ftrack_addon.html#client.ayon_ftrack.ftrack_addon.FtrackAddon.get_launch_hook_paths","title":"<code>get_launch_hook_paths()</code>","text":"<p>Implementation for applications launch hooks.</p> Source code in <code>client/ayon_ftrack/ftrack_addon.py</code> <pre><code>def get_launch_hook_paths(self):\n    \"\"\"Implementation for applications launch hooks.\"\"\"\n\n    return os.path.join(FTRACK_ADDON_DIR, \"launch_hooks\")\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/ftrack_addon.html#client.ayon_ftrack.ftrack_addon.FtrackAddon.get_plugin_paths","title":"<code>get_plugin_paths()</code>","text":"<p>ftrack plugin paths.</p> Source code in <code>client/ayon_ftrack/ftrack_addon.py</code> <pre><code>def get_plugin_paths(self):\n    \"\"\"ftrack plugin paths.\"\"\"\n    plugins_dir = os.path.join(FTRACK_ADDON_DIR, \"plugins\")\n    return {\n        \"actions\": [os.path.join(plugins_dir, \"launcher_actions\")],\n        \"publish\": [os.path.join(plugins_dir, \"publish\")]\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/ftrack_addon.html#client.ayon_ftrack.ftrack_addon.resolve_ftrack_url","title":"<code>resolve_ftrack_url(url, logger=None)</code>","text":"<p>Checks if ftrack server is responding.</p> Source code in <code>client/ayon_ftrack/ftrack_addon.py</code> <pre><code>def resolve_ftrack_url(url, logger=None):\n    \"\"\"Checks if ftrack server is responding.\"\"\"\n\n    if logger is None:\n        logger = Logger.get_logger(__name__)\n\n    url = url.strip(\"/ \")\n    if not url:\n        logger.error(\"ftrack URL is not set!\")\n        return None\n\n    if not url.startswith(\"http\"):\n        url = \"https://\" + url\n\n    ftrack_url = None\n    if url and _check_ftrack_url(url):\n        ftrack_url = url\n\n    if not ftrack_url and not url.endswith(\"ftrackapp.com\"):\n        ftrackapp_url = url + \".ftrackapp.com\"\n        if _check_ftrack_url(ftrackapp_url):\n            ftrack_url = ftrackapp_url\n\n    if not ftrack_url and _check_ftrack_url(url):\n        ftrack_url = url\n\n    if ftrack_url:\n        logger.debug(\"ftrack server \\\"{}\\\" is accessible.\".format(ftrack_url))\n\n    else:\n        logger.error(\"ftrack server \\\"{}\\\" is not accessible!\".format(url))\n\n    return ftrack_url\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/version.html","title":"version","text":"<p>Package declaring AYON addon 'ftrack' version.</p>"},{"location":"autoapi/client/ayon_ftrack/common/index.html","title":"common","text":"<p>ftrack common functions that can be used in ftrack services or on client.</p> <p>Most of the functionality is usable at multiple places and would require to be duplicated.</p> <p>It is expected content of this folder is copied to place from which will be process able to import them.</p>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseAction","title":"<code>BaseAction</code>","text":"<p>               Bases: <code>BaseHandler</code></p> <p>Custom Action base class.</p> <p>Simplify action discovery and launch. This implementation represents single action with single callback. To change the behavior implement custom callbacks or override '_discover' and '_launch' methods.</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>Label of action of group name of action. Can be combined with 'variant' attribute.</p> <code>variant</code> <code>str</code> <p>Variant under 'label'. Can be combined with 'label' e.g. when 'label' is \"Admin\" and variant is \"Kill jobs\". In case there is more variants for \"Admin\" label they'll grouped in ftrack UI widgets.</p> <code>identifier</code> <code>str</code> <p>Action identifier. Is used to trigger the launch logic of action.</p> <code>icon</code> <code>str</code> <p>Url to icon (Browser which should show the icon must have access to the resource).</p> <code>description</code> <code>str</code> <p>Hint of action which is showed to user hovering over the action.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Connected ftrack session.</p> required Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>class BaseAction(BaseHandler):\n    \"\"\"Custom Action base class.\n\n    Simplify action discovery and launch. This implementation represents\n    single action with single callback. To change the behavior implement\n    custom callbacks or override '_discover' and '_launch' methods.\n\n    Attributes:\n        label (str): Label of action of group name of action. Can be combined\n            with 'variant' attribute.\n        variant (str): Variant under 'label'. Can be combined with 'label' e.g.\n            when 'label' is \"Admin\" and variant is \"Kill jobs\". In case\n            there is more variants for \"Admin\" label they'll grouped in ftrack\n            UI widgets.\n        identifier (str): Action identifier. Is used to trigger the launch\n            logic of action.\n        icon (str): Url to icon (Browser which should show the icon must have\n            access to the resource).\n        description (str): Hint of action which is showed to user hovering\n            over the action.\n\n    Args:\n        session (ftrack_api.Session): Connected ftrack session.\n\n    \"\"\"\n    __ignore_handler_class = True\n\n    label: Optional[str] = None\n    variant: Optional[str] = None\n    identifier: Optional[str] = None\n    description: Optional[str] = None\n    icon: Optional[str] = None\n    handler_type: str = \"Action\"\n    preactions: List[str] = []\n\n    _full_label: Optional[str] = None\n    _discover_identifier: Optional[str] = None\n    _launch_identifier: Optional[str] = None\n\n    settings_frack_subkey: str = \"user_handlers\"\n    settings_enabled_key: str = \"enabled\"\n\n    def __init__(self, session: ftrack_api.Session):\n        # Validate minimum requirements\n        if not self.label:\n            raise ValueError(\"Action missing 'label'.\")\n\n        if not self.identifier:\n            raise ValueError(\"Action missing 'identifier'.\")\n\n        super().__init__(session)\n        self.setup_launch_wrapper()\n\n    def setup_launch_wrapper(self):\n        self._launch = self.launch_wrapper(self._launch)\n\n    @property\n    def discover_identifier(self) -&gt; str:\n        return self.identifier\n\n    @property\n    def launch_identifier(self) -&gt; str:\n        return self.identifier\n\n    @property\n    def handler_label(self) -&gt; str:\n        return self.full_label\n\n    @property\n    def full_label(self) -&gt; str:\n        \"\"\"Full label of action.\n\n        Value of full label is cached.\n\n        Returns:\n            str: Label created from 'label' and 'variant' attributes.\n\n        \"\"\"\n        if self._full_label is None:\n            if self.variant:\n                label = \"{} {}\".format(self.label, self.variant)\n            else:\n                label = self.label\n            self._full_label = label\n        return self._full_label\n\n    def register(self):\n        \"\"\"Register to ftrack topics to discover and launch action.\"\"\"\n        self.session.event_hub.subscribe(\n            \"topic=ftrack.action.discover\",\n            self._discover,\n            priority=self.priority\n        )\n\n        launch_subscription = (\n            \"topic=ftrack.action.launch and data.actionIdentifier={}\"\n        ).format(self.launch_identifier)\n        self.session.event_hub.subscribe(launch_subscription, self._launch)\n\n    def _translate_event(\n        self,\n        event: ftrack_api.event.base.Event,\n        session: Optional[ftrack_api.Session] = None\n    ) -&gt; List[ftrack_api.entity.base.Entity]:\n        \"\"\"Translate event to receive entities based on it's data.\"\"\"\n        if session is None:\n            session = self.session\n\n        _entities = event[\"data\"].get(\"entities_object\", None)\n        if _entities is not None and not _entities:\n            return _entities\n\n        if (\n            _entities is None\n            or _entities[0].get(\"link\") == ftrack_api.symbol.NOT_SET\n        ):\n            _entities = [\n                item\n                for item in self._get_entities(\n                    event,\n                    session=session,\n                    ignore={\"socialfeed\", \"socialnotification\", \"team\"}\n                )\n                if item is not None\n            ]\n            event[\"data\"][\"entities_object\"] = _entities\n\n        return _entities\n\n    def _discover(\n        self, event: ftrack_api.event.base.Event\n    ) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Decide if and how will be action showed to user in ftrack.\n\n        Args:\n            event (ftrack_api.Event): Event with topic which triggered this\n                callback.\n\n        Returns:\n            Union[None, Dict[str, Any]]: None if action is not returned\n                otherwise returns items to show in UI (structure of items is\n                defined by ftrack and can be found in documentation).\n\n        \"\"\"\n        entities = self._translate_event(event)\n        if not entities:\n            return None\n\n        accepts = self.discover(self.session, entities, event)\n        if not accepts:\n            return None\n\n        self.log.debug(\"Discovering action with selection: {}\".format(\n            event[\"data\"].get(\"selection\") or []\n        ))\n\n        return {\n            \"items\": [{\n                \"label\": self.label,\n                \"variant\": self.variant,\n                \"description\": self.description,\n                \"actionIdentifier\": self.discover_identifier,\n                \"icon\": self.icon,\n            }]\n        }\n\n    def discover(\n        self,\n        session: ftrack_api.Session,\n        entities: List[ftrack_api.entity.base.Entity],\n        event: ftrack_api.event.base.Event,\n    ) -&gt; bool:\n        \"\"\"Decide if action is showed to used based on event data.\n\n        Action should override the method to implement logic to show the\n        action. The most common logic is based on combination of user roles\n        and selected entities.\n\n        Args:\n            session (ftrack_api.Session): Session which triggered callback of\n                the event.\n            entities (List[Any]): Prepared list of entities from event data.\n            event (ftrack_api.Event): ftrack event which caused this callback\n                is triggered.\n\n        Returns:\n            bool: True if action should be returned.\n\n        \"\"\"\n        return False\n\n    def _handle_preactions(\n        self, session: ftrack_api.Session, event: ftrack_api.event.base.Event\n    ) -&gt; bool:\n        \"\"\"Launch actions before launching this action.\n\n        Concept came from Pype and got deprecated (and used) over time. Should\n        be probably removed.\n\n        Note:\n            Added warning log that this functionlity is deprecated and will\n                be removed in the future.\n\n        Args:\n            session (ftrack_api.Session): ftrack session.\n            event (ftrack_api.Event): Event which triggered launch of this\n                action.\n\n        Returns:\n            bool: Preactions were launched or not.\n\n        Deprecated:\n            Preactions are marked as deprecated. Server actions should not\n                use preactions and local actions use local identifier which\n                is hard to handle automatically\n\n        \"\"\"\n        # If preactions are not set\n        if len(self.preactions) == 0:\n            return True\n\n        if not event.get(\"data\", {}).get(\"selection\"):\n            return False\n\n        # If preactions were already started\n        if event[\"data\"].get(\"preactions_launched\") is True:\n            return True\n\n        self.log.warning((\n            \"DEPRECATION WARNING: Action \\\"{}\\\" is using 'preactions'\"\n            \" which are deprecated and will be removed Q2 2023.\"\n        ).format(self.full_label))\n\n        # Launch preactions\n        for preaction in self.preactions:\n            self.trigger_action(preaction, event)\n\n        # Relaunch this action\n        self.trigger_action(\n            self.launch_identifier,\n            event,\n            additional_event_data={\"preactions_launched\": True}\n        )\n        return False\n\n    def launch_wrapper(self, func):\n        @functools.wraps(func)\n        def wrapper_func(*args, **kwargs):\n            self.log.info(\"{} \\\"{}\\\": Launched\".format(\n                self.handler_type, self.full_label\n            ))\n\n            try:\n                output = func(*args, **kwargs)\n                self.log.info(\"{} \\\"{}\\\": Finished\".format(\n                    self.handler_type, self.full_label\n                ))\n\n            except BaseException as exc:\n                self.session.rollback()\n                self.session._configure_locations()\n                msg = \"{} \\\"{}\\\": Failed ({})\".format(\n                    self.handler_type, self.full_label, str(exc))\n                self.log.error(msg, exc_info=True)\n                output = {\n                    \"success\": False,\n                    \"message\": msg\n                }\n\n            return output\n        return wrapper_func\n\n    def _launch(\n        self, event: ftrack_api.event.base.Event\n    ) -&gt; Optional[Dict[str, Any]]:\n        entities = self._translate_event(event)\n        if not entities:\n            return\n\n        preactions_launched = self._handle_preactions(self.session, event)\n        if preactions_launched is False:\n            return\n\n        interface = self._interface(self.session, entities, event)\n        if interface:\n            return interface\n\n        response = self.launch(self.session, entities, event)\n\n        return self._handle_result(response)\n\n    def launch(\n        self,\n        session: ftrack_api.Session,\n        entities: List[ftrack_api.entity.base.Entity],\n        event: ftrack_api.event.base.Event\n    ) -&gt; Optional[Union[bool, Dict[str, Any]]]:\n        \"\"\"Main part of handling event callback.\n\n        Args:\n            session (ftrack_api.Session): Session which queried entities.\n            entities (List[Any]): Prequeried entities based on event data.\n            event (ftrack_api.Event): ftrack event to process.\n\n        Returns:\n            Union[bool, Dict[str, Any]]: True or false for success or fail,\n                or more complex data structure e.g. to show interface to user.\n\n        \"\"\"\n        raise NotImplementedError()\n\n    def _interface(\n        self,\n        session: ftrack_api.Session,\n        entities: List[ftrack_api.entity.base.Entity],\n        event: ftrack_api.event.base.Event\n    ) -&gt; Optional[Dict[str, Any]]:\n        interface = self.interface(session, entities, event)\n        if not interface:\n            return\n\n        if isinstance(interface, (tuple, list)):\n            return {\"items\": interface}\n\n        if isinstance(interface, dict):\n            if (\n                \"items\" in interface\n                or (\"success\" in interface and \"message\" in interface)\n            ):\n                return interface\n\n            raise ValueError((\n                \"Invalid interface output expected key: \\\"items\\\" or keys:\"\n                \" \\\"success\\\" and \\\"message\\\". Got: \\\"{}\\\"\"\n            ).format(str(interface)))\n\n        raise ValueError(\n            \"Invalid interface output type \\\"{}\\\"\".format(\n                str(type(interface))\n            )\n        )\n\n    def interface(\n        self,\n        session: ftrack_api.Session,\n        entities: List[ftrack_api.entity.base.Entity],\n        event: ftrack_api.event.base.Event\n    ) -&gt; Optional[Union[Dict[str, Any], List[Dict[str, Any]]]]:\n        \"\"\"Show an interface to user befor the action is processed.\n\n        This is part of launch callback which gives option to return ftrack\n        widgets items. These items are showed to user which can fill/change\n        values and submit them.\n\n        Interface must in that case handle if event contains values from user.\n\n        Args:\n            session (ftrack_api.Session): Connected ftrack api session.\n            entities (List[Any]): Entities on which was action triggered.\n            event (ftrack_api.Event): Event which triggered launch callback.\n\n        Returns:\n            Union[None, List[Dict[str, Any], Dict[str, Any]]: None if nothing\n                should be showed, list of items to show or dictionary with\n                'items' key and possibly additional data\n                (e.g. submit button label).\n\n        \"\"\"\n        return None\n\n    def _handle_result(self, result: Any) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Validate the returned result from the action callback.\"\"\"\n        if not result:\n            return None\n\n        if isinstance(result, dict):\n            if \"items\" in result:\n                if not isinstance(result[\"items\"], list):\n                    raise TypeError(\n                        \"Invalid items type {} expected list\".format(\n                            str(type(result[\"items\"]))))\n                return result\n\n            if \"success\" not in result and \"message\" not in result:\n                self.log.error((\n                    \"{} \\\"{}\\\" Missing required keys\"\n                    \" \\\"success\\\" and \\\"message\\\" in callback output. This is\"\n                    \" soft fail.\"\n                ).format(self.handler_type, self.full_label))\n\n            elif \"message\" in result:\n                if \"success\" not in result:\n                    result[\"success\"] = True\n                return result\n\n            # Fallback to 'bool' result\n            result = result.get(\"success\", True)\n\n        if isinstance(result, bool):\n            if result:\n                return {\n                    \"success\": True,\n                    \"message\": \"{} finished.\".format(self.full_label)\n                }\n            return {\n                \"success\": False,\n                \"message\": \"{} failed.\".format(self.full_label)\n            }\n\n        return result\n\n    @staticmethod\n    def roles_check(\n        settings_roles: List[str],\n        user_roles: List[str],\n        default: Optional[bool] = True\n    ) -&gt; bool:\n        \"\"\"Compare roles from setting and user's roles.\n\n        Args:\n            settings_roles(list): List of role names from settings.\n            user_roles(list): User's lowered role names.\n            default(bool): If 'settings_roles' is empty list.\n\n        Returns:\n            bool: 'True' if user has at least one role from settings or\n                default if 'settings_roles' is empty.\n\n        \"\"\"\n        if not settings_roles:\n            return default\n\n        user_roles = {\n            role_name.lower()\n            for role_name in user_roles\n        }\n        for role_name in settings_roles:\n            if role_name.lower() in user_roles:\n                return True\n        return False\n\n    @classmethod\n    def get_user_entity_from_event(\n        cls,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event\n    ) -&gt; Optional[ftrack_api.entity.user.User]:\n        \"\"\"Query user entity from event.\"\"\"\n\n        not_set = object()\n\n        # Check if user is already stored in event data\n        user_entity = event[\"data\"].get(\"user_entity\", not_set)\n        if user_entity is not_set:\n            # Query user entity from event\n            user_info = event.get(\"source\", {}).get(\"user\", {})\n            user_id = user_info.get(\"id\")\n            username = user_info.get(\"username\")\n            if user_id:\n                user_entity = session.query(\n                    \"User where id is {}\".format(user_id)\n                ).first()\n            if not user_entity and username:\n                user_entity = session.query(\n                    \"User where username is {}\".format(username)\n                ).first()\n            event[\"data\"][\"user_entity\"] = user_entity\n\n        return user_entity\n\n    @classmethod\n    def get_user_roles_from_event(\n        cls,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event,\n        lower: Optional[bool] = False\n    ) -&gt; List[str]:\n        \"\"\"Get user roles based on data in event.\n\n        Args:\n            session (ftrack_api.Session): Prepared ftrack session.\n            event (ftrack_api.event.Event): Event which is processed.\n            lower (Optional[bool]): Lower the role names. Default 'False'.\n\n        Returns:\n            List[str]: List of user roles.\n\n        \"\"\"\n        not_set = object()\n\n        user_roles = event[\"data\"].get(\"user_roles\", not_set)\n        if user_roles is not_set:\n            user_roles = []\n            user_entity = cls.get_user_entity_from_event(session, event)\n            for role in user_entity[\"user_security_roles\"]:\n                role_name = role[\"security_role\"][\"name\"]\n                if lower:\n                    role_name = role_name.lower()\n                user_roles.append(role_name)\n            event[\"data\"][\"user_roles\"] = user_roles\n        return user_roles\n\n    def get_project_name_from_event_with_entities(\n        self,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event,\n        entities: List[ftrack_api.entity.base.Entity],\n    ) -&gt; Optional[str]:\n        \"\"\"Load or query and fill project entity from/to event data.\n\n        Project data are stored by ftrack id because in most cases it is\n        easier to access project id than project name.\n\n        Args:\n            session (ftrack_api.Session): Current session.\n            event (ftrack_api.Event): Processed event by session.\n            entities (List[Any]): ftrack entities of selection.\n\n        Returns:\n            Optional[str]: Project name from event data.\n\n        \"\"\"\n        # Try to get project entity from event\n        project_name = event[\"data\"].get(\"project_name\")\n        if not project_name:\n            project_entity = self.get_project_from_entity(\n                entities[0], session\n            )\n            project_name = project_entity[\"full_name\"]\n\n            event[\"data\"][\"project_name\"] = project_name\n        return project_name\n\n    def get_ftrack_settings(\n        self,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event,\n        entities: List[ftrack_api.entity.base.Entity],\n    ) -&gt; Dict[str, Any]:\n        project_name = self.get_project_name_from_event_with_entities(\n            session, event, entities\n        )\n        project_settings = self.get_project_settings_from_event(\n            event, project_name\n        )\n        return project_settings[\"ftrack\"]\n\n    def valid_roles(\n        self,\n        session: ftrack_api.Session,\n        entities: List[ftrack_api.entity.base.Entity],\n        event: ftrack_api.event.base.Event,\n    ) -&gt; bool:\n        \"\"\"Validate user roles by settings.\n\n        Method requires to have set `settings_key` attribute.\n        \"\"\"\n        ftrack_settings = self.get_ftrack_settings(session, event, entities)\n        settings = (\n            ftrack_settings[self.settings_frack_subkey][self.settings_key]\n        )\n        if self.settings_enabled_key:\n            if not settings.get(self.settings_enabled_key, True):\n                return False\n\n        user_role_list = self.get_user_roles_from_event(session, event)\n        if not self.roles_check(settings.get(\"role_list\"), user_role_list):\n            return False\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseAction.full_label","title":"<code>full_label</code>  <code>property</code>","text":"<p>Full label of action.</p> <p>Value of full label is cached.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Label created from 'label' and 'variant' attributes.</p>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseAction.discover","title":"<code>discover(session, entities, event)</code>","text":"<p>Decide if action is showed to used based on event data.</p> <p>Action should override the method to implement logic to show the action. The most common logic is based on combination of user roles and selected entities.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Session which triggered callback of the event.</p> required <code>entities</code> <code>List[Any]</code> <p>Prepared list of entities from event data.</p> required <code>event</code> <code>Event</code> <p>ftrack event which caused this callback is triggered.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if action should be returned.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>def discover(\n    self,\n    session: ftrack_api.Session,\n    entities: List[ftrack_api.entity.base.Entity],\n    event: ftrack_api.event.base.Event,\n) -&gt; bool:\n    \"\"\"Decide if action is showed to used based on event data.\n\n    Action should override the method to implement logic to show the\n    action. The most common logic is based on combination of user roles\n    and selected entities.\n\n    Args:\n        session (ftrack_api.Session): Session which triggered callback of\n            the event.\n        entities (List[Any]): Prepared list of entities from event data.\n        event (ftrack_api.Event): ftrack event which caused this callback\n            is triggered.\n\n    Returns:\n        bool: True if action should be returned.\n\n    \"\"\"\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseAction.get_project_name_from_event_with_entities","title":"<code>get_project_name_from_event_with_entities(session, event, entities)</code>","text":"<p>Load or query and fill project entity from/to event data.</p> <p>Project data are stored by ftrack id because in most cases it is easier to access project id than project name.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Current session.</p> required <code>event</code> <code>Event</code> <p>Processed event by session.</p> required <code>entities</code> <code>List[Any]</code> <p>ftrack entities of selection.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Project name from event data.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>def get_project_name_from_event_with_entities(\n    self,\n    session: ftrack_api.Session,\n    event: ftrack_api.event.base.Event,\n    entities: List[ftrack_api.entity.base.Entity],\n) -&gt; Optional[str]:\n    \"\"\"Load or query and fill project entity from/to event data.\n\n    Project data are stored by ftrack id because in most cases it is\n    easier to access project id than project name.\n\n    Args:\n        session (ftrack_api.Session): Current session.\n        event (ftrack_api.Event): Processed event by session.\n        entities (List[Any]): ftrack entities of selection.\n\n    Returns:\n        Optional[str]: Project name from event data.\n\n    \"\"\"\n    # Try to get project entity from event\n    project_name = event[\"data\"].get(\"project_name\")\n    if not project_name:\n        project_entity = self.get_project_from_entity(\n            entities[0], session\n        )\n        project_name = project_entity[\"full_name\"]\n\n        event[\"data\"][\"project_name\"] = project_name\n    return project_name\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseAction.get_user_entity_from_event","title":"<code>get_user_entity_from_event(session, event)</code>  <code>classmethod</code>","text":"<p>Query user entity from event.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>@classmethod\ndef get_user_entity_from_event(\n    cls,\n    session: ftrack_api.Session,\n    event: ftrack_api.event.base.Event\n) -&gt; Optional[ftrack_api.entity.user.User]:\n    \"\"\"Query user entity from event.\"\"\"\n\n    not_set = object()\n\n    # Check if user is already stored in event data\n    user_entity = event[\"data\"].get(\"user_entity\", not_set)\n    if user_entity is not_set:\n        # Query user entity from event\n        user_info = event.get(\"source\", {}).get(\"user\", {})\n        user_id = user_info.get(\"id\")\n        username = user_info.get(\"username\")\n        if user_id:\n            user_entity = session.query(\n                \"User where id is {}\".format(user_id)\n            ).first()\n        if not user_entity and username:\n            user_entity = session.query(\n                \"User where username is {}\".format(username)\n            ).first()\n        event[\"data\"][\"user_entity\"] = user_entity\n\n    return user_entity\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseAction.get_user_roles_from_event","title":"<code>get_user_roles_from_event(session, event, lower=False)</code>  <code>classmethod</code>","text":"<p>Get user roles based on data in event.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Prepared ftrack session.</p> required <code>event</code> <code>Event</code> <p>Event which is processed.</p> required <code>lower</code> <code>Optional[bool]</code> <p>Lower the role names. Default 'False'.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of user roles.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>@classmethod\ndef get_user_roles_from_event(\n    cls,\n    session: ftrack_api.Session,\n    event: ftrack_api.event.base.Event,\n    lower: Optional[bool] = False\n) -&gt; List[str]:\n    \"\"\"Get user roles based on data in event.\n\n    Args:\n        session (ftrack_api.Session): Prepared ftrack session.\n        event (ftrack_api.event.Event): Event which is processed.\n        lower (Optional[bool]): Lower the role names. Default 'False'.\n\n    Returns:\n        List[str]: List of user roles.\n\n    \"\"\"\n    not_set = object()\n\n    user_roles = event[\"data\"].get(\"user_roles\", not_set)\n    if user_roles is not_set:\n        user_roles = []\n        user_entity = cls.get_user_entity_from_event(session, event)\n        for role in user_entity[\"user_security_roles\"]:\n            role_name = role[\"security_role\"][\"name\"]\n            if lower:\n                role_name = role_name.lower()\n            user_roles.append(role_name)\n        event[\"data\"][\"user_roles\"] = user_roles\n    return user_roles\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseAction.interface","title":"<code>interface(session, entities, event)</code>","text":"<p>Show an interface to user befor the action is processed.</p> <p>This is part of launch callback which gives option to return ftrack widgets items. These items are showed to user which can fill/change values and submit them.</p> <p>Interface must in that case handle if event contains values from user.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Connected ftrack api session.</p> required <code>entities</code> <code>List[Any]</code> <p>Entities on which was action triggered.</p> required <code>event</code> <code>Event</code> <p>Event which triggered launch callback.</p> required <p>Returns:</p> Type Description <code>Optional[Union[Dict[str, Any], List[Dict[str, Any]]]]</code> <p>Union[None, List[Dict[str, Any], Dict[str, Any]]: None if nothing should be showed, list of items to show or dictionary with 'items' key and possibly additional data (e.g. submit button label).</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>def interface(\n    self,\n    session: ftrack_api.Session,\n    entities: List[ftrack_api.entity.base.Entity],\n    event: ftrack_api.event.base.Event\n) -&gt; Optional[Union[Dict[str, Any], List[Dict[str, Any]]]]:\n    \"\"\"Show an interface to user befor the action is processed.\n\n    This is part of launch callback which gives option to return ftrack\n    widgets items. These items are showed to user which can fill/change\n    values and submit them.\n\n    Interface must in that case handle if event contains values from user.\n\n    Args:\n        session (ftrack_api.Session): Connected ftrack api session.\n        entities (List[Any]): Entities on which was action triggered.\n        event (ftrack_api.Event): Event which triggered launch callback.\n\n    Returns:\n        Union[None, List[Dict[str, Any], Dict[str, Any]]: None if nothing\n            should be showed, list of items to show or dictionary with\n            'items' key and possibly additional data\n            (e.g. submit button label).\n\n    \"\"\"\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseAction.launch","title":"<code>launch(session, entities, event)</code>","text":"<p>Main part of handling event callback.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Session which queried entities.</p> required <code>entities</code> <code>List[Any]</code> <p>Prequeried entities based on event data.</p> required <code>event</code> <code>Event</code> <p>ftrack event to process.</p> required <p>Returns:</p> Type Description <code>Optional[Union[bool, Dict[str, Any]]]</code> <p>Union[bool, Dict[str, Any]]: True or false for success or fail, or more complex data structure e.g. to show interface to user.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>def launch(\n    self,\n    session: ftrack_api.Session,\n    entities: List[ftrack_api.entity.base.Entity],\n    event: ftrack_api.event.base.Event\n) -&gt; Optional[Union[bool, Dict[str, Any]]]:\n    \"\"\"Main part of handling event callback.\n\n    Args:\n        session (ftrack_api.Session): Session which queried entities.\n        entities (List[Any]): Prequeried entities based on event data.\n        event (ftrack_api.Event): ftrack event to process.\n\n    Returns:\n        Union[bool, Dict[str, Any]]: True or false for success or fail,\n            or more complex data structure e.g. to show interface to user.\n\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseAction.register","title":"<code>register()</code>","text":"<p>Register to ftrack topics to discover and launch action.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>def register(self):\n    \"\"\"Register to ftrack topics to discover and launch action.\"\"\"\n    self.session.event_hub.subscribe(\n        \"topic=ftrack.action.discover\",\n        self._discover,\n        priority=self.priority\n    )\n\n    launch_subscription = (\n        \"topic=ftrack.action.launch and data.actionIdentifier={}\"\n    ).format(self.launch_identifier)\n    self.session.event_hub.subscribe(launch_subscription, self._launch)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseAction.roles_check","title":"<code>roles_check(settings_roles, user_roles, default=True)</code>  <code>staticmethod</code>","text":"<p>Compare roles from setting and user's roles.</p> <p>Parameters:</p> Name Type Description Default <code>settings_roles</code> <code>list</code> <p>List of role names from settings.</p> required <code>user_roles</code> <code>list</code> <p>User's lowered role names.</p> required <code>default</code> <code>bool</code> <p>If 'settings_roles' is empty list.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>'True' if user has at least one role from settings or default if 'settings_roles' is empty.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>@staticmethod\ndef roles_check(\n    settings_roles: List[str],\n    user_roles: List[str],\n    default: Optional[bool] = True\n) -&gt; bool:\n    \"\"\"Compare roles from setting and user's roles.\n\n    Args:\n        settings_roles(list): List of role names from settings.\n        user_roles(list): User's lowered role names.\n        default(bool): If 'settings_roles' is empty list.\n\n    Returns:\n        bool: 'True' if user has at least one role from settings or\n            default if 'settings_roles' is empty.\n\n    \"\"\"\n    if not settings_roles:\n        return default\n\n    user_roles = {\n        role_name.lower()\n        for role_name in user_roles\n    }\n    for role_name in settings_roles:\n        if role_name.lower() in user_roles:\n            return True\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseAction.valid_roles","title":"<code>valid_roles(session, entities, event)</code>","text":"<p>Validate user roles by settings.</p> <p>Method requires to have set <code>settings_key</code> attribute.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>def valid_roles(\n    self,\n    session: ftrack_api.Session,\n    entities: List[ftrack_api.entity.base.Entity],\n    event: ftrack_api.event.base.Event,\n) -&gt; bool:\n    \"\"\"Validate user roles by settings.\n\n    Method requires to have set `settings_key` attribute.\n    \"\"\"\n    ftrack_settings = self.get_ftrack_settings(session, event, entities)\n    settings = (\n        ftrack_settings[self.settings_frack_subkey][self.settings_key]\n    )\n    if self.settings_enabled_key:\n        if not settings.get(self.settings_enabled_key, True):\n            return False\n\n    user_role_list = self.get_user_roles_from_event(session, event)\n    if not self.roles_check(settings.get(\"role_list\"), user_role_list):\n        return False\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseEventHandler","title":"<code>BaseEventHandler</code>","text":"<p>               Bases: <code>BaseHandler</code></p> <p>Event handler listening to topics.</p> <p>Output of callback is not handled and handler is not designed for actions.</p> <p>By default is listening to \"ftrack.update\". To change it override 'register' method of change 'subscription_topic' attribute.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_event_handler.py</code> <pre><code>class BaseEventHandler(BaseHandler):\n    \"\"\"Event handler listening to topics.\n\n    Output of callback is not handled and handler is not designed for actions.\n\n    By default is listening to \"ftrack.update\". To change it override\n    'register' method of change 'subscription_topic' attribute.\n    \"\"\"\n    __ignore_handler_class: bool = True\n\n    subscription_topic: str = \"ftrack.update\"\n    handler_type: str = \"Event\"\n\n    def register(self):\n        \"\"\"Register to subscription topic.\"\"\"\n        self.session.event_hub.subscribe(\n            \"topic={}\".format(self.subscription_topic),\n            self._process,\n            priority=self.priority\n        )\n\n    def process(self, event: ftrack_api.event.base.Event):\n        \"\"\"Callback triggered on event with matching topic.\n\n        Args:\n            event (ftrack_api.Event): ftrack event to process.\n\n        \"\"\"\n        return self.launch(self.session, event)\n\n    def launch(\n        self,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event\n    ):\n        \"\"\"Deprecated method used for backwards compatibility.\n\n        Override 'process' method rather then 'launch'. Method name 'launch'\n        is derived from action event handler which does not make sense in terms\n        of not action based processing.\n\n        Args:\n            session (ftrack_api.Session): ftrack session which triggered\n                the event.\n            event (ftrack_api.Event): ftrack event to process.\n\n        \"\"\"\n        raise NotImplementedError()\n\n    def _process(self, event: ftrack_api.event.base.Event):\n        return self._launch(event)\n\n    def _launch(self, event: ftrack_api.event.base.Event):\n        \"\"\"Callback kept for backwards compatibility.\n\n        Will be removed when default\n        \"\"\"\n        self.session.rollback()\n        self.session._local_cache.clear()\n\n        try:\n            self.process(event)\n\n        except Exception as exc:\n            self.log.error(\n                \"Event \\\"{}\\\" Failed: {}\".format(\n                    self.__class__.__name__, str(exc)\n                ),\n                exc_info=True\n            )\n            self.session.rollback()\n            self.session._configure_locations()\n\n    def _translate_event(\n        self,\n        event: ftrack_api.event.base.Event,\n        session: Optional[ftrack_api.Session] = None\n    ):\n        \"\"\"Receive entity objects based on event.\n\n        Args:\n            event (ftrack_api.Event): Event to process.\n            session (ftrack_api.Session): Connected ftrack session.\n\n        Returns:\n            List[ftrack_api.Entity]: Queried entities based on event data.\n\n        \"\"\"\n        return self._get_entities(\n            event,\n            session,\n            ignore={\"socialfeed\", \"socialnotification\", \"team\"}\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseEventHandler.launch","title":"<code>launch(session, event)</code>","text":"<p>Deprecated method used for backwards compatibility.</p> <p>Override 'process' method rather then 'launch'. Method name 'launch' is derived from action event handler which does not make sense in terms of not action based processing.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>ftrack session which triggered the event.</p> required <code>event</code> <code>Event</code> <p>ftrack event to process.</p> required Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_event_handler.py</code> <pre><code>def launch(\n    self,\n    session: ftrack_api.Session,\n    event: ftrack_api.event.base.Event\n):\n    \"\"\"Deprecated method used for backwards compatibility.\n\n    Override 'process' method rather then 'launch'. Method name 'launch'\n    is derived from action event handler which does not make sense in terms\n    of not action based processing.\n\n    Args:\n        session (ftrack_api.Session): ftrack session which triggered\n            the event.\n        event (ftrack_api.Event): ftrack event to process.\n\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseEventHandler.process","title":"<code>process(event)</code>","text":"<p>Callback triggered on event with matching topic.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>ftrack event to process.</p> required Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_event_handler.py</code> <pre><code>def process(self, event: ftrack_api.event.base.Event):\n    \"\"\"Callback triggered on event with matching topic.\n\n    Args:\n        event (ftrack_api.Event): ftrack event to process.\n\n    \"\"\"\n    return self.launch(self.session, event)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseEventHandler.register","title":"<code>register()</code>","text":"<p>Register to subscription topic.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_event_handler.py</code> <pre><code>def register(self):\n    \"\"\"Register to subscription topic.\"\"\"\n    self.session.event_hub.subscribe(\n        \"topic={}\".format(self.subscription_topic),\n        self._process,\n        priority=self.priority\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseHandler","title":"<code>BaseHandler</code>","text":"<p>Base class for handling ftrack events.</p> <p>Attributes:</p> Name Type Description <code>enabled</code> <code>bool</code> <p>Is handler enabled.</p> <code>priority</code> <code>int</code> <p>Priority of handler processing. The lower value is the earlier is handler processed.</p> <code>handler_type</code> <code>str</code> <p>Has only debugging purposes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Connected ftrack session.</p> required Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>class BaseHandler(metaclass=ABCMeta):\n    \"\"\"Base class for handling ftrack events.\n\n    Attributes:\n        enabled (bool): Is handler enabled.\n        priority (int): Priority of handler processing. The lower value is the\n            earlier is handler processed.\n        handler_type (str): Has only debugging purposes.\n\n    Args:\n        session (ftrack_api.Session): Connected ftrack session.\n\n    \"\"\"\n    _log: Optional[logging.Logger] = None\n    _process_id: Optional[str] = None\n    # Default priority is 100\n    enabled: bool = True\n    priority: int = 100\n    handler_type: str = \"Base\"\n    _handler_label: Optional[str] = None\n    # Mark base classes to be ignored for discovery\n    __ignore_handler_class: bool = True\n\n    def __init__(self, session):\n        if not isinstance(session, ftrack_api.session.Session):\n            raise TypeError(\n                \"Expected 'ftrack_api.Session' object got '{}'\".format(\n                    str(type(session))))\n\n        self._session = session\n\n        self.register = self.register_wrapper(self.register)\n\n    @classmethod\n    def ignore_handler_class(cls) -&gt; bool:\n        \"\"\"Check if handler class should be ignored.\n\n        Do not touch implementation of this method, set\n            '__ignore_handler_class' to 'True' if you want to ignore class.\n\n        \"\"\"\n        cls_name = cls.__name__\n        if not cls_name.startswith(\"_\"):\n            cls_name = f\"_{cls_name}\"\n        return getattr(cls, f\"{cls_name}__ignore_handler_class\", False)\n\n    @staticmethod\n    def join_filter_values(values: Iterable[str]) -&gt; str:\n        return \",\".join({'\"{}\"'.format(value) for value in values})\n\n    @classmethod\n    def join_query_keys(cls, keys: Iterable[str]) -&gt; str:\n        return cls.join_filter_values(keys)\n\n    @property\n    def log(self) -&gt; logging.Logger:\n        \"\"\"Quick access to logger.\n\n        Returns:\n            logging.Logger: Logger that can be used for logging of handler.\n\n        \"\"\"\n        if self._log is None:\n            # TODO better logging mechanism\n            self._log = logging.getLogger(self.__class__.__name__)\n            self._log.setLevel(logging.DEBUG)\n        return self._log\n\n    @property\n    def handler_label(self) -&gt; str:\n        if self._handler_label is None:\n            self._handler_label = self.__class__.__name__\n        return self._handler_label\n\n    @property\n    def session(self) -&gt; ftrack_api.Session:\n        \"\"\"Fast access to session.\n\n        Returns:\n            session (ftrack_api.Session): Session which is source of events.\n\n        \"\"\"\n        return self._session\n\n    def reset_session(self):\n        \"\"\"Reset session cache.\"\"\"\n        self.session.reset()\n\n    @staticmethod\n    def process_identifier() -&gt; str:\n        \"\"\"Helper property to have unified access to process id.\n\n        Todos:\n            Use some global approach rather then implementation on\n                'BaseEntity'.\n\n        \"\"\"\n        if not BaseHandler._process_id:\n            BaseHandler._process_id = str(uuid.uuid4())\n        return BaseHandler._process_id\n\n    @abstractmethod\n    def register(self):\n        \"\"\"Subscribe to event topics.\"\"\"\n        pass\n\n    def cleanup(self):\n        \"\"\"Cleanup handler.\n\n        This method should end threads, timers, close connections, etc.\n        \"\"\"\n        pass\n\n    def register_wrapper(self, func):\n        @functools.wraps(func)\n        def wrapper_register(*args, **kwargs):\n            if not self.enabled:\n                return\n\n            try:\n                start_time = time.perf_counter()\n                func(*args, **kwargs)\n                end_time = time.perf_counter()\n                run_time = end_time - start_time\n                self.log.info((\n                    \"{} \\\"{}\\\" - Registered successfully ({:.4f}sec)\"\n                ).format(self.handler_type, self.handler_label, run_time))\n\n            except NotImplementedError:\n                self.log.error((\n                    \"{} \\\"{}\\\" - Register method is not implemented\"\n                ).format(self.handler_type, self.handler_label))\n\n            except Exception as exc:\n                self.log.error(\"{} \\\"{}\\\" - Registration failed ({})\".format(\n                    self.handler_type, self.handler_label, str(exc)\n                ))\n        return wrapper_register\n\n    def _get_entities(self, event, session=None, ignore=None):\n        entities = []\n        selection = event[\"data\"].get(\"selection\")\n        if not selection:\n            return entities\n\n        if ignore is None:\n            ignore = set()\n        elif isinstance(ignore, str):\n            ignore = {ignore}\n\n        filtered_selection = []\n        for entity in selection:\n            if entity[\"entityType\"] not in ignore:\n                filtered_selection.append(entity)\n\n        if not filtered_selection:\n            return entities\n\n        if session is None:\n            session = self.session\n            session._local_cache.clear()\n\n        for entity in filtered_selection:\n            entities.append(session.get(\n                self._get_entity_type(entity, session),\n                entity.get(\"entityId\")\n            ))\n\n        return entities\n\n    def _get_entity_type(self, entity, session=None):\n        \"\"\"Translate entity type so it can be used with API.\n\n        Todos:\n            Use object id rather.\n\n        \"\"\"\n        # Get entity type and make sure it is lower cased. Most places except\n        # the component tab in the Sidebar will use lower case notation.\n        entity_type = entity.get(\"entityType\").replace(\"_\", \"\").lower()\n\n        if session is None:\n            session = self.session\n\n        for schema in session.schemas:\n            alias_for = schema.get(\"alias_for\")\n\n            if (\n                alias_for\n                and isinstance(alias_for, str)\n                and alias_for.lower() == entity_type\n            ):\n                return schema[\"id\"]\n\n        for schema in self.session.schemas:\n            if schema[\"id\"].lower() == entity_type:\n                return schema[\"id\"]\n\n        raise ValueError(\n            \"Unable to translate entity type: {0}.\".format(entity_type)\n        )\n\n    def show_message(\n        self,\n        event: ftrack_api.event.base.Event,\n        message: str,\n        success: Optional[bool] = False,\n    ):\n        \"\"\"Shows message to user who triggered event.\n\n        Args:\n            event (ftrack_api.event.base.Event): Event used for source\n                of user id.\n            message (str): Message that will be shown to user.\n            success (bool): Define type (color) of message. False -&gt; red color.\n\n        \"\"\"\n        if not isinstance(success, bool):\n            success = False\n\n        try:\n            message = str(message)\n        except Exception:\n            return\n\n        user_id = event[\"source\"][\"user\"][\"id\"]\n        target = (\n            \"applicationId=ftrack.client.web and user.id=\\\"{}\\\"\"\n        ).format(user_id)\n        self.session.event_hub.publish(\n            ftrack_api.event.base.Event(\n                topic=\"ftrack.action.trigger-user-interface\",\n                data={\n                    \"type\": \"message\",\n                    \"success\": success,\n                    \"message\": message\n                },\n                target=target\n            ),\n            on_error=\"ignore\"\n        )\n\n    def show_interface(\n        self,\n        items: List[Dict[str, Any]],\n        title: Optional[str] = \"\",\n        user_id: Optional[str] = None,\n        user: Optional[Any] = None,\n        event: Optional[ftrack_api.event.base.Event] = None,\n        username: Optional[str] = None,\n        submit_btn_label: Optional[str] = None,\n    ):\n        \"\"\"Shows ftrack widgets interface to user.\n\n        Interface is shown to a user. To identify user one of arguments must be\n        passed: 'user_id', 'user', 'event', 'username'.\n\n        Args:\n            items (List[Dict[str, Any]]) Interface items (their structure is\n                defined by ftrack documentation).\n            title (str): Title of shown widget.\n            user_id (str): User id.\n            user (Any): Object of ftrack user (queried using ftrack api\n                session).\n            event (ftrack_api.Event): Event which can be used as source for\n                user id.\n            username (str): Username of user to get it's id. This is slowest\n                way how user id is received.\n            submit_btn_label (str): Label of submit button in ftrack widget.\n\n        \"\"\"\n        if user_id:\n            pass\n\n        elif user:\n            user_id = user[\"id\"]\n\n        elif username:\n            user = self.session.query(\n                \"User where username is \\\"{}\\\"\".format(username)\n            ).first()\n            if not user:\n                raise ValueError((\n                    \"ftrack user with username \\\"{}\\\" was not found!\"\n                ).format(username))\n\n            user_id = user[\"id\"]\n\n        elif event:\n            user_id = event[\"source\"][\"user\"][\"id\"]\n\n        if not user_id:\n            return\n\n        target = (\n            \"applicationId=ftrack.client.web and user.id=\\\"{}\\\"\"\n        ).format(user_id)\n\n        event_data = {\n            \"type\": \"widget\",\n            \"items\": items,\n            \"title\": title\n        }\n        if submit_btn_label:\n            event_data[\"submit_button_label\"] = submit_btn_label\n\n        self.session.event_hub.publish(\n            ftrack_api.event.base.Event(\n                topic=\"ftrack.action.trigger-user-interface\",\n                data=event_data,\n                target=target\n            ),\n            on_error=\"ignore\"\n        )\n\n    def show_interface_from_dict(\n        self,\n        messages: Dict[str, Union[str, List[str]]],\n        title: Optional[str] = \"\",\n        user_id: Optional[str] = None,\n        user: Optional[Any] = None,\n        event: Optional[ftrack_api.event.base.Event] = None,\n        username: Optional[str] = None,\n        submit_btn_label: Optional[str] = None,\n    ):\n        # TODO Find out how and where is this used\n        if not messages:\n            self.log.debug(\"No messages to show! (messages dict is empty)\")\n            return\n        items = []\n        splitter = {\"type\": \"label\", \"value\": \"---\"}\n        first = True\n        for key, value in messages.items():\n            if not first:\n                items.append(splitter)\n            first = False\n\n            items.append({\"type\": \"label\", \"value\": \"&lt;h3&gt;{}&lt;/h3&gt;\".format(key)})\n            if isinstance(value, str):\n                value = [value]\n\n            for item in value:\n                items.append({\"type\": \"label\", \"value\": f\"&lt;p&gt;{item}&lt;/p&gt;\"})\n\n        self.show_interface(\n            items,\n            title=title,\n            user_id=user_id,\n            user=user,\n            event=event,\n            username=username,\n            submit_btn_label=submit_btn_label\n        )\n\n    def trigger_action(\n        self,\n        action_identifier: str,\n        event: Optional[ftrack_api.event.base.Event] = None,\n        session: Optional[ftrack_api.Session] = None,\n        selection: Optional[List[Dict[str, str]]] = None,\n        user_data: Optional[Dict[str, Any]] = None,\n        topic: Optional[str] = \"ftrack.action.launch\",\n        additional_event_data: Optional[Dict[str, Any]] = None,\n        on_error: Optional[str] = \"ignore\"\n    ):\n        self.log.debug(\n            \"Triggering action \\\"{}\\\" Begins\".format(action_identifier))\n\n        if not session:\n            session = self.session\n\n        # Getting selection and user data\n        if event:\n            if selection is None:\n                selection = event.get(\"data\", {}).get(\"selection\")\n            if user_data is None:\n                user_data = event.get(\"source\", {}).get(\"user\")\n\n        # Without selection and user data skip triggering\n        msg = \"Can't trigger \\\"{}\\\" action without {}.\"\n        if selection is None:\n            self.log.error(msg.format(action_identifier, \"selection\"))\n            return\n\n        if user_data is None:\n            self.log.error(msg.format(action_identifier, \"user data\"))\n            return\n\n        event_data = {\n            \"actionIdentifier\": action_identifier,\n            \"selection\": selection\n        }\n\n        # Add additional data\n        if additional_event_data:\n            event_data.update(additional_event_data)\n\n        # Create and trigger event\n        session.event_hub.publish(\n            ftrack_api.event.base.Event(\n                topic=topic,\n                data=event_data,\n                source={\"user\": user_data}\n            ),\n            on_error=on_error\n        )\n        self.log.debug(\n            \"Action \\\"{}\\\" triggered\".format(action_identifier))\n\n    def trigger_event(\n        self,\n        topic: str,\n        event_data: Optional[Dict[str, Any]] = None,\n        session: Optional[ftrack_api.Session] = None,\n        source: Optional[Dict[str, Any]] = None,\n        event: Optional[ftrack_api.event.base.Event] = None,\n        on_error: Optional[str] = \"ignore\"\n    ):\n        if session is None:\n            session = self.session\n\n        if not source and event:\n            source = event.get(\"source\")\n\n        if event_data is None:\n            event_data = {}\n        # Create and trigger event\n        event = ftrack_api.event.base.Event(\n            topic=topic,\n            data=event_data,\n            source=source\n        )\n        session.event_hub.publish(event, on_error=on_error)\n\n        self.log.debug((\n            \"Publishing event: {}\"\n        ).format(str(event.__dict__)))\n\n    def get_project_from_entity(\n        self,\n        entity: ftrack_api.entity.base.Entity,\n        session: Optional[ftrack_api.Session] = None\n    ):\n        low_entity_type = entity.entity_type.lower()\n        if low_entity_type == \"project\":\n            return entity\n\n        if \"project\" in entity:\n            # reviewsession, task(Task, Shot, Sequence,...)\n            return entity[\"project\"]\n\n        if low_entity_type == \"filecomponent\":\n            entity = entity[\"version\"]\n            low_entity_type = entity.entity_type.lower()\n\n        if low_entity_type == \"assetversion\":\n            asset = entity[\"asset\"]\n            parent = None\n            if asset:\n                parent = asset[\"parent\"]\n\n            if parent:\n                if parent.entity_type.lower() == \"project\":\n                    return parent\n\n                if \"project\" in parent:\n                    return parent[\"project\"]\n\n        project_data = entity[\"link\"][0]\n\n        if session is None:\n            session = self.session\n        return session.query(\n            \"Project where id is {}\".format(project_data[\"id\"])\n        ).one()\n\n    def get_project_entity_from_event(\n        self,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event,\n        project_id: str,\n    ):\n        \"\"\"Load or query and fill project entity from/to event data.\n\n        Project data are stored by ftrack id because in most cases it is\n        easier to access project id than project name.\n\n        Args:\n            session (ftrack_api.Session): Current session.\n            event (ftrack_api.Event): Processed event by session.\n            project_id (str): ftrack project id.\n\n        Returns:\n            Union[str, None]: Project name based on entities or None if project\n                cannot be defined.\n\n        \"\"\"\n        if not project_id:\n            raise ValueError(\n                \"Entered `project_id` is not valid. {} ({})\".format(\n                    str(project_id), str(type(project_id))\n                )\n            )\n\n        project_id_mapping = event[\"data\"].setdefault(\n            \"project_entity_by_id\", {}\n        )\n        if project_id in project_id_mapping:\n            return project_id_mapping[project_id]\n\n        # Get project entity from task and store to event\n        project_entity = session.query((\n            \"select full_name from Project where id is \\\"{}\\\"\"\n        ).format(project_id)).first()\n        project_id_mapping[project_id] = project_entity\n\n        return project_entity\n\n    def get_project_name_from_event(\n        self,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event,\n        project_id: str,\n    ):\n        \"\"\"Load or query and fill project entity from/to event data.\n\n        Project data are stored by ftrack id because in most cases it is\n        easier to access project id than project name.\n\n        Args:\n            session (ftrack_api.Session): Current session.\n            event (ftrack_api.Event): Processed event by session.\n            project_id (str): ftrack project id.\n\n        Returns:\n            Union[str, None]: Project name based on entities or None if project\n                cannot be defined.\n\n        \"\"\"\n        if not project_id:\n            raise ValueError(\n                \"Entered `project_id` is not valid. {} ({})\".format(\n                    str(project_id), str(type(project_id))\n                )\n            )\n\n        project_id_mapping = event[\"data\"].setdefault(\"project_id_name\", {})\n        if project_id in project_id_mapping:\n            return project_id_mapping[project_id]\n\n        # Get project entity from task and store to event\n        project_entity = self.get_project_entity_from_event(\n            session, event, project_id\n        )\n        if project_entity:\n            project_name = project_entity[\"full_name\"]\n        project_id_mapping[project_id] = project_name\n        return project_name\n\n    def get_ayon_project_from_event(\n        self,\n        event: ftrack_api.event.base.Event,\n        project_name: str\n    ):\n        \"\"\"Get AYON project from event.\n\n        Args:\n            event (ftrack_api.Event): Event which is source of project id.\n            project_name (Union[str, None]): Project name.\n\n        Returns:\n            Union[dict[str, Any], None]: AYON project.\n\n        \"\"\"\n        ayon_projects = event[\"data\"].setdefault(\"ayon_projects\", {})\n        if project_name in ayon_projects:\n            return ayon_projects[project_name]\n\n        project = None\n        if project_name:\n            project = get_project(project_name)\n        ayon_projects[project_name] = project\n        return project\n\n    def get_project_settings_from_event(\n        self,\n        event: ftrack_api.event.base.Event,\n        project_name: str\n    ):\n        \"\"\"Load or fill AYON's project settings from event data.\n\n        Project data are stored by ftrack id because in most cases it is\n        easier to access project id than project name.\n\n        Args:\n            event (ftrack_api.Event): Processed event by session.\n            project_name (str): Project name.\n\n        \"\"\"\n        project_settings_by_name = event[\"data\"].setdefault(\n            \"project_settings\", {}\n        )\n        if project_name in project_settings_by_name:\n            return copy.deepcopy(project_settings_by_name[project_name])\n\n        # NOTE there is no safe way how to get project settings if project\n        #   does not exist on AYON server.\n        # TODO Should we somehow find out if ftrack is enabled for the\n        #   project?\n        # TODO how to find out which bundle should be used?\n        project = self.get_ayon_project_from_event(event, project_name)\n        if not project:\n            project_name = None\n        project_settings = get_addons_settings(project_name=project_name)\n        project_settings_by_name[project_name] = project_settings\n        return copy.deepcopy(project_settings)\n\n    @staticmethod\n    def get_entity_path(entity: ftrack_api.entity.base.Entity) -&gt; str:\n        \"\"\"Return full hierarchical path to entity.\"\"\"\n        return \"/\".join(\n            [ent[\"name\"] for ent in entity[\"link\"]]\n        )\n\n    @classmethod\n    def add_traceback_to_job(\n        cls,\n        job: ftrack_api.entity.job.Job,\n        session: ftrack_api.Session,\n        exc_info: Tuple,\n        description: Optional[str] = None,\n        component_name: Optional[str] = None,\n        job_status: Optional[str] = None\n    ):\n        \"\"\"Add traceback file to a job.\n\n        Args:\n            job (JobEntity): Entity of job where file should be able to\n                download (Created or queried with passed session).\n            session (Session): ftrack session which was used to query/create\n                entered job.\n            exc_info (tuple): Exception info (e.g. from `sys.exc_info()`).\n            description (str): Change job description to describe what\n                happened. Job description won't change if not passed.\n            component_name (str): Name of component and default name of\n                downloaded file. Class name and current date time are used if\n                not specified.\n            job_status (str): Status of job which will be set. By default is\n                set to 'failed'.\n\n        \"\"\"\n        if description:\n            job_data = {\n                \"description\": description\n            }\n            job[\"data\"] = json.dumps(job_data)\n\n        if not job_status:\n            job_status = \"failed\"\n\n        job[\"status\"] = job_status\n\n        # Create temp file where traceback will be stored\n        with tempfile.NamedTemporaryFile(\n            mode=\"w\", prefix=\"ayon_ftrack_\", suffix=\".txt\", delete=False\n        ) as temp_obj:\n            temp_filepath = temp_obj.name\n\n        # Store traceback to file\n        result = traceback.format_exception(*exc_info)\n        with open(temp_filepath, \"w\") as temp_file:\n            temp_file.write(\"\".join(result))\n\n        # Upload file with traceback to ftrack server and add it to job\n        if not component_name:\n            component_name = \"{}_{}\".format(\n                cls.__name__,\n                datetime.datetime.now().strftime(\"%y-%m-%d-%H%M\")\n            )\n        cls.add_file_component_to_job(\n            job, session, temp_filepath, component_name\n        )\n        # Delete temp file\n        os.remove(temp_filepath)\n\n    @staticmethod\n    def add_file_component_to_job(\n        job: ftrack_api.entity.job.Job,\n        session: ftrack_api.Session,\n        filepath: str,\n        basename: Optional[str] = None\n    ):\n        \"\"\"Add filepath as downloadable component to job.\n\n        Args:\n            job (JobEntity): Entity of job where file should be able to\n                download (Created or queried with passed session).\n            session (Session): ftrack session which was used to query/create\n                entered job.\n            filepath (str): Path to file which should be added to job.\n            basename (str): Defines name of file which will be downloaded on\n                user's side. Must be without extension otherwise extension will\n                be duplicated in downloaded name. Basename from entered path\n                used when not entered.\n\n        \"\"\"\n        # Make sure session's locations are configured\n        # - they can be deconfigured e.g. using `rollback` method\n        session._configure_locations()\n\n        # Query `ftrack.server` location where component will be stored\n        location = session.query(\n            \"Location where name is \\\"ftrack.server\\\"\"\n        ).one()\n\n        # Use filename as basename if not entered (must be without extension)\n        if basename is None:\n            basename = os.path.splitext(\n                os.path.basename(filepath)\n            )[0]\n\n        component = session.create_component(\n            filepath,\n            data={\"name\": basename},\n            location=location\n        )\n        session.create(\n            \"JobComponent\",\n            {\n                \"component_id\": component[\"id\"],\n                \"job_id\": job[\"id\"]\n            }\n        )\n        session.commit()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseHandler.log","title":"<code>log</code>  <code>property</code>","text":"<p>Quick access to logger.</p> <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: Logger that can be used for logging of handler.</p>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseHandler.session","title":"<code>session</code>  <code>property</code>","text":"<p>Fast access to session.</p> <p>Returns:</p> Name Type Description <code>session</code> <code>Session</code> <p>Session which is source of events.</p>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseHandler.add_file_component_to_job","title":"<code>add_file_component_to_job(job, session, filepath, basename=None)</code>  <code>staticmethod</code>","text":"<p>Add filepath as downloadable component to job.</p> <p>Parameters:</p> Name Type Description Default <code>job</code> <code>JobEntity</code> <p>Entity of job where file should be able to download (Created or queried with passed session).</p> required <code>session</code> <code>Session</code> <p>ftrack session which was used to query/create entered job.</p> required <code>filepath</code> <code>str</code> <p>Path to file which should be added to job.</p> required <code>basename</code> <code>str</code> <p>Defines name of file which will be downloaded on user's side. Must be without extension otherwise extension will be duplicated in downloaded name. Basename from entered path used when not entered.</p> <code>None</code> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>@staticmethod\ndef add_file_component_to_job(\n    job: ftrack_api.entity.job.Job,\n    session: ftrack_api.Session,\n    filepath: str,\n    basename: Optional[str] = None\n):\n    \"\"\"Add filepath as downloadable component to job.\n\n    Args:\n        job (JobEntity): Entity of job where file should be able to\n            download (Created or queried with passed session).\n        session (Session): ftrack session which was used to query/create\n            entered job.\n        filepath (str): Path to file which should be added to job.\n        basename (str): Defines name of file which will be downloaded on\n            user's side. Must be without extension otherwise extension will\n            be duplicated in downloaded name. Basename from entered path\n            used when not entered.\n\n    \"\"\"\n    # Make sure session's locations are configured\n    # - they can be deconfigured e.g. using `rollback` method\n    session._configure_locations()\n\n    # Query `ftrack.server` location where component will be stored\n    location = session.query(\n        \"Location where name is \\\"ftrack.server\\\"\"\n    ).one()\n\n    # Use filename as basename if not entered (must be without extension)\n    if basename is None:\n        basename = os.path.splitext(\n            os.path.basename(filepath)\n        )[0]\n\n    component = session.create_component(\n        filepath,\n        data={\"name\": basename},\n        location=location\n    )\n    session.create(\n        \"JobComponent\",\n        {\n            \"component_id\": component[\"id\"],\n            \"job_id\": job[\"id\"]\n        }\n    )\n    session.commit()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseHandler.add_traceback_to_job","title":"<code>add_traceback_to_job(job, session, exc_info, description=None, component_name=None, job_status=None)</code>  <code>classmethod</code>","text":"<p>Add traceback file to a job.</p> <p>Parameters:</p> Name Type Description Default <code>job</code> <code>JobEntity</code> <p>Entity of job where file should be able to download (Created or queried with passed session).</p> required <code>session</code> <code>Session</code> <p>ftrack session which was used to query/create entered job.</p> required <code>exc_info</code> <code>tuple</code> <p>Exception info (e.g. from <code>sys.exc_info()</code>).</p> required <code>description</code> <code>str</code> <p>Change job description to describe what happened. Job description won't change if not passed.</p> <code>None</code> <code>component_name</code> <code>str</code> <p>Name of component and default name of downloaded file. Class name and current date time are used if not specified.</p> <code>None</code> <code>job_status</code> <code>str</code> <p>Status of job which will be set. By default is set to 'failed'.</p> <code>None</code> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>@classmethod\ndef add_traceback_to_job(\n    cls,\n    job: ftrack_api.entity.job.Job,\n    session: ftrack_api.Session,\n    exc_info: Tuple,\n    description: Optional[str] = None,\n    component_name: Optional[str] = None,\n    job_status: Optional[str] = None\n):\n    \"\"\"Add traceback file to a job.\n\n    Args:\n        job (JobEntity): Entity of job where file should be able to\n            download (Created or queried with passed session).\n        session (Session): ftrack session which was used to query/create\n            entered job.\n        exc_info (tuple): Exception info (e.g. from `sys.exc_info()`).\n        description (str): Change job description to describe what\n            happened. Job description won't change if not passed.\n        component_name (str): Name of component and default name of\n            downloaded file. Class name and current date time are used if\n            not specified.\n        job_status (str): Status of job which will be set. By default is\n            set to 'failed'.\n\n    \"\"\"\n    if description:\n        job_data = {\n            \"description\": description\n        }\n        job[\"data\"] = json.dumps(job_data)\n\n    if not job_status:\n        job_status = \"failed\"\n\n    job[\"status\"] = job_status\n\n    # Create temp file where traceback will be stored\n    with tempfile.NamedTemporaryFile(\n        mode=\"w\", prefix=\"ayon_ftrack_\", suffix=\".txt\", delete=False\n    ) as temp_obj:\n        temp_filepath = temp_obj.name\n\n    # Store traceback to file\n    result = traceback.format_exception(*exc_info)\n    with open(temp_filepath, \"w\") as temp_file:\n        temp_file.write(\"\".join(result))\n\n    # Upload file with traceback to ftrack server and add it to job\n    if not component_name:\n        component_name = \"{}_{}\".format(\n            cls.__name__,\n            datetime.datetime.now().strftime(\"%y-%m-%d-%H%M\")\n        )\n    cls.add_file_component_to_job(\n        job, session, temp_filepath, component_name\n    )\n    # Delete temp file\n    os.remove(temp_filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseHandler.cleanup","title":"<code>cleanup()</code>","text":"<p>Cleanup handler.</p> <p>This method should end threads, timers, close connections, etc.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def cleanup(self):\n    \"\"\"Cleanup handler.\n\n    This method should end threads, timers, close connections, etc.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseHandler.get_ayon_project_from_event","title":"<code>get_ayon_project_from_event(event, project_name)</code>","text":"<p>Get AYON project from event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>Event which is source of project id.</p> required <code>project_name</code> <code>Union[str, None]</code> <p>Project name.</p> required <p>Returns:</p> Type Description <p>Union[dict[str, Any], None]: AYON project.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def get_ayon_project_from_event(\n    self,\n    event: ftrack_api.event.base.Event,\n    project_name: str\n):\n    \"\"\"Get AYON project from event.\n\n    Args:\n        event (ftrack_api.Event): Event which is source of project id.\n        project_name (Union[str, None]): Project name.\n\n    Returns:\n        Union[dict[str, Any], None]: AYON project.\n\n    \"\"\"\n    ayon_projects = event[\"data\"].setdefault(\"ayon_projects\", {})\n    if project_name in ayon_projects:\n        return ayon_projects[project_name]\n\n    project = None\n    if project_name:\n        project = get_project(project_name)\n    ayon_projects[project_name] = project\n    return project\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseHandler.get_entity_path","title":"<code>get_entity_path(entity)</code>  <code>staticmethod</code>","text":"<p>Return full hierarchical path to entity.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>@staticmethod\ndef get_entity_path(entity: ftrack_api.entity.base.Entity) -&gt; str:\n    \"\"\"Return full hierarchical path to entity.\"\"\"\n    return \"/\".join(\n        [ent[\"name\"] for ent in entity[\"link\"]]\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseHandler.get_project_entity_from_event","title":"<code>get_project_entity_from_event(session, event, project_id)</code>","text":"<p>Load or query and fill project entity from/to event data.</p> <p>Project data are stored by ftrack id because in most cases it is easier to access project id than project name.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Current session.</p> required <code>event</code> <code>Event</code> <p>Processed event by session.</p> required <code>project_id</code> <code>str</code> <p>ftrack project id.</p> required <p>Returns:</p> Type Description <p>Union[str, None]: Project name based on entities or None if project cannot be defined.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def get_project_entity_from_event(\n    self,\n    session: ftrack_api.Session,\n    event: ftrack_api.event.base.Event,\n    project_id: str,\n):\n    \"\"\"Load or query and fill project entity from/to event data.\n\n    Project data are stored by ftrack id because in most cases it is\n    easier to access project id than project name.\n\n    Args:\n        session (ftrack_api.Session): Current session.\n        event (ftrack_api.Event): Processed event by session.\n        project_id (str): ftrack project id.\n\n    Returns:\n        Union[str, None]: Project name based on entities or None if project\n            cannot be defined.\n\n    \"\"\"\n    if not project_id:\n        raise ValueError(\n            \"Entered `project_id` is not valid. {} ({})\".format(\n                str(project_id), str(type(project_id))\n            )\n        )\n\n    project_id_mapping = event[\"data\"].setdefault(\n        \"project_entity_by_id\", {}\n    )\n    if project_id in project_id_mapping:\n        return project_id_mapping[project_id]\n\n    # Get project entity from task and store to event\n    project_entity = session.query((\n        \"select full_name from Project where id is \\\"{}\\\"\"\n    ).format(project_id)).first()\n    project_id_mapping[project_id] = project_entity\n\n    return project_entity\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseHandler.get_project_name_from_event","title":"<code>get_project_name_from_event(session, event, project_id)</code>","text":"<p>Load or query and fill project entity from/to event data.</p> <p>Project data are stored by ftrack id because in most cases it is easier to access project id than project name.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Current session.</p> required <code>event</code> <code>Event</code> <p>Processed event by session.</p> required <code>project_id</code> <code>str</code> <p>ftrack project id.</p> required <p>Returns:</p> Type Description <p>Union[str, None]: Project name based on entities or None if project cannot be defined.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def get_project_name_from_event(\n    self,\n    session: ftrack_api.Session,\n    event: ftrack_api.event.base.Event,\n    project_id: str,\n):\n    \"\"\"Load or query and fill project entity from/to event data.\n\n    Project data are stored by ftrack id because in most cases it is\n    easier to access project id than project name.\n\n    Args:\n        session (ftrack_api.Session): Current session.\n        event (ftrack_api.Event): Processed event by session.\n        project_id (str): ftrack project id.\n\n    Returns:\n        Union[str, None]: Project name based on entities or None if project\n            cannot be defined.\n\n    \"\"\"\n    if not project_id:\n        raise ValueError(\n            \"Entered `project_id` is not valid. {} ({})\".format(\n                str(project_id), str(type(project_id))\n            )\n        )\n\n    project_id_mapping = event[\"data\"].setdefault(\"project_id_name\", {})\n    if project_id in project_id_mapping:\n        return project_id_mapping[project_id]\n\n    # Get project entity from task and store to event\n    project_entity = self.get_project_entity_from_event(\n        session, event, project_id\n    )\n    if project_entity:\n        project_name = project_entity[\"full_name\"]\n    project_id_mapping[project_id] = project_name\n    return project_name\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseHandler.get_project_settings_from_event","title":"<code>get_project_settings_from_event(event, project_name)</code>","text":"<p>Load or fill AYON's project settings from event data.</p> <p>Project data are stored by ftrack id because in most cases it is easier to access project id than project name.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>Processed event by session.</p> required <code>project_name</code> <code>str</code> <p>Project name.</p> required Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def get_project_settings_from_event(\n    self,\n    event: ftrack_api.event.base.Event,\n    project_name: str\n):\n    \"\"\"Load or fill AYON's project settings from event data.\n\n    Project data are stored by ftrack id because in most cases it is\n    easier to access project id than project name.\n\n    Args:\n        event (ftrack_api.Event): Processed event by session.\n        project_name (str): Project name.\n\n    \"\"\"\n    project_settings_by_name = event[\"data\"].setdefault(\n        \"project_settings\", {}\n    )\n    if project_name in project_settings_by_name:\n        return copy.deepcopy(project_settings_by_name[project_name])\n\n    # NOTE there is no safe way how to get project settings if project\n    #   does not exist on AYON server.\n    # TODO Should we somehow find out if ftrack is enabled for the\n    #   project?\n    # TODO how to find out which bundle should be used?\n    project = self.get_ayon_project_from_event(event, project_name)\n    if not project:\n        project_name = None\n    project_settings = get_addons_settings(project_name=project_name)\n    project_settings_by_name[project_name] = project_settings\n    return copy.deepcopy(project_settings)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseHandler.ignore_handler_class","title":"<code>ignore_handler_class()</code>  <code>classmethod</code>","text":"<p>Check if handler class should be ignored.</p> <p>Do not touch implementation of this method, set     '__ignore_handler_class' to 'True' if you want to ignore class.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>@classmethod\ndef ignore_handler_class(cls) -&gt; bool:\n    \"\"\"Check if handler class should be ignored.\n\n    Do not touch implementation of this method, set\n        '__ignore_handler_class' to 'True' if you want to ignore class.\n\n    \"\"\"\n    cls_name = cls.__name__\n    if not cls_name.startswith(\"_\"):\n        cls_name = f\"_{cls_name}\"\n    return getattr(cls, f\"{cls_name}__ignore_handler_class\", False)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseHandler.process_identifier","title":"<code>process_identifier()</code>  <code>staticmethod</code>","text":"<p>Helper property to have unified access to process id.</p> Todos <p>Use some global approach rather then implementation on     'BaseEntity'.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>@staticmethod\ndef process_identifier() -&gt; str:\n    \"\"\"Helper property to have unified access to process id.\n\n    Todos:\n        Use some global approach rather then implementation on\n            'BaseEntity'.\n\n    \"\"\"\n    if not BaseHandler._process_id:\n        BaseHandler._process_id = str(uuid.uuid4())\n    return BaseHandler._process_id\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseHandler.register","title":"<code>register()</code>  <code>abstractmethod</code>","text":"<p>Subscribe to event topics.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>@abstractmethod\ndef register(self):\n    \"\"\"Subscribe to event topics.\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseHandler.reset_session","title":"<code>reset_session()</code>","text":"<p>Reset session cache.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def reset_session(self):\n    \"\"\"Reset session cache.\"\"\"\n    self.session.reset()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseHandler.show_interface","title":"<code>show_interface(items, title='', user_id=None, user=None, event=None, username=None, submit_btn_label=None)</code>","text":"<p>Shows ftrack widgets interface to user.</p> <p>Interface is shown to a user. To identify user one of arguments must be passed: 'user_id', 'user', 'event', 'username'.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of shown widget.</p> <code>''</code> <code>user_id</code> <code>str</code> <p>User id.</p> <code>None</code> <code>user</code> <code>Any</code> <p>Object of ftrack user (queried using ftrack api session).</p> <code>None</code> <code>event</code> <code>Event</code> <p>Event which can be used as source for user id.</p> <code>None</code> <code>username</code> <code>str</code> <p>Username of user to get it's id. This is slowest way how user id is received.</p> <code>None</code> <code>submit_btn_label</code> <code>str</code> <p>Label of submit button in ftrack widget.</p> <code>None</code> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def show_interface(\n    self,\n    items: List[Dict[str, Any]],\n    title: Optional[str] = \"\",\n    user_id: Optional[str] = None,\n    user: Optional[Any] = None,\n    event: Optional[ftrack_api.event.base.Event] = None,\n    username: Optional[str] = None,\n    submit_btn_label: Optional[str] = None,\n):\n    \"\"\"Shows ftrack widgets interface to user.\n\n    Interface is shown to a user. To identify user one of arguments must be\n    passed: 'user_id', 'user', 'event', 'username'.\n\n    Args:\n        items (List[Dict[str, Any]]) Interface items (their structure is\n            defined by ftrack documentation).\n        title (str): Title of shown widget.\n        user_id (str): User id.\n        user (Any): Object of ftrack user (queried using ftrack api\n            session).\n        event (ftrack_api.Event): Event which can be used as source for\n            user id.\n        username (str): Username of user to get it's id. This is slowest\n            way how user id is received.\n        submit_btn_label (str): Label of submit button in ftrack widget.\n\n    \"\"\"\n    if user_id:\n        pass\n\n    elif user:\n        user_id = user[\"id\"]\n\n    elif username:\n        user = self.session.query(\n            \"User where username is \\\"{}\\\"\".format(username)\n        ).first()\n        if not user:\n            raise ValueError((\n                \"ftrack user with username \\\"{}\\\" was not found!\"\n            ).format(username))\n\n        user_id = user[\"id\"]\n\n    elif event:\n        user_id = event[\"source\"][\"user\"][\"id\"]\n\n    if not user_id:\n        return\n\n    target = (\n        \"applicationId=ftrack.client.web and user.id=\\\"{}\\\"\"\n    ).format(user_id)\n\n    event_data = {\n        \"type\": \"widget\",\n        \"items\": items,\n        \"title\": title\n    }\n    if submit_btn_label:\n        event_data[\"submit_button_label\"] = submit_btn_label\n\n    self.session.event_hub.publish(\n        ftrack_api.event.base.Event(\n            topic=\"ftrack.action.trigger-user-interface\",\n            data=event_data,\n            target=target\n        ),\n        on_error=\"ignore\"\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.BaseHandler.show_message","title":"<code>show_message(event, message, success=False)</code>","text":"<p>Shows message to user who triggered event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>Event used for source of user id.</p> required <code>message</code> <code>str</code> <p>Message that will be shown to user.</p> required <code>success</code> <code>bool</code> <p>Define type (color) of message. False -&gt; red color.</p> <code>False</code> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def show_message(\n    self,\n    event: ftrack_api.event.base.Event,\n    message: str,\n    success: Optional[bool] = False,\n):\n    \"\"\"Shows message to user who triggered event.\n\n    Args:\n        event (ftrack_api.event.base.Event): Event used for source\n            of user id.\n        message (str): Message that will be shown to user.\n        success (bool): Define type (color) of message. False -&gt; red color.\n\n    \"\"\"\n    if not isinstance(success, bool):\n        success = False\n\n    try:\n        message = str(message)\n    except Exception:\n        return\n\n    user_id = event[\"source\"][\"user\"][\"id\"]\n    target = (\n        \"applicationId=ftrack.client.web and user.id=\\\"{}\\\"\"\n    ).format(user_id)\n    self.session.event_hub.publish(\n        ftrack_api.event.base.Event(\n            topic=\"ftrack.action.trigger-user-interface\",\n            data={\n                \"type\": \"message\",\n                \"success\": success,\n                \"message\": message\n            },\n            target=target\n        ),\n        on_error=\"ignore\"\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.FtrackServer","title":"<code>FtrackServer</code>","text":"<p>Helper wrapper to run ftrack server with event handlers.</p> <p>Handlers are discovered based on a list of paths. Each path is scanned for python files which are imported as modules. Each module is checked for 'register' function or classes inheriting from 'BaseHandler'. If class inheriting from 'BaseHandler' is found it is instantiated and 'register' method is called. If 'register' function is found it is called with ftrack session as argument and 'BaseHandler' from the file are ignored.</p> <p>Function 'register' tells discovery system to skip looking for classes.</p> <p>Classes that start with '_' are ignored. It is possible to define attribute <code>__ignore_handler_class = True</code> on class definition to mark a \"base class\" that will be ignored on discovery, so you can safely import custom base classes in the files.</p> Source code in <code>client/ayon_ftrack/common/ftrack_server.py</code> <pre><code>class FtrackServer:\n    \"\"\"Helper wrapper to run ftrack server with event handlers.\n\n    Handlers are discovered based on a list of paths. Each path is scanned for\n    python files which are imported as modules. Each module is checked for\n    'register' function or classes inheriting from 'BaseHandler'. If class\n    inheriting from 'BaseHandler' is found it is instantiated and 'register'\n    method is called. If 'register' function is found it is called with\n    ftrack session as argument and 'BaseHandler' from the file are ignored.\n\n    Function 'register' tells discovery system to skip looking for classes.\n\n    Classes that start with '_' are ignored. It is possible to define\n    attribute `__ignore_handler_class = True` on class definition to mark\n    a \"base class\" that will be ignored on discovery, so you can safely import\n    custom base classes in the files.\n    \"\"\"\n    def __init__(self, handler_paths=None):\n        # set ftrack logging to Warning only - OPTIONAL\n        ftrack_log = logging.getLogger(\"ftrack_api\")\n        ftrack_log.setLevel(logging.WARNING)\n\n        self.log = logging.getLogger(__name__)\n\n        self._stopped = True\n        self._is_running = False\n\n        if handler_paths is None:\n            handler_paths = []\n\n        self._handler_paths = handler_paths\n\n        self._session = None\n        self._cached_modules = []\n        self._cached_objects = []\n\n    def stop_session(self):\n        session = self._session\n        self._session = None\n        self._stopped = True\n        if session.event_hub.connected is True:\n            session.event_hub.disconnect()\n        session.close()\n\n    def get_session(self):\n        return self._session\n\n    def get_handler_paths(self):\n        return self._handler_paths\n\n    def set_handler_paths(self, paths):\n        if self._is_running:\n            raise ValueError(\n                \"Cannot change handler paths when server is running.\"\n            )\n        self._handler_paths = paths\n\n    session = property(get_session)\n    handler_paths = property(get_handler_paths, set_handler_paths)\n\n    def run_server(self, session=None):\n        if self._is_running:\n            raise ValueError(\"Server is already running.\")\n        self._stopped = False\n        self._is_running = True\n        if not session:\n            session = ftrack_api.Session(auto_connect_event_hub=True)\n\n        # Wait until session has connected event hub\n        if session._auto_connect_event_hub_thread:\n            # Use timeout from session (since ftrack-api 2.1.0)\n            timeout = getattr(session, \"request_timeout\", 60)\n            self.log.info(\"Waiting for event hub to connect\")\n            started = time.time()\n            while not session.event_hub.connected:\n                if (time.time() - started) &gt; timeout:\n                    raise RuntimeError((\n                        \"Connection to ftrack was not created in {} seconds\"\n                    ).format(timeout))\n                time.sleep(0.1)\n\n        elif not session.event_hub.connected:\n            self.log.info(\"Connecting event hub\")\n            session.event_hub.connect()\n\n        self._session = session\n        if not self._handler_paths:\n            self.log.warning((\n                \"Paths to event handlers are not set.\"\n                \" ftrack server won't launch.\"\n            ))\n            self._is_running = False\n            return\n\n        self._load_handlers()\n\n        msg = \"Registration of event handlers has finished!\"\n        self.log.info(len(msg) * \"*\")\n        self.log.info(msg)\n\n        # keep event_hub on session running\n        try:\n            session.event_hub.wait()\n        finally:\n            for handler in self._cached_objects:\n                try:\n                    handler.cleanup()\n                except Exception:\n                    self.log.warning(\n                        \"Failed to cleanup handler\", exc_info=True\n                    )\n            self._is_running = False\n            self._cached_modules = []\n\n    def _load_handlers(self):\n        register_functions = []\n        handler_classes = []\n\n        # Iterate all paths\n        paths = self._handler_paths\n        for path in paths:\n            # Try to format path with environments\n            try:\n                path = path.format(**os.environ)\n            except BaseException:\n                pass\n\n            # Get all modules with functions\n            modules, crashed = modules_from_path(path)\n            for filepath, exc_info in crashed:\n                self.log.warning(\"Filepath load crashed {}.\\n{}\".format(\n                    filepath, \"\".join(traceback.format_exception(*exc_info))\n                ))\n\n            for filepath, module in modules:\n                self._cached_modules.append(module)\n                register_function = getattr(module, \"register\", None)\n                if register_function is not None:\n                    if isinstance(register_function, types.FunctionType):\n                        register_functions.append(\n                            (filepath, register_function)\n                        )\n                    else:\n                        self.log.warning(\n                            f\"\\\"{filepath}\\\"\"\n                            \" - Found 'register' but it is not a function.\"\n                        )\n                    continue\n\n                for attr_name in dir(module):\n                    if attr_name.startswith(\"_\"):\n                        self.log.debug(\n                            f\"Skipping private class '{attr_name}'\"\n                        )\n                        continue\n\n                    attr = getattr(module, attr_name, None)\n                    if (\n                        not inspect.isclass(attr)\n                        or not issubclass(attr, BaseHandler)\n                        or attr.ignore_handler_class()\n                    ):\n                        continue\n\n                    if inspect.isabstract(attr):\n                        self.log.warning(\n                            f\"Skipping abstract class '{attr_name}'.\"\n                        )\n                        continue\n                    handler_classes.append(attr)\n\n                if not handler_classes:\n                    self.log.warning(\n                        f\"\\\"{filepath}\\\"\"\n                        \" - No 'register' function\"\n                        \" or 'BaseHandler' classes found.\"\n                    )\n\n        if not register_functions and not handler_classes:\n            self.log.warning((\n                \"There are no files with `register` function or 'BaseHandler'\"\n                \" classes in registered paths:\\n- \\\"{}\\\"\"\n            ).format(\"- \\n\".join(paths)))\n\n        for filepath, register_func in register_functions:\n            try:\n                register_func(self._session)\n            except Exception:\n                self.log.warning(\n                    f\"\\\"{filepath}\\\" - register was not successful\",\n                    exc_info=True\n                )\n\n        for handler_class in handler_classes:\n            try:\n                obj = handler_class(self._session)\n                obj.register()\n                self._cached_objects.append(obj)\n\n            except Exception:\n                self.log.warning(\n                    f\"\\\"{handler_class}\\\" - register was not successful\",\n                    exc_info=True\n                )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.LocalAction","title":"<code>LocalAction</code>","text":"<p>               Bases: <code>BaseAction</code></p> <p>Action that warn user when more Processes with same action are running.</p> <p>Action is launched all the time but if id does not match id of current instanace then message is shown to user.</p> <p>Handy for actions where matters if is executed on specific machine.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>class LocalAction(BaseAction):\n    \"\"\"Action that warn user when more Processes with same action are running.\n\n    Action is launched all the time but if id does not match id of current\n    instanace then message is shown to user.\n\n    Handy for actions where matters if is executed on specific machine.\n    \"\"\"\n    __ignore_handler_class: bool = True\n    _full_launch_identifier: bool = None\n\n    @property\n    def discover_identifier(self) -&gt; str:\n        if self._discover_identifier is None:\n            self._discover_identifier = \"{}.{}\".format(\n                self.identifier, self.process_identifier()\n            )\n        return self._discover_identifier\n\n    @property\n    def launch_identifier(self) -&gt; str:\n        \"\"\"Catch all topics with same identifier.\"\"\"\n        if self._launch_identifier is None:\n            self._launch_identifier = \"{}.*\".format(self.identifier)\n        return self._launch_identifier\n\n    @property\n    def full_launch_identifier(self):\n        \"\"\"Catch all topics with same identifier.\"\"\"\n        if self._full_launch_identifier is None:\n            self._full_launch_identifier = \"{}.{}\".format(\n                self.identifier, self.process_identifier()\n            )\n        return self._full_launch_identifier\n\n    def register(self):\n        \"\"\"Register to ftrack topics to discover and launch action.\n\n        Filter events to this session user.\n        \"\"\"\n        # Subscribe to discover topic for user under this session\n        self.session.event_hub.subscribe(\n            \"topic=ftrack.action.discover and source.user.username={}\".format(\n                self.session.api_user\n            ),\n            self._discover,\n            priority=self.priority\n        )\n\n        launch_subscription = (\n            \"topic=ftrack.action.launch\"\n            \" and data.actionIdentifier={}\"\n            \" and source.user.username={}\"\n        ).format(self.launch_identifier, self.session.api_user)\n        self.session.event_hub.subscribe(\n            launch_subscription,\n            self._launch\n        )\n\n    def _discover(\n        self, event: ftrack_api.event.base.Event\n    ) -&gt; Optional[Dict[str, Any]]:\n        entities = self._translate_event(event)\n        if not entities:\n            return\n\n        accepts = self.discover(self.session, entities, event)\n        if not accepts:\n            return\n\n        self.log.debug(\"Discovering action with selection: {0}\".format(\n            event[\"data\"].get(\"selection\", [])\n        ))\n\n        return {\n            \"items\": [{\n                \"label\": self.label,\n                \"variant\": self.variant,\n                \"description\": self.description,\n                \"actionIdentifier\": self.discover_identifier,\n                \"icon\": self.icon,\n            }]\n        }\n\n    def _launch(\n        self, event: ftrack_api.event.base.Event\n    ) -&gt; Optional[Dict[str, Any]]:\n        event_identifier = event[\"data\"][\"actionIdentifier\"]\n        # Check if identifier is same\n        # - show message that acion may not be triggered on this machine\n        if event_identifier != self.full_launch_identifier:\n            return {\n                \"success\": False,\n                \"message\": (\n                    \"There are running more AYON processes\"\n                    \" where this action could be launched.\"\n                )\n            }\n        return super()._launch(event)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.LocalAction.full_launch_identifier","title":"<code>full_launch_identifier</code>  <code>property</code>","text":"<p>Catch all topics with same identifier.</p>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.LocalAction.launch_identifier","title":"<code>launch_identifier</code>  <code>property</code>","text":"<p>Catch all topics with same identifier.</p>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.LocalAction.register","title":"<code>register()</code>","text":"<p>Register to ftrack topics to discover and launch action.</p> <p>Filter events to this session user.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>def register(self):\n    \"\"\"Register to ftrack topics to discover and launch action.\n\n    Filter events to this session user.\n    \"\"\"\n    # Subscribe to discover topic for user under this session\n    self.session.event_hub.subscribe(\n        \"topic=ftrack.action.discover and source.user.username={}\".format(\n            self.session.api_user\n        ),\n        self._discover,\n        priority=self.priority\n    )\n\n    launch_subscription = (\n        \"topic=ftrack.action.launch\"\n        \" and data.actionIdentifier={}\"\n        \" and source.user.username={}\"\n    ).format(self.launch_identifier, self.session.api_user)\n    self.session.event_hub.subscribe(\n        launch_subscription,\n        self._launch\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.ServerAction","title":"<code>ServerAction</code>","text":"<p>               Bases: <code>BaseAction</code></p> <p>Action class meant to be used on event server.</p> <p>Unlike the <code>BaseAction</code> roles are not checked on register but on discover. For the same reason register is modified to not filter topics by username.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>class ServerAction(BaseAction):\n    \"\"\"Action class meant to be used on event server.\n\n    Unlike the `BaseAction` roles are not checked on register but on discover.\n    For the same reason register is modified to not filter topics by username.\n    \"\"\"\n    __ignore_handler_class: bool = True\n\n    settings_frack_subkey: str = \"service_event_handlers\"\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.convert_to_fps","title":"<code>convert_to_fps(source_value)</code>","text":"<p>Convert value into fps value.</p> <p>Non string values are kept untouched. String is tried to convert. Valid values: \"1000\" \"1000.05\" \"1000,05\" \",05\" \".05\" \"1000,\" \"1000.\" \"1000/1000\" \"1000.05/1000\" \"1000/1000.05\" \"1000.05/1000.05\" \"1000,05/1000\" \"1000/1000,05\" \"1000,05/1000,05\"</p> <p>Invalid values: \"/\" \"/1000\" \"1000/\" \",\" \".\" ...any other string</p> <p>Returns:</p> Name Type Description <code>float</code> <p>Converted value.</p> <p>Raises:</p> Type Description <code>InvalidFpsValue</code> <p>When value can't be converted to float.</p> Source code in <code>client/ayon_ftrack/common/lib.py</code> <pre><code>def convert_to_fps(source_value):\n    \"\"\"Convert value into fps value.\n\n    Non string values are kept untouched. String is tried to convert.\n    Valid values:\n    \"1000\"\n    \"1000.05\"\n    \"1000,05\"\n    \",05\"\n    \".05\"\n    \"1000,\"\n    \"1000.\"\n    \"1000/1000\"\n    \"1000.05/1000\"\n    \"1000/1000.05\"\n    \"1000.05/1000.05\"\n    \"1000,05/1000\"\n    \"1000/1000,05\"\n    \"1000,05/1000,05\"\n\n    Invalid values:\n    \"/\"\n    \"/1000\"\n    \"1000/\"\n    \",\"\n    \".\"\n    ...any other string\n\n    Returns:\n        float: Converted value.\n\n    Raises:\n        InvalidFpsValue: When value can't be converted to float.\n    \"\"\"\n\n    if not isinstance(source_value, str):\n        if isinstance(source_value, numbers.Number):\n            return float(source_value)\n        return source_value\n\n    value = source_value.strip().replace(\",\", \".\")\n    if not value:\n        raise InvalidFpsValue(\"Got empty value\")\n\n    subs = value.split(\"/\")\n    if len(subs) == 1:\n        str_value = subs[0]\n        if not is_string_number(str_value):\n            raise InvalidFpsValue(\n                \"Value \\\"{}\\\" can't be converted to number.\".format(value)\n            )\n        return float(str_value)\n\n    elif len(subs) == 2:\n        divident, divisor = subs\n        if not divident or not is_string_number(divident):\n            raise InvalidFpsValue(\n                \"Divident value \\\"{}\\\" can't be converted to number\".format(\n                    divident\n                )\n            )\n\n        if not divisor or not is_string_number(divisor):\n            raise InvalidFpsValue(\n                \"Divisor value \\\"{}\\\" can't be converted to number\".format(\n                    divident\n                )\n            )\n        divisor_float = float(divisor)\n        if divisor_float == 0.0:\n            raise InvalidFpsValue(\"Can't divide by zero\")\n        return float(divident) / divisor_float\n\n    raise InvalidFpsValue(\n        \"Value can't be converted to number \\\"{}\\\"\".format(source_value)\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.create_chunks","title":"<code>create_chunks(iterable, chunk_size=None)</code>","text":"<p>Separate iterable into multiple chunks by size.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable[Any]</code> <p>Object that will be separated into chunks.</p> required <code>chunk_size</code> <code>int</code> <p>Size of one chunk. Default value is 200.</p> <code>None</code> <p>Returns:</p> Type Description <p>List[List[Any]]: Chunked items.</p> Source code in <code>client/ayon_ftrack/common/lib.py</code> <pre><code>def create_chunks(iterable, chunk_size=None):\n    \"\"\"Separate iterable into multiple chunks by size.\n\n    Args:\n        iterable (Iterable[Any]): Object that will be separated into chunks.\n        chunk_size (int): Size of one chunk. Default value is 200.\n\n    Returns:\n        List[List[Any]]: Chunked items.\n    \"\"\"\n\n    chunks = []\n    tupled_iterable = tuple(iterable)\n    if not tupled_iterable:\n        return chunks\n    iterable_size = len(tupled_iterable)\n    if chunk_size is None:\n        chunk_size = 200\n\n    if chunk_size &lt; 1:\n        chunk_size = 1\n\n    for idx in range(0, iterable_size, chunk_size):\n        chunks.append(tupled_iterable[idx:idx + chunk_size])\n    return chunks\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.default_custom_attributes_definition","title":"<code>default_custom_attributes_definition()</code>","text":"<p>Default custom attribute definitions created in ftracl.</p> Todos <p>Convert to list of dictionaries to be able determine order. Check if     ftrack api support to define order first!</p> <p>Returns:</p> Type Description <p>dict[str, Any]: Custom attribute configurations per entity type that can be used to create/update custom attributes.</p> Source code in <code>client/ayon_ftrack/common/custom_attributes.py</code> <pre><code>def default_custom_attributes_definition():\n    \"\"\"Default custom attribute definitions created in ftracl.\n\n    Todos:\n        Convert to list of dictionaries to be able determine order. Check if\n            ftrack api support to define order first!\n\n    Returns:\n        dict[str, Any]: Custom attribute configurations per entity type that\n            can be used to create/update custom attributes.\n\n    \"\"\"\n    # TODO use AYON built-in attributes as source of truth\n    json_file_path = os.path.join(\n        os.path.dirname(os.path.abspath(__file__)),\n        \"custom_attributes.json\"\n    )\n    with open(json_file_path, \"r\") as json_stream:\n        data = json.load(json_stream)\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.ensure_mandatory_custom_attributes_exists","title":"<code>ensure_mandatory_custom_attributes_exists(session, addon_settings, attr_confs=None, custom_attribute_types=None, groups=None, security_roles=None)</code>","text":"<p>Make sure that mandatory custom attributes exists in ftrack.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Connected ftrack session.</p> required <code>addon_settings</code> <code>Dict[str, Any]</code> <p>Addon settings.</p> required <code>attr_confs</code> <code>Optional[List[Entity]]</code> <p>Pre-fetched all existing custom attribute configurations in ftrack.</p> <code>None</code> <code>custom_attribute_types</code> <code>Optional[List[Entity]]</code> <p>Pre-fetched custom attribute types.</p> <code>None</code> <code>groups</code> <code>Optional[List[Entity]]</code> <p>Pre-fetched custom attribute groups.</p> <code>None</code> <code>security_roles</code> <code>Optional[List[Entity]]</code> <p>Pre-fetched security roles.</p> <code>None</code> Source code in <code>client/ayon_ftrack/common/custom_attributes.py</code> <pre><code>def ensure_mandatory_custom_attributes_exists(\n    session: ftrack_api.Session,\n    addon_settings: Dict[str, Any],\n    attr_confs: Optional[List[\"FtrackEntity\"]] = None,\n    custom_attribute_types: Optional[List[\"FtrackEntity\"]] = None,\n    groups: Optional[List[\"FtrackEntity\"]] = None,\n    security_roles: Optional[List[\"FtrackEntity\"]] = None,\n):\n    \"\"\"Make sure that mandatory custom attributes exists in ftrack.\n\n    Args:\n        session (ftrack_api.Session): Connected ftrack session.\n        addon_settings (Dict[str, Any]): Addon settings.\n        attr_confs (Optional[List[FtrackEntity]]): Pre-fetched all existing\n            custom attribute configurations in ftrack.\n        custom_attribute_types (Optional[List[FtrackEntity]]): Pre-fetched\n            custom attribute types.\n        groups (Optional[List[FtrackEntity]]): Pre-fetched custom attribute\n            groups.\n        security_roles (Optional[List[FtrackEntity]]): Pre-fetched security\n            roles.\n\n    \"\"\"\n    if attr_confs is None:\n        attr_confs = get_all_attr_configs(session)\n\n    # Split existing custom attributes\n    attr_confs_by_entity_type = collections.defaultdict(list)\n    hier_confs = []\n    for attr_conf in attr_confs:\n        if attr_conf[\"is_hierarchical\"]:\n            hier_confs.append(attr_conf)\n        else:\n            entity_type = attr_conf[\"entity_type\"]\n            attr_confs_by_entity_type[entity_type].append(attr_conf)\n\n    # Prepare possible attribute types\n    if custom_attribute_types is None:\n        custom_attribute_types = session.query(\n            \"select id, name from CustomAttributeType\"\n        ).all()\n\n    attr_type_id_by_low_name = {\n        attr_type[\"name\"].lower(): attr_type[\"id\"]\n        for attr_type in custom_attribute_types\n    }\n\n    if security_roles is None:\n        security_roles = session.query(\n            \"select id, name, type from SecurityRole\"\n        ).all()\n\n    security_roles = {\n        role[\"name\"].lower(): role\n        for role in security_roles\n    }\n    mandatory_attributes_settings = (\n        addon_settings\n        [\"custom_attributes\"]\n        [\"mandatory_attributes\"]\n    )\n\n    # Prepare group\n    group_entity = ensure_custom_attribute_group_exists(\n        session, CUST_ATTR_GROUP, groups\n    )\n    group_id = group_entity[\"id\"]\n\n    for item in [\n        {\n            \"key\": CUST_ATTR_KEY_SERVER_ID,\n            \"type\": \"text\",\n            \"label\": \"AYON ID\",\n            \"default\": \"\",\n            \"is_hierarchical\": True,\n            \"config\": {\"markdown\": False},\n            \"group_id\": group_id,\n        },\n        {\n            \"key\": CUST_ATTR_KEY_SERVER_PATH,\n            \"type\": \"text\",\n            \"label\": \"AYON path\",\n            \"default\": \"\",\n            \"is_hierarchical\": True,\n            \"config\": {\"markdown\": False},\n            \"group_id\": group_id,\n        },\n        {\n            \"key\": CUST_ATTR_KEY_LIST_TYPE,\n            \"type\": \"enumerator\",\n            \"label\": \"AYON list type\",\n            \"default\": \"folder\",\n            \"entity_type\": \"list\",\n            \"is_hierarchical\": False,\n            \"config\": {\n                \"data\": json.dumps([\n                    {\"value\": \"folder\", \"menu\": \"Folder\"},\n                    {\"value\": \"task\", \"menu\": \"Task\"},\n                    {\"value\": \"version\", \"menu\": \"version\"},\n                ]),\n                \"multiSelect\": False,\n            },\n            \"group_id\": group_id,\n        },\n        {\n            \"key\": CUST_ATTR_KEY_SYNC_FAIL,\n            \"type\": \"boolean\",\n            \"label\": \"AYON sync failed\",\n            \"is_hierarchical\": True,\n            \"default\": False,\n            \"group_id\": group_id,\n        },\n        {\n            \"key\": CUST_ATTR_AUTO_SYNC,\n            \"type\": \"boolean\",\n            \"label\": \"AYON auto-sync\",\n            \"default\": False,\n            \"is_hierarchical\": False,\n            \"entity_type\": \"show\",\n            \"group_id\": group_id,\n        }\n    ]:\n        key = item[\"key\"]\n        attr_settings = mandatory_attributes_settings[key]\n        read_roles = []\n        write_roles = []\n        for role_names, roles in (\n            (attr_settings[\"read_security_roles\"], read_roles),\n            (attr_settings[\"write_security_roles\"], write_roles),\n        ):\n            if not role_names:\n                roles.extend(security_roles.values())\n                continue\n\n            for name in role_names:\n                role = security_roles.get(name.lower())\n                if role is not None:\n                    roles.append(role)\n\n        is_hierarchical = item[\"is_hierarchical\"]\n        entity_type_confs = hier_confs\n        if not is_hierarchical:\n            entity_type = item[\"entity_type\"]\n            entity_type_confs = attr_confs_by_entity_type.get(entity_type, [])\n        matching_attr_conf = next(\n            (\n                attr_conf\n                for attr_conf in entity_type_confs\n                if attr_conf[\"key\"] == key\n            ),\n            None\n        )\n\n        entity_data = copy.deepcopy(item)\n        attr_type = entity_data.pop(\"type\")\n        entity_data[\"type_id\"] = attr_type_id_by_low_name[attr_type.lower()]\n        # Convert 'config' to json string\n        config = entity_data.get(\"config\")\n        if isinstance(config, dict):\n            entity_data[\"config\"] = json.dumps(config)\n\n        if matching_attr_conf is None:\n            # Make sure 'entity_type' is filled for hierarchical attribute\n            # - it is required to be able to create custom attribute\n            if is_hierarchical:\n                entity_data.setdefault(\"entity_type\", \"show\")\n            # Make sure config is set to empty dictionary for creation\n            entity_data.setdefault(\"config\", \"{}\")\n            entity_data[\"read_security_roles\"] = read_roles\n            entity_data[\"write_security_roles\"] = write_roles\n            session.create(\n                \"CustomAttributeConfiguration\",\n                entity_data\n            )\n            session.commit()\n            continue\n\n        changed = False\n        for key, value in entity_data.items():\n            if matching_attr_conf[key] != value:\n                matching_attr_conf[key] = value\n                changed = True\n\n        match_read_role_ids = {\n            role[\"id\"] for role in matching_attr_conf[\"read_security_roles\"]\n        }\n        match_write_role_ids = {\n            role[\"id\"] for role in matching_attr_conf[\"write_security_roles\"]\n        }\n        if match_read_role_ids != {role[\"id\"] for role in read_roles}:\n            matching_attr_conf[\"read_security_roles\"] = read_roles\n            changed = True\n        if match_write_role_ids != {role[\"id\"] for role in write_roles}:\n            matching_attr_conf[\"write_security_roles\"] = write_roles\n            changed = True\n\n        if changed:\n            session.commit()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.get_all_attr_configs","title":"<code>get_all_attr_configs(session, fields=None)</code>","text":"<p>Query custom attribute configurations from ftrack server.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Connected ftrack session.</p> required <code>fields</code> <code>Optional[Iterable[str]]</code> <p>Field to query for attribute configurations.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Entity]</code> <p>List[FtrackEntity]: ftrack custom attributes.</p> Source code in <code>client/ayon_ftrack/common/custom_attributes.py</code> <pre><code>def get_all_attr_configs(\n    session: ftrack_api.Session,\n    fields: Optional[Iterable[str]] = None,\n) -&gt; List[\"FtrackEntity\"]:\n    \"\"\"Query custom attribute configurations from ftrack server.\n\n    Args:\n        session (ftrack_api.Session): Connected ftrack session.\n        fields (Optional[Iterable[str]]): Field to query for\n            attribute configurations.\n\n    Returns:\n        List[FtrackEntity]: ftrack custom attributes.\n\n    \"\"\"\n    if not fields:\n        fields = {\n            \"id\",\n            \"key\",\n            \"entity_type\",\n            \"object_type_id\",\n            \"is_hierarchical\",\n            \"default\",\n            \"group_id\",\n            \"type_id\",\n            # \"config\",\n            # \"label\",\n            # \"sort\",\n            # \"project_id\",\n        }\n\n    joined_fields = \", \".join(set(fields))\n\n    return session.query(\n        f\"select {joined_fields} from CustomAttributeConfiguration\"\n    ).all()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.get_custom_attributes_by_entity_id","title":"<code>get_custom_attributes_by_entity_id(session, entity_ids, attr_configs, skip_none_values=True, store_by_key=True)</code>","text":"<p>Query custom attribute values and store their value by entity and attr.</p> <p>There is option to return values by attribute key or attribute id. In case the output should be stored by key and there is hierarchical attribute with same key as non-hierarchical it's then hierarchical value has priority of usage.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Connected ftrack session.</p> required <code>entity_ids</code> <code>Iterable[str]</code> <p>Entity ids for which custom attribute values should be returned.</p> required <code>attr_configs</code> <p>Custom attribute configurations.</p> required <code>skip_none_values</code> <code>bool</code> <p>Custom attribute with value set to 'None' won't be in output.</p> <code>True</code> <code>store_by_key</code> <code>bool</code> <p>Output will be stored by attribute keys if true otherwise is value stored by attribute id.</p> <code>True</code> <p>Returns:</p> Type Description <p>Dict[str, Dict[str, Any]]: Custom attribute values by entity id.</p> Source code in <code>client/ayon_ftrack/common/custom_attributes.py</code> <pre><code>def get_custom_attributes_by_entity_id(\n    session,\n    entity_ids,\n    attr_configs,\n    skip_none_values=True,\n    store_by_key=True\n):\n    \"\"\"Query custom attribute values and store their value by entity and attr.\n\n    There is option to return values by attribute key or attribute id. In case\n    the output should be stored by key and there is hierarchical attribute\n    with same key as non-hierarchical it's then hierarchical value\n    has priority of usage.\n\n    Args:\n        session (ftrack_api.Session): Connected ftrack session.\n        entity_ids (Iterable[str]): Entity ids for which custom attribute\n            values should be returned.\n        attr_configs: Custom attribute configurations.\n        skip_none_values (bool): Custom attribute with value set to 'None'\n            won't be in output.\n        store_by_key (bool): Output will be stored by attribute keys if true\n            otherwise is value stored by attribute id.\n\n    Returns:\n        Dict[str, Dict[str, Any]]: Custom attribute values by entity id.\n\n    \"\"\"\n    entity_ids = set(entity_ids)\n    hier_attr_ids = {\n        attr_conf[\"id\"]\n        for attr_conf in attr_configs\n        if attr_conf[\"is_hierarchical\"]\n    }\n    attr_by_id = {\n        attr_conf[\"id\"]: attr_conf[\"key\"]\n        for attr_conf in attr_configs\n    }\n\n    value_items = query_custom_attribute_values(\n        session, attr_by_id.keys(), entity_ids\n    )\n\n    output = collections.defaultdict(dict)\n    for value_item in value_items:\n        value = value_item[\"value\"]\n        if skip_none_values and value is None:\n            continue\n\n        entity_id = value_item[\"entity_id\"]\n        entity_values = output[entity_id]\n        attr_id = value_item[\"configuration_id\"]\n        if not store_by_key:\n            entity_values[attr_id] = value\n            continue\n\n        attr_key = attr_by_id[attr_id]\n        # Hierarchical attributes are always preferred\n        if attr_key not in entity_values or attr_id in hier_attr_ids:\n            entity_values[attr_key] = value\n\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.get_custom_attributes_mapping","title":"<code>get_custom_attributes_mapping(session, addon_settings, attr_confs=None, ayon_attributes=None)</code>","text":"<p>Query custom attribute configurations from ftrack server.</p> <p>Returns:</p> Type Description <code>CustomAttributesMapping</code> <p>Dict[str, List[object]]: ftrack custom attributes.</p> Source code in <code>client/ayon_ftrack/common/custom_attributes.py</code> <pre><code>def get_custom_attributes_mapping(\n    session: ftrack_api.Session,\n    addon_settings: Dict[str, Any],\n    attr_confs: Optional[List[object]] = None,\n    ayon_attributes: Optional[List[object]] = None,\n) -&gt; CustomAttributesMapping:\n    \"\"\"Query custom attribute configurations from ftrack server.\n\n    Returns:\n        Dict[str, List[object]]: ftrack custom attributes.\n\n    \"\"\"\n    cust_attr = addon_settings[\"custom_attributes\"]\n    # \"custom_attributes/attributes_mapping/mapping\"\n    attributes_mapping = cust_attr[\"attributes_mapping\"]\n\n    if attr_confs is None:\n        attr_confs = get_all_attr_configs(session)\n\n    if ayon_attributes is None:\n        ayon_attributes = ayon_api.get_attributes_schema()[\"attributes\"]\n\n    ayon_attribute_names = {\n        attr[\"name\"]\n        for attr in ayon_attributes\n    }\n\n    hier_attrs = []\n    nonhier_attrs = []\n    for attr_conf in attr_confs:\n        if attr_conf[\"is_hierarchical\"]:\n            hier_attrs.append(attr_conf)\n        else:\n            nonhier_attrs.append(attr_conf)\n\n    output = CustomAttributesMapping()\n    if not attributes_mapping[\"enabled\"]:\n        builtin_attrs = {\n            attr[\"name\"]\n            for attr in ayon_attributes\n            if attr[\"builtin\"]\n        }\n        for attr_conf in hier_attrs:\n            attr_name = attr_conf[\"key\"]\n            # Use only AYON attribute hierarchical equivalent\n            if (\n                attr_name in output\n                or attr_name not in ayon_attribute_names\n            ):\n                continue\n\n            # Attribute must be in builtin attributes or openpype/ayon group\n            # NOTE get rid of group name check when only mapping is used\n            if (\n                attr_name in builtin_attrs\n                or attr_conf[\"group\"][\"name\"] in (\"openpype\", CUST_ATTR_GROUP)\n            ):\n                output.add_mapping_item(MappedAYONAttribute(\n                    attr_name,\n                    True,\n                    [attr_conf],\n                ))\n\n    else:\n        for item in attributes_mapping[\"mapping\"]:\n            ayon_attr_name = item[\"name\"]\n            if ayon_attr_name not in ayon_attribute_names:\n                continue\n\n            is_hierarchical = item[\"attr_type\"] == \"hierarchical\"\n\n            mapped_item = MappedAYONAttribute(\n                ayon_attr_name, is_hierarchical, []\n            )\n\n            if is_hierarchical:\n                attr_name = item[\"hierarchical\"]\n                for attr_conf in hier_attrs:\n                    if attr_conf[\"key\"] == attr_name:\n                        mapped_item.add_attr_conf(attr_conf)\n                        break\n            else:\n                attr_names = item[\"standard\"]\n                for attr_conf in nonhier_attrs:\n                    if attr_conf[\"key\"] in attr_names:\n                        mapped_item.add_attr_conf(attr_conf)\n            output.add_mapping_item(mapped_item)\n\n    for attr_name in ayon_attribute_names:\n        if attr_name not in output:\n            output.add_mapping_item(MappedAYONAttribute(attr_name))\n\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.get_datetime_data","title":"<code>get_datetime_data(datetime_obj=None)</code>","text":"<p>Returns current datetime data as dictionary.</p> Note <p>This function is copied from 'ayon_core.lib'.</p> <p>Parameters:</p> Name Type Description Default <code>datetime_obj</code> <code>datetime</code> <p>Specific datetime object</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>prepared date &amp; time data</p> Available keys <p>\"d\" -  in shortest possible way. \"dd\" -  with 2 digits. \"ddd\" -  shortened week day. e.g.: <code>Mon</code>, ... \"dddd\" -  full name of week day. e.g.: <code>Monday</code>, ... \"m\" -  in shortest possible way. e.g.: <code>1</code> if January \"mm\" -  with 2 digits. \"mmm\" -  shortened month name. e.g.: <code>Jan</code>, ... \"mmmm\" -  full month name. e.g.: <code>January</code>, ... \"yy\" -  shortened year. e.g.: <code>19</code>, <code>20</code>, ... \"yyyy\" -  full year. e.g.: <code>2019</code>, <code>2020</code>, ... \"H\" -  shortened hours. \"HH\" -  with 2 digits. \"h\" -  shortened hours. \"hh\" -  with 2 digits. \"ht\" -  AM or PM. \"M\" -  shortened minutes. \"MM\" -  with 2 digits. \"S\" -  shortened seconds. \"SS\" -  with 2 digits. Source code in <code>client/ayon_ftrack/common/utils.py</code> <pre><code>def get_datetime_data(datetime_obj=None):\n    \"\"\"Returns current datetime data as dictionary.\n\n    Note:\n        This function is copied from 'ayon_core.lib'.\n\n    Args:\n        datetime_obj (datetime): Specific datetime object\n\n    Returns:\n        dict: prepared date &amp; time data\n\n    Available keys:\n        \"d\" - &lt;Day of month number&gt; in shortest possible way.\n        \"dd\" - &lt;Day of month number&gt; with 2 digits.\n        \"ddd\" - &lt;Week day name&gt; shortened week day. e.g.: `Mon`, ...\n        \"dddd\" - &lt;Week day name&gt; full name of week day. e.g.: `Monday`, ...\n        \"m\" - &lt;Month number&gt; in shortest possible way. e.g.: `1` if January\n        \"mm\" - &lt;Month number&gt; with 2 digits.\n        \"mmm\" - &lt;Month name&gt; shortened month name. e.g.: `Jan`, ...\n        \"mmmm\" - &lt;Month name&gt; full month name. e.g.: `January`, ...\n        \"yy\" - &lt;Year number&gt; shortened year. e.g.: `19`, `20`, ...\n        \"yyyy\" - &lt;Year number&gt; full year. e.g.: `2019`, `2020`, ...\n        \"H\" - &lt;Hours number 24-hour&gt; shortened hours.\n        \"HH\" - &lt;Hours number 24-hour&gt; with 2 digits.\n        \"h\" - &lt;Hours number 12-hour&gt; shortened hours.\n        \"hh\" - &lt;Hours number 12-hour&gt; with 2 digits.\n        \"ht\" - &lt;Midday type&gt; AM or PM.\n        \"M\" - &lt;Minutes number&gt; shortened minutes.\n        \"MM\" - &lt;Minutes number&gt; with 2 digits.\n        \"S\" - &lt;Seconds number&gt; shortened seconds.\n        \"SS\" - &lt;Seconds number&gt; with 2 digits.\n    \"\"\"\n\n    if not datetime_obj:\n        datetime_obj = datetime.datetime.now()\n\n    year = datetime_obj.strftime(\"%Y\")\n\n    month = datetime_obj.strftime(\"%m\")\n    month_name_full = datetime_obj.strftime(\"%B\")\n    month_name_short = datetime_obj.strftime(\"%b\")\n    day = datetime_obj.strftime(\"%d\")\n\n    weekday_full = datetime_obj.strftime(\"%A\")\n    weekday_short = datetime_obj.strftime(\"%a\")\n\n    hours = datetime_obj.strftime(\"%H\")\n    hours_midday = datetime_obj.strftime(\"%I\")\n    hour_midday_type = datetime_obj.strftime(\"%p\")\n    minutes = datetime_obj.strftime(\"%M\")\n    seconds = datetime_obj.strftime(\"%S\")\n\n    return {\n        \"d\": str(int(day)),\n        \"dd\": str(day),\n        \"ddd\": weekday_short,\n        \"dddd\": weekday_full,\n        \"m\": str(int(month)),\n        \"mm\": str(month),\n        \"mmm\": month_name_short,\n        \"mmmm\": month_name_full,\n        \"yy\": str(year[2:]),\n        \"yyyy\": str(year),\n        \"H\": str(int(hours)),\n        \"HH\": str(hours),\n        \"h\": str(int(hours_midday)),\n        \"hh\": str(hours_midday),\n        \"ht\": hour_midday_type,\n        \"M\": str(int(minutes)),\n        \"MM\": str(minutes),\n        \"S\": str(int(seconds)),\n        \"SS\": str(seconds),\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.get_folder_path_for_entities","title":"<code>get_folder_path_for_entities(session, entities, path_cust_attr_id=None, allow_use_link=True)</code>","text":"<p>Get folder path for ftrack entities.</p> <p>Folder path is received from custom attribute, or from entity link     which contains name of parent entities.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Connected ftrack session.</p> required <code>entities</code> <code>List[dict]</code> <p>List of ftrack entities.</p> required <code>path_cust_attr_id</code> <code>Union[str, None]</code> <p>Custom attribute configuration id which stores entity path.</p> <code>None</code> <code>allow_use_link</code> <code>bool</code> <p>Use 'link' value if path is not found in custom attributes.</p> <code>True</code> <p>Returns:</p> Type Description <p>dict[str, Union[str, None]]: Entity path by ftrack entity id. Output will always contain all entity ids from input.</p> Source code in <code>client/ayon_ftrack/common/utils.py</code> <pre><code>def get_folder_path_for_entities(\n    session, entities, path_cust_attr_id=None, allow_use_link=True\n):\n    \"\"\"Get folder path for ftrack entities.\n\n    Folder path is received from custom attribute, or from entity link\n        which contains name of parent entities.\n\n    Args:\n        session (ftrack_api.Session): Connected ftrack session.\n        entities (List[dict]): List of ftrack entities.\n        path_cust_attr_id (Union[str, None]): Custom attribute\n            configuration id which stores entity path.\n        allow_use_link (bool): Use 'link' value if path is not found in\n            custom attributes.\n\n    Returns:\n        dict[str, Union[str, None]]: Entity path by ftrack entity id.\n            Output will always contain all entity ids from input.\n    \"\"\"\n\n    entities_by_id = {\n        entity[\"id\"]: entity\n        for entity in entities\n    }\n    entity_ids = set(entities_by_id.keys())\n    folder_paths_by_id = {\n        entity_id: None\n        for entity_id in entity_ids\n    }\n    if not folder_paths_by_id:\n        return folder_paths_by_id\n\n    if path_cust_attr_id is None:\n        cust_attr_conf = session.query(\n            \"select id, key from CustomAttributeConfiguration\"\n            f\" where key is '{CUST_ATTR_KEY_SERVER_PATH}'\"\n        ).first()\n        if cust_attr_conf:\n            path_cust_attr_id = cust_attr_conf[\"id\"]\n\n    value_items = []\n    if path_cust_attr_id is not None:\n        value_items = query_custom_attribute_values(\n            session, {path_cust_attr_id}, entity_ids\n        )\n\n    for value_item in value_items:\n        path = value_item[\"value\"]\n        entity_id = value_item[\"entity_id\"]\n        if path:\n            entity_ids.discard(entity_id)\n            folder_paths_by_id[entity_id] = path\n\n    if allow_use_link:\n        for missing_id in entity_ids:\n            entity = entities_by_id[missing_id]\n            # Use stupidly simple solution\n            link_names = [item[\"name\"] for item in entity[\"link\"]]\n            # Change project name to empty string\n            link_names[0] = \"\"\n            folder_paths_by_id[missing_id] = \"/\".join(link_names)\n\n    return folder_paths_by_id\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.get_ftrack_icon_url","title":"<code>get_ftrack_icon_url(icon_name, addon_version, addon_name=None)</code>","text":"<p>Helper to get icon url to server.</p> <p>The existence of file is not validated.</p> <p>Parameters:</p> Name Type Description Default <code>icon_name</code> <code>str</code> <p>Name of icon filename.</p> required <code>addon_version</code> <code>str</code> <p>Version of addon.</p> required <code>addon_name</code> <code>Optional[str]</code> <p>Name of addon. For development purposes. Default value 'ftrack'.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>Url to icon on server.</p> Source code in <code>client/ayon_ftrack/common/lib.py</code> <pre><code>def get_ftrack_icon_url(icon_name, addon_version, addon_name=None):\n    \"\"\"Helper to get icon url to server.\n\n    The existence of file is not validated.\n\n    Args:\n        icon_name (str): Name of icon filename.\n        addon_version (str): Version of addon.\n        addon_name (Optional[str]): Name of addon. For development purposes.\n            Default value 'ftrack'.\n\n    Returns:\n        str: Url to icon on server.\n    \"\"\"\n\n    return get_ftrack_public_url(\n        \"icons\", icon_name,\n        addon_version=addon_version,\n        addon_name=addon_name\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.get_ftrack_public_url","title":"<code>get_ftrack_public_url(*args, addon_version, addon_name=None)</code>","text":"<p>Url to public path in ftrack addon.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>tuple[str]</code> <p>Subpaths in 'public' dir.</p> <code>()</code> <code>addon_version</code> <code>str</code> <p>Version of addon.</p> required <code>addon_name</code> <code>Optional[str]</code> <p>Name of addon. This is for development purposes. Default value 'ftrack'.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>Url to public file on server in ftrack addon.</p> Source code in <code>client/ayon_ftrack/common/lib.py</code> <pre><code>def get_ftrack_public_url(*args, addon_version, addon_name=None):\n    \"\"\"Url to public path in ftrack addon.\n\n    Args:\n        args (tuple[str]): Subpaths in 'public' dir.\n        addon_version (str): Version of addon.\n        addon_name (Optional[str]): Name of addon. This is for development\n            purposes. Default value 'ftrack'.\n\n    Returns:\n        str: Url to public file on server in ftrack addon.\n    \"\"\"\n\n    server_url = get_base_url()\n    parts = [\n        server_url,\n        \"addons\",\n        addon_name or \"ftrack\",\n        addon_version,\n        \"public\"\n    ]\n    parts.extend(args)\n    return \"/\".join(parts)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.get_host_ip","title":"<code>get_host_ip()</code>","text":"<p>Get IP of machine.</p> <p>Returns:</p> Type Description <p>Union[str, None]: IP address of machine or None if could not be detected.</p> Source code in <code>client/ayon_ftrack/common/lib.py</code> <pre><code>def get_host_ip():\n    \"\"\"Get IP of machine.\n\n    Returns:\n        Union[str, None]: IP address of machine or None if could not be\n            detected.\n    \"\"\"\n\n    host_name = socket.gethostname()\n    try:\n        return socket.gethostbyname(host_name)\n    except Exception:\n        pass\n\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.get_service_ftrack_icon_url","title":"<code>get_service_ftrack_icon_url(icon_name, addon_version=None, addon_name=None)</code>","text":"<p>Icon url to server for service process.</p> <p>Information about addon version are taken from registered service in 'ayon_api'.</p> <p>Parameters:</p> Name Type Description Default <code>icon_name</code> <code>str</code> <p>Name of icon filename.</p> required <code>addon_version</code> <code>Optional[str]</code> <p>Version of addon. Version from registered service is used if not passed. For development purposes.</p> <code>None</code> <code>addon_name</code> <code>Optional[str]</code> <p>Name of addon. For development purposes.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>Url to icon on server.</p> Source code in <code>client/ayon_ftrack/common/lib.py</code> <pre><code>def get_service_ftrack_icon_url(\n    icon_name, addon_version=None, addon_name=None\n):\n    \"\"\"Icon url to server for service process.\n\n    Information about addon version are taken from registered service\n    in 'ayon_api'.\n\n    Args:\n        icon_name (str): Name of icon filename.\n        addon_version (Optional[str]): Version of addon. Version from\n            registered service is used if not passed. For development purposes.\n        addon_name (Optional[str]): Name of addon. For development purposes.\n\n    Returns:\n        str: Url to icon on server.\n    \"\"\"\n\n    return get_ftrack_icon_url(\n        icon_name,\n        addon_version=addon_version or get_service_addon_version(),\n        addon_name=addon_name or get_service_addon_name()\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.import_filepath","title":"<code>import_filepath(filepath, module_name=None)</code>","text":"<p>Import python file as python module.</p> <p>Python 2 and Python 3 compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to python file.</p> required <code>module_name</code> <code>str</code> <p>Name of loaded module. Only for Python 3. By default is filled with filename of filepath.</p> <code>None</code> Source code in <code>client/ayon_ftrack/common/python_module_tools.py</code> <pre><code>def import_filepath(filepath, module_name=None):\n    \"\"\"Import python file as python module.\n\n    Python 2 and Python 3 compatibility.\n\n    Args:\n        filepath(str): Path to python file.\n        module_name(str): Name of loaded module. Only for Python 3. By default\n            is filled with filename of filepath.\n    \"\"\"\n    if module_name is None:\n        module_name = os.path.splitext(os.path.basename(filepath))[0]\n\n    # Make sure it is not 'unicode' in Python 2\n    module_name = str(module_name)\n\n    # Prepare module object where content of file will be parsed\n    module = types.ModuleType(module_name)\n\n    # Use loader so module has full specs\n    module_loader = importlib.machinery.SourceFileLoader(\n        module_name, filepath\n    )\n    module_loader.exec_module(module)\n    return module\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.is_ftrack_enabled_in_settings","title":"<code>is_ftrack_enabled_in_settings(project_settings)</code>","text":"<p>Check if ftrack is enabled in ftrack project settings.</p> <p>This function expect settings for a specific project. It is not checking if ftrack is enabled in general.</p> <p>Project settings gives option to disable ftrack integration per project. That should disable most of ftrack integration functionality, especially pipeline integration &gt; publish plugins, and some automations like event server handlers.</p> <p>Parameters:</p> Name Type Description Default <code>project_settings</code> <code>dict[str, Any]</code> <p>ftrack project settings.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if ftrack is enabled in project settings.</p> Source code in <code>client/ayon_ftrack/common/lib.py</code> <pre><code>def is_ftrack_enabled_in_settings(project_settings):\n    \"\"\"Check if ftrack is enabled in ftrack project settings.\n\n    This function expect settings for a specific project. It is not checking\n    if ftrack is enabled in general.\n\n    Project settings gives option to disable ftrack integration per project.\n    That should disable most of ftrack integration functionality, especially\n    pipeline integration &gt; publish plugins, and some automations like event\n    server handlers.\n\n    Args:\n        project_settings (dict[str, Any]): ftrack project settings.\n\n    Returns:\n        bool: True if ftrack is enabled in project settings.\n    \"\"\"\n\n    ftrack_enabled = project_settings.get(\"enabled\")\n    # If 'ftrack_enabled' is not set, we assume it is enabled.\n    # - this is for backwards compatibility - remove in future\n    if ftrack_enabled is None:\n        return True\n    return ftrack_enabled\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.join_filter_values","title":"<code>join_filter_values(values)</code>","text":"<p>Prepare values to be used for filtering in ftrack query.</p> <p>Parameters:</p> Name Type Description Default <code>Iterable[str]</code> <p>Values to join for filter query.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Prepared values for ftrack query.</p> Source code in <code>client/ayon_ftrack/common/lib.py</code> <pre><code>def join_filter_values(values):\n    \"\"\"Prepare values to be used for filtering in ftrack query.\n\n    Args:\n        Iterable[str]: Values to join for filter query.\n\n    Returns:\n        str: Prepared values for ftrack query.\n    \"\"\"\n\n    return \",\".join({\n        '\"{}\"'.format(value)\n        for value in values\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.map_ftrack_users_to_ayon_users","title":"<code>map_ftrack_users_to_ayon_users(ftrack_users, ayon_users=None)</code>","text":"<p>Map ftrack users to AYON users.</p> <p>Mapping is based on 2 possible keys, email and username where email has higher priority. Once AYON user is mapped it cannot be mapped again to different user.</p> <p>Fields used from ftrack users: 'id', 'username', 'email'.</p> <p>Parameters:</p> Name Type Description Default <code>ftrack_users</code> <code>List[User]</code> <p>List of ftrack users.</p> required <code>ayon_users</code> <code>List[Dict[str, Any]]</code> <p>List of AYON users.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Union[str, None]]</code> <p>Dict[str, Union[str, None]]: Mapping of ftrack user id to AYON username.</p> Source code in <code>client/ayon_ftrack/common/users.py</code> <pre><code>def map_ftrack_users_to_ayon_users(\n    ftrack_users: List[\"ftrack_api.entity.user.User\"],\n    ayon_users: Optional[List[Dict[str, Any]]] = None,\n) -&gt; Dict[str, \"Union[str, None]\"]:\n    \"\"\"Map ftrack users to AYON users.\n\n    Mapping is based on 2 possible keys, email and username where email has\n    higher priority. Once AYON user is mapped it cannot be mapped again to\n    different user.\n\n    Fields used from ftrack users: 'id', 'username', 'email'.\n\n    Args:\n        ftrack_users (List[ftrack_api.entity.user.User]): List of ftrack users.\n        ayon_users (List[Dict[str, Any]]): List of AYON users.\n\n    Returns:\n        Dict[str, Union[str, None]]: Mapping of ftrack user id\n            to AYON username.\n\n    \"\"\"\n    if ayon_users is None:\n        ayon_users = ayon_api.get_users()\n\n    mapping: Dict[str, \"Union[str, None]\"] = {\n        user[\"id\"]: None\n        for user in ftrack_users\n    }\n    ayon_users_by_email: Dict[str, str] = {}\n    ayon_users_by_name: Dict[str, str] = {}\n    for ayon_user in ayon_users:\n        ayon_name = ayon_user[\"name\"]\n        ayon_email = ayon_user[\"attrib\"][\"email\"]\n        ayon_users_by_name[ayon_name.lower()] = ayon_name\n        if ayon_email:\n            ayon_users_by_email[ayon_email.lower()] = ayon_name\n\n    mapped_ayon_users: Set[str] = set()\n    for ftrack_user in ftrack_users:\n        ftrack_id: str = ftrack_user[\"id\"]\n        # Make sure username does not contain '@' character\n        ftrack_name: str = ftrack_user[\"username\"].split(\"@\", 1)[0]\n        ftrack_email: str = ftrack_user[\"email\"]\n\n        if ftrack_email and ftrack_email.lower() in ayon_users_by_email:\n            ayon_name: str = ayon_users_by_email[ftrack_email.lower()]\n            if ayon_name not in mapped_ayon_users:\n                mapping[ftrack_id] = ayon_name\n                mapped_ayon_users.add(ayon_name)\n            continue\n\n        if ftrack_name in ayon_users_by_name:\n            ayon_name: str = ayon_users_by_name[ftrack_name]\n            if ayon_name not in mapped_ayon_users:\n                mapped_ayon_users.add(ayon_name)\n                mapping[ftrack_id] = ayon_name\n\n    return mapping\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.modules_from_path","title":"<code>modules_from_path(folder_path, log=None)</code>","text":"<p>Get python scripts as modules from a path.</p> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>str</code> <p>Path to folder containing python scripts.</p> required <code>log</code> <code>Optional[Logger]</code> <p>Logger used for logs.</p> <code>None</code> <p>Returns:</p> Type Description <p>tuple: First list contains successfully imported modules and second list contains tuples of path and exception. Source code in <code>client/ayon_ftrack/common/python_module_tools.py</code> <pre><code>def modules_from_path(folder_path, log=None):\n    \"\"\"Get python scripts as modules from a path.\n\n    Arguments:\n        folder_path (str): Path to folder containing python scripts.\n        log (Optional[logging.Logger]): Logger used for logs.\n\n    Returns:\n        tuple&lt;list, list&gt;: First list contains successfully imported modules\n            and second list contains tuples of path and exception.\n    \"\"\"\n    crashed = []\n    modules = []\n    output = (modules, crashed)\n    # Just skip and return empty list if path is not set\n    if not folder_path:\n        return output\n\n    if log is None:\n        log = logging.getLogger(\"modules_from_path\")\n    # Do not allow relative imports\n    if folder_path.startswith(\".\"):\n        log.warning((\n            \"BUG: Relative paths are not allowed for security reasons. {}\"\n        ).format(folder_path))\n        return output\n\n    folder_path = os.path.normpath(folder_path)\n\n    if not os.path.isdir(folder_path):\n        log.warning(\"Not a directory path: {}\".format(folder_path))\n        return output\n\n    for filename in os.listdir(folder_path):\n        # Ignore files which start with underscore\n        if filename.startswith(\"_\"):\n            continue\n\n        mod_name, mod_ext = os.path.splitext(filename)\n        if not mod_ext == \".py\":\n            continue\n\n        full_path = os.path.join(folder_path, filename)\n        if not os.path.isfile(full_path):\n            continue\n\n        try:\n            module = import_filepath(full_path, mod_name)\n            modules.append((full_path, module))\n\n        except Exception:\n            crashed.append((full_path, sys.exc_info()))\n            log.warning(\n                \"Failed to load path: \\\"{0}\\\"\".format(full_path),\n                exc_info=True\n            )\n            continue\n\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/index.html#client.ayon_ftrack.common.query_custom_attribute_values","title":"<code>query_custom_attribute_values(session, attr_ids, entity_ids)</code>","text":"<p>Query custom attribute values from ftrack database.</p> <p>Using ftrack call method result may differ based on used table name and version of ftrack server.</p> <p>For hierarchical attributes you shou always use <code>only_set_values=True</code> otherwise result will be default value of custom attribute and it would not be possible to differentiate if value is set on entity or default value is used.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Connected ftrack session.</p> required <code>attr_ids</code> <code>Iterable[str]</code> <p>Attribute configuration ids.</p> required <code>entity_ids</code> <code>Iterable[str]</code> <p>Entity ids for which are values queried.</p> required <p>Returns:</p> Type Description <p>List[Dict[str, Any]]: Results from server.</p> Source code in <code>client/ayon_ftrack/common/custom_attributes.py</code> <pre><code>def query_custom_attribute_values(session, attr_ids, entity_ids):\n    \"\"\"Query custom attribute values from ftrack database.\n\n    Using ftrack call method result may differ based on used table name and\n    version of ftrack server.\n\n    For hierarchical attributes you shou always use `only_set_values=True`\n    otherwise result will be default value of custom attribute and it would not\n    be possible to differentiate if value is set on entity or default value is\n    used.\n\n    Args:\n        session (ftrack_api.Session): Connected ftrack session.\n        attr_ids (Iterable[str]): Attribute configuration ids.\n        entity_ids (Iterable[str]): Entity ids for which are values queried.\n\n    Returns:\n        List[Dict[str, Any]]: Results from server.\n    \"\"\"\n\n    output = []\n    # Just skip\n    attr_ids = set(attr_ids)\n    entity_ids = set(entity_ids)\n    if not attr_ids or not entity_ids:\n        return output\n\n    # Prepare values to query\n    attributes_joined = join_filter_values(attr_ids)\n\n    # Query values in chunks\n    chunk_size = 5000 // len(attr_ids)\n    # Make sure entity_ids is `list` for chunk selection\n    for chunk in create_chunks(entity_ids, chunk_size):\n        entity_ids_joined = join_filter_values(chunk)\n        output.extend(\n            session.query(\n                (\n                    \"select value, entity_id, configuration_id\"\n                    \" from CustomAttributeValue\"\n                    \" where entity_id in ({}) and configuration_id in ({})\"\n                ).format(entity_ids_joined, attributes_joined)\n            ).all()\n        )\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/constants.html","title":"constants","text":""},{"location":"autoapi/client/ayon_ftrack/common/custom_attributes.html","title":"custom_attributes","text":""},{"location":"autoapi/client/ayon_ftrack/common/custom_attributes.html#client.ayon_ftrack.common.custom_attributes.default_custom_attributes_definition","title":"<code>default_custom_attributes_definition()</code>","text":"<p>Default custom attribute definitions created in ftracl.</p> Todos <p>Convert to list of dictionaries to be able determine order. Check if     ftrack api support to define order first!</p> <p>Returns:</p> Type Description <p>dict[str, Any]: Custom attribute configurations per entity type that can be used to create/update custom attributes.</p> Source code in <code>client/ayon_ftrack/common/custom_attributes.py</code> <pre><code>def default_custom_attributes_definition():\n    \"\"\"Default custom attribute definitions created in ftracl.\n\n    Todos:\n        Convert to list of dictionaries to be able determine order. Check if\n            ftrack api support to define order first!\n\n    Returns:\n        dict[str, Any]: Custom attribute configurations per entity type that\n            can be used to create/update custom attributes.\n\n    \"\"\"\n    # TODO use AYON built-in attributes as source of truth\n    json_file_path = os.path.join(\n        os.path.dirname(os.path.abspath(__file__)),\n        \"custom_attributes.json\"\n    )\n    with open(json_file_path, \"r\") as json_stream:\n        data = json.load(json_stream)\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/custom_attributes.html#client.ayon_ftrack.common.custom_attributes.ensure_custom_attribute_group_exists","title":"<code>ensure_custom_attribute_group_exists(session, group, groups=None)</code>","text":"<p>Ensure custom attribute group in ftrack.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Connected ftrack session.</p> required <code>group</code> <code>str</code> <p>Name of group.</p> required <code>groups</code> <code>Optional[List[Entity]]</code> <p>Pre-fetched custom attribute groups.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FtrackEntity</code> <code>Entity</code> <p>Created custom attribute group.</p> Source code in <code>client/ayon_ftrack/common/custom_attributes.py</code> <pre><code>def ensure_custom_attribute_group_exists(\n    session: ftrack_api.Session,\n    group: str,\n    groups: Optional[List[\"FtrackEntity\"]] = None,\n) -&gt; \"FtrackEntity\":\n    \"\"\"Ensure custom attribute group in ftrack.\n\n    Args:\n        session (ftrack_api.Session): Connected ftrack session.\n        group (str): Name of group.\n        groups (Optional[List[FtrackEntity]]): Pre-fetched\n            custom attribute groups.\n\n    Returns:\n        FtrackEntity: Created custom attribute group.\n\n    \"\"\"\n    if groups is None:\n        groups = session.query(\n            \"select id, name from CustomAttributeGroup\"\n        ).all()\n    low_name = group.lower()\n    for group in groups:\n        if group[\"name\"].lower() == low_name:\n            return group\n\n    group = session.create(\n        \"CustomAttributeGroup\",\n        {\"name\": group}\n    )\n    session.commit()\n    return group\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/custom_attributes.html#client.ayon_ftrack.common.custom_attributes.ensure_mandatory_custom_attributes_exists","title":"<code>ensure_mandatory_custom_attributes_exists(session, addon_settings, attr_confs=None, custom_attribute_types=None, groups=None, security_roles=None)</code>","text":"<p>Make sure that mandatory custom attributes exists in ftrack.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Connected ftrack session.</p> required <code>addon_settings</code> <code>Dict[str, Any]</code> <p>Addon settings.</p> required <code>attr_confs</code> <code>Optional[List[Entity]]</code> <p>Pre-fetched all existing custom attribute configurations in ftrack.</p> <code>None</code> <code>custom_attribute_types</code> <code>Optional[List[Entity]]</code> <p>Pre-fetched custom attribute types.</p> <code>None</code> <code>groups</code> <code>Optional[List[Entity]]</code> <p>Pre-fetched custom attribute groups.</p> <code>None</code> <code>security_roles</code> <code>Optional[List[Entity]]</code> <p>Pre-fetched security roles.</p> <code>None</code> Source code in <code>client/ayon_ftrack/common/custom_attributes.py</code> <pre><code>def ensure_mandatory_custom_attributes_exists(\n    session: ftrack_api.Session,\n    addon_settings: Dict[str, Any],\n    attr_confs: Optional[List[\"FtrackEntity\"]] = None,\n    custom_attribute_types: Optional[List[\"FtrackEntity\"]] = None,\n    groups: Optional[List[\"FtrackEntity\"]] = None,\n    security_roles: Optional[List[\"FtrackEntity\"]] = None,\n):\n    \"\"\"Make sure that mandatory custom attributes exists in ftrack.\n\n    Args:\n        session (ftrack_api.Session): Connected ftrack session.\n        addon_settings (Dict[str, Any]): Addon settings.\n        attr_confs (Optional[List[FtrackEntity]]): Pre-fetched all existing\n            custom attribute configurations in ftrack.\n        custom_attribute_types (Optional[List[FtrackEntity]]): Pre-fetched\n            custom attribute types.\n        groups (Optional[List[FtrackEntity]]): Pre-fetched custom attribute\n            groups.\n        security_roles (Optional[List[FtrackEntity]]): Pre-fetched security\n            roles.\n\n    \"\"\"\n    if attr_confs is None:\n        attr_confs = get_all_attr_configs(session)\n\n    # Split existing custom attributes\n    attr_confs_by_entity_type = collections.defaultdict(list)\n    hier_confs = []\n    for attr_conf in attr_confs:\n        if attr_conf[\"is_hierarchical\"]:\n            hier_confs.append(attr_conf)\n        else:\n            entity_type = attr_conf[\"entity_type\"]\n            attr_confs_by_entity_type[entity_type].append(attr_conf)\n\n    # Prepare possible attribute types\n    if custom_attribute_types is None:\n        custom_attribute_types = session.query(\n            \"select id, name from CustomAttributeType\"\n        ).all()\n\n    attr_type_id_by_low_name = {\n        attr_type[\"name\"].lower(): attr_type[\"id\"]\n        for attr_type in custom_attribute_types\n    }\n\n    if security_roles is None:\n        security_roles = session.query(\n            \"select id, name, type from SecurityRole\"\n        ).all()\n\n    security_roles = {\n        role[\"name\"].lower(): role\n        for role in security_roles\n    }\n    mandatory_attributes_settings = (\n        addon_settings\n        [\"custom_attributes\"]\n        [\"mandatory_attributes\"]\n    )\n\n    # Prepare group\n    group_entity = ensure_custom_attribute_group_exists(\n        session, CUST_ATTR_GROUP, groups\n    )\n    group_id = group_entity[\"id\"]\n\n    for item in [\n        {\n            \"key\": CUST_ATTR_KEY_SERVER_ID,\n            \"type\": \"text\",\n            \"label\": \"AYON ID\",\n            \"default\": \"\",\n            \"is_hierarchical\": True,\n            \"config\": {\"markdown\": False},\n            \"group_id\": group_id,\n        },\n        {\n            \"key\": CUST_ATTR_KEY_SERVER_PATH,\n            \"type\": \"text\",\n            \"label\": \"AYON path\",\n            \"default\": \"\",\n            \"is_hierarchical\": True,\n            \"config\": {\"markdown\": False},\n            \"group_id\": group_id,\n        },\n        {\n            \"key\": CUST_ATTR_KEY_LIST_TYPE,\n            \"type\": \"enumerator\",\n            \"label\": \"AYON list type\",\n            \"default\": \"folder\",\n            \"entity_type\": \"list\",\n            \"is_hierarchical\": False,\n            \"config\": {\n                \"data\": json.dumps([\n                    {\"value\": \"folder\", \"menu\": \"Folder\"},\n                    {\"value\": \"task\", \"menu\": \"Task\"},\n                    {\"value\": \"version\", \"menu\": \"version\"},\n                ]),\n                \"multiSelect\": False,\n            },\n            \"group_id\": group_id,\n        },\n        {\n            \"key\": CUST_ATTR_KEY_SYNC_FAIL,\n            \"type\": \"boolean\",\n            \"label\": \"AYON sync failed\",\n            \"is_hierarchical\": True,\n            \"default\": False,\n            \"group_id\": group_id,\n        },\n        {\n            \"key\": CUST_ATTR_AUTO_SYNC,\n            \"type\": \"boolean\",\n            \"label\": \"AYON auto-sync\",\n            \"default\": False,\n            \"is_hierarchical\": False,\n            \"entity_type\": \"show\",\n            \"group_id\": group_id,\n        }\n    ]:\n        key = item[\"key\"]\n        attr_settings = mandatory_attributes_settings[key]\n        read_roles = []\n        write_roles = []\n        for role_names, roles in (\n            (attr_settings[\"read_security_roles\"], read_roles),\n            (attr_settings[\"write_security_roles\"], write_roles),\n        ):\n            if not role_names:\n                roles.extend(security_roles.values())\n                continue\n\n            for name in role_names:\n                role = security_roles.get(name.lower())\n                if role is not None:\n                    roles.append(role)\n\n        is_hierarchical = item[\"is_hierarchical\"]\n        entity_type_confs = hier_confs\n        if not is_hierarchical:\n            entity_type = item[\"entity_type\"]\n            entity_type_confs = attr_confs_by_entity_type.get(entity_type, [])\n        matching_attr_conf = next(\n            (\n                attr_conf\n                for attr_conf in entity_type_confs\n                if attr_conf[\"key\"] == key\n            ),\n            None\n        )\n\n        entity_data = copy.deepcopy(item)\n        attr_type = entity_data.pop(\"type\")\n        entity_data[\"type_id\"] = attr_type_id_by_low_name[attr_type.lower()]\n        # Convert 'config' to json string\n        config = entity_data.get(\"config\")\n        if isinstance(config, dict):\n            entity_data[\"config\"] = json.dumps(config)\n\n        if matching_attr_conf is None:\n            # Make sure 'entity_type' is filled for hierarchical attribute\n            # - it is required to be able to create custom attribute\n            if is_hierarchical:\n                entity_data.setdefault(\"entity_type\", \"show\")\n            # Make sure config is set to empty dictionary for creation\n            entity_data.setdefault(\"config\", \"{}\")\n            entity_data[\"read_security_roles\"] = read_roles\n            entity_data[\"write_security_roles\"] = write_roles\n            session.create(\n                \"CustomAttributeConfiguration\",\n                entity_data\n            )\n            session.commit()\n            continue\n\n        changed = False\n        for key, value in entity_data.items():\n            if matching_attr_conf[key] != value:\n                matching_attr_conf[key] = value\n                changed = True\n\n        match_read_role_ids = {\n            role[\"id\"] for role in matching_attr_conf[\"read_security_roles\"]\n        }\n        match_write_role_ids = {\n            role[\"id\"] for role in matching_attr_conf[\"write_security_roles\"]\n        }\n        if match_read_role_ids != {role[\"id\"] for role in read_roles}:\n            matching_attr_conf[\"read_security_roles\"] = read_roles\n            changed = True\n        if match_write_role_ids != {role[\"id\"] for role in write_roles}:\n            matching_attr_conf[\"write_security_roles\"] = write_roles\n            changed = True\n\n        if changed:\n            session.commit()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/custom_attributes.html#client.ayon_ftrack.common.custom_attributes.get_all_attr_configs","title":"<code>get_all_attr_configs(session, fields=None)</code>","text":"<p>Query custom attribute configurations from ftrack server.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Connected ftrack session.</p> required <code>fields</code> <code>Optional[Iterable[str]]</code> <p>Field to query for attribute configurations.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Entity]</code> <p>List[FtrackEntity]: ftrack custom attributes.</p> Source code in <code>client/ayon_ftrack/common/custom_attributes.py</code> <pre><code>def get_all_attr_configs(\n    session: ftrack_api.Session,\n    fields: Optional[Iterable[str]] = None,\n) -&gt; List[\"FtrackEntity\"]:\n    \"\"\"Query custom attribute configurations from ftrack server.\n\n    Args:\n        session (ftrack_api.Session): Connected ftrack session.\n        fields (Optional[Iterable[str]]): Field to query for\n            attribute configurations.\n\n    Returns:\n        List[FtrackEntity]: ftrack custom attributes.\n\n    \"\"\"\n    if not fields:\n        fields = {\n            \"id\",\n            \"key\",\n            \"entity_type\",\n            \"object_type_id\",\n            \"is_hierarchical\",\n            \"default\",\n            \"group_id\",\n            \"type_id\",\n            # \"config\",\n            # \"label\",\n            # \"sort\",\n            # \"project_id\",\n        }\n\n    joined_fields = \", \".join(set(fields))\n\n    return session.query(\n        f\"select {joined_fields} from CustomAttributeConfiguration\"\n    ).all()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/custom_attributes.html#client.ayon_ftrack.common.custom_attributes.get_custom_attributes_by_entity_id","title":"<code>get_custom_attributes_by_entity_id(session, entity_ids, attr_configs, skip_none_values=True, store_by_key=True)</code>","text":"<p>Query custom attribute values and store their value by entity and attr.</p> <p>There is option to return values by attribute key or attribute id. In case the output should be stored by key and there is hierarchical attribute with same key as non-hierarchical it's then hierarchical value has priority of usage.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Connected ftrack session.</p> required <code>entity_ids</code> <code>Iterable[str]</code> <p>Entity ids for which custom attribute values should be returned.</p> required <code>attr_configs</code> <p>Custom attribute configurations.</p> required <code>skip_none_values</code> <code>bool</code> <p>Custom attribute with value set to 'None' won't be in output.</p> <code>True</code> <code>store_by_key</code> <code>bool</code> <p>Output will be stored by attribute keys if true otherwise is value stored by attribute id.</p> <code>True</code> <p>Returns:</p> Type Description <p>Dict[str, Dict[str, Any]]: Custom attribute values by entity id.</p> Source code in <code>client/ayon_ftrack/common/custom_attributes.py</code> <pre><code>def get_custom_attributes_by_entity_id(\n    session,\n    entity_ids,\n    attr_configs,\n    skip_none_values=True,\n    store_by_key=True\n):\n    \"\"\"Query custom attribute values and store their value by entity and attr.\n\n    There is option to return values by attribute key or attribute id. In case\n    the output should be stored by key and there is hierarchical attribute\n    with same key as non-hierarchical it's then hierarchical value\n    has priority of usage.\n\n    Args:\n        session (ftrack_api.Session): Connected ftrack session.\n        entity_ids (Iterable[str]): Entity ids for which custom attribute\n            values should be returned.\n        attr_configs: Custom attribute configurations.\n        skip_none_values (bool): Custom attribute with value set to 'None'\n            won't be in output.\n        store_by_key (bool): Output will be stored by attribute keys if true\n            otherwise is value stored by attribute id.\n\n    Returns:\n        Dict[str, Dict[str, Any]]: Custom attribute values by entity id.\n\n    \"\"\"\n    entity_ids = set(entity_ids)\n    hier_attr_ids = {\n        attr_conf[\"id\"]\n        for attr_conf in attr_configs\n        if attr_conf[\"is_hierarchical\"]\n    }\n    attr_by_id = {\n        attr_conf[\"id\"]: attr_conf[\"key\"]\n        for attr_conf in attr_configs\n    }\n\n    value_items = query_custom_attribute_values(\n        session, attr_by_id.keys(), entity_ids\n    )\n\n    output = collections.defaultdict(dict)\n    for value_item in value_items:\n        value = value_item[\"value\"]\n        if skip_none_values and value is None:\n            continue\n\n        entity_id = value_item[\"entity_id\"]\n        entity_values = output[entity_id]\n        attr_id = value_item[\"configuration_id\"]\n        if not store_by_key:\n            entity_values[attr_id] = value\n            continue\n\n        attr_key = attr_by_id[attr_id]\n        # Hierarchical attributes are always preferred\n        if attr_key not in entity_values or attr_id in hier_attr_ids:\n            entity_values[attr_key] = value\n\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/custom_attributes.html#client.ayon_ftrack.common.custom_attributes.get_custom_attributes_mapping","title":"<code>get_custom_attributes_mapping(session, addon_settings, attr_confs=None, ayon_attributes=None)</code>","text":"<p>Query custom attribute configurations from ftrack server.</p> <p>Returns:</p> Type Description <code>CustomAttributesMapping</code> <p>Dict[str, List[object]]: ftrack custom attributes.</p> Source code in <code>client/ayon_ftrack/common/custom_attributes.py</code> <pre><code>def get_custom_attributes_mapping(\n    session: ftrack_api.Session,\n    addon_settings: Dict[str, Any],\n    attr_confs: Optional[List[object]] = None,\n    ayon_attributes: Optional[List[object]] = None,\n) -&gt; CustomAttributesMapping:\n    \"\"\"Query custom attribute configurations from ftrack server.\n\n    Returns:\n        Dict[str, List[object]]: ftrack custom attributes.\n\n    \"\"\"\n    cust_attr = addon_settings[\"custom_attributes\"]\n    # \"custom_attributes/attributes_mapping/mapping\"\n    attributes_mapping = cust_attr[\"attributes_mapping\"]\n\n    if attr_confs is None:\n        attr_confs = get_all_attr_configs(session)\n\n    if ayon_attributes is None:\n        ayon_attributes = ayon_api.get_attributes_schema()[\"attributes\"]\n\n    ayon_attribute_names = {\n        attr[\"name\"]\n        for attr in ayon_attributes\n    }\n\n    hier_attrs = []\n    nonhier_attrs = []\n    for attr_conf in attr_confs:\n        if attr_conf[\"is_hierarchical\"]:\n            hier_attrs.append(attr_conf)\n        else:\n            nonhier_attrs.append(attr_conf)\n\n    output = CustomAttributesMapping()\n    if not attributes_mapping[\"enabled\"]:\n        builtin_attrs = {\n            attr[\"name\"]\n            for attr in ayon_attributes\n            if attr[\"builtin\"]\n        }\n        for attr_conf in hier_attrs:\n            attr_name = attr_conf[\"key\"]\n            # Use only AYON attribute hierarchical equivalent\n            if (\n                attr_name in output\n                or attr_name not in ayon_attribute_names\n            ):\n                continue\n\n            # Attribute must be in builtin attributes or openpype/ayon group\n            # NOTE get rid of group name check when only mapping is used\n            if (\n                attr_name in builtin_attrs\n                or attr_conf[\"group\"][\"name\"] in (\"openpype\", CUST_ATTR_GROUP)\n            ):\n                output.add_mapping_item(MappedAYONAttribute(\n                    attr_name,\n                    True,\n                    [attr_conf],\n                ))\n\n    else:\n        for item in attributes_mapping[\"mapping\"]:\n            ayon_attr_name = item[\"name\"]\n            if ayon_attr_name not in ayon_attribute_names:\n                continue\n\n            is_hierarchical = item[\"attr_type\"] == \"hierarchical\"\n\n            mapped_item = MappedAYONAttribute(\n                ayon_attr_name, is_hierarchical, []\n            )\n\n            if is_hierarchical:\n                attr_name = item[\"hierarchical\"]\n                for attr_conf in hier_attrs:\n                    if attr_conf[\"key\"] == attr_name:\n                        mapped_item.add_attr_conf(attr_conf)\n                        break\n            else:\n                attr_names = item[\"standard\"]\n                for attr_conf in nonhier_attrs:\n                    if attr_conf[\"key\"] in attr_names:\n                        mapped_item.add_attr_conf(attr_conf)\n            output.add_mapping_item(mapped_item)\n\n    for attr_name in ayon_attribute_names:\n        if attr_name not in output:\n            output.add_mapping_item(MappedAYONAttribute(attr_name))\n\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/custom_attributes.html#client.ayon_ftrack.common.custom_attributes.query_custom_attribute_values","title":"<code>query_custom_attribute_values(session, attr_ids, entity_ids)</code>","text":"<p>Query custom attribute values from ftrack database.</p> <p>Using ftrack call method result may differ based on used table name and version of ftrack server.</p> <p>For hierarchical attributes you shou always use <code>only_set_values=True</code> otherwise result will be default value of custom attribute and it would not be possible to differentiate if value is set on entity or default value is used.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Connected ftrack session.</p> required <code>attr_ids</code> <code>Iterable[str]</code> <p>Attribute configuration ids.</p> required <code>entity_ids</code> <code>Iterable[str]</code> <p>Entity ids for which are values queried.</p> required <p>Returns:</p> Type Description <p>List[Dict[str, Any]]: Results from server.</p> Source code in <code>client/ayon_ftrack/common/custom_attributes.py</code> <pre><code>def query_custom_attribute_values(session, attr_ids, entity_ids):\n    \"\"\"Query custom attribute values from ftrack database.\n\n    Using ftrack call method result may differ based on used table name and\n    version of ftrack server.\n\n    For hierarchical attributes you shou always use `only_set_values=True`\n    otherwise result will be default value of custom attribute and it would not\n    be possible to differentiate if value is set on entity or default value is\n    used.\n\n    Args:\n        session (ftrack_api.Session): Connected ftrack session.\n        attr_ids (Iterable[str]): Attribute configuration ids.\n        entity_ids (Iterable[str]): Entity ids for which are values queried.\n\n    Returns:\n        List[Dict[str, Any]]: Results from server.\n    \"\"\"\n\n    output = []\n    # Just skip\n    attr_ids = set(attr_ids)\n    entity_ids = set(entity_ids)\n    if not attr_ids or not entity_ids:\n        return output\n\n    # Prepare values to query\n    attributes_joined = join_filter_values(attr_ids)\n\n    # Query values in chunks\n    chunk_size = 5000 // len(attr_ids)\n    # Make sure entity_ids is `list` for chunk selection\n    for chunk in create_chunks(entity_ids, chunk_size):\n        entity_ids_joined = join_filter_values(chunk)\n        output.extend(\n            session.query(\n                (\n                    \"select value, entity_id, configuration_id\"\n                    \" from CustomAttributeValue\"\n                    \" where entity_id in ({}) and configuration_id in ({})\"\n                ).format(entity_ids_joined, attributes_joined)\n            ).all()\n        )\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/exceptions.html","title":"exceptions","text":""},{"location":"autoapi/client/ayon_ftrack/common/ftrack_server.html","title":"ftrack_server","text":""},{"location":"autoapi/client/ayon_ftrack/common/ftrack_server.html#client.ayon_ftrack.common.ftrack_server.FtrackServer","title":"<code>FtrackServer</code>","text":"<p>Helper wrapper to run ftrack server with event handlers.</p> <p>Handlers are discovered based on a list of paths. Each path is scanned for python files which are imported as modules. Each module is checked for 'register' function or classes inheriting from 'BaseHandler'. If class inheriting from 'BaseHandler' is found it is instantiated and 'register' method is called. If 'register' function is found it is called with ftrack session as argument and 'BaseHandler' from the file are ignored.</p> <p>Function 'register' tells discovery system to skip looking for classes.</p> <p>Classes that start with '_' are ignored. It is possible to define attribute <code>__ignore_handler_class = True</code> on class definition to mark a \"base class\" that will be ignored on discovery, so you can safely import custom base classes in the files.</p> Source code in <code>client/ayon_ftrack/common/ftrack_server.py</code> <pre><code>class FtrackServer:\n    \"\"\"Helper wrapper to run ftrack server with event handlers.\n\n    Handlers are discovered based on a list of paths. Each path is scanned for\n    python files which are imported as modules. Each module is checked for\n    'register' function or classes inheriting from 'BaseHandler'. If class\n    inheriting from 'BaseHandler' is found it is instantiated and 'register'\n    method is called. If 'register' function is found it is called with\n    ftrack session as argument and 'BaseHandler' from the file are ignored.\n\n    Function 'register' tells discovery system to skip looking for classes.\n\n    Classes that start with '_' are ignored. It is possible to define\n    attribute `__ignore_handler_class = True` on class definition to mark\n    a \"base class\" that will be ignored on discovery, so you can safely import\n    custom base classes in the files.\n    \"\"\"\n    def __init__(self, handler_paths=None):\n        # set ftrack logging to Warning only - OPTIONAL\n        ftrack_log = logging.getLogger(\"ftrack_api\")\n        ftrack_log.setLevel(logging.WARNING)\n\n        self.log = logging.getLogger(__name__)\n\n        self._stopped = True\n        self._is_running = False\n\n        if handler_paths is None:\n            handler_paths = []\n\n        self._handler_paths = handler_paths\n\n        self._session = None\n        self._cached_modules = []\n        self._cached_objects = []\n\n    def stop_session(self):\n        session = self._session\n        self._session = None\n        self._stopped = True\n        if session.event_hub.connected is True:\n            session.event_hub.disconnect()\n        session.close()\n\n    def get_session(self):\n        return self._session\n\n    def get_handler_paths(self):\n        return self._handler_paths\n\n    def set_handler_paths(self, paths):\n        if self._is_running:\n            raise ValueError(\n                \"Cannot change handler paths when server is running.\"\n            )\n        self._handler_paths = paths\n\n    session = property(get_session)\n    handler_paths = property(get_handler_paths, set_handler_paths)\n\n    def run_server(self, session=None):\n        if self._is_running:\n            raise ValueError(\"Server is already running.\")\n        self._stopped = False\n        self._is_running = True\n        if not session:\n            session = ftrack_api.Session(auto_connect_event_hub=True)\n\n        # Wait until session has connected event hub\n        if session._auto_connect_event_hub_thread:\n            # Use timeout from session (since ftrack-api 2.1.0)\n            timeout = getattr(session, \"request_timeout\", 60)\n            self.log.info(\"Waiting for event hub to connect\")\n            started = time.time()\n            while not session.event_hub.connected:\n                if (time.time() - started) &gt; timeout:\n                    raise RuntimeError((\n                        \"Connection to ftrack was not created in {} seconds\"\n                    ).format(timeout))\n                time.sleep(0.1)\n\n        elif not session.event_hub.connected:\n            self.log.info(\"Connecting event hub\")\n            session.event_hub.connect()\n\n        self._session = session\n        if not self._handler_paths:\n            self.log.warning((\n                \"Paths to event handlers are not set.\"\n                \" ftrack server won't launch.\"\n            ))\n            self._is_running = False\n            return\n\n        self._load_handlers()\n\n        msg = \"Registration of event handlers has finished!\"\n        self.log.info(len(msg) * \"*\")\n        self.log.info(msg)\n\n        # keep event_hub on session running\n        try:\n            session.event_hub.wait()\n        finally:\n            for handler in self._cached_objects:\n                try:\n                    handler.cleanup()\n                except Exception:\n                    self.log.warning(\n                        \"Failed to cleanup handler\", exc_info=True\n                    )\n            self._is_running = False\n            self._cached_modules = []\n\n    def _load_handlers(self):\n        register_functions = []\n        handler_classes = []\n\n        # Iterate all paths\n        paths = self._handler_paths\n        for path in paths:\n            # Try to format path with environments\n            try:\n                path = path.format(**os.environ)\n            except BaseException:\n                pass\n\n            # Get all modules with functions\n            modules, crashed = modules_from_path(path)\n            for filepath, exc_info in crashed:\n                self.log.warning(\"Filepath load crashed {}.\\n{}\".format(\n                    filepath, \"\".join(traceback.format_exception(*exc_info))\n                ))\n\n            for filepath, module in modules:\n                self._cached_modules.append(module)\n                register_function = getattr(module, \"register\", None)\n                if register_function is not None:\n                    if isinstance(register_function, types.FunctionType):\n                        register_functions.append(\n                            (filepath, register_function)\n                        )\n                    else:\n                        self.log.warning(\n                            f\"\\\"{filepath}\\\"\"\n                            \" - Found 'register' but it is not a function.\"\n                        )\n                    continue\n\n                for attr_name in dir(module):\n                    if attr_name.startswith(\"_\"):\n                        self.log.debug(\n                            f\"Skipping private class '{attr_name}'\"\n                        )\n                        continue\n\n                    attr = getattr(module, attr_name, None)\n                    if (\n                        not inspect.isclass(attr)\n                        or not issubclass(attr, BaseHandler)\n                        or attr.ignore_handler_class()\n                    ):\n                        continue\n\n                    if inspect.isabstract(attr):\n                        self.log.warning(\n                            f\"Skipping abstract class '{attr_name}'.\"\n                        )\n                        continue\n                    handler_classes.append(attr)\n\n                if not handler_classes:\n                    self.log.warning(\n                        f\"\\\"{filepath}\\\"\"\n                        \" - No 'register' function\"\n                        \" or 'BaseHandler' classes found.\"\n                    )\n\n        if not register_functions and not handler_classes:\n            self.log.warning((\n                \"There are no files with `register` function or 'BaseHandler'\"\n                \" classes in registered paths:\\n- \\\"{}\\\"\"\n            ).format(\"- \\n\".join(paths)))\n\n        for filepath, register_func in register_functions:\n            try:\n                register_func(self._session)\n            except Exception:\n                self.log.warning(\n                    f\"\\\"{filepath}\\\" - register was not successful\",\n                    exc_info=True\n                )\n\n        for handler_class in handler_classes:\n            try:\n                obj = handler_class(self._session)\n                obj.register()\n                self._cached_objects.append(obj)\n\n            except Exception:\n                self.log.warning(\n                    f\"\\\"{handler_class}\\\" - register was not successful\",\n                    exc_info=True\n                )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/lib.html","title":"lib","text":""},{"location":"autoapi/client/ayon_ftrack/common/lib.html#client.ayon_ftrack.common.lib.convert_to_fps","title":"<code>convert_to_fps(source_value)</code>","text":"<p>Convert value into fps value.</p> <p>Non string values are kept untouched. String is tried to convert. Valid values: \"1000\" \"1000.05\" \"1000,05\" \",05\" \".05\" \"1000,\" \"1000.\" \"1000/1000\" \"1000.05/1000\" \"1000/1000.05\" \"1000.05/1000.05\" \"1000,05/1000\" \"1000/1000,05\" \"1000,05/1000,05\"</p> <p>Invalid values: \"/\" \"/1000\" \"1000/\" \",\" \".\" ...any other string</p> <p>Returns:</p> Name Type Description <code>float</code> <p>Converted value.</p> <p>Raises:</p> Type Description <code>InvalidFpsValue</code> <p>When value can't be converted to float.</p> Source code in <code>client/ayon_ftrack/common/lib.py</code> <pre><code>def convert_to_fps(source_value):\n    \"\"\"Convert value into fps value.\n\n    Non string values are kept untouched. String is tried to convert.\n    Valid values:\n    \"1000\"\n    \"1000.05\"\n    \"1000,05\"\n    \",05\"\n    \".05\"\n    \"1000,\"\n    \"1000.\"\n    \"1000/1000\"\n    \"1000.05/1000\"\n    \"1000/1000.05\"\n    \"1000.05/1000.05\"\n    \"1000,05/1000\"\n    \"1000/1000,05\"\n    \"1000,05/1000,05\"\n\n    Invalid values:\n    \"/\"\n    \"/1000\"\n    \"1000/\"\n    \",\"\n    \".\"\n    ...any other string\n\n    Returns:\n        float: Converted value.\n\n    Raises:\n        InvalidFpsValue: When value can't be converted to float.\n    \"\"\"\n\n    if not isinstance(source_value, str):\n        if isinstance(source_value, numbers.Number):\n            return float(source_value)\n        return source_value\n\n    value = source_value.strip().replace(\",\", \".\")\n    if not value:\n        raise InvalidFpsValue(\"Got empty value\")\n\n    subs = value.split(\"/\")\n    if len(subs) == 1:\n        str_value = subs[0]\n        if not is_string_number(str_value):\n            raise InvalidFpsValue(\n                \"Value \\\"{}\\\" can't be converted to number.\".format(value)\n            )\n        return float(str_value)\n\n    elif len(subs) == 2:\n        divident, divisor = subs\n        if not divident or not is_string_number(divident):\n            raise InvalidFpsValue(\n                \"Divident value \\\"{}\\\" can't be converted to number\".format(\n                    divident\n                )\n            )\n\n        if not divisor or not is_string_number(divisor):\n            raise InvalidFpsValue(\n                \"Divisor value \\\"{}\\\" can't be converted to number\".format(\n                    divident\n                )\n            )\n        divisor_float = float(divisor)\n        if divisor_float == 0.0:\n            raise InvalidFpsValue(\"Can't divide by zero\")\n        return float(divident) / divisor_float\n\n    raise InvalidFpsValue(\n        \"Value can't be converted to number \\\"{}\\\"\".format(source_value)\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/lib.html#client.ayon_ftrack.common.lib.create_chunks","title":"<code>create_chunks(iterable, chunk_size=None)</code>","text":"<p>Separate iterable into multiple chunks by size.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable[Any]</code> <p>Object that will be separated into chunks.</p> required <code>chunk_size</code> <code>int</code> <p>Size of one chunk. Default value is 200.</p> <code>None</code> <p>Returns:</p> Type Description <p>List[List[Any]]: Chunked items.</p> Source code in <code>client/ayon_ftrack/common/lib.py</code> <pre><code>def create_chunks(iterable, chunk_size=None):\n    \"\"\"Separate iterable into multiple chunks by size.\n\n    Args:\n        iterable (Iterable[Any]): Object that will be separated into chunks.\n        chunk_size (int): Size of one chunk. Default value is 200.\n\n    Returns:\n        List[List[Any]]: Chunked items.\n    \"\"\"\n\n    chunks = []\n    tupled_iterable = tuple(iterable)\n    if not tupled_iterable:\n        return chunks\n    iterable_size = len(tupled_iterable)\n    if chunk_size is None:\n        chunk_size = 200\n\n    if chunk_size &lt; 1:\n        chunk_size = 1\n\n    for idx in range(0, iterable_size, chunk_size):\n        chunks.append(tupled_iterable[idx:idx + chunk_size])\n    return chunks\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/lib.html#client.ayon_ftrack.common.lib.get_ftrack_icon_url","title":"<code>get_ftrack_icon_url(icon_name, addon_version, addon_name=None)</code>","text":"<p>Helper to get icon url to server.</p> <p>The existence of file is not validated.</p> <p>Parameters:</p> Name Type Description Default <code>icon_name</code> <code>str</code> <p>Name of icon filename.</p> required <code>addon_version</code> <code>str</code> <p>Version of addon.</p> required <code>addon_name</code> <code>Optional[str]</code> <p>Name of addon. For development purposes. Default value 'ftrack'.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>Url to icon on server.</p> Source code in <code>client/ayon_ftrack/common/lib.py</code> <pre><code>def get_ftrack_icon_url(icon_name, addon_version, addon_name=None):\n    \"\"\"Helper to get icon url to server.\n\n    The existence of file is not validated.\n\n    Args:\n        icon_name (str): Name of icon filename.\n        addon_version (str): Version of addon.\n        addon_name (Optional[str]): Name of addon. For development purposes.\n            Default value 'ftrack'.\n\n    Returns:\n        str: Url to icon on server.\n    \"\"\"\n\n    return get_ftrack_public_url(\n        \"icons\", icon_name,\n        addon_version=addon_version,\n        addon_name=addon_name\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/lib.html#client.ayon_ftrack.common.lib.get_ftrack_public_url","title":"<code>get_ftrack_public_url(*args, addon_version, addon_name=None)</code>","text":"<p>Url to public path in ftrack addon.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>tuple[str]</code> <p>Subpaths in 'public' dir.</p> <code>()</code> <code>addon_version</code> <code>str</code> <p>Version of addon.</p> required <code>addon_name</code> <code>Optional[str]</code> <p>Name of addon. This is for development purposes. Default value 'ftrack'.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>Url to public file on server in ftrack addon.</p> Source code in <code>client/ayon_ftrack/common/lib.py</code> <pre><code>def get_ftrack_public_url(*args, addon_version, addon_name=None):\n    \"\"\"Url to public path in ftrack addon.\n\n    Args:\n        args (tuple[str]): Subpaths in 'public' dir.\n        addon_version (str): Version of addon.\n        addon_name (Optional[str]): Name of addon. This is for development\n            purposes. Default value 'ftrack'.\n\n    Returns:\n        str: Url to public file on server in ftrack addon.\n    \"\"\"\n\n    server_url = get_base_url()\n    parts = [\n        server_url,\n        \"addons\",\n        addon_name or \"ftrack\",\n        addon_version,\n        \"public\"\n    ]\n    parts.extend(args)\n    return \"/\".join(parts)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/lib.html#client.ayon_ftrack.common.lib.get_host_ip","title":"<code>get_host_ip()</code>","text":"<p>Get IP of machine.</p> <p>Returns:</p> Type Description <p>Union[str, None]: IP address of machine or None if could not be detected.</p> Source code in <code>client/ayon_ftrack/common/lib.py</code> <pre><code>def get_host_ip():\n    \"\"\"Get IP of machine.\n\n    Returns:\n        Union[str, None]: IP address of machine or None if could not be\n            detected.\n    \"\"\"\n\n    host_name = socket.gethostname()\n    try:\n        return socket.gethostbyname(host_name)\n    except Exception:\n        pass\n\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/lib.html#client.ayon_ftrack.common.lib.get_service_ftrack_icon_url","title":"<code>get_service_ftrack_icon_url(icon_name, addon_version=None, addon_name=None)</code>","text":"<p>Icon url to server for service process.</p> <p>Information about addon version are taken from registered service in 'ayon_api'.</p> <p>Parameters:</p> Name Type Description Default <code>icon_name</code> <code>str</code> <p>Name of icon filename.</p> required <code>addon_version</code> <code>Optional[str]</code> <p>Version of addon. Version from registered service is used if not passed. For development purposes.</p> <code>None</code> <code>addon_name</code> <code>Optional[str]</code> <p>Name of addon. For development purposes.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>Url to icon on server.</p> Source code in <code>client/ayon_ftrack/common/lib.py</code> <pre><code>def get_service_ftrack_icon_url(\n    icon_name, addon_version=None, addon_name=None\n):\n    \"\"\"Icon url to server for service process.\n\n    Information about addon version are taken from registered service\n    in 'ayon_api'.\n\n    Args:\n        icon_name (str): Name of icon filename.\n        addon_version (Optional[str]): Version of addon. Version from\n            registered service is used if not passed. For development purposes.\n        addon_name (Optional[str]): Name of addon. For development purposes.\n\n    Returns:\n        str: Url to icon on server.\n    \"\"\"\n\n    return get_ftrack_icon_url(\n        icon_name,\n        addon_version=addon_version or get_service_addon_version(),\n        addon_name=addon_name or get_service_addon_name()\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/lib.html#client.ayon_ftrack.common.lib.is_ftrack_enabled_in_settings","title":"<code>is_ftrack_enabled_in_settings(project_settings)</code>","text":"<p>Check if ftrack is enabled in ftrack project settings.</p> <p>This function expect settings for a specific project. It is not checking if ftrack is enabled in general.</p> <p>Project settings gives option to disable ftrack integration per project. That should disable most of ftrack integration functionality, especially pipeline integration &gt; publish plugins, and some automations like event server handlers.</p> <p>Parameters:</p> Name Type Description Default <code>project_settings</code> <code>dict[str, Any]</code> <p>ftrack project settings.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if ftrack is enabled in project settings.</p> Source code in <code>client/ayon_ftrack/common/lib.py</code> <pre><code>def is_ftrack_enabled_in_settings(project_settings):\n    \"\"\"Check if ftrack is enabled in ftrack project settings.\n\n    This function expect settings for a specific project. It is not checking\n    if ftrack is enabled in general.\n\n    Project settings gives option to disable ftrack integration per project.\n    That should disable most of ftrack integration functionality, especially\n    pipeline integration &gt; publish plugins, and some automations like event\n    server handlers.\n\n    Args:\n        project_settings (dict[str, Any]): ftrack project settings.\n\n    Returns:\n        bool: True if ftrack is enabled in project settings.\n    \"\"\"\n\n    ftrack_enabled = project_settings.get(\"enabled\")\n    # If 'ftrack_enabled' is not set, we assume it is enabled.\n    # - this is for backwards compatibility - remove in future\n    if ftrack_enabled is None:\n        return True\n    return ftrack_enabled\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/lib.html#client.ayon_ftrack.common.lib.is_string_number","title":"<code>is_string_number(value)</code>","text":"<p>Can string value be converted to number (float).</p> Source code in <code>client/ayon_ftrack/common/lib.py</code> <pre><code>def is_string_number(value: str) -&gt; bool:\n    \"\"\"Can string value be converted to number (float).\"\"\"\n\n    if not isinstance(value, str):\n        raise TypeError(f\"Expected str got {str(type(value))}\")\n    if value == \".\":\n        return False\n\n    if value.startswith(\".\"):\n        value = \"0\" + value\n    elif value.endswith(\".\"):\n        value = value + \"0\"\n\n    if re.match(r\"^\\d+(\\.\\d+)?$\", value) is None:\n        return False\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/lib.html#client.ayon_ftrack.common.lib.join_filter_values","title":"<code>join_filter_values(values)</code>","text":"<p>Prepare values to be used for filtering in ftrack query.</p> <p>Parameters:</p> Name Type Description Default <code>Iterable[str]</code> <p>Values to join for filter query.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Prepared values for ftrack query.</p> Source code in <code>client/ayon_ftrack/common/lib.py</code> <pre><code>def join_filter_values(values):\n    \"\"\"Prepare values to be used for filtering in ftrack query.\n\n    Args:\n        Iterable[str]: Values to join for filter query.\n\n    Returns:\n        str: Prepared values for ftrack query.\n    \"\"\"\n\n    return \",\".join({\n        '\"{}\"'.format(value)\n        for value in values\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/python_module_tools.html","title":"python_module_tools","text":""},{"location":"autoapi/client/ayon_ftrack/common/python_module_tools.html#client.ayon_ftrack.common.python_module_tools.import_filepath","title":"<code>import_filepath(filepath, module_name=None)</code>","text":"<p>Import python file as python module.</p> <p>Python 2 and Python 3 compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to python file.</p> required <code>module_name</code> <code>str</code> <p>Name of loaded module. Only for Python 3. By default is filled with filename of filepath.</p> <code>None</code> Source code in <code>client/ayon_ftrack/common/python_module_tools.py</code> <pre><code>def import_filepath(filepath, module_name=None):\n    \"\"\"Import python file as python module.\n\n    Python 2 and Python 3 compatibility.\n\n    Args:\n        filepath(str): Path to python file.\n        module_name(str): Name of loaded module. Only for Python 3. By default\n            is filled with filename of filepath.\n    \"\"\"\n    if module_name is None:\n        module_name = os.path.splitext(os.path.basename(filepath))[0]\n\n    # Make sure it is not 'unicode' in Python 2\n    module_name = str(module_name)\n\n    # Prepare module object where content of file will be parsed\n    module = types.ModuleType(module_name)\n\n    # Use loader so module has full specs\n    module_loader = importlib.machinery.SourceFileLoader(\n        module_name, filepath\n    )\n    module_loader.exec_module(module)\n    return module\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/python_module_tools.html#client.ayon_ftrack.common.python_module_tools.modules_from_path","title":"<code>modules_from_path(folder_path, log=None)</code>","text":"<p>Get python scripts as modules from a path.</p> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>str</code> <p>Path to folder containing python scripts.</p> required <code>log</code> <code>Optional[Logger]</code> <p>Logger used for logs.</p> <code>None</code> <p>Returns:</p> Type Description <p>tuple: First list contains successfully imported modules and second list contains tuples of path and exception. Source code in <code>client/ayon_ftrack/common/python_module_tools.py</code> <pre><code>def modules_from_path(folder_path, log=None):\n    \"\"\"Get python scripts as modules from a path.\n\n    Arguments:\n        folder_path (str): Path to folder containing python scripts.\n        log (Optional[logging.Logger]): Logger used for logs.\n\n    Returns:\n        tuple&lt;list, list&gt;: First list contains successfully imported modules\n            and second list contains tuples of path and exception.\n    \"\"\"\n    crashed = []\n    modules = []\n    output = (modules, crashed)\n    # Just skip and return empty list if path is not set\n    if not folder_path:\n        return output\n\n    if log is None:\n        log = logging.getLogger(\"modules_from_path\")\n    # Do not allow relative imports\n    if folder_path.startswith(\".\"):\n        log.warning((\n            \"BUG: Relative paths are not allowed for security reasons. {}\"\n        ).format(folder_path))\n        return output\n\n    folder_path = os.path.normpath(folder_path)\n\n    if not os.path.isdir(folder_path):\n        log.warning(\"Not a directory path: {}\".format(folder_path))\n        return output\n\n    for filename in os.listdir(folder_path):\n        # Ignore files which start with underscore\n        if filename.startswith(\"_\"):\n            continue\n\n        mod_name, mod_ext = os.path.splitext(filename)\n        if not mod_ext == \".py\":\n            continue\n\n        full_path = os.path.join(folder_path, filename)\n        if not os.path.isfile(full_path):\n            continue\n\n        try:\n            module = import_filepath(full_path, mod_name)\n            modules.append((full_path, module))\n\n        except Exception:\n            crashed.append((full_path, sys.exc_info()))\n            log.warning(\n                \"Failed to load path: \\\"{0}\\\"\".format(full_path),\n                exc_info=True\n            )\n            continue\n\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/users.html","title":"users","text":""},{"location":"autoapi/client/ayon_ftrack/common/users.html#client.ayon_ftrack.common.users.map_ftrack_users_to_ayon_users","title":"<code>map_ftrack_users_to_ayon_users(ftrack_users, ayon_users=None)</code>","text":"<p>Map ftrack users to AYON users.</p> <p>Mapping is based on 2 possible keys, email and username where email has higher priority. Once AYON user is mapped it cannot be mapped again to different user.</p> <p>Fields used from ftrack users: 'id', 'username', 'email'.</p> <p>Parameters:</p> Name Type Description Default <code>ftrack_users</code> <code>List[User]</code> <p>List of ftrack users.</p> required <code>ayon_users</code> <code>List[Dict[str, Any]]</code> <p>List of AYON users.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Union[str, None]]</code> <p>Dict[str, Union[str, None]]: Mapping of ftrack user id to AYON username.</p> Source code in <code>client/ayon_ftrack/common/users.py</code> <pre><code>def map_ftrack_users_to_ayon_users(\n    ftrack_users: List[\"ftrack_api.entity.user.User\"],\n    ayon_users: Optional[List[Dict[str, Any]]] = None,\n) -&gt; Dict[str, \"Union[str, None]\"]:\n    \"\"\"Map ftrack users to AYON users.\n\n    Mapping is based on 2 possible keys, email and username where email has\n    higher priority. Once AYON user is mapped it cannot be mapped again to\n    different user.\n\n    Fields used from ftrack users: 'id', 'username', 'email'.\n\n    Args:\n        ftrack_users (List[ftrack_api.entity.user.User]): List of ftrack users.\n        ayon_users (List[Dict[str, Any]]): List of AYON users.\n\n    Returns:\n        Dict[str, Union[str, None]]: Mapping of ftrack user id\n            to AYON username.\n\n    \"\"\"\n    if ayon_users is None:\n        ayon_users = ayon_api.get_users()\n\n    mapping: Dict[str, \"Union[str, None]\"] = {\n        user[\"id\"]: None\n        for user in ftrack_users\n    }\n    ayon_users_by_email: Dict[str, str] = {}\n    ayon_users_by_name: Dict[str, str] = {}\n    for ayon_user in ayon_users:\n        ayon_name = ayon_user[\"name\"]\n        ayon_email = ayon_user[\"attrib\"][\"email\"]\n        ayon_users_by_name[ayon_name.lower()] = ayon_name\n        if ayon_email:\n            ayon_users_by_email[ayon_email.lower()] = ayon_name\n\n    mapped_ayon_users: Set[str] = set()\n    for ftrack_user in ftrack_users:\n        ftrack_id: str = ftrack_user[\"id\"]\n        # Make sure username does not contain '@' character\n        ftrack_name: str = ftrack_user[\"username\"].split(\"@\", 1)[0]\n        ftrack_email: str = ftrack_user[\"email\"]\n\n        if ftrack_email and ftrack_email.lower() in ayon_users_by_email:\n            ayon_name: str = ayon_users_by_email[ftrack_email.lower()]\n            if ayon_name not in mapped_ayon_users:\n                mapping[ftrack_id] = ayon_name\n                mapped_ayon_users.add(ayon_name)\n            continue\n\n        if ftrack_name in ayon_users_by_name:\n            ayon_name: str = ayon_users_by_name[ftrack_name]\n            if ayon_name not in mapped_ayon_users:\n                mapped_ayon_users.add(ayon_name)\n                mapping[ftrack_id] = ayon_name\n\n    return mapping\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/utils.html","title":"utils","text":"<p>Utils for ftrack.</p> <p>Whereas lib.py contains utils for general use, this module contains utils     for certain situations, or functions that would cause circular import     when implemented in lib.py.</p> <p>It is possible that some functions will be moved from lib.py to this module     to keep consistency.</p>"},{"location":"autoapi/client/ayon_ftrack/common/utils.html#client.ayon_ftrack.common.utils.get_datetime_data","title":"<code>get_datetime_data(datetime_obj=None)</code>","text":"<p>Returns current datetime data as dictionary.</p> Note <p>This function is copied from 'ayon_core.lib'.</p> <p>Parameters:</p> Name Type Description Default <code>datetime_obj</code> <code>datetime</code> <p>Specific datetime object</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>prepared date &amp; time data</p> Available keys <p>\"d\" -  in shortest possible way. \"dd\" -  with 2 digits. \"ddd\" -  shortened week day. e.g.: <code>Mon</code>, ... \"dddd\" -  full name of week day. e.g.: <code>Monday</code>, ... \"m\" -  in shortest possible way. e.g.: <code>1</code> if January \"mm\" -  with 2 digits. \"mmm\" -  shortened month name. e.g.: <code>Jan</code>, ... \"mmmm\" -  full month name. e.g.: <code>January</code>, ... \"yy\" -  shortened year. e.g.: <code>19</code>, <code>20</code>, ... \"yyyy\" -  full year. e.g.: <code>2019</code>, <code>2020</code>, ... \"H\" -  shortened hours. \"HH\" -  with 2 digits. \"h\" -  shortened hours. \"hh\" -  with 2 digits. \"ht\" -  AM or PM. \"M\" -  shortened minutes. \"MM\" -  with 2 digits. \"S\" -  shortened seconds. \"SS\" -  with 2 digits. Source code in <code>client/ayon_ftrack/common/utils.py</code> <pre><code>def get_datetime_data(datetime_obj=None):\n    \"\"\"Returns current datetime data as dictionary.\n\n    Note:\n        This function is copied from 'ayon_core.lib'.\n\n    Args:\n        datetime_obj (datetime): Specific datetime object\n\n    Returns:\n        dict: prepared date &amp; time data\n\n    Available keys:\n        \"d\" - &lt;Day of month number&gt; in shortest possible way.\n        \"dd\" - &lt;Day of month number&gt; with 2 digits.\n        \"ddd\" - &lt;Week day name&gt; shortened week day. e.g.: `Mon`, ...\n        \"dddd\" - &lt;Week day name&gt; full name of week day. e.g.: `Monday`, ...\n        \"m\" - &lt;Month number&gt; in shortest possible way. e.g.: `1` if January\n        \"mm\" - &lt;Month number&gt; with 2 digits.\n        \"mmm\" - &lt;Month name&gt; shortened month name. e.g.: `Jan`, ...\n        \"mmmm\" - &lt;Month name&gt; full month name. e.g.: `January`, ...\n        \"yy\" - &lt;Year number&gt; shortened year. e.g.: `19`, `20`, ...\n        \"yyyy\" - &lt;Year number&gt; full year. e.g.: `2019`, `2020`, ...\n        \"H\" - &lt;Hours number 24-hour&gt; shortened hours.\n        \"HH\" - &lt;Hours number 24-hour&gt; with 2 digits.\n        \"h\" - &lt;Hours number 12-hour&gt; shortened hours.\n        \"hh\" - &lt;Hours number 12-hour&gt; with 2 digits.\n        \"ht\" - &lt;Midday type&gt; AM or PM.\n        \"M\" - &lt;Minutes number&gt; shortened minutes.\n        \"MM\" - &lt;Minutes number&gt; with 2 digits.\n        \"S\" - &lt;Seconds number&gt; shortened seconds.\n        \"SS\" - &lt;Seconds number&gt; with 2 digits.\n    \"\"\"\n\n    if not datetime_obj:\n        datetime_obj = datetime.datetime.now()\n\n    year = datetime_obj.strftime(\"%Y\")\n\n    month = datetime_obj.strftime(\"%m\")\n    month_name_full = datetime_obj.strftime(\"%B\")\n    month_name_short = datetime_obj.strftime(\"%b\")\n    day = datetime_obj.strftime(\"%d\")\n\n    weekday_full = datetime_obj.strftime(\"%A\")\n    weekday_short = datetime_obj.strftime(\"%a\")\n\n    hours = datetime_obj.strftime(\"%H\")\n    hours_midday = datetime_obj.strftime(\"%I\")\n    hour_midday_type = datetime_obj.strftime(\"%p\")\n    minutes = datetime_obj.strftime(\"%M\")\n    seconds = datetime_obj.strftime(\"%S\")\n\n    return {\n        \"d\": str(int(day)),\n        \"dd\": str(day),\n        \"ddd\": weekday_short,\n        \"dddd\": weekday_full,\n        \"m\": str(int(month)),\n        \"mm\": str(month),\n        \"mmm\": month_name_short,\n        \"mmmm\": month_name_full,\n        \"yy\": str(year[2:]),\n        \"yyyy\": str(year),\n        \"H\": str(int(hours)),\n        \"HH\": str(hours),\n        \"h\": str(int(hours_midday)),\n        \"hh\": str(hours_midday),\n        \"ht\": hour_midday_type,\n        \"M\": str(int(minutes)),\n        \"MM\": str(minutes),\n        \"S\": str(int(seconds)),\n        \"SS\": str(seconds),\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/utils.html#client.ayon_ftrack.common.utils.get_folder_path_for_entities","title":"<code>get_folder_path_for_entities(session, entities, path_cust_attr_id=None, allow_use_link=True)</code>","text":"<p>Get folder path for ftrack entities.</p> <p>Folder path is received from custom attribute, or from entity link     which contains name of parent entities.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Connected ftrack session.</p> required <code>entities</code> <code>List[dict]</code> <p>List of ftrack entities.</p> required <code>path_cust_attr_id</code> <code>Union[str, None]</code> <p>Custom attribute configuration id which stores entity path.</p> <code>None</code> <code>allow_use_link</code> <code>bool</code> <p>Use 'link' value if path is not found in custom attributes.</p> <code>True</code> <p>Returns:</p> Type Description <p>dict[str, Union[str, None]]: Entity path by ftrack entity id. Output will always contain all entity ids from input.</p> Source code in <code>client/ayon_ftrack/common/utils.py</code> <pre><code>def get_folder_path_for_entities(\n    session, entities, path_cust_attr_id=None, allow_use_link=True\n):\n    \"\"\"Get folder path for ftrack entities.\n\n    Folder path is received from custom attribute, or from entity link\n        which contains name of parent entities.\n\n    Args:\n        session (ftrack_api.Session): Connected ftrack session.\n        entities (List[dict]): List of ftrack entities.\n        path_cust_attr_id (Union[str, None]): Custom attribute\n            configuration id which stores entity path.\n        allow_use_link (bool): Use 'link' value if path is not found in\n            custom attributes.\n\n    Returns:\n        dict[str, Union[str, None]]: Entity path by ftrack entity id.\n            Output will always contain all entity ids from input.\n    \"\"\"\n\n    entities_by_id = {\n        entity[\"id\"]: entity\n        for entity in entities\n    }\n    entity_ids = set(entities_by_id.keys())\n    folder_paths_by_id = {\n        entity_id: None\n        for entity_id in entity_ids\n    }\n    if not folder_paths_by_id:\n        return folder_paths_by_id\n\n    if path_cust_attr_id is None:\n        cust_attr_conf = session.query(\n            \"select id, key from CustomAttributeConfiguration\"\n            f\" where key is '{CUST_ATTR_KEY_SERVER_PATH}'\"\n        ).first()\n        if cust_attr_conf:\n            path_cust_attr_id = cust_attr_conf[\"id\"]\n\n    value_items = []\n    if path_cust_attr_id is not None:\n        value_items = query_custom_attribute_values(\n            session, {path_cust_attr_id}, entity_ids\n        )\n\n    for value_item in value_items:\n        path = value_item[\"value\"]\n        entity_id = value_item[\"entity_id\"]\n        if path:\n            entity_ids.discard(entity_id)\n            folder_paths_by_id[entity_id] = path\n\n    if allow_use_link:\n        for missing_id in entity_ids:\n            entity = entities_by_id[missing_id]\n            # Use stupidly simple solution\n            link_names = [item[\"name\"] for item in entity[\"link\"]]\n            # Change project name to empty string\n            link_names[0] = \"\"\n            folder_paths_by_id[missing_id] = \"/\".join(link_names)\n\n    return folder_paths_by_id\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html","title":"event_handlers","text":"<p>Helper handlers for ftrack events with pre-implemented logic.</p> Note <p>Import requires to have available 'ftrack_api' which is reason why it's     not available from top package of 'ftrack_common'.</p>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseAction","title":"<code>BaseAction</code>","text":"<p>               Bases: <code>BaseHandler</code></p> <p>Custom Action base class.</p> <p>Simplify action discovery and launch. This implementation represents single action with single callback. To change the behavior implement custom callbacks or override '_discover' and '_launch' methods.</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>Label of action of group name of action. Can be combined with 'variant' attribute.</p> <code>variant</code> <code>str</code> <p>Variant under 'label'. Can be combined with 'label' e.g. when 'label' is \"Admin\" and variant is \"Kill jobs\". In case there is more variants for \"Admin\" label they'll grouped in ftrack UI widgets.</p> <code>identifier</code> <code>str</code> <p>Action identifier. Is used to trigger the launch logic of action.</p> <code>icon</code> <code>str</code> <p>Url to icon (Browser which should show the icon must have access to the resource).</p> <code>description</code> <code>str</code> <p>Hint of action which is showed to user hovering over the action.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Connected ftrack session.</p> required Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>class BaseAction(BaseHandler):\n    \"\"\"Custom Action base class.\n\n    Simplify action discovery and launch. This implementation represents\n    single action with single callback. To change the behavior implement\n    custom callbacks or override '_discover' and '_launch' methods.\n\n    Attributes:\n        label (str): Label of action of group name of action. Can be combined\n            with 'variant' attribute.\n        variant (str): Variant under 'label'. Can be combined with 'label' e.g.\n            when 'label' is \"Admin\" and variant is \"Kill jobs\". In case\n            there is more variants for \"Admin\" label they'll grouped in ftrack\n            UI widgets.\n        identifier (str): Action identifier. Is used to trigger the launch\n            logic of action.\n        icon (str): Url to icon (Browser which should show the icon must have\n            access to the resource).\n        description (str): Hint of action which is showed to user hovering\n            over the action.\n\n    Args:\n        session (ftrack_api.Session): Connected ftrack session.\n\n    \"\"\"\n    __ignore_handler_class = True\n\n    label: Optional[str] = None\n    variant: Optional[str] = None\n    identifier: Optional[str] = None\n    description: Optional[str] = None\n    icon: Optional[str] = None\n    handler_type: str = \"Action\"\n    preactions: List[str] = []\n\n    _full_label: Optional[str] = None\n    _discover_identifier: Optional[str] = None\n    _launch_identifier: Optional[str] = None\n\n    settings_frack_subkey: str = \"user_handlers\"\n    settings_enabled_key: str = \"enabled\"\n\n    def __init__(self, session: ftrack_api.Session):\n        # Validate minimum requirements\n        if not self.label:\n            raise ValueError(\"Action missing 'label'.\")\n\n        if not self.identifier:\n            raise ValueError(\"Action missing 'identifier'.\")\n\n        super().__init__(session)\n        self.setup_launch_wrapper()\n\n    def setup_launch_wrapper(self):\n        self._launch = self.launch_wrapper(self._launch)\n\n    @property\n    def discover_identifier(self) -&gt; str:\n        return self.identifier\n\n    @property\n    def launch_identifier(self) -&gt; str:\n        return self.identifier\n\n    @property\n    def handler_label(self) -&gt; str:\n        return self.full_label\n\n    @property\n    def full_label(self) -&gt; str:\n        \"\"\"Full label of action.\n\n        Value of full label is cached.\n\n        Returns:\n            str: Label created from 'label' and 'variant' attributes.\n\n        \"\"\"\n        if self._full_label is None:\n            if self.variant:\n                label = \"{} {}\".format(self.label, self.variant)\n            else:\n                label = self.label\n            self._full_label = label\n        return self._full_label\n\n    def register(self):\n        \"\"\"Register to ftrack topics to discover and launch action.\"\"\"\n        self.session.event_hub.subscribe(\n            \"topic=ftrack.action.discover\",\n            self._discover,\n            priority=self.priority\n        )\n\n        launch_subscription = (\n            \"topic=ftrack.action.launch and data.actionIdentifier={}\"\n        ).format(self.launch_identifier)\n        self.session.event_hub.subscribe(launch_subscription, self._launch)\n\n    def _translate_event(\n        self,\n        event: ftrack_api.event.base.Event,\n        session: Optional[ftrack_api.Session] = None\n    ) -&gt; List[ftrack_api.entity.base.Entity]:\n        \"\"\"Translate event to receive entities based on it's data.\"\"\"\n        if session is None:\n            session = self.session\n\n        _entities = event[\"data\"].get(\"entities_object\", None)\n        if _entities is not None and not _entities:\n            return _entities\n\n        if (\n            _entities is None\n            or _entities[0].get(\"link\") == ftrack_api.symbol.NOT_SET\n        ):\n            _entities = [\n                item\n                for item in self._get_entities(\n                    event,\n                    session=session,\n                    ignore={\"socialfeed\", \"socialnotification\", \"team\"}\n                )\n                if item is not None\n            ]\n            event[\"data\"][\"entities_object\"] = _entities\n\n        return _entities\n\n    def _discover(\n        self, event: ftrack_api.event.base.Event\n    ) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Decide if and how will be action showed to user in ftrack.\n\n        Args:\n            event (ftrack_api.Event): Event with topic which triggered this\n                callback.\n\n        Returns:\n            Union[None, Dict[str, Any]]: None if action is not returned\n                otherwise returns items to show in UI (structure of items is\n                defined by ftrack and can be found in documentation).\n\n        \"\"\"\n        entities = self._translate_event(event)\n        if not entities:\n            return None\n\n        accepts = self.discover(self.session, entities, event)\n        if not accepts:\n            return None\n\n        self.log.debug(\"Discovering action with selection: {}\".format(\n            event[\"data\"].get(\"selection\") or []\n        ))\n\n        return {\n            \"items\": [{\n                \"label\": self.label,\n                \"variant\": self.variant,\n                \"description\": self.description,\n                \"actionIdentifier\": self.discover_identifier,\n                \"icon\": self.icon,\n            }]\n        }\n\n    def discover(\n        self,\n        session: ftrack_api.Session,\n        entities: List[ftrack_api.entity.base.Entity],\n        event: ftrack_api.event.base.Event,\n    ) -&gt; bool:\n        \"\"\"Decide if action is showed to used based on event data.\n\n        Action should override the method to implement logic to show the\n        action. The most common logic is based on combination of user roles\n        and selected entities.\n\n        Args:\n            session (ftrack_api.Session): Session which triggered callback of\n                the event.\n            entities (List[Any]): Prepared list of entities from event data.\n            event (ftrack_api.Event): ftrack event which caused this callback\n                is triggered.\n\n        Returns:\n            bool: True if action should be returned.\n\n        \"\"\"\n        return False\n\n    def _handle_preactions(\n        self, session: ftrack_api.Session, event: ftrack_api.event.base.Event\n    ) -&gt; bool:\n        \"\"\"Launch actions before launching this action.\n\n        Concept came from Pype and got deprecated (and used) over time. Should\n        be probably removed.\n\n        Note:\n            Added warning log that this functionlity is deprecated and will\n                be removed in the future.\n\n        Args:\n            session (ftrack_api.Session): ftrack session.\n            event (ftrack_api.Event): Event which triggered launch of this\n                action.\n\n        Returns:\n            bool: Preactions were launched or not.\n\n        Deprecated:\n            Preactions are marked as deprecated. Server actions should not\n                use preactions and local actions use local identifier which\n                is hard to handle automatically\n\n        \"\"\"\n        # If preactions are not set\n        if len(self.preactions) == 0:\n            return True\n\n        if not event.get(\"data\", {}).get(\"selection\"):\n            return False\n\n        # If preactions were already started\n        if event[\"data\"].get(\"preactions_launched\") is True:\n            return True\n\n        self.log.warning((\n            \"DEPRECATION WARNING: Action \\\"{}\\\" is using 'preactions'\"\n            \" which are deprecated and will be removed Q2 2023.\"\n        ).format(self.full_label))\n\n        # Launch preactions\n        for preaction in self.preactions:\n            self.trigger_action(preaction, event)\n\n        # Relaunch this action\n        self.trigger_action(\n            self.launch_identifier,\n            event,\n            additional_event_data={\"preactions_launched\": True}\n        )\n        return False\n\n    def launch_wrapper(self, func):\n        @functools.wraps(func)\n        def wrapper_func(*args, **kwargs):\n            self.log.info(\"{} \\\"{}\\\": Launched\".format(\n                self.handler_type, self.full_label\n            ))\n\n            try:\n                output = func(*args, **kwargs)\n                self.log.info(\"{} \\\"{}\\\": Finished\".format(\n                    self.handler_type, self.full_label\n                ))\n\n            except BaseException as exc:\n                self.session.rollback()\n                self.session._configure_locations()\n                msg = \"{} \\\"{}\\\": Failed ({})\".format(\n                    self.handler_type, self.full_label, str(exc))\n                self.log.error(msg, exc_info=True)\n                output = {\n                    \"success\": False,\n                    \"message\": msg\n                }\n\n            return output\n        return wrapper_func\n\n    def _launch(\n        self, event: ftrack_api.event.base.Event\n    ) -&gt; Optional[Dict[str, Any]]:\n        entities = self._translate_event(event)\n        if not entities:\n            return\n\n        preactions_launched = self._handle_preactions(self.session, event)\n        if preactions_launched is False:\n            return\n\n        interface = self._interface(self.session, entities, event)\n        if interface:\n            return interface\n\n        response = self.launch(self.session, entities, event)\n\n        return self._handle_result(response)\n\n    def launch(\n        self,\n        session: ftrack_api.Session,\n        entities: List[ftrack_api.entity.base.Entity],\n        event: ftrack_api.event.base.Event\n    ) -&gt; Optional[Union[bool, Dict[str, Any]]]:\n        \"\"\"Main part of handling event callback.\n\n        Args:\n            session (ftrack_api.Session): Session which queried entities.\n            entities (List[Any]): Prequeried entities based on event data.\n            event (ftrack_api.Event): ftrack event to process.\n\n        Returns:\n            Union[bool, Dict[str, Any]]: True or false for success or fail,\n                or more complex data structure e.g. to show interface to user.\n\n        \"\"\"\n        raise NotImplementedError()\n\n    def _interface(\n        self,\n        session: ftrack_api.Session,\n        entities: List[ftrack_api.entity.base.Entity],\n        event: ftrack_api.event.base.Event\n    ) -&gt; Optional[Dict[str, Any]]:\n        interface = self.interface(session, entities, event)\n        if not interface:\n            return\n\n        if isinstance(interface, (tuple, list)):\n            return {\"items\": interface}\n\n        if isinstance(interface, dict):\n            if (\n                \"items\" in interface\n                or (\"success\" in interface and \"message\" in interface)\n            ):\n                return interface\n\n            raise ValueError((\n                \"Invalid interface output expected key: \\\"items\\\" or keys:\"\n                \" \\\"success\\\" and \\\"message\\\". Got: \\\"{}\\\"\"\n            ).format(str(interface)))\n\n        raise ValueError(\n            \"Invalid interface output type \\\"{}\\\"\".format(\n                str(type(interface))\n            )\n        )\n\n    def interface(\n        self,\n        session: ftrack_api.Session,\n        entities: List[ftrack_api.entity.base.Entity],\n        event: ftrack_api.event.base.Event\n    ) -&gt; Optional[Union[Dict[str, Any], List[Dict[str, Any]]]]:\n        \"\"\"Show an interface to user befor the action is processed.\n\n        This is part of launch callback which gives option to return ftrack\n        widgets items. These items are showed to user which can fill/change\n        values and submit them.\n\n        Interface must in that case handle if event contains values from user.\n\n        Args:\n            session (ftrack_api.Session): Connected ftrack api session.\n            entities (List[Any]): Entities on which was action triggered.\n            event (ftrack_api.Event): Event which triggered launch callback.\n\n        Returns:\n            Union[None, List[Dict[str, Any], Dict[str, Any]]: None if nothing\n                should be showed, list of items to show or dictionary with\n                'items' key and possibly additional data\n                (e.g. submit button label).\n\n        \"\"\"\n        return None\n\n    def _handle_result(self, result: Any) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Validate the returned result from the action callback.\"\"\"\n        if not result:\n            return None\n\n        if isinstance(result, dict):\n            if \"items\" in result:\n                if not isinstance(result[\"items\"], list):\n                    raise TypeError(\n                        \"Invalid items type {} expected list\".format(\n                            str(type(result[\"items\"]))))\n                return result\n\n            if \"success\" not in result and \"message\" not in result:\n                self.log.error((\n                    \"{} \\\"{}\\\" Missing required keys\"\n                    \" \\\"success\\\" and \\\"message\\\" in callback output. This is\"\n                    \" soft fail.\"\n                ).format(self.handler_type, self.full_label))\n\n            elif \"message\" in result:\n                if \"success\" not in result:\n                    result[\"success\"] = True\n                return result\n\n            # Fallback to 'bool' result\n            result = result.get(\"success\", True)\n\n        if isinstance(result, bool):\n            if result:\n                return {\n                    \"success\": True,\n                    \"message\": \"{} finished.\".format(self.full_label)\n                }\n            return {\n                \"success\": False,\n                \"message\": \"{} failed.\".format(self.full_label)\n            }\n\n        return result\n\n    @staticmethod\n    def roles_check(\n        settings_roles: List[str],\n        user_roles: List[str],\n        default: Optional[bool] = True\n    ) -&gt; bool:\n        \"\"\"Compare roles from setting and user's roles.\n\n        Args:\n            settings_roles(list): List of role names from settings.\n            user_roles(list): User's lowered role names.\n            default(bool): If 'settings_roles' is empty list.\n\n        Returns:\n            bool: 'True' if user has at least one role from settings or\n                default if 'settings_roles' is empty.\n\n        \"\"\"\n        if not settings_roles:\n            return default\n\n        user_roles = {\n            role_name.lower()\n            for role_name in user_roles\n        }\n        for role_name in settings_roles:\n            if role_name.lower() in user_roles:\n                return True\n        return False\n\n    @classmethod\n    def get_user_entity_from_event(\n        cls,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event\n    ) -&gt; Optional[ftrack_api.entity.user.User]:\n        \"\"\"Query user entity from event.\"\"\"\n\n        not_set = object()\n\n        # Check if user is already stored in event data\n        user_entity = event[\"data\"].get(\"user_entity\", not_set)\n        if user_entity is not_set:\n            # Query user entity from event\n            user_info = event.get(\"source\", {}).get(\"user\", {})\n            user_id = user_info.get(\"id\")\n            username = user_info.get(\"username\")\n            if user_id:\n                user_entity = session.query(\n                    \"User where id is {}\".format(user_id)\n                ).first()\n            if not user_entity and username:\n                user_entity = session.query(\n                    \"User where username is {}\".format(username)\n                ).first()\n            event[\"data\"][\"user_entity\"] = user_entity\n\n        return user_entity\n\n    @classmethod\n    def get_user_roles_from_event(\n        cls,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event,\n        lower: Optional[bool] = False\n    ) -&gt; List[str]:\n        \"\"\"Get user roles based on data in event.\n\n        Args:\n            session (ftrack_api.Session): Prepared ftrack session.\n            event (ftrack_api.event.Event): Event which is processed.\n            lower (Optional[bool]): Lower the role names. Default 'False'.\n\n        Returns:\n            List[str]: List of user roles.\n\n        \"\"\"\n        not_set = object()\n\n        user_roles = event[\"data\"].get(\"user_roles\", not_set)\n        if user_roles is not_set:\n            user_roles = []\n            user_entity = cls.get_user_entity_from_event(session, event)\n            for role in user_entity[\"user_security_roles\"]:\n                role_name = role[\"security_role\"][\"name\"]\n                if lower:\n                    role_name = role_name.lower()\n                user_roles.append(role_name)\n            event[\"data\"][\"user_roles\"] = user_roles\n        return user_roles\n\n    def get_project_name_from_event_with_entities(\n        self,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event,\n        entities: List[ftrack_api.entity.base.Entity],\n    ) -&gt; Optional[str]:\n        \"\"\"Load or query and fill project entity from/to event data.\n\n        Project data are stored by ftrack id because in most cases it is\n        easier to access project id than project name.\n\n        Args:\n            session (ftrack_api.Session): Current session.\n            event (ftrack_api.Event): Processed event by session.\n            entities (List[Any]): ftrack entities of selection.\n\n        Returns:\n            Optional[str]: Project name from event data.\n\n        \"\"\"\n        # Try to get project entity from event\n        project_name = event[\"data\"].get(\"project_name\")\n        if not project_name:\n            project_entity = self.get_project_from_entity(\n                entities[0], session\n            )\n            project_name = project_entity[\"full_name\"]\n\n            event[\"data\"][\"project_name\"] = project_name\n        return project_name\n\n    def get_ftrack_settings(\n        self,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event,\n        entities: List[ftrack_api.entity.base.Entity],\n    ) -&gt; Dict[str, Any]:\n        project_name = self.get_project_name_from_event_with_entities(\n            session, event, entities\n        )\n        project_settings = self.get_project_settings_from_event(\n            event, project_name\n        )\n        return project_settings[\"ftrack\"]\n\n    def valid_roles(\n        self,\n        session: ftrack_api.Session,\n        entities: List[ftrack_api.entity.base.Entity],\n        event: ftrack_api.event.base.Event,\n    ) -&gt; bool:\n        \"\"\"Validate user roles by settings.\n\n        Method requires to have set `settings_key` attribute.\n        \"\"\"\n        ftrack_settings = self.get_ftrack_settings(session, event, entities)\n        settings = (\n            ftrack_settings[self.settings_frack_subkey][self.settings_key]\n        )\n        if self.settings_enabled_key:\n            if not settings.get(self.settings_enabled_key, True):\n                return False\n\n        user_role_list = self.get_user_roles_from_event(session, event)\n        if not self.roles_check(settings.get(\"role_list\"), user_role_list):\n            return False\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseAction.full_label","title":"<code>full_label</code>  <code>property</code>","text":"<p>Full label of action.</p> <p>Value of full label is cached.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Label created from 'label' and 'variant' attributes.</p>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseAction.discover","title":"<code>discover(session, entities, event)</code>","text":"<p>Decide if action is showed to used based on event data.</p> <p>Action should override the method to implement logic to show the action. The most common logic is based on combination of user roles and selected entities.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Session which triggered callback of the event.</p> required <code>entities</code> <code>List[Any]</code> <p>Prepared list of entities from event data.</p> required <code>event</code> <code>Event</code> <p>ftrack event which caused this callback is triggered.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if action should be returned.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>def discover(\n    self,\n    session: ftrack_api.Session,\n    entities: List[ftrack_api.entity.base.Entity],\n    event: ftrack_api.event.base.Event,\n) -&gt; bool:\n    \"\"\"Decide if action is showed to used based on event data.\n\n    Action should override the method to implement logic to show the\n    action. The most common logic is based on combination of user roles\n    and selected entities.\n\n    Args:\n        session (ftrack_api.Session): Session which triggered callback of\n            the event.\n        entities (List[Any]): Prepared list of entities from event data.\n        event (ftrack_api.Event): ftrack event which caused this callback\n            is triggered.\n\n    Returns:\n        bool: True if action should be returned.\n\n    \"\"\"\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseAction.get_project_name_from_event_with_entities","title":"<code>get_project_name_from_event_with_entities(session, event, entities)</code>","text":"<p>Load or query and fill project entity from/to event data.</p> <p>Project data are stored by ftrack id because in most cases it is easier to access project id than project name.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Current session.</p> required <code>event</code> <code>Event</code> <p>Processed event by session.</p> required <code>entities</code> <code>List[Any]</code> <p>ftrack entities of selection.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Project name from event data.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>def get_project_name_from_event_with_entities(\n    self,\n    session: ftrack_api.Session,\n    event: ftrack_api.event.base.Event,\n    entities: List[ftrack_api.entity.base.Entity],\n) -&gt; Optional[str]:\n    \"\"\"Load or query and fill project entity from/to event data.\n\n    Project data are stored by ftrack id because in most cases it is\n    easier to access project id than project name.\n\n    Args:\n        session (ftrack_api.Session): Current session.\n        event (ftrack_api.Event): Processed event by session.\n        entities (List[Any]): ftrack entities of selection.\n\n    Returns:\n        Optional[str]: Project name from event data.\n\n    \"\"\"\n    # Try to get project entity from event\n    project_name = event[\"data\"].get(\"project_name\")\n    if not project_name:\n        project_entity = self.get_project_from_entity(\n            entities[0], session\n        )\n        project_name = project_entity[\"full_name\"]\n\n        event[\"data\"][\"project_name\"] = project_name\n    return project_name\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseAction.get_user_entity_from_event","title":"<code>get_user_entity_from_event(session, event)</code>  <code>classmethod</code>","text":"<p>Query user entity from event.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>@classmethod\ndef get_user_entity_from_event(\n    cls,\n    session: ftrack_api.Session,\n    event: ftrack_api.event.base.Event\n) -&gt; Optional[ftrack_api.entity.user.User]:\n    \"\"\"Query user entity from event.\"\"\"\n\n    not_set = object()\n\n    # Check if user is already stored in event data\n    user_entity = event[\"data\"].get(\"user_entity\", not_set)\n    if user_entity is not_set:\n        # Query user entity from event\n        user_info = event.get(\"source\", {}).get(\"user\", {})\n        user_id = user_info.get(\"id\")\n        username = user_info.get(\"username\")\n        if user_id:\n            user_entity = session.query(\n                \"User where id is {}\".format(user_id)\n            ).first()\n        if not user_entity and username:\n            user_entity = session.query(\n                \"User where username is {}\".format(username)\n            ).first()\n        event[\"data\"][\"user_entity\"] = user_entity\n\n    return user_entity\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseAction.get_user_roles_from_event","title":"<code>get_user_roles_from_event(session, event, lower=False)</code>  <code>classmethod</code>","text":"<p>Get user roles based on data in event.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Prepared ftrack session.</p> required <code>event</code> <code>Event</code> <p>Event which is processed.</p> required <code>lower</code> <code>Optional[bool]</code> <p>Lower the role names. Default 'False'.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of user roles.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>@classmethod\ndef get_user_roles_from_event(\n    cls,\n    session: ftrack_api.Session,\n    event: ftrack_api.event.base.Event,\n    lower: Optional[bool] = False\n) -&gt; List[str]:\n    \"\"\"Get user roles based on data in event.\n\n    Args:\n        session (ftrack_api.Session): Prepared ftrack session.\n        event (ftrack_api.event.Event): Event which is processed.\n        lower (Optional[bool]): Lower the role names. Default 'False'.\n\n    Returns:\n        List[str]: List of user roles.\n\n    \"\"\"\n    not_set = object()\n\n    user_roles = event[\"data\"].get(\"user_roles\", not_set)\n    if user_roles is not_set:\n        user_roles = []\n        user_entity = cls.get_user_entity_from_event(session, event)\n        for role in user_entity[\"user_security_roles\"]:\n            role_name = role[\"security_role\"][\"name\"]\n            if lower:\n                role_name = role_name.lower()\n            user_roles.append(role_name)\n        event[\"data\"][\"user_roles\"] = user_roles\n    return user_roles\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseAction.interface","title":"<code>interface(session, entities, event)</code>","text":"<p>Show an interface to user befor the action is processed.</p> <p>This is part of launch callback which gives option to return ftrack widgets items. These items are showed to user which can fill/change values and submit them.</p> <p>Interface must in that case handle if event contains values from user.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Connected ftrack api session.</p> required <code>entities</code> <code>List[Any]</code> <p>Entities on which was action triggered.</p> required <code>event</code> <code>Event</code> <p>Event which triggered launch callback.</p> required <p>Returns:</p> Type Description <code>Optional[Union[Dict[str, Any], List[Dict[str, Any]]]]</code> <p>Union[None, List[Dict[str, Any], Dict[str, Any]]: None if nothing should be showed, list of items to show or dictionary with 'items' key and possibly additional data (e.g. submit button label).</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>def interface(\n    self,\n    session: ftrack_api.Session,\n    entities: List[ftrack_api.entity.base.Entity],\n    event: ftrack_api.event.base.Event\n) -&gt; Optional[Union[Dict[str, Any], List[Dict[str, Any]]]]:\n    \"\"\"Show an interface to user befor the action is processed.\n\n    This is part of launch callback which gives option to return ftrack\n    widgets items. These items are showed to user which can fill/change\n    values and submit them.\n\n    Interface must in that case handle if event contains values from user.\n\n    Args:\n        session (ftrack_api.Session): Connected ftrack api session.\n        entities (List[Any]): Entities on which was action triggered.\n        event (ftrack_api.Event): Event which triggered launch callback.\n\n    Returns:\n        Union[None, List[Dict[str, Any], Dict[str, Any]]: None if nothing\n            should be showed, list of items to show or dictionary with\n            'items' key and possibly additional data\n            (e.g. submit button label).\n\n    \"\"\"\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseAction.launch","title":"<code>launch(session, entities, event)</code>","text":"<p>Main part of handling event callback.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Session which queried entities.</p> required <code>entities</code> <code>List[Any]</code> <p>Prequeried entities based on event data.</p> required <code>event</code> <code>Event</code> <p>ftrack event to process.</p> required <p>Returns:</p> Type Description <code>Optional[Union[bool, Dict[str, Any]]]</code> <p>Union[bool, Dict[str, Any]]: True or false for success or fail, or more complex data structure e.g. to show interface to user.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>def launch(\n    self,\n    session: ftrack_api.Session,\n    entities: List[ftrack_api.entity.base.Entity],\n    event: ftrack_api.event.base.Event\n) -&gt; Optional[Union[bool, Dict[str, Any]]]:\n    \"\"\"Main part of handling event callback.\n\n    Args:\n        session (ftrack_api.Session): Session which queried entities.\n        entities (List[Any]): Prequeried entities based on event data.\n        event (ftrack_api.Event): ftrack event to process.\n\n    Returns:\n        Union[bool, Dict[str, Any]]: True or false for success or fail,\n            or more complex data structure e.g. to show interface to user.\n\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseAction.register","title":"<code>register()</code>","text":"<p>Register to ftrack topics to discover and launch action.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>def register(self):\n    \"\"\"Register to ftrack topics to discover and launch action.\"\"\"\n    self.session.event_hub.subscribe(\n        \"topic=ftrack.action.discover\",\n        self._discover,\n        priority=self.priority\n    )\n\n    launch_subscription = (\n        \"topic=ftrack.action.launch and data.actionIdentifier={}\"\n    ).format(self.launch_identifier)\n    self.session.event_hub.subscribe(launch_subscription, self._launch)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseAction.roles_check","title":"<code>roles_check(settings_roles, user_roles, default=True)</code>  <code>staticmethod</code>","text":"<p>Compare roles from setting and user's roles.</p> <p>Parameters:</p> Name Type Description Default <code>settings_roles</code> <code>list</code> <p>List of role names from settings.</p> required <code>user_roles</code> <code>list</code> <p>User's lowered role names.</p> required <code>default</code> <code>bool</code> <p>If 'settings_roles' is empty list.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>'True' if user has at least one role from settings or default if 'settings_roles' is empty.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>@staticmethod\ndef roles_check(\n    settings_roles: List[str],\n    user_roles: List[str],\n    default: Optional[bool] = True\n) -&gt; bool:\n    \"\"\"Compare roles from setting and user's roles.\n\n    Args:\n        settings_roles(list): List of role names from settings.\n        user_roles(list): User's lowered role names.\n        default(bool): If 'settings_roles' is empty list.\n\n    Returns:\n        bool: 'True' if user has at least one role from settings or\n            default if 'settings_roles' is empty.\n\n    \"\"\"\n    if not settings_roles:\n        return default\n\n    user_roles = {\n        role_name.lower()\n        for role_name in user_roles\n    }\n    for role_name in settings_roles:\n        if role_name.lower() in user_roles:\n            return True\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseAction.valid_roles","title":"<code>valid_roles(session, entities, event)</code>","text":"<p>Validate user roles by settings.</p> <p>Method requires to have set <code>settings_key</code> attribute.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>def valid_roles(\n    self,\n    session: ftrack_api.Session,\n    entities: List[ftrack_api.entity.base.Entity],\n    event: ftrack_api.event.base.Event,\n) -&gt; bool:\n    \"\"\"Validate user roles by settings.\n\n    Method requires to have set `settings_key` attribute.\n    \"\"\"\n    ftrack_settings = self.get_ftrack_settings(session, event, entities)\n    settings = (\n        ftrack_settings[self.settings_frack_subkey][self.settings_key]\n    )\n    if self.settings_enabled_key:\n        if not settings.get(self.settings_enabled_key, True):\n            return False\n\n    user_role_list = self.get_user_roles_from_event(session, event)\n    if not self.roles_check(settings.get(\"role_list\"), user_role_list):\n        return False\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseEventHandler","title":"<code>BaseEventHandler</code>","text":"<p>               Bases: <code>BaseHandler</code></p> <p>Event handler listening to topics.</p> <p>Output of callback is not handled and handler is not designed for actions.</p> <p>By default is listening to \"ftrack.update\". To change it override 'register' method of change 'subscription_topic' attribute.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_event_handler.py</code> <pre><code>class BaseEventHandler(BaseHandler):\n    \"\"\"Event handler listening to topics.\n\n    Output of callback is not handled and handler is not designed for actions.\n\n    By default is listening to \"ftrack.update\". To change it override\n    'register' method of change 'subscription_topic' attribute.\n    \"\"\"\n    __ignore_handler_class: bool = True\n\n    subscription_topic: str = \"ftrack.update\"\n    handler_type: str = \"Event\"\n\n    def register(self):\n        \"\"\"Register to subscription topic.\"\"\"\n        self.session.event_hub.subscribe(\n            \"topic={}\".format(self.subscription_topic),\n            self._process,\n            priority=self.priority\n        )\n\n    def process(self, event: ftrack_api.event.base.Event):\n        \"\"\"Callback triggered on event with matching topic.\n\n        Args:\n            event (ftrack_api.Event): ftrack event to process.\n\n        \"\"\"\n        return self.launch(self.session, event)\n\n    def launch(\n        self,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event\n    ):\n        \"\"\"Deprecated method used for backwards compatibility.\n\n        Override 'process' method rather then 'launch'. Method name 'launch'\n        is derived from action event handler which does not make sense in terms\n        of not action based processing.\n\n        Args:\n            session (ftrack_api.Session): ftrack session which triggered\n                the event.\n            event (ftrack_api.Event): ftrack event to process.\n\n        \"\"\"\n        raise NotImplementedError()\n\n    def _process(self, event: ftrack_api.event.base.Event):\n        return self._launch(event)\n\n    def _launch(self, event: ftrack_api.event.base.Event):\n        \"\"\"Callback kept for backwards compatibility.\n\n        Will be removed when default\n        \"\"\"\n        self.session.rollback()\n        self.session._local_cache.clear()\n\n        try:\n            self.process(event)\n\n        except Exception as exc:\n            self.log.error(\n                \"Event \\\"{}\\\" Failed: {}\".format(\n                    self.__class__.__name__, str(exc)\n                ),\n                exc_info=True\n            )\n            self.session.rollback()\n            self.session._configure_locations()\n\n    def _translate_event(\n        self,\n        event: ftrack_api.event.base.Event,\n        session: Optional[ftrack_api.Session] = None\n    ):\n        \"\"\"Receive entity objects based on event.\n\n        Args:\n            event (ftrack_api.Event): Event to process.\n            session (ftrack_api.Session): Connected ftrack session.\n\n        Returns:\n            List[ftrack_api.Entity]: Queried entities based on event data.\n\n        \"\"\"\n        return self._get_entities(\n            event,\n            session,\n            ignore={\"socialfeed\", \"socialnotification\", \"team\"}\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseEventHandler.launch","title":"<code>launch(session, event)</code>","text":"<p>Deprecated method used for backwards compatibility.</p> <p>Override 'process' method rather then 'launch'. Method name 'launch' is derived from action event handler which does not make sense in terms of not action based processing.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>ftrack session which triggered the event.</p> required <code>event</code> <code>Event</code> <p>ftrack event to process.</p> required Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_event_handler.py</code> <pre><code>def launch(\n    self,\n    session: ftrack_api.Session,\n    event: ftrack_api.event.base.Event\n):\n    \"\"\"Deprecated method used for backwards compatibility.\n\n    Override 'process' method rather then 'launch'. Method name 'launch'\n    is derived from action event handler which does not make sense in terms\n    of not action based processing.\n\n    Args:\n        session (ftrack_api.Session): ftrack session which triggered\n            the event.\n        event (ftrack_api.Event): ftrack event to process.\n\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseEventHandler.process","title":"<code>process(event)</code>","text":"<p>Callback triggered on event with matching topic.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>ftrack event to process.</p> required Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_event_handler.py</code> <pre><code>def process(self, event: ftrack_api.event.base.Event):\n    \"\"\"Callback triggered on event with matching topic.\n\n    Args:\n        event (ftrack_api.Event): ftrack event to process.\n\n    \"\"\"\n    return self.launch(self.session, event)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseEventHandler.register","title":"<code>register()</code>","text":"<p>Register to subscription topic.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_event_handler.py</code> <pre><code>def register(self):\n    \"\"\"Register to subscription topic.\"\"\"\n    self.session.event_hub.subscribe(\n        \"topic={}\".format(self.subscription_topic),\n        self._process,\n        priority=self.priority\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseHandler","title":"<code>BaseHandler</code>","text":"<p>Base class for handling ftrack events.</p> <p>Attributes:</p> Name Type Description <code>enabled</code> <code>bool</code> <p>Is handler enabled.</p> <code>priority</code> <code>int</code> <p>Priority of handler processing. The lower value is the earlier is handler processed.</p> <code>handler_type</code> <code>str</code> <p>Has only debugging purposes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Connected ftrack session.</p> required Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>class BaseHandler(metaclass=ABCMeta):\n    \"\"\"Base class for handling ftrack events.\n\n    Attributes:\n        enabled (bool): Is handler enabled.\n        priority (int): Priority of handler processing. The lower value is the\n            earlier is handler processed.\n        handler_type (str): Has only debugging purposes.\n\n    Args:\n        session (ftrack_api.Session): Connected ftrack session.\n\n    \"\"\"\n    _log: Optional[logging.Logger] = None\n    _process_id: Optional[str] = None\n    # Default priority is 100\n    enabled: bool = True\n    priority: int = 100\n    handler_type: str = \"Base\"\n    _handler_label: Optional[str] = None\n    # Mark base classes to be ignored for discovery\n    __ignore_handler_class: bool = True\n\n    def __init__(self, session):\n        if not isinstance(session, ftrack_api.session.Session):\n            raise TypeError(\n                \"Expected 'ftrack_api.Session' object got '{}'\".format(\n                    str(type(session))))\n\n        self._session = session\n\n        self.register = self.register_wrapper(self.register)\n\n    @classmethod\n    def ignore_handler_class(cls) -&gt; bool:\n        \"\"\"Check if handler class should be ignored.\n\n        Do not touch implementation of this method, set\n            '__ignore_handler_class' to 'True' if you want to ignore class.\n\n        \"\"\"\n        cls_name = cls.__name__\n        if not cls_name.startswith(\"_\"):\n            cls_name = f\"_{cls_name}\"\n        return getattr(cls, f\"{cls_name}__ignore_handler_class\", False)\n\n    @staticmethod\n    def join_filter_values(values: Iterable[str]) -&gt; str:\n        return \",\".join({'\"{}\"'.format(value) for value in values})\n\n    @classmethod\n    def join_query_keys(cls, keys: Iterable[str]) -&gt; str:\n        return cls.join_filter_values(keys)\n\n    @property\n    def log(self) -&gt; logging.Logger:\n        \"\"\"Quick access to logger.\n\n        Returns:\n            logging.Logger: Logger that can be used for logging of handler.\n\n        \"\"\"\n        if self._log is None:\n            # TODO better logging mechanism\n            self._log = logging.getLogger(self.__class__.__name__)\n            self._log.setLevel(logging.DEBUG)\n        return self._log\n\n    @property\n    def handler_label(self) -&gt; str:\n        if self._handler_label is None:\n            self._handler_label = self.__class__.__name__\n        return self._handler_label\n\n    @property\n    def session(self) -&gt; ftrack_api.Session:\n        \"\"\"Fast access to session.\n\n        Returns:\n            session (ftrack_api.Session): Session which is source of events.\n\n        \"\"\"\n        return self._session\n\n    def reset_session(self):\n        \"\"\"Reset session cache.\"\"\"\n        self.session.reset()\n\n    @staticmethod\n    def process_identifier() -&gt; str:\n        \"\"\"Helper property to have unified access to process id.\n\n        Todos:\n            Use some global approach rather then implementation on\n                'BaseEntity'.\n\n        \"\"\"\n        if not BaseHandler._process_id:\n            BaseHandler._process_id = str(uuid.uuid4())\n        return BaseHandler._process_id\n\n    @abstractmethod\n    def register(self):\n        \"\"\"Subscribe to event topics.\"\"\"\n        pass\n\n    def cleanup(self):\n        \"\"\"Cleanup handler.\n\n        This method should end threads, timers, close connections, etc.\n        \"\"\"\n        pass\n\n    def register_wrapper(self, func):\n        @functools.wraps(func)\n        def wrapper_register(*args, **kwargs):\n            if not self.enabled:\n                return\n\n            try:\n                start_time = time.perf_counter()\n                func(*args, **kwargs)\n                end_time = time.perf_counter()\n                run_time = end_time - start_time\n                self.log.info((\n                    \"{} \\\"{}\\\" - Registered successfully ({:.4f}sec)\"\n                ).format(self.handler_type, self.handler_label, run_time))\n\n            except NotImplementedError:\n                self.log.error((\n                    \"{} \\\"{}\\\" - Register method is not implemented\"\n                ).format(self.handler_type, self.handler_label))\n\n            except Exception as exc:\n                self.log.error(\"{} \\\"{}\\\" - Registration failed ({})\".format(\n                    self.handler_type, self.handler_label, str(exc)\n                ))\n        return wrapper_register\n\n    def _get_entities(self, event, session=None, ignore=None):\n        entities = []\n        selection = event[\"data\"].get(\"selection\")\n        if not selection:\n            return entities\n\n        if ignore is None:\n            ignore = set()\n        elif isinstance(ignore, str):\n            ignore = {ignore}\n\n        filtered_selection = []\n        for entity in selection:\n            if entity[\"entityType\"] not in ignore:\n                filtered_selection.append(entity)\n\n        if not filtered_selection:\n            return entities\n\n        if session is None:\n            session = self.session\n            session._local_cache.clear()\n\n        for entity in filtered_selection:\n            entities.append(session.get(\n                self._get_entity_type(entity, session),\n                entity.get(\"entityId\")\n            ))\n\n        return entities\n\n    def _get_entity_type(self, entity, session=None):\n        \"\"\"Translate entity type so it can be used with API.\n\n        Todos:\n            Use object id rather.\n\n        \"\"\"\n        # Get entity type and make sure it is lower cased. Most places except\n        # the component tab in the Sidebar will use lower case notation.\n        entity_type = entity.get(\"entityType\").replace(\"_\", \"\").lower()\n\n        if session is None:\n            session = self.session\n\n        for schema in session.schemas:\n            alias_for = schema.get(\"alias_for\")\n\n            if (\n                alias_for\n                and isinstance(alias_for, str)\n                and alias_for.lower() == entity_type\n            ):\n                return schema[\"id\"]\n\n        for schema in self.session.schemas:\n            if schema[\"id\"].lower() == entity_type:\n                return schema[\"id\"]\n\n        raise ValueError(\n            \"Unable to translate entity type: {0}.\".format(entity_type)\n        )\n\n    def show_message(\n        self,\n        event: ftrack_api.event.base.Event,\n        message: str,\n        success: Optional[bool] = False,\n    ):\n        \"\"\"Shows message to user who triggered event.\n\n        Args:\n            event (ftrack_api.event.base.Event): Event used for source\n                of user id.\n            message (str): Message that will be shown to user.\n            success (bool): Define type (color) of message. False -&gt; red color.\n\n        \"\"\"\n        if not isinstance(success, bool):\n            success = False\n\n        try:\n            message = str(message)\n        except Exception:\n            return\n\n        user_id = event[\"source\"][\"user\"][\"id\"]\n        target = (\n            \"applicationId=ftrack.client.web and user.id=\\\"{}\\\"\"\n        ).format(user_id)\n        self.session.event_hub.publish(\n            ftrack_api.event.base.Event(\n                topic=\"ftrack.action.trigger-user-interface\",\n                data={\n                    \"type\": \"message\",\n                    \"success\": success,\n                    \"message\": message\n                },\n                target=target\n            ),\n            on_error=\"ignore\"\n        )\n\n    def show_interface(\n        self,\n        items: List[Dict[str, Any]],\n        title: Optional[str] = \"\",\n        user_id: Optional[str] = None,\n        user: Optional[Any] = None,\n        event: Optional[ftrack_api.event.base.Event] = None,\n        username: Optional[str] = None,\n        submit_btn_label: Optional[str] = None,\n    ):\n        \"\"\"Shows ftrack widgets interface to user.\n\n        Interface is shown to a user. To identify user one of arguments must be\n        passed: 'user_id', 'user', 'event', 'username'.\n\n        Args:\n            items (List[Dict[str, Any]]) Interface items (their structure is\n                defined by ftrack documentation).\n            title (str): Title of shown widget.\n            user_id (str): User id.\n            user (Any): Object of ftrack user (queried using ftrack api\n                session).\n            event (ftrack_api.Event): Event which can be used as source for\n                user id.\n            username (str): Username of user to get it's id. This is slowest\n                way how user id is received.\n            submit_btn_label (str): Label of submit button in ftrack widget.\n\n        \"\"\"\n        if user_id:\n            pass\n\n        elif user:\n            user_id = user[\"id\"]\n\n        elif username:\n            user = self.session.query(\n                \"User where username is \\\"{}\\\"\".format(username)\n            ).first()\n            if not user:\n                raise ValueError((\n                    \"ftrack user with username \\\"{}\\\" was not found!\"\n                ).format(username))\n\n            user_id = user[\"id\"]\n\n        elif event:\n            user_id = event[\"source\"][\"user\"][\"id\"]\n\n        if not user_id:\n            return\n\n        target = (\n            \"applicationId=ftrack.client.web and user.id=\\\"{}\\\"\"\n        ).format(user_id)\n\n        event_data = {\n            \"type\": \"widget\",\n            \"items\": items,\n            \"title\": title\n        }\n        if submit_btn_label:\n            event_data[\"submit_button_label\"] = submit_btn_label\n\n        self.session.event_hub.publish(\n            ftrack_api.event.base.Event(\n                topic=\"ftrack.action.trigger-user-interface\",\n                data=event_data,\n                target=target\n            ),\n            on_error=\"ignore\"\n        )\n\n    def show_interface_from_dict(\n        self,\n        messages: Dict[str, Union[str, List[str]]],\n        title: Optional[str] = \"\",\n        user_id: Optional[str] = None,\n        user: Optional[Any] = None,\n        event: Optional[ftrack_api.event.base.Event] = None,\n        username: Optional[str] = None,\n        submit_btn_label: Optional[str] = None,\n    ):\n        # TODO Find out how and where is this used\n        if not messages:\n            self.log.debug(\"No messages to show! (messages dict is empty)\")\n            return\n        items = []\n        splitter = {\"type\": \"label\", \"value\": \"---\"}\n        first = True\n        for key, value in messages.items():\n            if not first:\n                items.append(splitter)\n            first = False\n\n            items.append({\"type\": \"label\", \"value\": \"&lt;h3&gt;{}&lt;/h3&gt;\".format(key)})\n            if isinstance(value, str):\n                value = [value]\n\n            for item in value:\n                items.append({\"type\": \"label\", \"value\": f\"&lt;p&gt;{item}&lt;/p&gt;\"})\n\n        self.show_interface(\n            items,\n            title=title,\n            user_id=user_id,\n            user=user,\n            event=event,\n            username=username,\n            submit_btn_label=submit_btn_label\n        )\n\n    def trigger_action(\n        self,\n        action_identifier: str,\n        event: Optional[ftrack_api.event.base.Event] = None,\n        session: Optional[ftrack_api.Session] = None,\n        selection: Optional[List[Dict[str, str]]] = None,\n        user_data: Optional[Dict[str, Any]] = None,\n        topic: Optional[str] = \"ftrack.action.launch\",\n        additional_event_data: Optional[Dict[str, Any]] = None,\n        on_error: Optional[str] = \"ignore\"\n    ):\n        self.log.debug(\n            \"Triggering action \\\"{}\\\" Begins\".format(action_identifier))\n\n        if not session:\n            session = self.session\n\n        # Getting selection and user data\n        if event:\n            if selection is None:\n                selection = event.get(\"data\", {}).get(\"selection\")\n            if user_data is None:\n                user_data = event.get(\"source\", {}).get(\"user\")\n\n        # Without selection and user data skip triggering\n        msg = \"Can't trigger \\\"{}\\\" action without {}.\"\n        if selection is None:\n            self.log.error(msg.format(action_identifier, \"selection\"))\n            return\n\n        if user_data is None:\n            self.log.error(msg.format(action_identifier, \"user data\"))\n            return\n\n        event_data = {\n            \"actionIdentifier\": action_identifier,\n            \"selection\": selection\n        }\n\n        # Add additional data\n        if additional_event_data:\n            event_data.update(additional_event_data)\n\n        # Create and trigger event\n        session.event_hub.publish(\n            ftrack_api.event.base.Event(\n                topic=topic,\n                data=event_data,\n                source={\"user\": user_data}\n            ),\n            on_error=on_error\n        )\n        self.log.debug(\n            \"Action \\\"{}\\\" triggered\".format(action_identifier))\n\n    def trigger_event(\n        self,\n        topic: str,\n        event_data: Optional[Dict[str, Any]] = None,\n        session: Optional[ftrack_api.Session] = None,\n        source: Optional[Dict[str, Any]] = None,\n        event: Optional[ftrack_api.event.base.Event] = None,\n        on_error: Optional[str] = \"ignore\"\n    ):\n        if session is None:\n            session = self.session\n\n        if not source and event:\n            source = event.get(\"source\")\n\n        if event_data is None:\n            event_data = {}\n        # Create and trigger event\n        event = ftrack_api.event.base.Event(\n            topic=topic,\n            data=event_data,\n            source=source\n        )\n        session.event_hub.publish(event, on_error=on_error)\n\n        self.log.debug((\n            \"Publishing event: {}\"\n        ).format(str(event.__dict__)))\n\n    def get_project_from_entity(\n        self,\n        entity: ftrack_api.entity.base.Entity,\n        session: Optional[ftrack_api.Session] = None\n    ):\n        low_entity_type = entity.entity_type.lower()\n        if low_entity_type == \"project\":\n            return entity\n\n        if \"project\" in entity:\n            # reviewsession, task(Task, Shot, Sequence,...)\n            return entity[\"project\"]\n\n        if low_entity_type == \"filecomponent\":\n            entity = entity[\"version\"]\n            low_entity_type = entity.entity_type.lower()\n\n        if low_entity_type == \"assetversion\":\n            asset = entity[\"asset\"]\n            parent = None\n            if asset:\n                parent = asset[\"parent\"]\n\n            if parent:\n                if parent.entity_type.lower() == \"project\":\n                    return parent\n\n                if \"project\" in parent:\n                    return parent[\"project\"]\n\n        project_data = entity[\"link\"][0]\n\n        if session is None:\n            session = self.session\n        return session.query(\n            \"Project where id is {}\".format(project_data[\"id\"])\n        ).one()\n\n    def get_project_entity_from_event(\n        self,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event,\n        project_id: str,\n    ):\n        \"\"\"Load or query and fill project entity from/to event data.\n\n        Project data are stored by ftrack id because in most cases it is\n        easier to access project id than project name.\n\n        Args:\n            session (ftrack_api.Session): Current session.\n            event (ftrack_api.Event): Processed event by session.\n            project_id (str): ftrack project id.\n\n        Returns:\n            Union[str, None]: Project name based on entities or None if project\n                cannot be defined.\n\n        \"\"\"\n        if not project_id:\n            raise ValueError(\n                \"Entered `project_id` is not valid. {} ({})\".format(\n                    str(project_id), str(type(project_id))\n                )\n            )\n\n        project_id_mapping = event[\"data\"].setdefault(\n            \"project_entity_by_id\", {}\n        )\n        if project_id in project_id_mapping:\n            return project_id_mapping[project_id]\n\n        # Get project entity from task and store to event\n        project_entity = session.query((\n            \"select full_name from Project where id is \\\"{}\\\"\"\n        ).format(project_id)).first()\n        project_id_mapping[project_id] = project_entity\n\n        return project_entity\n\n    def get_project_name_from_event(\n        self,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event,\n        project_id: str,\n    ):\n        \"\"\"Load or query and fill project entity from/to event data.\n\n        Project data are stored by ftrack id because in most cases it is\n        easier to access project id than project name.\n\n        Args:\n            session (ftrack_api.Session): Current session.\n            event (ftrack_api.Event): Processed event by session.\n            project_id (str): ftrack project id.\n\n        Returns:\n            Union[str, None]: Project name based on entities or None if project\n                cannot be defined.\n\n        \"\"\"\n        if not project_id:\n            raise ValueError(\n                \"Entered `project_id` is not valid. {} ({})\".format(\n                    str(project_id), str(type(project_id))\n                )\n            )\n\n        project_id_mapping = event[\"data\"].setdefault(\"project_id_name\", {})\n        if project_id in project_id_mapping:\n            return project_id_mapping[project_id]\n\n        # Get project entity from task and store to event\n        project_entity = self.get_project_entity_from_event(\n            session, event, project_id\n        )\n        if project_entity:\n            project_name = project_entity[\"full_name\"]\n        project_id_mapping[project_id] = project_name\n        return project_name\n\n    def get_ayon_project_from_event(\n        self,\n        event: ftrack_api.event.base.Event,\n        project_name: str\n    ):\n        \"\"\"Get AYON project from event.\n\n        Args:\n            event (ftrack_api.Event): Event which is source of project id.\n            project_name (Union[str, None]): Project name.\n\n        Returns:\n            Union[dict[str, Any], None]: AYON project.\n\n        \"\"\"\n        ayon_projects = event[\"data\"].setdefault(\"ayon_projects\", {})\n        if project_name in ayon_projects:\n            return ayon_projects[project_name]\n\n        project = None\n        if project_name:\n            project = get_project(project_name)\n        ayon_projects[project_name] = project\n        return project\n\n    def get_project_settings_from_event(\n        self,\n        event: ftrack_api.event.base.Event,\n        project_name: str\n    ):\n        \"\"\"Load or fill AYON's project settings from event data.\n\n        Project data are stored by ftrack id because in most cases it is\n        easier to access project id than project name.\n\n        Args:\n            event (ftrack_api.Event): Processed event by session.\n            project_name (str): Project name.\n\n        \"\"\"\n        project_settings_by_name = event[\"data\"].setdefault(\n            \"project_settings\", {}\n        )\n        if project_name in project_settings_by_name:\n            return copy.deepcopy(project_settings_by_name[project_name])\n\n        # NOTE there is no safe way how to get project settings if project\n        #   does not exist on AYON server.\n        # TODO Should we somehow find out if ftrack is enabled for the\n        #   project?\n        # TODO how to find out which bundle should be used?\n        project = self.get_ayon_project_from_event(event, project_name)\n        if not project:\n            project_name = None\n        project_settings = get_addons_settings(project_name=project_name)\n        project_settings_by_name[project_name] = project_settings\n        return copy.deepcopy(project_settings)\n\n    @staticmethod\n    def get_entity_path(entity: ftrack_api.entity.base.Entity) -&gt; str:\n        \"\"\"Return full hierarchical path to entity.\"\"\"\n        return \"/\".join(\n            [ent[\"name\"] for ent in entity[\"link\"]]\n        )\n\n    @classmethod\n    def add_traceback_to_job(\n        cls,\n        job: ftrack_api.entity.job.Job,\n        session: ftrack_api.Session,\n        exc_info: Tuple,\n        description: Optional[str] = None,\n        component_name: Optional[str] = None,\n        job_status: Optional[str] = None\n    ):\n        \"\"\"Add traceback file to a job.\n\n        Args:\n            job (JobEntity): Entity of job where file should be able to\n                download (Created or queried with passed session).\n            session (Session): ftrack session which was used to query/create\n                entered job.\n            exc_info (tuple): Exception info (e.g. from `sys.exc_info()`).\n            description (str): Change job description to describe what\n                happened. Job description won't change if not passed.\n            component_name (str): Name of component and default name of\n                downloaded file. Class name and current date time are used if\n                not specified.\n            job_status (str): Status of job which will be set. By default is\n                set to 'failed'.\n\n        \"\"\"\n        if description:\n            job_data = {\n                \"description\": description\n            }\n            job[\"data\"] = json.dumps(job_data)\n\n        if not job_status:\n            job_status = \"failed\"\n\n        job[\"status\"] = job_status\n\n        # Create temp file where traceback will be stored\n        with tempfile.NamedTemporaryFile(\n            mode=\"w\", prefix=\"ayon_ftrack_\", suffix=\".txt\", delete=False\n        ) as temp_obj:\n            temp_filepath = temp_obj.name\n\n        # Store traceback to file\n        result = traceback.format_exception(*exc_info)\n        with open(temp_filepath, \"w\") as temp_file:\n            temp_file.write(\"\".join(result))\n\n        # Upload file with traceback to ftrack server and add it to job\n        if not component_name:\n            component_name = \"{}_{}\".format(\n                cls.__name__,\n                datetime.datetime.now().strftime(\"%y-%m-%d-%H%M\")\n            )\n        cls.add_file_component_to_job(\n            job, session, temp_filepath, component_name\n        )\n        # Delete temp file\n        os.remove(temp_filepath)\n\n    @staticmethod\n    def add_file_component_to_job(\n        job: ftrack_api.entity.job.Job,\n        session: ftrack_api.Session,\n        filepath: str,\n        basename: Optional[str] = None\n    ):\n        \"\"\"Add filepath as downloadable component to job.\n\n        Args:\n            job (JobEntity): Entity of job where file should be able to\n                download (Created or queried with passed session).\n            session (Session): ftrack session which was used to query/create\n                entered job.\n            filepath (str): Path to file which should be added to job.\n            basename (str): Defines name of file which will be downloaded on\n                user's side. Must be without extension otherwise extension will\n                be duplicated in downloaded name. Basename from entered path\n                used when not entered.\n\n        \"\"\"\n        # Make sure session's locations are configured\n        # - they can be deconfigured e.g. using `rollback` method\n        session._configure_locations()\n\n        # Query `ftrack.server` location where component will be stored\n        location = session.query(\n            \"Location where name is \\\"ftrack.server\\\"\"\n        ).one()\n\n        # Use filename as basename if not entered (must be without extension)\n        if basename is None:\n            basename = os.path.splitext(\n                os.path.basename(filepath)\n            )[0]\n\n        component = session.create_component(\n            filepath,\n            data={\"name\": basename},\n            location=location\n        )\n        session.create(\n            \"JobComponent\",\n            {\n                \"component_id\": component[\"id\"],\n                \"job_id\": job[\"id\"]\n            }\n        )\n        session.commit()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseHandler.log","title":"<code>log</code>  <code>property</code>","text":"<p>Quick access to logger.</p> <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: Logger that can be used for logging of handler.</p>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseHandler.session","title":"<code>session</code>  <code>property</code>","text":"<p>Fast access to session.</p> <p>Returns:</p> Name Type Description <code>session</code> <code>Session</code> <p>Session which is source of events.</p>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseHandler.add_file_component_to_job","title":"<code>add_file_component_to_job(job, session, filepath, basename=None)</code>  <code>staticmethod</code>","text":"<p>Add filepath as downloadable component to job.</p> <p>Parameters:</p> Name Type Description Default <code>job</code> <code>JobEntity</code> <p>Entity of job where file should be able to download (Created or queried with passed session).</p> required <code>session</code> <code>Session</code> <p>ftrack session which was used to query/create entered job.</p> required <code>filepath</code> <code>str</code> <p>Path to file which should be added to job.</p> required <code>basename</code> <code>str</code> <p>Defines name of file which will be downloaded on user's side. Must be without extension otherwise extension will be duplicated in downloaded name. Basename from entered path used when not entered.</p> <code>None</code> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>@staticmethod\ndef add_file_component_to_job(\n    job: ftrack_api.entity.job.Job,\n    session: ftrack_api.Session,\n    filepath: str,\n    basename: Optional[str] = None\n):\n    \"\"\"Add filepath as downloadable component to job.\n\n    Args:\n        job (JobEntity): Entity of job where file should be able to\n            download (Created or queried with passed session).\n        session (Session): ftrack session which was used to query/create\n            entered job.\n        filepath (str): Path to file which should be added to job.\n        basename (str): Defines name of file which will be downloaded on\n            user's side. Must be without extension otherwise extension will\n            be duplicated in downloaded name. Basename from entered path\n            used when not entered.\n\n    \"\"\"\n    # Make sure session's locations are configured\n    # - they can be deconfigured e.g. using `rollback` method\n    session._configure_locations()\n\n    # Query `ftrack.server` location where component will be stored\n    location = session.query(\n        \"Location where name is \\\"ftrack.server\\\"\"\n    ).one()\n\n    # Use filename as basename if not entered (must be without extension)\n    if basename is None:\n        basename = os.path.splitext(\n            os.path.basename(filepath)\n        )[0]\n\n    component = session.create_component(\n        filepath,\n        data={\"name\": basename},\n        location=location\n    )\n    session.create(\n        \"JobComponent\",\n        {\n            \"component_id\": component[\"id\"],\n            \"job_id\": job[\"id\"]\n        }\n    )\n    session.commit()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseHandler.add_traceback_to_job","title":"<code>add_traceback_to_job(job, session, exc_info, description=None, component_name=None, job_status=None)</code>  <code>classmethod</code>","text":"<p>Add traceback file to a job.</p> <p>Parameters:</p> Name Type Description Default <code>job</code> <code>JobEntity</code> <p>Entity of job where file should be able to download (Created or queried with passed session).</p> required <code>session</code> <code>Session</code> <p>ftrack session which was used to query/create entered job.</p> required <code>exc_info</code> <code>tuple</code> <p>Exception info (e.g. from <code>sys.exc_info()</code>).</p> required <code>description</code> <code>str</code> <p>Change job description to describe what happened. Job description won't change if not passed.</p> <code>None</code> <code>component_name</code> <code>str</code> <p>Name of component and default name of downloaded file. Class name and current date time are used if not specified.</p> <code>None</code> <code>job_status</code> <code>str</code> <p>Status of job which will be set. By default is set to 'failed'.</p> <code>None</code> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>@classmethod\ndef add_traceback_to_job(\n    cls,\n    job: ftrack_api.entity.job.Job,\n    session: ftrack_api.Session,\n    exc_info: Tuple,\n    description: Optional[str] = None,\n    component_name: Optional[str] = None,\n    job_status: Optional[str] = None\n):\n    \"\"\"Add traceback file to a job.\n\n    Args:\n        job (JobEntity): Entity of job where file should be able to\n            download (Created or queried with passed session).\n        session (Session): ftrack session which was used to query/create\n            entered job.\n        exc_info (tuple): Exception info (e.g. from `sys.exc_info()`).\n        description (str): Change job description to describe what\n            happened. Job description won't change if not passed.\n        component_name (str): Name of component and default name of\n            downloaded file. Class name and current date time are used if\n            not specified.\n        job_status (str): Status of job which will be set. By default is\n            set to 'failed'.\n\n    \"\"\"\n    if description:\n        job_data = {\n            \"description\": description\n        }\n        job[\"data\"] = json.dumps(job_data)\n\n    if not job_status:\n        job_status = \"failed\"\n\n    job[\"status\"] = job_status\n\n    # Create temp file where traceback will be stored\n    with tempfile.NamedTemporaryFile(\n        mode=\"w\", prefix=\"ayon_ftrack_\", suffix=\".txt\", delete=False\n    ) as temp_obj:\n        temp_filepath = temp_obj.name\n\n    # Store traceback to file\n    result = traceback.format_exception(*exc_info)\n    with open(temp_filepath, \"w\") as temp_file:\n        temp_file.write(\"\".join(result))\n\n    # Upload file with traceback to ftrack server and add it to job\n    if not component_name:\n        component_name = \"{}_{}\".format(\n            cls.__name__,\n            datetime.datetime.now().strftime(\"%y-%m-%d-%H%M\")\n        )\n    cls.add_file_component_to_job(\n        job, session, temp_filepath, component_name\n    )\n    # Delete temp file\n    os.remove(temp_filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseHandler.cleanup","title":"<code>cleanup()</code>","text":"<p>Cleanup handler.</p> <p>This method should end threads, timers, close connections, etc.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def cleanup(self):\n    \"\"\"Cleanup handler.\n\n    This method should end threads, timers, close connections, etc.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseHandler.get_ayon_project_from_event","title":"<code>get_ayon_project_from_event(event, project_name)</code>","text":"<p>Get AYON project from event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>Event which is source of project id.</p> required <code>project_name</code> <code>Union[str, None]</code> <p>Project name.</p> required <p>Returns:</p> Type Description <p>Union[dict[str, Any], None]: AYON project.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def get_ayon_project_from_event(\n    self,\n    event: ftrack_api.event.base.Event,\n    project_name: str\n):\n    \"\"\"Get AYON project from event.\n\n    Args:\n        event (ftrack_api.Event): Event which is source of project id.\n        project_name (Union[str, None]): Project name.\n\n    Returns:\n        Union[dict[str, Any], None]: AYON project.\n\n    \"\"\"\n    ayon_projects = event[\"data\"].setdefault(\"ayon_projects\", {})\n    if project_name in ayon_projects:\n        return ayon_projects[project_name]\n\n    project = None\n    if project_name:\n        project = get_project(project_name)\n    ayon_projects[project_name] = project\n    return project\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseHandler.get_entity_path","title":"<code>get_entity_path(entity)</code>  <code>staticmethod</code>","text":"<p>Return full hierarchical path to entity.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>@staticmethod\ndef get_entity_path(entity: ftrack_api.entity.base.Entity) -&gt; str:\n    \"\"\"Return full hierarchical path to entity.\"\"\"\n    return \"/\".join(\n        [ent[\"name\"] for ent in entity[\"link\"]]\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseHandler.get_project_entity_from_event","title":"<code>get_project_entity_from_event(session, event, project_id)</code>","text":"<p>Load or query and fill project entity from/to event data.</p> <p>Project data are stored by ftrack id because in most cases it is easier to access project id than project name.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Current session.</p> required <code>event</code> <code>Event</code> <p>Processed event by session.</p> required <code>project_id</code> <code>str</code> <p>ftrack project id.</p> required <p>Returns:</p> Type Description <p>Union[str, None]: Project name based on entities or None if project cannot be defined.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def get_project_entity_from_event(\n    self,\n    session: ftrack_api.Session,\n    event: ftrack_api.event.base.Event,\n    project_id: str,\n):\n    \"\"\"Load or query and fill project entity from/to event data.\n\n    Project data are stored by ftrack id because in most cases it is\n    easier to access project id than project name.\n\n    Args:\n        session (ftrack_api.Session): Current session.\n        event (ftrack_api.Event): Processed event by session.\n        project_id (str): ftrack project id.\n\n    Returns:\n        Union[str, None]: Project name based on entities or None if project\n            cannot be defined.\n\n    \"\"\"\n    if not project_id:\n        raise ValueError(\n            \"Entered `project_id` is not valid. {} ({})\".format(\n                str(project_id), str(type(project_id))\n            )\n        )\n\n    project_id_mapping = event[\"data\"].setdefault(\n        \"project_entity_by_id\", {}\n    )\n    if project_id in project_id_mapping:\n        return project_id_mapping[project_id]\n\n    # Get project entity from task and store to event\n    project_entity = session.query((\n        \"select full_name from Project where id is \\\"{}\\\"\"\n    ).format(project_id)).first()\n    project_id_mapping[project_id] = project_entity\n\n    return project_entity\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseHandler.get_project_name_from_event","title":"<code>get_project_name_from_event(session, event, project_id)</code>","text":"<p>Load or query and fill project entity from/to event data.</p> <p>Project data are stored by ftrack id because in most cases it is easier to access project id than project name.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Current session.</p> required <code>event</code> <code>Event</code> <p>Processed event by session.</p> required <code>project_id</code> <code>str</code> <p>ftrack project id.</p> required <p>Returns:</p> Type Description <p>Union[str, None]: Project name based on entities or None if project cannot be defined.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def get_project_name_from_event(\n    self,\n    session: ftrack_api.Session,\n    event: ftrack_api.event.base.Event,\n    project_id: str,\n):\n    \"\"\"Load or query and fill project entity from/to event data.\n\n    Project data are stored by ftrack id because in most cases it is\n    easier to access project id than project name.\n\n    Args:\n        session (ftrack_api.Session): Current session.\n        event (ftrack_api.Event): Processed event by session.\n        project_id (str): ftrack project id.\n\n    Returns:\n        Union[str, None]: Project name based on entities or None if project\n            cannot be defined.\n\n    \"\"\"\n    if not project_id:\n        raise ValueError(\n            \"Entered `project_id` is not valid. {} ({})\".format(\n                str(project_id), str(type(project_id))\n            )\n        )\n\n    project_id_mapping = event[\"data\"].setdefault(\"project_id_name\", {})\n    if project_id in project_id_mapping:\n        return project_id_mapping[project_id]\n\n    # Get project entity from task and store to event\n    project_entity = self.get_project_entity_from_event(\n        session, event, project_id\n    )\n    if project_entity:\n        project_name = project_entity[\"full_name\"]\n    project_id_mapping[project_id] = project_name\n    return project_name\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseHandler.get_project_settings_from_event","title":"<code>get_project_settings_from_event(event, project_name)</code>","text":"<p>Load or fill AYON's project settings from event data.</p> <p>Project data are stored by ftrack id because in most cases it is easier to access project id than project name.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>Processed event by session.</p> required <code>project_name</code> <code>str</code> <p>Project name.</p> required Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def get_project_settings_from_event(\n    self,\n    event: ftrack_api.event.base.Event,\n    project_name: str\n):\n    \"\"\"Load or fill AYON's project settings from event data.\n\n    Project data are stored by ftrack id because in most cases it is\n    easier to access project id than project name.\n\n    Args:\n        event (ftrack_api.Event): Processed event by session.\n        project_name (str): Project name.\n\n    \"\"\"\n    project_settings_by_name = event[\"data\"].setdefault(\n        \"project_settings\", {}\n    )\n    if project_name in project_settings_by_name:\n        return copy.deepcopy(project_settings_by_name[project_name])\n\n    # NOTE there is no safe way how to get project settings if project\n    #   does not exist on AYON server.\n    # TODO Should we somehow find out if ftrack is enabled for the\n    #   project?\n    # TODO how to find out which bundle should be used?\n    project = self.get_ayon_project_from_event(event, project_name)\n    if not project:\n        project_name = None\n    project_settings = get_addons_settings(project_name=project_name)\n    project_settings_by_name[project_name] = project_settings\n    return copy.deepcopy(project_settings)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseHandler.ignore_handler_class","title":"<code>ignore_handler_class()</code>  <code>classmethod</code>","text":"<p>Check if handler class should be ignored.</p> <p>Do not touch implementation of this method, set     '__ignore_handler_class' to 'True' if you want to ignore class.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>@classmethod\ndef ignore_handler_class(cls) -&gt; bool:\n    \"\"\"Check if handler class should be ignored.\n\n    Do not touch implementation of this method, set\n        '__ignore_handler_class' to 'True' if you want to ignore class.\n\n    \"\"\"\n    cls_name = cls.__name__\n    if not cls_name.startswith(\"_\"):\n        cls_name = f\"_{cls_name}\"\n    return getattr(cls, f\"{cls_name}__ignore_handler_class\", False)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseHandler.process_identifier","title":"<code>process_identifier()</code>  <code>staticmethod</code>","text":"<p>Helper property to have unified access to process id.</p> Todos <p>Use some global approach rather then implementation on     'BaseEntity'.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>@staticmethod\ndef process_identifier() -&gt; str:\n    \"\"\"Helper property to have unified access to process id.\n\n    Todos:\n        Use some global approach rather then implementation on\n            'BaseEntity'.\n\n    \"\"\"\n    if not BaseHandler._process_id:\n        BaseHandler._process_id = str(uuid.uuid4())\n    return BaseHandler._process_id\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseHandler.register","title":"<code>register()</code>  <code>abstractmethod</code>","text":"<p>Subscribe to event topics.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>@abstractmethod\ndef register(self):\n    \"\"\"Subscribe to event topics.\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseHandler.reset_session","title":"<code>reset_session()</code>","text":"<p>Reset session cache.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def reset_session(self):\n    \"\"\"Reset session cache.\"\"\"\n    self.session.reset()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseHandler.show_interface","title":"<code>show_interface(items, title='', user_id=None, user=None, event=None, username=None, submit_btn_label=None)</code>","text":"<p>Shows ftrack widgets interface to user.</p> <p>Interface is shown to a user. To identify user one of arguments must be passed: 'user_id', 'user', 'event', 'username'.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of shown widget.</p> <code>''</code> <code>user_id</code> <code>str</code> <p>User id.</p> <code>None</code> <code>user</code> <code>Any</code> <p>Object of ftrack user (queried using ftrack api session).</p> <code>None</code> <code>event</code> <code>Event</code> <p>Event which can be used as source for user id.</p> <code>None</code> <code>username</code> <code>str</code> <p>Username of user to get it's id. This is slowest way how user id is received.</p> <code>None</code> <code>submit_btn_label</code> <code>str</code> <p>Label of submit button in ftrack widget.</p> <code>None</code> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def show_interface(\n    self,\n    items: List[Dict[str, Any]],\n    title: Optional[str] = \"\",\n    user_id: Optional[str] = None,\n    user: Optional[Any] = None,\n    event: Optional[ftrack_api.event.base.Event] = None,\n    username: Optional[str] = None,\n    submit_btn_label: Optional[str] = None,\n):\n    \"\"\"Shows ftrack widgets interface to user.\n\n    Interface is shown to a user. To identify user one of arguments must be\n    passed: 'user_id', 'user', 'event', 'username'.\n\n    Args:\n        items (List[Dict[str, Any]]) Interface items (their structure is\n            defined by ftrack documentation).\n        title (str): Title of shown widget.\n        user_id (str): User id.\n        user (Any): Object of ftrack user (queried using ftrack api\n            session).\n        event (ftrack_api.Event): Event which can be used as source for\n            user id.\n        username (str): Username of user to get it's id. This is slowest\n            way how user id is received.\n        submit_btn_label (str): Label of submit button in ftrack widget.\n\n    \"\"\"\n    if user_id:\n        pass\n\n    elif user:\n        user_id = user[\"id\"]\n\n    elif username:\n        user = self.session.query(\n            \"User where username is \\\"{}\\\"\".format(username)\n        ).first()\n        if not user:\n            raise ValueError((\n                \"ftrack user with username \\\"{}\\\" was not found!\"\n            ).format(username))\n\n        user_id = user[\"id\"]\n\n    elif event:\n        user_id = event[\"source\"][\"user\"][\"id\"]\n\n    if not user_id:\n        return\n\n    target = (\n        \"applicationId=ftrack.client.web and user.id=\\\"{}\\\"\"\n    ).format(user_id)\n\n    event_data = {\n        \"type\": \"widget\",\n        \"items\": items,\n        \"title\": title\n    }\n    if submit_btn_label:\n        event_data[\"submit_button_label\"] = submit_btn_label\n\n    self.session.event_hub.publish(\n        ftrack_api.event.base.Event(\n            topic=\"ftrack.action.trigger-user-interface\",\n            data=event_data,\n            target=target\n        ),\n        on_error=\"ignore\"\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.BaseHandler.show_message","title":"<code>show_message(event, message, success=False)</code>","text":"<p>Shows message to user who triggered event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>Event used for source of user id.</p> required <code>message</code> <code>str</code> <p>Message that will be shown to user.</p> required <code>success</code> <code>bool</code> <p>Define type (color) of message. False -&gt; red color.</p> <code>False</code> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def show_message(\n    self,\n    event: ftrack_api.event.base.Event,\n    message: str,\n    success: Optional[bool] = False,\n):\n    \"\"\"Shows message to user who triggered event.\n\n    Args:\n        event (ftrack_api.event.base.Event): Event used for source\n            of user id.\n        message (str): Message that will be shown to user.\n        success (bool): Define type (color) of message. False -&gt; red color.\n\n    \"\"\"\n    if not isinstance(success, bool):\n        success = False\n\n    try:\n        message = str(message)\n    except Exception:\n        return\n\n    user_id = event[\"source\"][\"user\"][\"id\"]\n    target = (\n        \"applicationId=ftrack.client.web and user.id=\\\"{}\\\"\"\n    ).format(user_id)\n    self.session.event_hub.publish(\n        ftrack_api.event.base.Event(\n            topic=\"ftrack.action.trigger-user-interface\",\n            data={\n                \"type\": \"message\",\n                \"success\": success,\n                \"message\": message\n            },\n            target=target\n        ),\n        on_error=\"ignore\"\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.LocalAction","title":"<code>LocalAction</code>","text":"<p>               Bases: <code>BaseAction</code></p> <p>Action that warn user when more Processes with same action are running.</p> <p>Action is launched all the time but if id does not match id of current instanace then message is shown to user.</p> <p>Handy for actions where matters if is executed on specific machine.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>class LocalAction(BaseAction):\n    \"\"\"Action that warn user when more Processes with same action are running.\n\n    Action is launched all the time but if id does not match id of current\n    instanace then message is shown to user.\n\n    Handy for actions where matters if is executed on specific machine.\n    \"\"\"\n    __ignore_handler_class: bool = True\n    _full_launch_identifier: bool = None\n\n    @property\n    def discover_identifier(self) -&gt; str:\n        if self._discover_identifier is None:\n            self._discover_identifier = \"{}.{}\".format(\n                self.identifier, self.process_identifier()\n            )\n        return self._discover_identifier\n\n    @property\n    def launch_identifier(self) -&gt; str:\n        \"\"\"Catch all topics with same identifier.\"\"\"\n        if self._launch_identifier is None:\n            self._launch_identifier = \"{}.*\".format(self.identifier)\n        return self._launch_identifier\n\n    @property\n    def full_launch_identifier(self):\n        \"\"\"Catch all topics with same identifier.\"\"\"\n        if self._full_launch_identifier is None:\n            self._full_launch_identifier = \"{}.{}\".format(\n                self.identifier, self.process_identifier()\n            )\n        return self._full_launch_identifier\n\n    def register(self):\n        \"\"\"Register to ftrack topics to discover and launch action.\n\n        Filter events to this session user.\n        \"\"\"\n        # Subscribe to discover topic for user under this session\n        self.session.event_hub.subscribe(\n            \"topic=ftrack.action.discover and source.user.username={}\".format(\n                self.session.api_user\n            ),\n            self._discover,\n            priority=self.priority\n        )\n\n        launch_subscription = (\n            \"topic=ftrack.action.launch\"\n            \" and data.actionIdentifier={}\"\n            \" and source.user.username={}\"\n        ).format(self.launch_identifier, self.session.api_user)\n        self.session.event_hub.subscribe(\n            launch_subscription,\n            self._launch\n        )\n\n    def _discover(\n        self, event: ftrack_api.event.base.Event\n    ) -&gt; Optional[Dict[str, Any]]:\n        entities = self._translate_event(event)\n        if not entities:\n            return\n\n        accepts = self.discover(self.session, entities, event)\n        if not accepts:\n            return\n\n        self.log.debug(\"Discovering action with selection: {0}\".format(\n            event[\"data\"].get(\"selection\", [])\n        ))\n\n        return {\n            \"items\": [{\n                \"label\": self.label,\n                \"variant\": self.variant,\n                \"description\": self.description,\n                \"actionIdentifier\": self.discover_identifier,\n                \"icon\": self.icon,\n            }]\n        }\n\n    def _launch(\n        self, event: ftrack_api.event.base.Event\n    ) -&gt; Optional[Dict[str, Any]]:\n        event_identifier = event[\"data\"][\"actionIdentifier\"]\n        # Check if identifier is same\n        # - show message that acion may not be triggered on this machine\n        if event_identifier != self.full_launch_identifier:\n            return {\n                \"success\": False,\n                \"message\": (\n                    \"There are running more AYON processes\"\n                    \" where this action could be launched.\"\n                )\n            }\n        return super()._launch(event)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.LocalAction.full_launch_identifier","title":"<code>full_launch_identifier</code>  <code>property</code>","text":"<p>Catch all topics with same identifier.</p>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.LocalAction.launch_identifier","title":"<code>launch_identifier</code>  <code>property</code>","text":"<p>Catch all topics with same identifier.</p>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.LocalAction.register","title":"<code>register()</code>","text":"<p>Register to ftrack topics to discover and launch action.</p> <p>Filter events to this session user.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>def register(self):\n    \"\"\"Register to ftrack topics to discover and launch action.\n\n    Filter events to this session user.\n    \"\"\"\n    # Subscribe to discover topic for user under this session\n    self.session.event_hub.subscribe(\n        \"topic=ftrack.action.discover and source.user.username={}\".format(\n            self.session.api_user\n        ),\n        self._discover,\n        priority=self.priority\n    )\n\n    launch_subscription = (\n        \"topic=ftrack.action.launch\"\n        \" and data.actionIdentifier={}\"\n        \" and source.user.username={}\"\n    ).format(self.launch_identifier, self.session.api_user)\n    self.session.event_hub.subscribe(\n        launch_subscription,\n        self._launch\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/index.html#client.ayon_ftrack.common.event_handlers.ServerAction","title":"<code>ServerAction</code>","text":"<p>               Bases: <code>BaseAction</code></p> <p>Action class meant to be used on event server.</p> <p>Unlike the <code>BaseAction</code> roles are not checked on register but on discover. For the same reason register is modified to not filter topics by username.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>class ServerAction(BaseAction):\n    \"\"\"Action class meant to be used on event server.\n\n    Unlike the `BaseAction` roles are not checked on register but on discover.\n    For the same reason register is modified to not filter topics by username.\n    \"\"\"\n    __ignore_handler_class: bool = True\n\n    settings_frack_subkey: str = \"service_event_handlers\"\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_action_handler.html","title":"ftrack_action_handler","text":""},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_action_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_action_handler.BaseAction","title":"<code>BaseAction</code>","text":"<p>               Bases: <code>BaseHandler</code></p> <p>Custom Action base class.</p> <p>Simplify action discovery and launch. This implementation represents single action with single callback. To change the behavior implement custom callbacks or override '_discover' and '_launch' methods.</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>Label of action of group name of action. Can be combined with 'variant' attribute.</p> <code>variant</code> <code>str</code> <p>Variant under 'label'. Can be combined with 'label' e.g. when 'label' is \"Admin\" and variant is \"Kill jobs\". In case there is more variants for \"Admin\" label they'll grouped in ftrack UI widgets.</p> <code>identifier</code> <code>str</code> <p>Action identifier. Is used to trigger the launch logic of action.</p> <code>icon</code> <code>str</code> <p>Url to icon (Browser which should show the icon must have access to the resource).</p> <code>description</code> <code>str</code> <p>Hint of action which is showed to user hovering over the action.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Connected ftrack session.</p> required Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>class BaseAction(BaseHandler):\n    \"\"\"Custom Action base class.\n\n    Simplify action discovery and launch. This implementation represents\n    single action with single callback. To change the behavior implement\n    custom callbacks or override '_discover' and '_launch' methods.\n\n    Attributes:\n        label (str): Label of action of group name of action. Can be combined\n            with 'variant' attribute.\n        variant (str): Variant under 'label'. Can be combined with 'label' e.g.\n            when 'label' is \"Admin\" and variant is \"Kill jobs\". In case\n            there is more variants for \"Admin\" label they'll grouped in ftrack\n            UI widgets.\n        identifier (str): Action identifier. Is used to trigger the launch\n            logic of action.\n        icon (str): Url to icon (Browser which should show the icon must have\n            access to the resource).\n        description (str): Hint of action which is showed to user hovering\n            over the action.\n\n    Args:\n        session (ftrack_api.Session): Connected ftrack session.\n\n    \"\"\"\n    __ignore_handler_class = True\n\n    label: Optional[str] = None\n    variant: Optional[str] = None\n    identifier: Optional[str] = None\n    description: Optional[str] = None\n    icon: Optional[str] = None\n    handler_type: str = \"Action\"\n    preactions: List[str] = []\n\n    _full_label: Optional[str] = None\n    _discover_identifier: Optional[str] = None\n    _launch_identifier: Optional[str] = None\n\n    settings_frack_subkey: str = \"user_handlers\"\n    settings_enabled_key: str = \"enabled\"\n\n    def __init__(self, session: ftrack_api.Session):\n        # Validate minimum requirements\n        if not self.label:\n            raise ValueError(\"Action missing 'label'.\")\n\n        if not self.identifier:\n            raise ValueError(\"Action missing 'identifier'.\")\n\n        super().__init__(session)\n        self.setup_launch_wrapper()\n\n    def setup_launch_wrapper(self):\n        self._launch = self.launch_wrapper(self._launch)\n\n    @property\n    def discover_identifier(self) -&gt; str:\n        return self.identifier\n\n    @property\n    def launch_identifier(self) -&gt; str:\n        return self.identifier\n\n    @property\n    def handler_label(self) -&gt; str:\n        return self.full_label\n\n    @property\n    def full_label(self) -&gt; str:\n        \"\"\"Full label of action.\n\n        Value of full label is cached.\n\n        Returns:\n            str: Label created from 'label' and 'variant' attributes.\n\n        \"\"\"\n        if self._full_label is None:\n            if self.variant:\n                label = \"{} {}\".format(self.label, self.variant)\n            else:\n                label = self.label\n            self._full_label = label\n        return self._full_label\n\n    def register(self):\n        \"\"\"Register to ftrack topics to discover and launch action.\"\"\"\n        self.session.event_hub.subscribe(\n            \"topic=ftrack.action.discover\",\n            self._discover,\n            priority=self.priority\n        )\n\n        launch_subscription = (\n            \"topic=ftrack.action.launch and data.actionIdentifier={}\"\n        ).format(self.launch_identifier)\n        self.session.event_hub.subscribe(launch_subscription, self._launch)\n\n    def _translate_event(\n        self,\n        event: ftrack_api.event.base.Event,\n        session: Optional[ftrack_api.Session] = None\n    ) -&gt; List[ftrack_api.entity.base.Entity]:\n        \"\"\"Translate event to receive entities based on it's data.\"\"\"\n        if session is None:\n            session = self.session\n\n        _entities = event[\"data\"].get(\"entities_object\", None)\n        if _entities is not None and not _entities:\n            return _entities\n\n        if (\n            _entities is None\n            or _entities[0].get(\"link\") == ftrack_api.symbol.NOT_SET\n        ):\n            _entities = [\n                item\n                for item in self._get_entities(\n                    event,\n                    session=session,\n                    ignore={\"socialfeed\", \"socialnotification\", \"team\"}\n                )\n                if item is not None\n            ]\n            event[\"data\"][\"entities_object\"] = _entities\n\n        return _entities\n\n    def _discover(\n        self, event: ftrack_api.event.base.Event\n    ) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Decide if and how will be action showed to user in ftrack.\n\n        Args:\n            event (ftrack_api.Event): Event with topic which triggered this\n                callback.\n\n        Returns:\n            Union[None, Dict[str, Any]]: None if action is not returned\n                otherwise returns items to show in UI (structure of items is\n                defined by ftrack and can be found in documentation).\n\n        \"\"\"\n        entities = self._translate_event(event)\n        if not entities:\n            return None\n\n        accepts = self.discover(self.session, entities, event)\n        if not accepts:\n            return None\n\n        self.log.debug(\"Discovering action with selection: {}\".format(\n            event[\"data\"].get(\"selection\") or []\n        ))\n\n        return {\n            \"items\": [{\n                \"label\": self.label,\n                \"variant\": self.variant,\n                \"description\": self.description,\n                \"actionIdentifier\": self.discover_identifier,\n                \"icon\": self.icon,\n            }]\n        }\n\n    def discover(\n        self,\n        session: ftrack_api.Session,\n        entities: List[ftrack_api.entity.base.Entity],\n        event: ftrack_api.event.base.Event,\n    ) -&gt; bool:\n        \"\"\"Decide if action is showed to used based on event data.\n\n        Action should override the method to implement logic to show the\n        action. The most common logic is based on combination of user roles\n        and selected entities.\n\n        Args:\n            session (ftrack_api.Session): Session which triggered callback of\n                the event.\n            entities (List[Any]): Prepared list of entities from event data.\n            event (ftrack_api.Event): ftrack event which caused this callback\n                is triggered.\n\n        Returns:\n            bool: True if action should be returned.\n\n        \"\"\"\n        return False\n\n    def _handle_preactions(\n        self, session: ftrack_api.Session, event: ftrack_api.event.base.Event\n    ) -&gt; bool:\n        \"\"\"Launch actions before launching this action.\n\n        Concept came from Pype and got deprecated (and used) over time. Should\n        be probably removed.\n\n        Note:\n            Added warning log that this functionlity is deprecated and will\n                be removed in the future.\n\n        Args:\n            session (ftrack_api.Session): ftrack session.\n            event (ftrack_api.Event): Event which triggered launch of this\n                action.\n\n        Returns:\n            bool: Preactions were launched or not.\n\n        Deprecated:\n            Preactions are marked as deprecated. Server actions should not\n                use preactions and local actions use local identifier which\n                is hard to handle automatically\n\n        \"\"\"\n        # If preactions are not set\n        if len(self.preactions) == 0:\n            return True\n\n        if not event.get(\"data\", {}).get(\"selection\"):\n            return False\n\n        # If preactions were already started\n        if event[\"data\"].get(\"preactions_launched\") is True:\n            return True\n\n        self.log.warning((\n            \"DEPRECATION WARNING: Action \\\"{}\\\" is using 'preactions'\"\n            \" which are deprecated and will be removed Q2 2023.\"\n        ).format(self.full_label))\n\n        # Launch preactions\n        for preaction in self.preactions:\n            self.trigger_action(preaction, event)\n\n        # Relaunch this action\n        self.trigger_action(\n            self.launch_identifier,\n            event,\n            additional_event_data={\"preactions_launched\": True}\n        )\n        return False\n\n    def launch_wrapper(self, func):\n        @functools.wraps(func)\n        def wrapper_func(*args, **kwargs):\n            self.log.info(\"{} \\\"{}\\\": Launched\".format(\n                self.handler_type, self.full_label\n            ))\n\n            try:\n                output = func(*args, **kwargs)\n                self.log.info(\"{} \\\"{}\\\": Finished\".format(\n                    self.handler_type, self.full_label\n                ))\n\n            except BaseException as exc:\n                self.session.rollback()\n                self.session._configure_locations()\n                msg = \"{} \\\"{}\\\": Failed ({})\".format(\n                    self.handler_type, self.full_label, str(exc))\n                self.log.error(msg, exc_info=True)\n                output = {\n                    \"success\": False,\n                    \"message\": msg\n                }\n\n            return output\n        return wrapper_func\n\n    def _launch(\n        self, event: ftrack_api.event.base.Event\n    ) -&gt; Optional[Dict[str, Any]]:\n        entities = self._translate_event(event)\n        if not entities:\n            return\n\n        preactions_launched = self._handle_preactions(self.session, event)\n        if preactions_launched is False:\n            return\n\n        interface = self._interface(self.session, entities, event)\n        if interface:\n            return interface\n\n        response = self.launch(self.session, entities, event)\n\n        return self._handle_result(response)\n\n    def launch(\n        self,\n        session: ftrack_api.Session,\n        entities: List[ftrack_api.entity.base.Entity],\n        event: ftrack_api.event.base.Event\n    ) -&gt; Optional[Union[bool, Dict[str, Any]]]:\n        \"\"\"Main part of handling event callback.\n\n        Args:\n            session (ftrack_api.Session): Session which queried entities.\n            entities (List[Any]): Prequeried entities based on event data.\n            event (ftrack_api.Event): ftrack event to process.\n\n        Returns:\n            Union[bool, Dict[str, Any]]: True or false for success or fail,\n                or more complex data structure e.g. to show interface to user.\n\n        \"\"\"\n        raise NotImplementedError()\n\n    def _interface(\n        self,\n        session: ftrack_api.Session,\n        entities: List[ftrack_api.entity.base.Entity],\n        event: ftrack_api.event.base.Event\n    ) -&gt; Optional[Dict[str, Any]]:\n        interface = self.interface(session, entities, event)\n        if not interface:\n            return\n\n        if isinstance(interface, (tuple, list)):\n            return {\"items\": interface}\n\n        if isinstance(interface, dict):\n            if (\n                \"items\" in interface\n                or (\"success\" in interface and \"message\" in interface)\n            ):\n                return interface\n\n            raise ValueError((\n                \"Invalid interface output expected key: \\\"items\\\" or keys:\"\n                \" \\\"success\\\" and \\\"message\\\". Got: \\\"{}\\\"\"\n            ).format(str(interface)))\n\n        raise ValueError(\n            \"Invalid interface output type \\\"{}\\\"\".format(\n                str(type(interface))\n            )\n        )\n\n    def interface(\n        self,\n        session: ftrack_api.Session,\n        entities: List[ftrack_api.entity.base.Entity],\n        event: ftrack_api.event.base.Event\n    ) -&gt; Optional[Union[Dict[str, Any], List[Dict[str, Any]]]]:\n        \"\"\"Show an interface to user befor the action is processed.\n\n        This is part of launch callback which gives option to return ftrack\n        widgets items. These items are showed to user which can fill/change\n        values and submit them.\n\n        Interface must in that case handle if event contains values from user.\n\n        Args:\n            session (ftrack_api.Session): Connected ftrack api session.\n            entities (List[Any]): Entities on which was action triggered.\n            event (ftrack_api.Event): Event which triggered launch callback.\n\n        Returns:\n            Union[None, List[Dict[str, Any], Dict[str, Any]]: None if nothing\n                should be showed, list of items to show or dictionary with\n                'items' key and possibly additional data\n                (e.g. submit button label).\n\n        \"\"\"\n        return None\n\n    def _handle_result(self, result: Any) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Validate the returned result from the action callback.\"\"\"\n        if not result:\n            return None\n\n        if isinstance(result, dict):\n            if \"items\" in result:\n                if not isinstance(result[\"items\"], list):\n                    raise TypeError(\n                        \"Invalid items type {} expected list\".format(\n                            str(type(result[\"items\"]))))\n                return result\n\n            if \"success\" not in result and \"message\" not in result:\n                self.log.error((\n                    \"{} \\\"{}\\\" Missing required keys\"\n                    \" \\\"success\\\" and \\\"message\\\" in callback output. This is\"\n                    \" soft fail.\"\n                ).format(self.handler_type, self.full_label))\n\n            elif \"message\" in result:\n                if \"success\" not in result:\n                    result[\"success\"] = True\n                return result\n\n            # Fallback to 'bool' result\n            result = result.get(\"success\", True)\n\n        if isinstance(result, bool):\n            if result:\n                return {\n                    \"success\": True,\n                    \"message\": \"{} finished.\".format(self.full_label)\n                }\n            return {\n                \"success\": False,\n                \"message\": \"{} failed.\".format(self.full_label)\n            }\n\n        return result\n\n    @staticmethod\n    def roles_check(\n        settings_roles: List[str],\n        user_roles: List[str],\n        default: Optional[bool] = True\n    ) -&gt; bool:\n        \"\"\"Compare roles from setting and user's roles.\n\n        Args:\n            settings_roles(list): List of role names from settings.\n            user_roles(list): User's lowered role names.\n            default(bool): If 'settings_roles' is empty list.\n\n        Returns:\n            bool: 'True' if user has at least one role from settings or\n                default if 'settings_roles' is empty.\n\n        \"\"\"\n        if not settings_roles:\n            return default\n\n        user_roles = {\n            role_name.lower()\n            for role_name in user_roles\n        }\n        for role_name in settings_roles:\n            if role_name.lower() in user_roles:\n                return True\n        return False\n\n    @classmethod\n    def get_user_entity_from_event(\n        cls,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event\n    ) -&gt; Optional[ftrack_api.entity.user.User]:\n        \"\"\"Query user entity from event.\"\"\"\n\n        not_set = object()\n\n        # Check if user is already stored in event data\n        user_entity = event[\"data\"].get(\"user_entity\", not_set)\n        if user_entity is not_set:\n            # Query user entity from event\n            user_info = event.get(\"source\", {}).get(\"user\", {})\n            user_id = user_info.get(\"id\")\n            username = user_info.get(\"username\")\n            if user_id:\n                user_entity = session.query(\n                    \"User where id is {}\".format(user_id)\n                ).first()\n            if not user_entity and username:\n                user_entity = session.query(\n                    \"User where username is {}\".format(username)\n                ).first()\n            event[\"data\"][\"user_entity\"] = user_entity\n\n        return user_entity\n\n    @classmethod\n    def get_user_roles_from_event(\n        cls,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event,\n        lower: Optional[bool] = False\n    ) -&gt; List[str]:\n        \"\"\"Get user roles based on data in event.\n\n        Args:\n            session (ftrack_api.Session): Prepared ftrack session.\n            event (ftrack_api.event.Event): Event which is processed.\n            lower (Optional[bool]): Lower the role names. Default 'False'.\n\n        Returns:\n            List[str]: List of user roles.\n\n        \"\"\"\n        not_set = object()\n\n        user_roles = event[\"data\"].get(\"user_roles\", not_set)\n        if user_roles is not_set:\n            user_roles = []\n            user_entity = cls.get_user_entity_from_event(session, event)\n            for role in user_entity[\"user_security_roles\"]:\n                role_name = role[\"security_role\"][\"name\"]\n                if lower:\n                    role_name = role_name.lower()\n                user_roles.append(role_name)\n            event[\"data\"][\"user_roles\"] = user_roles\n        return user_roles\n\n    def get_project_name_from_event_with_entities(\n        self,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event,\n        entities: List[ftrack_api.entity.base.Entity],\n    ) -&gt; Optional[str]:\n        \"\"\"Load or query and fill project entity from/to event data.\n\n        Project data are stored by ftrack id because in most cases it is\n        easier to access project id than project name.\n\n        Args:\n            session (ftrack_api.Session): Current session.\n            event (ftrack_api.Event): Processed event by session.\n            entities (List[Any]): ftrack entities of selection.\n\n        Returns:\n            Optional[str]: Project name from event data.\n\n        \"\"\"\n        # Try to get project entity from event\n        project_name = event[\"data\"].get(\"project_name\")\n        if not project_name:\n            project_entity = self.get_project_from_entity(\n                entities[0], session\n            )\n            project_name = project_entity[\"full_name\"]\n\n            event[\"data\"][\"project_name\"] = project_name\n        return project_name\n\n    def get_ftrack_settings(\n        self,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event,\n        entities: List[ftrack_api.entity.base.Entity],\n    ) -&gt; Dict[str, Any]:\n        project_name = self.get_project_name_from_event_with_entities(\n            session, event, entities\n        )\n        project_settings = self.get_project_settings_from_event(\n            event, project_name\n        )\n        return project_settings[\"ftrack\"]\n\n    def valid_roles(\n        self,\n        session: ftrack_api.Session,\n        entities: List[ftrack_api.entity.base.Entity],\n        event: ftrack_api.event.base.Event,\n    ) -&gt; bool:\n        \"\"\"Validate user roles by settings.\n\n        Method requires to have set `settings_key` attribute.\n        \"\"\"\n        ftrack_settings = self.get_ftrack_settings(session, event, entities)\n        settings = (\n            ftrack_settings[self.settings_frack_subkey][self.settings_key]\n        )\n        if self.settings_enabled_key:\n            if not settings.get(self.settings_enabled_key, True):\n                return False\n\n        user_role_list = self.get_user_roles_from_event(session, event)\n        if not self.roles_check(settings.get(\"role_list\"), user_role_list):\n            return False\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_action_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_action_handler.BaseAction.full_label","title":"<code>full_label</code>  <code>property</code>","text":"<p>Full label of action.</p> <p>Value of full label is cached.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Label created from 'label' and 'variant' attributes.</p>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_action_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_action_handler.BaseAction.discover","title":"<code>discover(session, entities, event)</code>","text":"<p>Decide if action is showed to used based on event data.</p> <p>Action should override the method to implement logic to show the action. The most common logic is based on combination of user roles and selected entities.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Session which triggered callback of the event.</p> required <code>entities</code> <code>List[Any]</code> <p>Prepared list of entities from event data.</p> required <code>event</code> <code>Event</code> <p>ftrack event which caused this callback is triggered.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if action should be returned.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>def discover(\n    self,\n    session: ftrack_api.Session,\n    entities: List[ftrack_api.entity.base.Entity],\n    event: ftrack_api.event.base.Event,\n) -&gt; bool:\n    \"\"\"Decide if action is showed to used based on event data.\n\n    Action should override the method to implement logic to show the\n    action. The most common logic is based on combination of user roles\n    and selected entities.\n\n    Args:\n        session (ftrack_api.Session): Session which triggered callback of\n            the event.\n        entities (List[Any]): Prepared list of entities from event data.\n        event (ftrack_api.Event): ftrack event which caused this callback\n            is triggered.\n\n    Returns:\n        bool: True if action should be returned.\n\n    \"\"\"\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_action_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_action_handler.BaseAction.get_project_name_from_event_with_entities","title":"<code>get_project_name_from_event_with_entities(session, event, entities)</code>","text":"<p>Load or query and fill project entity from/to event data.</p> <p>Project data are stored by ftrack id because in most cases it is easier to access project id than project name.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Current session.</p> required <code>event</code> <code>Event</code> <p>Processed event by session.</p> required <code>entities</code> <code>List[Any]</code> <p>ftrack entities of selection.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Project name from event data.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>def get_project_name_from_event_with_entities(\n    self,\n    session: ftrack_api.Session,\n    event: ftrack_api.event.base.Event,\n    entities: List[ftrack_api.entity.base.Entity],\n) -&gt; Optional[str]:\n    \"\"\"Load or query and fill project entity from/to event data.\n\n    Project data are stored by ftrack id because in most cases it is\n    easier to access project id than project name.\n\n    Args:\n        session (ftrack_api.Session): Current session.\n        event (ftrack_api.Event): Processed event by session.\n        entities (List[Any]): ftrack entities of selection.\n\n    Returns:\n        Optional[str]: Project name from event data.\n\n    \"\"\"\n    # Try to get project entity from event\n    project_name = event[\"data\"].get(\"project_name\")\n    if not project_name:\n        project_entity = self.get_project_from_entity(\n            entities[0], session\n        )\n        project_name = project_entity[\"full_name\"]\n\n        event[\"data\"][\"project_name\"] = project_name\n    return project_name\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_action_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_action_handler.BaseAction.get_user_entity_from_event","title":"<code>get_user_entity_from_event(session, event)</code>  <code>classmethod</code>","text":"<p>Query user entity from event.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>@classmethod\ndef get_user_entity_from_event(\n    cls,\n    session: ftrack_api.Session,\n    event: ftrack_api.event.base.Event\n) -&gt; Optional[ftrack_api.entity.user.User]:\n    \"\"\"Query user entity from event.\"\"\"\n\n    not_set = object()\n\n    # Check if user is already stored in event data\n    user_entity = event[\"data\"].get(\"user_entity\", not_set)\n    if user_entity is not_set:\n        # Query user entity from event\n        user_info = event.get(\"source\", {}).get(\"user\", {})\n        user_id = user_info.get(\"id\")\n        username = user_info.get(\"username\")\n        if user_id:\n            user_entity = session.query(\n                \"User where id is {}\".format(user_id)\n            ).first()\n        if not user_entity and username:\n            user_entity = session.query(\n                \"User where username is {}\".format(username)\n            ).first()\n        event[\"data\"][\"user_entity\"] = user_entity\n\n    return user_entity\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_action_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_action_handler.BaseAction.get_user_roles_from_event","title":"<code>get_user_roles_from_event(session, event, lower=False)</code>  <code>classmethod</code>","text":"<p>Get user roles based on data in event.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Prepared ftrack session.</p> required <code>event</code> <code>Event</code> <p>Event which is processed.</p> required <code>lower</code> <code>Optional[bool]</code> <p>Lower the role names. Default 'False'.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of user roles.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>@classmethod\ndef get_user_roles_from_event(\n    cls,\n    session: ftrack_api.Session,\n    event: ftrack_api.event.base.Event,\n    lower: Optional[bool] = False\n) -&gt; List[str]:\n    \"\"\"Get user roles based on data in event.\n\n    Args:\n        session (ftrack_api.Session): Prepared ftrack session.\n        event (ftrack_api.event.Event): Event which is processed.\n        lower (Optional[bool]): Lower the role names. Default 'False'.\n\n    Returns:\n        List[str]: List of user roles.\n\n    \"\"\"\n    not_set = object()\n\n    user_roles = event[\"data\"].get(\"user_roles\", not_set)\n    if user_roles is not_set:\n        user_roles = []\n        user_entity = cls.get_user_entity_from_event(session, event)\n        for role in user_entity[\"user_security_roles\"]:\n            role_name = role[\"security_role\"][\"name\"]\n            if lower:\n                role_name = role_name.lower()\n            user_roles.append(role_name)\n        event[\"data\"][\"user_roles\"] = user_roles\n    return user_roles\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_action_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_action_handler.BaseAction.interface","title":"<code>interface(session, entities, event)</code>","text":"<p>Show an interface to user befor the action is processed.</p> <p>This is part of launch callback which gives option to return ftrack widgets items. These items are showed to user which can fill/change values and submit them.</p> <p>Interface must in that case handle if event contains values from user.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Connected ftrack api session.</p> required <code>entities</code> <code>List[Any]</code> <p>Entities on which was action triggered.</p> required <code>event</code> <code>Event</code> <p>Event which triggered launch callback.</p> required <p>Returns:</p> Type Description <code>Optional[Union[Dict[str, Any], List[Dict[str, Any]]]]</code> <p>Union[None, List[Dict[str, Any], Dict[str, Any]]: None if nothing should be showed, list of items to show or dictionary with 'items' key and possibly additional data (e.g. submit button label).</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>def interface(\n    self,\n    session: ftrack_api.Session,\n    entities: List[ftrack_api.entity.base.Entity],\n    event: ftrack_api.event.base.Event\n) -&gt; Optional[Union[Dict[str, Any], List[Dict[str, Any]]]]:\n    \"\"\"Show an interface to user befor the action is processed.\n\n    This is part of launch callback which gives option to return ftrack\n    widgets items. These items are showed to user which can fill/change\n    values and submit them.\n\n    Interface must in that case handle if event contains values from user.\n\n    Args:\n        session (ftrack_api.Session): Connected ftrack api session.\n        entities (List[Any]): Entities on which was action triggered.\n        event (ftrack_api.Event): Event which triggered launch callback.\n\n    Returns:\n        Union[None, List[Dict[str, Any], Dict[str, Any]]: None if nothing\n            should be showed, list of items to show or dictionary with\n            'items' key and possibly additional data\n            (e.g. submit button label).\n\n    \"\"\"\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_action_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_action_handler.BaseAction.launch","title":"<code>launch(session, entities, event)</code>","text":"<p>Main part of handling event callback.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Session which queried entities.</p> required <code>entities</code> <code>List[Any]</code> <p>Prequeried entities based on event data.</p> required <code>event</code> <code>Event</code> <p>ftrack event to process.</p> required <p>Returns:</p> Type Description <code>Optional[Union[bool, Dict[str, Any]]]</code> <p>Union[bool, Dict[str, Any]]: True or false for success or fail, or more complex data structure e.g. to show interface to user.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>def launch(\n    self,\n    session: ftrack_api.Session,\n    entities: List[ftrack_api.entity.base.Entity],\n    event: ftrack_api.event.base.Event\n) -&gt; Optional[Union[bool, Dict[str, Any]]]:\n    \"\"\"Main part of handling event callback.\n\n    Args:\n        session (ftrack_api.Session): Session which queried entities.\n        entities (List[Any]): Prequeried entities based on event data.\n        event (ftrack_api.Event): ftrack event to process.\n\n    Returns:\n        Union[bool, Dict[str, Any]]: True or false for success or fail,\n            or more complex data structure e.g. to show interface to user.\n\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_action_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_action_handler.BaseAction.register","title":"<code>register()</code>","text":"<p>Register to ftrack topics to discover and launch action.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>def register(self):\n    \"\"\"Register to ftrack topics to discover and launch action.\"\"\"\n    self.session.event_hub.subscribe(\n        \"topic=ftrack.action.discover\",\n        self._discover,\n        priority=self.priority\n    )\n\n    launch_subscription = (\n        \"topic=ftrack.action.launch and data.actionIdentifier={}\"\n    ).format(self.launch_identifier)\n    self.session.event_hub.subscribe(launch_subscription, self._launch)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_action_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_action_handler.BaseAction.roles_check","title":"<code>roles_check(settings_roles, user_roles, default=True)</code>  <code>staticmethod</code>","text":"<p>Compare roles from setting and user's roles.</p> <p>Parameters:</p> Name Type Description Default <code>settings_roles</code> <code>list</code> <p>List of role names from settings.</p> required <code>user_roles</code> <code>list</code> <p>User's lowered role names.</p> required <code>default</code> <code>bool</code> <p>If 'settings_roles' is empty list.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>'True' if user has at least one role from settings or default if 'settings_roles' is empty.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>@staticmethod\ndef roles_check(\n    settings_roles: List[str],\n    user_roles: List[str],\n    default: Optional[bool] = True\n) -&gt; bool:\n    \"\"\"Compare roles from setting and user's roles.\n\n    Args:\n        settings_roles(list): List of role names from settings.\n        user_roles(list): User's lowered role names.\n        default(bool): If 'settings_roles' is empty list.\n\n    Returns:\n        bool: 'True' if user has at least one role from settings or\n            default if 'settings_roles' is empty.\n\n    \"\"\"\n    if not settings_roles:\n        return default\n\n    user_roles = {\n        role_name.lower()\n        for role_name in user_roles\n    }\n    for role_name in settings_roles:\n        if role_name.lower() in user_roles:\n            return True\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_action_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_action_handler.BaseAction.valid_roles","title":"<code>valid_roles(session, entities, event)</code>","text":"<p>Validate user roles by settings.</p> <p>Method requires to have set <code>settings_key</code> attribute.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>def valid_roles(\n    self,\n    session: ftrack_api.Session,\n    entities: List[ftrack_api.entity.base.Entity],\n    event: ftrack_api.event.base.Event,\n) -&gt; bool:\n    \"\"\"Validate user roles by settings.\n\n    Method requires to have set `settings_key` attribute.\n    \"\"\"\n    ftrack_settings = self.get_ftrack_settings(session, event, entities)\n    settings = (\n        ftrack_settings[self.settings_frack_subkey][self.settings_key]\n    )\n    if self.settings_enabled_key:\n        if not settings.get(self.settings_enabled_key, True):\n            return False\n\n    user_role_list = self.get_user_roles_from_event(session, event)\n    if not self.roles_check(settings.get(\"role_list\"), user_role_list):\n        return False\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_action_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_action_handler.LocalAction","title":"<code>LocalAction</code>","text":"<p>               Bases: <code>BaseAction</code></p> <p>Action that warn user when more Processes with same action are running.</p> <p>Action is launched all the time but if id does not match id of current instanace then message is shown to user.</p> <p>Handy for actions where matters if is executed on specific machine.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>class LocalAction(BaseAction):\n    \"\"\"Action that warn user when more Processes with same action are running.\n\n    Action is launched all the time but if id does not match id of current\n    instanace then message is shown to user.\n\n    Handy for actions where matters if is executed on specific machine.\n    \"\"\"\n    __ignore_handler_class: bool = True\n    _full_launch_identifier: bool = None\n\n    @property\n    def discover_identifier(self) -&gt; str:\n        if self._discover_identifier is None:\n            self._discover_identifier = \"{}.{}\".format(\n                self.identifier, self.process_identifier()\n            )\n        return self._discover_identifier\n\n    @property\n    def launch_identifier(self) -&gt; str:\n        \"\"\"Catch all topics with same identifier.\"\"\"\n        if self._launch_identifier is None:\n            self._launch_identifier = \"{}.*\".format(self.identifier)\n        return self._launch_identifier\n\n    @property\n    def full_launch_identifier(self):\n        \"\"\"Catch all topics with same identifier.\"\"\"\n        if self._full_launch_identifier is None:\n            self._full_launch_identifier = \"{}.{}\".format(\n                self.identifier, self.process_identifier()\n            )\n        return self._full_launch_identifier\n\n    def register(self):\n        \"\"\"Register to ftrack topics to discover and launch action.\n\n        Filter events to this session user.\n        \"\"\"\n        # Subscribe to discover topic for user under this session\n        self.session.event_hub.subscribe(\n            \"topic=ftrack.action.discover and source.user.username={}\".format(\n                self.session.api_user\n            ),\n            self._discover,\n            priority=self.priority\n        )\n\n        launch_subscription = (\n            \"topic=ftrack.action.launch\"\n            \" and data.actionIdentifier={}\"\n            \" and source.user.username={}\"\n        ).format(self.launch_identifier, self.session.api_user)\n        self.session.event_hub.subscribe(\n            launch_subscription,\n            self._launch\n        )\n\n    def _discover(\n        self, event: ftrack_api.event.base.Event\n    ) -&gt; Optional[Dict[str, Any]]:\n        entities = self._translate_event(event)\n        if not entities:\n            return\n\n        accepts = self.discover(self.session, entities, event)\n        if not accepts:\n            return\n\n        self.log.debug(\"Discovering action with selection: {0}\".format(\n            event[\"data\"].get(\"selection\", [])\n        ))\n\n        return {\n            \"items\": [{\n                \"label\": self.label,\n                \"variant\": self.variant,\n                \"description\": self.description,\n                \"actionIdentifier\": self.discover_identifier,\n                \"icon\": self.icon,\n            }]\n        }\n\n    def _launch(\n        self, event: ftrack_api.event.base.Event\n    ) -&gt; Optional[Dict[str, Any]]:\n        event_identifier = event[\"data\"][\"actionIdentifier\"]\n        # Check if identifier is same\n        # - show message that acion may not be triggered on this machine\n        if event_identifier != self.full_launch_identifier:\n            return {\n                \"success\": False,\n                \"message\": (\n                    \"There are running more AYON processes\"\n                    \" where this action could be launched.\"\n                )\n            }\n        return super()._launch(event)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_action_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_action_handler.LocalAction.full_launch_identifier","title":"<code>full_launch_identifier</code>  <code>property</code>","text":"<p>Catch all topics with same identifier.</p>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_action_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_action_handler.LocalAction.launch_identifier","title":"<code>launch_identifier</code>  <code>property</code>","text":"<p>Catch all topics with same identifier.</p>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_action_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_action_handler.LocalAction.register","title":"<code>register()</code>","text":"<p>Register to ftrack topics to discover and launch action.</p> <p>Filter events to this session user.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>def register(self):\n    \"\"\"Register to ftrack topics to discover and launch action.\n\n    Filter events to this session user.\n    \"\"\"\n    # Subscribe to discover topic for user under this session\n    self.session.event_hub.subscribe(\n        \"topic=ftrack.action.discover and source.user.username={}\".format(\n            self.session.api_user\n        ),\n        self._discover,\n        priority=self.priority\n    )\n\n    launch_subscription = (\n        \"topic=ftrack.action.launch\"\n        \" and data.actionIdentifier={}\"\n        \" and source.user.username={}\"\n    ).format(self.launch_identifier, self.session.api_user)\n    self.session.event_hub.subscribe(\n        launch_subscription,\n        self._launch\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_action_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_action_handler.ServerAction","title":"<code>ServerAction</code>","text":"<p>               Bases: <code>BaseAction</code></p> <p>Action class meant to be used on event server.</p> <p>Unlike the <code>BaseAction</code> roles are not checked on register but on discover. For the same reason register is modified to not filter topics by username.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_action_handler.py</code> <pre><code>class ServerAction(BaseAction):\n    \"\"\"Action class meant to be used on event server.\n\n    Unlike the `BaseAction` roles are not checked on register but on discover.\n    For the same reason register is modified to not filter topics by username.\n    \"\"\"\n    __ignore_handler_class: bool = True\n\n    settings_frack_subkey: str = \"service_event_handlers\"\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_base_handler.html","title":"ftrack_base_handler","text":""},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_base_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_base_handler.BaseHandler","title":"<code>BaseHandler</code>","text":"<p>Base class for handling ftrack events.</p> <p>Attributes:</p> Name Type Description <code>enabled</code> <code>bool</code> <p>Is handler enabled.</p> <code>priority</code> <code>int</code> <p>Priority of handler processing. The lower value is the earlier is handler processed.</p> <code>handler_type</code> <code>str</code> <p>Has only debugging purposes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Connected ftrack session.</p> required Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>class BaseHandler(metaclass=ABCMeta):\n    \"\"\"Base class for handling ftrack events.\n\n    Attributes:\n        enabled (bool): Is handler enabled.\n        priority (int): Priority of handler processing. The lower value is the\n            earlier is handler processed.\n        handler_type (str): Has only debugging purposes.\n\n    Args:\n        session (ftrack_api.Session): Connected ftrack session.\n\n    \"\"\"\n    _log: Optional[logging.Logger] = None\n    _process_id: Optional[str] = None\n    # Default priority is 100\n    enabled: bool = True\n    priority: int = 100\n    handler_type: str = \"Base\"\n    _handler_label: Optional[str] = None\n    # Mark base classes to be ignored for discovery\n    __ignore_handler_class: bool = True\n\n    def __init__(self, session):\n        if not isinstance(session, ftrack_api.session.Session):\n            raise TypeError(\n                \"Expected 'ftrack_api.Session' object got '{}'\".format(\n                    str(type(session))))\n\n        self._session = session\n\n        self.register = self.register_wrapper(self.register)\n\n    @classmethod\n    def ignore_handler_class(cls) -&gt; bool:\n        \"\"\"Check if handler class should be ignored.\n\n        Do not touch implementation of this method, set\n            '__ignore_handler_class' to 'True' if you want to ignore class.\n\n        \"\"\"\n        cls_name = cls.__name__\n        if not cls_name.startswith(\"_\"):\n            cls_name = f\"_{cls_name}\"\n        return getattr(cls, f\"{cls_name}__ignore_handler_class\", False)\n\n    @staticmethod\n    def join_filter_values(values: Iterable[str]) -&gt; str:\n        return \",\".join({'\"{}\"'.format(value) for value in values})\n\n    @classmethod\n    def join_query_keys(cls, keys: Iterable[str]) -&gt; str:\n        return cls.join_filter_values(keys)\n\n    @property\n    def log(self) -&gt; logging.Logger:\n        \"\"\"Quick access to logger.\n\n        Returns:\n            logging.Logger: Logger that can be used for logging of handler.\n\n        \"\"\"\n        if self._log is None:\n            # TODO better logging mechanism\n            self._log = logging.getLogger(self.__class__.__name__)\n            self._log.setLevel(logging.DEBUG)\n        return self._log\n\n    @property\n    def handler_label(self) -&gt; str:\n        if self._handler_label is None:\n            self._handler_label = self.__class__.__name__\n        return self._handler_label\n\n    @property\n    def session(self) -&gt; ftrack_api.Session:\n        \"\"\"Fast access to session.\n\n        Returns:\n            session (ftrack_api.Session): Session which is source of events.\n\n        \"\"\"\n        return self._session\n\n    def reset_session(self):\n        \"\"\"Reset session cache.\"\"\"\n        self.session.reset()\n\n    @staticmethod\n    def process_identifier() -&gt; str:\n        \"\"\"Helper property to have unified access to process id.\n\n        Todos:\n            Use some global approach rather then implementation on\n                'BaseEntity'.\n\n        \"\"\"\n        if not BaseHandler._process_id:\n            BaseHandler._process_id = str(uuid.uuid4())\n        return BaseHandler._process_id\n\n    @abstractmethod\n    def register(self):\n        \"\"\"Subscribe to event topics.\"\"\"\n        pass\n\n    def cleanup(self):\n        \"\"\"Cleanup handler.\n\n        This method should end threads, timers, close connections, etc.\n        \"\"\"\n        pass\n\n    def register_wrapper(self, func):\n        @functools.wraps(func)\n        def wrapper_register(*args, **kwargs):\n            if not self.enabled:\n                return\n\n            try:\n                start_time = time.perf_counter()\n                func(*args, **kwargs)\n                end_time = time.perf_counter()\n                run_time = end_time - start_time\n                self.log.info((\n                    \"{} \\\"{}\\\" - Registered successfully ({:.4f}sec)\"\n                ).format(self.handler_type, self.handler_label, run_time))\n\n            except NotImplementedError:\n                self.log.error((\n                    \"{} \\\"{}\\\" - Register method is not implemented\"\n                ).format(self.handler_type, self.handler_label))\n\n            except Exception as exc:\n                self.log.error(\"{} \\\"{}\\\" - Registration failed ({})\".format(\n                    self.handler_type, self.handler_label, str(exc)\n                ))\n        return wrapper_register\n\n    def _get_entities(self, event, session=None, ignore=None):\n        entities = []\n        selection = event[\"data\"].get(\"selection\")\n        if not selection:\n            return entities\n\n        if ignore is None:\n            ignore = set()\n        elif isinstance(ignore, str):\n            ignore = {ignore}\n\n        filtered_selection = []\n        for entity in selection:\n            if entity[\"entityType\"] not in ignore:\n                filtered_selection.append(entity)\n\n        if not filtered_selection:\n            return entities\n\n        if session is None:\n            session = self.session\n            session._local_cache.clear()\n\n        for entity in filtered_selection:\n            entities.append(session.get(\n                self._get_entity_type(entity, session),\n                entity.get(\"entityId\")\n            ))\n\n        return entities\n\n    def _get_entity_type(self, entity, session=None):\n        \"\"\"Translate entity type so it can be used with API.\n\n        Todos:\n            Use object id rather.\n\n        \"\"\"\n        # Get entity type and make sure it is lower cased. Most places except\n        # the component tab in the Sidebar will use lower case notation.\n        entity_type = entity.get(\"entityType\").replace(\"_\", \"\").lower()\n\n        if session is None:\n            session = self.session\n\n        for schema in session.schemas:\n            alias_for = schema.get(\"alias_for\")\n\n            if (\n                alias_for\n                and isinstance(alias_for, str)\n                and alias_for.lower() == entity_type\n            ):\n                return schema[\"id\"]\n\n        for schema in self.session.schemas:\n            if schema[\"id\"].lower() == entity_type:\n                return schema[\"id\"]\n\n        raise ValueError(\n            \"Unable to translate entity type: {0}.\".format(entity_type)\n        )\n\n    def show_message(\n        self,\n        event: ftrack_api.event.base.Event,\n        message: str,\n        success: Optional[bool] = False,\n    ):\n        \"\"\"Shows message to user who triggered event.\n\n        Args:\n            event (ftrack_api.event.base.Event): Event used for source\n                of user id.\n            message (str): Message that will be shown to user.\n            success (bool): Define type (color) of message. False -&gt; red color.\n\n        \"\"\"\n        if not isinstance(success, bool):\n            success = False\n\n        try:\n            message = str(message)\n        except Exception:\n            return\n\n        user_id = event[\"source\"][\"user\"][\"id\"]\n        target = (\n            \"applicationId=ftrack.client.web and user.id=\\\"{}\\\"\"\n        ).format(user_id)\n        self.session.event_hub.publish(\n            ftrack_api.event.base.Event(\n                topic=\"ftrack.action.trigger-user-interface\",\n                data={\n                    \"type\": \"message\",\n                    \"success\": success,\n                    \"message\": message\n                },\n                target=target\n            ),\n            on_error=\"ignore\"\n        )\n\n    def show_interface(\n        self,\n        items: List[Dict[str, Any]],\n        title: Optional[str] = \"\",\n        user_id: Optional[str] = None,\n        user: Optional[Any] = None,\n        event: Optional[ftrack_api.event.base.Event] = None,\n        username: Optional[str] = None,\n        submit_btn_label: Optional[str] = None,\n    ):\n        \"\"\"Shows ftrack widgets interface to user.\n\n        Interface is shown to a user. To identify user one of arguments must be\n        passed: 'user_id', 'user', 'event', 'username'.\n\n        Args:\n            items (List[Dict[str, Any]]) Interface items (their structure is\n                defined by ftrack documentation).\n            title (str): Title of shown widget.\n            user_id (str): User id.\n            user (Any): Object of ftrack user (queried using ftrack api\n                session).\n            event (ftrack_api.Event): Event which can be used as source for\n                user id.\n            username (str): Username of user to get it's id. This is slowest\n                way how user id is received.\n            submit_btn_label (str): Label of submit button in ftrack widget.\n\n        \"\"\"\n        if user_id:\n            pass\n\n        elif user:\n            user_id = user[\"id\"]\n\n        elif username:\n            user = self.session.query(\n                \"User where username is \\\"{}\\\"\".format(username)\n            ).first()\n            if not user:\n                raise ValueError((\n                    \"ftrack user with username \\\"{}\\\" was not found!\"\n                ).format(username))\n\n            user_id = user[\"id\"]\n\n        elif event:\n            user_id = event[\"source\"][\"user\"][\"id\"]\n\n        if not user_id:\n            return\n\n        target = (\n            \"applicationId=ftrack.client.web and user.id=\\\"{}\\\"\"\n        ).format(user_id)\n\n        event_data = {\n            \"type\": \"widget\",\n            \"items\": items,\n            \"title\": title\n        }\n        if submit_btn_label:\n            event_data[\"submit_button_label\"] = submit_btn_label\n\n        self.session.event_hub.publish(\n            ftrack_api.event.base.Event(\n                topic=\"ftrack.action.trigger-user-interface\",\n                data=event_data,\n                target=target\n            ),\n            on_error=\"ignore\"\n        )\n\n    def show_interface_from_dict(\n        self,\n        messages: Dict[str, Union[str, List[str]]],\n        title: Optional[str] = \"\",\n        user_id: Optional[str] = None,\n        user: Optional[Any] = None,\n        event: Optional[ftrack_api.event.base.Event] = None,\n        username: Optional[str] = None,\n        submit_btn_label: Optional[str] = None,\n    ):\n        # TODO Find out how and where is this used\n        if not messages:\n            self.log.debug(\"No messages to show! (messages dict is empty)\")\n            return\n        items = []\n        splitter = {\"type\": \"label\", \"value\": \"---\"}\n        first = True\n        for key, value in messages.items():\n            if not first:\n                items.append(splitter)\n            first = False\n\n            items.append({\"type\": \"label\", \"value\": \"&lt;h3&gt;{}&lt;/h3&gt;\".format(key)})\n            if isinstance(value, str):\n                value = [value]\n\n            for item in value:\n                items.append({\"type\": \"label\", \"value\": f\"&lt;p&gt;{item}&lt;/p&gt;\"})\n\n        self.show_interface(\n            items,\n            title=title,\n            user_id=user_id,\n            user=user,\n            event=event,\n            username=username,\n            submit_btn_label=submit_btn_label\n        )\n\n    def trigger_action(\n        self,\n        action_identifier: str,\n        event: Optional[ftrack_api.event.base.Event] = None,\n        session: Optional[ftrack_api.Session] = None,\n        selection: Optional[List[Dict[str, str]]] = None,\n        user_data: Optional[Dict[str, Any]] = None,\n        topic: Optional[str] = \"ftrack.action.launch\",\n        additional_event_data: Optional[Dict[str, Any]] = None,\n        on_error: Optional[str] = \"ignore\"\n    ):\n        self.log.debug(\n            \"Triggering action \\\"{}\\\" Begins\".format(action_identifier))\n\n        if not session:\n            session = self.session\n\n        # Getting selection and user data\n        if event:\n            if selection is None:\n                selection = event.get(\"data\", {}).get(\"selection\")\n            if user_data is None:\n                user_data = event.get(\"source\", {}).get(\"user\")\n\n        # Without selection and user data skip triggering\n        msg = \"Can't trigger \\\"{}\\\" action without {}.\"\n        if selection is None:\n            self.log.error(msg.format(action_identifier, \"selection\"))\n            return\n\n        if user_data is None:\n            self.log.error(msg.format(action_identifier, \"user data\"))\n            return\n\n        event_data = {\n            \"actionIdentifier\": action_identifier,\n            \"selection\": selection\n        }\n\n        # Add additional data\n        if additional_event_data:\n            event_data.update(additional_event_data)\n\n        # Create and trigger event\n        session.event_hub.publish(\n            ftrack_api.event.base.Event(\n                topic=topic,\n                data=event_data,\n                source={\"user\": user_data}\n            ),\n            on_error=on_error\n        )\n        self.log.debug(\n            \"Action \\\"{}\\\" triggered\".format(action_identifier))\n\n    def trigger_event(\n        self,\n        topic: str,\n        event_data: Optional[Dict[str, Any]] = None,\n        session: Optional[ftrack_api.Session] = None,\n        source: Optional[Dict[str, Any]] = None,\n        event: Optional[ftrack_api.event.base.Event] = None,\n        on_error: Optional[str] = \"ignore\"\n    ):\n        if session is None:\n            session = self.session\n\n        if not source and event:\n            source = event.get(\"source\")\n\n        if event_data is None:\n            event_data = {}\n        # Create and trigger event\n        event = ftrack_api.event.base.Event(\n            topic=topic,\n            data=event_data,\n            source=source\n        )\n        session.event_hub.publish(event, on_error=on_error)\n\n        self.log.debug((\n            \"Publishing event: {}\"\n        ).format(str(event.__dict__)))\n\n    def get_project_from_entity(\n        self,\n        entity: ftrack_api.entity.base.Entity,\n        session: Optional[ftrack_api.Session] = None\n    ):\n        low_entity_type = entity.entity_type.lower()\n        if low_entity_type == \"project\":\n            return entity\n\n        if \"project\" in entity:\n            # reviewsession, task(Task, Shot, Sequence,...)\n            return entity[\"project\"]\n\n        if low_entity_type == \"filecomponent\":\n            entity = entity[\"version\"]\n            low_entity_type = entity.entity_type.lower()\n\n        if low_entity_type == \"assetversion\":\n            asset = entity[\"asset\"]\n            parent = None\n            if asset:\n                parent = asset[\"parent\"]\n\n            if parent:\n                if parent.entity_type.lower() == \"project\":\n                    return parent\n\n                if \"project\" in parent:\n                    return parent[\"project\"]\n\n        project_data = entity[\"link\"][0]\n\n        if session is None:\n            session = self.session\n        return session.query(\n            \"Project where id is {}\".format(project_data[\"id\"])\n        ).one()\n\n    def get_project_entity_from_event(\n        self,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event,\n        project_id: str,\n    ):\n        \"\"\"Load or query and fill project entity from/to event data.\n\n        Project data are stored by ftrack id because in most cases it is\n        easier to access project id than project name.\n\n        Args:\n            session (ftrack_api.Session): Current session.\n            event (ftrack_api.Event): Processed event by session.\n            project_id (str): ftrack project id.\n\n        Returns:\n            Union[str, None]: Project name based on entities or None if project\n                cannot be defined.\n\n        \"\"\"\n        if not project_id:\n            raise ValueError(\n                \"Entered `project_id` is not valid. {} ({})\".format(\n                    str(project_id), str(type(project_id))\n                )\n            )\n\n        project_id_mapping = event[\"data\"].setdefault(\n            \"project_entity_by_id\", {}\n        )\n        if project_id in project_id_mapping:\n            return project_id_mapping[project_id]\n\n        # Get project entity from task and store to event\n        project_entity = session.query((\n            \"select full_name from Project where id is \\\"{}\\\"\"\n        ).format(project_id)).first()\n        project_id_mapping[project_id] = project_entity\n\n        return project_entity\n\n    def get_project_name_from_event(\n        self,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event,\n        project_id: str,\n    ):\n        \"\"\"Load or query and fill project entity from/to event data.\n\n        Project data are stored by ftrack id because in most cases it is\n        easier to access project id than project name.\n\n        Args:\n            session (ftrack_api.Session): Current session.\n            event (ftrack_api.Event): Processed event by session.\n            project_id (str): ftrack project id.\n\n        Returns:\n            Union[str, None]: Project name based on entities or None if project\n                cannot be defined.\n\n        \"\"\"\n        if not project_id:\n            raise ValueError(\n                \"Entered `project_id` is not valid. {} ({})\".format(\n                    str(project_id), str(type(project_id))\n                )\n            )\n\n        project_id_mapping = event[\"data\"].setdefault(\"project_id_name\", {})\n        if project_id in project_id_mapping:\n            return project_id_mapping[project_id]\n\n        # Get project entity from task and store to event\n        project_entity = self.get_project_entity_from_event(\n            session, event, project_id\n        )\n        if project_entity:\n            project_name = project_entity[\"full_name\"]\n        project_id_mapping[project_id] = project_name\n        return project_name\n\n    def get_ayon_project_from_event(\n        self,\n        event: ftrack_api.event.base.Event,\n        project_name: str\n    ):\n        \"\"\"Get AYON project from event.\n\n        Args:\n            event (ftrack_api.Event): Event which is source of project id.\n            project_name (Union[str, None]): Project name.\n\n        Returns:\n            Union[dict[str, Any], None]: AYON project.\n\n        \"\"\"\n        ayon_projects = event[\"data\"].setdefault(\"ayon_projects\", {})\n        if project_name in ayon_projects:\n            return ayon_projects[project_name]\n\n        project = None\n        if project_name:\n            project = get_project(project_name)\n        ayon_projects[project_name] = project\n        return project\n\n    def get_project_settings_from_event(\n        self,\n        event: ftrack_api.event.base.Event,\n        project_name: str\n    ):\n        \"\"\"Load or fill AYON's project settings from event data.\n\n        Project data are stored by ftrack id because in most cases it is\n        easier to access project id than project name.\n\n        Args:\n            event (ftrack_api.Event): Processed event by session.\n            project_name (str): Project name.\n\n        \"\"\"\n        project_settings_by_name = event[\"data\"].setdefault(\n            \"project_settings\", {}\n        )\n        if project_name in project_settings_by_name:\n            return copy.deepcopy(project_settings_by_name[project_name])\n\n        # NOTE there is no safe way how to get project settings if project\n        #   does not exist on AYON server.\n        # TODO Should we somehow find out if ftrack is enabled for the\n        #   project?\n        # TODO how to find out which bundle should be used?\n        project = self.get_ayon_project_from_event(event, project_name)\n        if not project:\n            project_name = None\n        project_settings = get_addons_settings(project_name=project_name)\n        project_settings_by_name[project_name] = project_settings\n        return copy.deepcopy(project_settings)\n\n    @staticmethod\n    def get_entity_path(entity: ftrack_api.entity.base.Entity) -&gt; str:\n        \"\"\"Return full hierarchical path to entity.\"\"\"\n        return \"/\".join(\n            [ent[\"name\"] for ent in entity[\"link\"]]\n        )\n\n    @classmethod\n    def add_traceback_to_job(\n        cls,\n        job: ftrack_api.entity.job.Job,\n        session: ftrack_api.Session,\n        exc_info: Tuple,\n        description: Optional[str] = None,\n        component_name: Optional[str] = None,\n        job_status: Optional[str] = None\n    ):\n        \"\"\"Add traceback file to a job.\n\n        Args:\n            job (JobEntity): Entity of job where file should be able to\n                download (Created or queried with passed session).\n            session (Session): ftrack session which was used to query/create\n                entered job.\n            exc_info (tuple): Exception info (e.g. from `sys.exc_info()`).\n            description (str): Change job description to describe what\n                happened. Job description won't change if not passed.\n            component_name (str): Name of component and default name of\n                downloaded file. Class name and current date time are used if\n                not specified.\n            job_status (str): Status of job which will be set. By default is\n                set to 'failed'.\n\n        \"\"\"\n        if description:\n            job_data = {\n                \"description\": description\n            }\n            job[\"data\"] = json.dumps(job_data)\n\n        if not job_status:\n            job_status = \"failed\"\n\n        job[\"status\"] = job_status\n\n        # Create temp file where traceback will be stored\n        with tempfile.NamedTemporaryFile(\n            mode=\"w\", prefix=\"ayon_ftrack_\", suffix=\".txt\", delete=False\n        ) as temp_obj:\n            temp_filepath = temp_obj.name\n\n        # Store traceback to file\n        result = traceback.format_exception(*exc_info)\n        with open(temp_filepath, \"w\") as temp_file:\n            temp_file.write(\"\".join(result))\n\n        # Upload file with traceback to ftrack server and add it to job\n        if not component_name:\n            component_name = \"{}_{}\".format(\n                cls.__name__,\n                datetime.datetime.now().strftime(\"%y-%m-%d-%H%M\")\n            )\n        cls.add_file_component_to_job(\n            job, session, temp_filepath, component_name\n        )\n        # Delete temp file\n        os.remove(temp_filepath)\n\n    @staticmethod\n    def add_file_component_to_job(\n        job: ftrack_api.entity.job.Job,\n        session: ftrack_api.Session,\n        filepath: str,\n        basename: Optional[str] = None\n    ):\n        \"\"\"Add filepath as downloadable component to job.\n\n        Args:\n            job (JobEntity): Entity of job where file should be able to\n                download (Created or queried with passed session).\n            session (Session): ftrack session which was used to query/create\n                entered job.\n            filepath (str): Path to file which should be added to job.\n            basename (str): Defines name of file which will be downloaded on\n                user's side. Must be without extension otherwise extension will\n                be duplicated in downloaded name. Basename from entered path\n                used when not entered.\n\n        \"\"\"\n        # Make sure session's locations are configured\n        # - they can be deconfigured e.g. using `rollback` method\n        session._configure_locations()\n\n        # Query `ftrack.server` location where component will be stored\n        location = session.query(\n            \"Location where name is \\\"ftrack.server\\\"\"\n        ).one()\n\n        # Use filename as basename if not entered (must be without extension)\n        if basename is None:\n            basename = os.path.splitext(\n                os.path.basename(filepath)\n            )[0]\n\n        component = session.create_component(\n            filepath,\n            data={\"name\": basename},\n            location=location\n        )\n        session.create(\n            \"JobComponent\",\n            {\n                \"component_id\": component[\"id\"],\n                \"job_id\": job[\"id\"]\n            }\n        )\n        session.commit()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_base_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_base_handler.BaseHandler.log","title":"<code>log</code>  <code>property</code>","text":"<p>Quick access to logger.</p> <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: Logger that can be used for logging of handler.</p>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_base_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_base_handler.BaseHandler.session","title":"<code>session</code>  <code>property</code>","text":"<p>Fast access to session.</p> <p>Returns:</p> Name Type Description <code>session</code> <code>Session</code> <p>Session which is source of events.</p>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_base_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_base_handler.BaseHandler.add_file_component_to_job","title":"<code>add_file_component_to_job(job, session, filepath, basename=None)</code>  <code>staticmethod</code>","text":"<p>Add filepath as downloadable component to job.</p> <p>Parameters:</p> Name Type Description Default <code>job</code> <code>JobEntity</code> <p>Entity of job where file should be able to download (Created or queried with passed session).</p> required <code>session</code> <code>Session</code> <p>ftrack session which was used to query/create entered job.</p> required <code>filepath</code> <code>str</code> <p>Path to file which should be added to job.</p> required <code>basename</code> <code>str</code> <p>Defines name of file which will be downloaded on user's side. Must be without extension otherwise extension will be duplicated in downloaded name. Basename from entered path used when not entered.</p> <code>None</code> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>@staticmethod\ndef add_file_component_to_job(\n    job: ftrack_api.entity.job.Job,\n    session: ftrack_api.Session,\n    filepath: str,\n    basename: Optional[str] = None\n):\n    \"\"\"Add filepath as downloadable component to job.\n\n    Args:\n        job (JobEntity): Entity of job where file should be able to\n            download (Created or queried with passed session).\n        session (Session): ftrack session which was used to query/create\n            entered job.\n        filepath (str): Path to file which should be added to job.\n        basename (str): Defines name of file which will be downloaded on\n            user's side. Must be without extension otherwise extension will\n            be duplicated in downloaded name. Basename from entered path\n            used when not entered.\n\n    \"\"\"\n    # Make sure session's locations are configured\n    # - they can be deconfigured e.g. using `rollback` method\n    session._configure_locations()\n\n    # Query `ftrack.server` location where component will be stored\n    location = session.query(\n        \"Location where name is \\\"ftrack.server\\\"\"\n    ).one()\n\n    # Use filename as basename if not entered (must be without extension)\n    if basename is None:\n        basename = os.path.splitext(\n            os.path.basename(filepath)\n        )[0]\n\n    component = session.create_component(\n        filepath,\n        data={\"name\": basename},\n        location=location\n    )\n    session.create(\n        \"JobComponent\",\n        {\n            \"component_id\": component[\"id\"],\n            \"job_id\": job[\"id\"]\n        }\n    )\n    session.commit()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_base_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_base_handler.BaseHandler.add_traceback_to_job","title":"<code>add_traceback_to_job(job, session, exc_info, description=None, component_name=None, job_status=None)</code>  <code>classmethod</code>","text":"<p>Add traceback file to a job.</p> <p>Parameters:</p> Name Type Description Default <code>job</code> <code>JobEntity</code> <p>Entity of job where file should be able to download (Created or queried with passed session).</p> required <code>session</code> <code>Session</code> <p>ftrack session which was used to query/create entered job.</p> required <code>exc_info</code> <code>tuple</code> <p>Exception info (e.g. from <code>sys.exc_info()</code>).</p> required <code>description</code> <code>str</code> <p>Change job description to describe what happened. Job description won't change if not passed.</p> <code>None</code> <code>component_name</code> <code>str</code> <p>Name of component and default name of downloaded file. Class name and current date time are used if not specified.</p> <code>None</code> <code>job_status</code> <code>str</code> <p>Status of job which will be set. By default is set to 'failed'.</p> <code>None</code> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>@classmethod\ndef add_traceback_to_job(\n    cls,\n    job: ftrack_api.entity.job.Job,\n    session: ftrack_api.Session,\n    exc_info: Tuple,\n    description: Optional[str] = None,\n    component_name: Optional[str] = None,\n    job_status: Optional[str] = None\n):\n    \"\"\"Add traceback file to a job.\n\n    Args:\n        job (JobEntity): Entity of job where file should be able to\n            download (Created or queried with passed session).\n        session (Session): ftrack session which was used to query/create\n            entered job.\n        exc_info (tuple): Exception info (e.g. from `sys.exc_info()`).\n        description (str): Change job description to describe what\n            happened. Job description won't change if not passed.\n        component_name (str): Name of component and default name of\n            downloaded file. Class name and current date time are used if\n            not specified.\n        job_status (str): Status of job which will be set. By default is\n            set to 'failed'.\n\n    \"\"\"\n    if description:\n        job_data = {\n            \"description\": description\n        }\n        job[\"data\"] = json.dumps(job_data)\n\n    if not job_status:\n        job_status = \"failed\"\n\n    job[\"status\"] = job_status\n\n    # Create temp file where traceback will be stored\n    with tempfile.NamedTemporaryFile(\n        mode=\"w\", prefix=\"ayon_ftrack_\", suffix=\".txt\", delete=False\n    ) as temp_obj:\n        temp_filepath = temp_obj.name\n\n    # Store traceback to file\n    result = traceback.format_exception(*exc_info)\n    with open(temp_filepath, \"w\") as temp_file:\n        temp_file.write(\"\".join(result))\n\n    # Upload file with traceback to ftrack server and add it to job\n    if not component_name:\n        component_name = \"{}_{}\".format(\n            cls.__name__,\n            datetime.datetime.now().strftime(\"%y-%m-%d-%H%M\")\n        )\n    cls.add_file_component_to_job(\n        job, session, temp_filepath, component_name\n    )\n    # Delete temp file\n    os.remove(temp_filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_base_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_base_handler.BaseHandler.cleanup","title":"<code>cleanup()</code>","text":"<p>Cleanup handler.</p> <p>This method should end threads, timers, close connections, etc.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def cleanup(self):\n    \"\"\"Cleanup handler.\n\n    This method should end threads, timers, close connections, etc.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_base_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_base_handler.BaseHandler.get_ayon_project_from_event","title":"<code>get_ayon_project_from_event(event, project_name)</code>","text":"<p>Get AYON project from event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>Event which is source of project id.</p> required <code>project_name</code> <code>Union[str, None]</code> <p>Project name.</p> required <p>Returns:</p> Type Description <p>Union[dict[str, Any], None]: AYON project.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def get_ayon_project_from_event(\n    self,\n    event: ftrack_api.event.base.Event,\n    project_name: str\n):\n    \"\"\"Get AYON project from event.\n\n    Args:\n        event (ftrack_api.Event): Event which is source of project id.\n        project_name (Union[str, None]): Project name.\n\n    Returns:\n        Union[dict[str, Any], None]: AYON project.\n\n    \"\"\"\n    ayon_projects = event[\"data\"].setdefault(\"ayon_projects\", {})\n    if project_name in ayon_projects:\n        return ayon_projects[project_name]\n\n    project = None\n    if project_name:\n        project = get_project(project_name)\n    ayon_projects[project_name] = project\n    return project\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_base_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_base_handler.BaseHandler.get_entity_path","title":"<code>get_entity_path(entity)</code>  <code>staticmethod</code>","text":"<p>Return full hierarchical path to entity.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>@staticmethod\ndef get_entity_path(entity: ftrack_api.entity.base.Entity) -&gt; str:\n    \"\"\"Return full hierarchical path to entity.\"\"\"\n    return \"/\".join(\n        [ent[\"name\"] for ent in entity[\"link\"]]\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_base_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_base_handler.BaseHandler.get_project_entity_from_event","title":"<code>get_project_entity_from_event(session, event, project_id)</code>","text":"<p>Load or query and fill project entity from/to event data.</p> <p>Project data are stored by ftrack id because in most cases it is easier to access project id than project name.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Current session.</p> required <code>event</code> <code>Event</code> <p>Processed event by session.</p> required <code>project_id</code> <code>str</code> <p>ftrack project id.</p> required <p>Returns:</p> Type Description <p>Union[str, None]: Project name based on entities or None if project cannot be defined.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def get_project_entity_from_event(\n    self,\n    session: ftrack_api.Session,\n    event: ftrack_api.event.base.Event,\n    project_id: str,\n):\n    \"\"\"Load or query and fill project entity from/to event data.\n\n    Project data are stored by ftrack id because in most cases it is\n    easier to access project id than project name.\n\n    Args:\n        session (ftrack_api.Session): Current session.\n        event (ftrack_api.Event): Processed event by session.\n        project_id (str): ftrack project id.\n\n    Returns:\n        Union[str, None]: Project name based on entities or None if project\n            cannot be defined.\n\n    \"\"\"\n    if not project_id:\n        raise ValueError(\n            \"Entered `project_id` is not valid. {} ({})\".format(\n                str(project_id), str(type(project_id))\n            )\n        )\n\n    project_id_mapping = event[\"data\"].setdefault(\n        \"project_entity_by_id\", {}\n    )\n    if project_id in project_id_mapping:\n        return project_id_mapping[project_id]\n\n    # Get project entity from task and store to event\n    project_entity = session.query((\n        \"select full_name from Project where id is \\\"{}\\\"\"\n    ).format(project_id)).first()\n    project_id_mapping[project_id] = project_entity\n\n    return project_entity\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_base_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_base_handler.BaseHandler.get_project_name_from_event","title":"<code>get_project_name_from_event(session, event, project_id)</code>","text":"<p>Load or query and fill project entity from/to event data.</p> <p>Project data are stored by ftrack id because in most cases it is easier to access project id than project name.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Current session.</p> required <code>event</code> <code>Event</code> <p>Processed event by session.</p> required <code>project_id</code> <code>str</code> <p>ftrack project id.</p> required <p>Returns:</p> Type Description <p>Union[str, None]: Project name based on entities or None if project cannot be defined.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def get_project_name_from_event(\n    self,\n    session: ftrack_api.Session,\n    event: ftrack_api.event.base.Event,\n    project_id: str,\n):\n    \"\"\"Load or query and fill project entity from/to event data.\n\n    Project data are stored by ftrack id because in most cases it is\n    easier to access project id than project name.\n\n    Args:\n        session (ftrack_api.Session): Current session.\n        event (ftrack_api.Event): Processed event by session.\n        project_id (str): ftrack project id.\n\n    Returns:\n        Union[str, None]: Project name based on entities or None if project\n            cannot be defined.\n\n    \"\"\"\n    if not project_id:\n        raise ValueError(\n            \"Entered `project_id` is not valid. {} ({})\".format(\n                str(project_id), str(type(project_id))\n            )\n        )\n\n    project_id_mapping = event[\"data\"].setdefault(\"project_id_name\", {})\n    if project_id in project_id_mapping:\n        return project_id_mapping[project_id]\n\n    # Get project entity from task and store to event\n    project_entity = self.get_project_entity_from_event(\n        session, event, project_id\n    )\n    if project_entity:\n        project_name = project_entity[\"full_name\"]\n    project_id_mapping[project_id] = project_name\n    return project_name\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_base_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_base_handler.BaseHandler.get_project_settings_from_event","title":"<code>get_project_settings_from_event(event, project_name)</code>","text":"<p>Load or fill AYON's project settings from event data.</p> <p>Project data are stored by ftrack id because in most cases it is easier to access project id than project name.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>Processed event by session.</p> required <code>project_name</code> <code>str</code> <p>Project name.</p> required Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def get_project_settings_from_event(\n    self,\n    event: ftrack_api.event.base.Event,\n    project_name: str\n):\n    \"\"\"Load or fill AYON's project settings from event data.\n\n    Project data are stored by ftrack id because in most cases it is\n    easier to access project id than project name.\n\n    Args:\n        event (ftrack_api.Event): Processed event by session.\n        project_name (str): Project name.\n\n    \"\"\"\n    project_settings_by_name = event[\"data\"].setdefault(\n        \"project_settings\", {}\n    )\n    if project_name in project_settings_by_name:\n        return copy.deepcopy(project_settings_by_name[project_name])\n\n    # NOTE there is no safe way how to get project settings if project\n    #   does not exist on AYON server.\n    # TODO Should we somehow find out if ftrack is enabled for the\n    #   project?\n    # TODO how to find out which bundle should be used?\n    project = self.get_ayon_project_from_event(event, project_name)\n    if not project:\n        project_name = None\n    project_settings = get_addons_settings(project_name=project_name)\n    project_settings_by_name[project_name] = project_settings\n    return copy.deepcopy(project_settings)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_base_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_base_handler.BaseHandler.ignore_handler_class","title":"<code>ignore_handler_class()</code>  <code>classmethod</code>","text":"<p>Check if handler class should be ignored.</p> <p>Do not touch implementation of this method, set     '__ignore_handler_class' to 'True' if you want to ignore class.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>@classmethod\ndef ignore_handler_class(cls) -&gt; bool:\n    \"\"\"Check if handler class should be ignored.\n\n    Do not touch implementation of this method, set\n        '__ignore_handler_class' to 'True' if you want to ignore class.\n\n    \"\"\"\n    cls_name = cls.__name__\n    if not cls_name.startswith(\"_\"):\n        cls_name = f\"_{cls_name}\"\n    return getattr(cls, f\"{cls_name}__ignore_handler_class\", False)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_base_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_base_handler.BaseHandler.process_identifier","title":"<code>process_identifier()</code>  <code>staticmethod</code>","text":"<p>Helper property to have unified access to process id.</p> Todos <p>Use some global approach rather then implementation on     'BaseEntity'.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>@staticmethod\ndef process_identifier() -&gt; str:\n    \"\"\"Helper property to have unified access to process id.\n\n    Todos:\n        Use some global approach rather then implementation on\n            'BaseEntity'.\n\n    \"\"\"\n    if not BaseHandler._process_id:\n        BaseHandler._process_id = str(uuid.uuid4())\n    return BaseHandler._process_id\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_base_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_base_handler.BaseHandler.register","title":"<code>register()</code>  <code>abstractmethod</code>","text":"<p>Subscribe to event topics.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>@abstractmethod\ndef register(self):\n    \"\"\"Subscribe to event topics.\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_base_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_base_handler.BaseHandler.reset_session","title":"<code>reset_session()</code>","text":"<p>Reset session cache.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def reset_session(self):\n    \"\"\"Reset session cache.\"\"\"\n    self.session.reset()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_base_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_base_handler.BaseHandler.show_interface","title":"<code>show_interface(items, title='', user_id=None, user=None, event=None, username=None, submit_btn_label=None)</code>","text":"<p>Shows ftrack widgets interface to user.</p> <p>Interface is shown to a user. To identify user one of arguments must be passed: 'user_id', 'user', 'event', 'username'.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of shown widget.</p> <code>''</code> <code>user_id</code> <code>str</code> <p>User id.</p> <code>None</code> <code>user</code> <code>Any</code> <p>Object of ftrack user (queried using ftrack api session).</p> <code>None</code> <code>event</code> <code>Event</code> <p>Event which can be used as source for user id.</p> <code>None</code> <code>username</code> <code>str</code> <p>Username of user to get it's id. This is slowest way how user id is received.</p> <code>None</code> <code>submit_btn_label</code> <code>str</code> <p>Label of submit button in ftrack widget.</p> <code>None</code> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def show_interface(\n    self,\n    items: List[Dict[str, Any]],\n    title: Optional[str] = \"\",\n    user_id: Optional[str] = None,\n    user: Optional[Any] = None,\n    event: Optional[ftrack_api.event.base.Event] = None,\n    username: Optional[str] = None,\n    submit_btn_label: Optional[str] = None,\n):\n    \"\"\"Shows ftrack widgets interface to user.\n\n    Interface is shown to a user. To identify user one of arguments must be\n    passed: 'user_id', 'user', 'event', 'username'.\n\n    Args:\n        items (List[Dict[str, Any]]) Interface items (their structure is\n            defined by ftrack documentation).\n        title (str): Title of shown widget.\n        user_id (str): User id.\n        user (Any): Object of ftrack user (queried using ftrack api\n            session).\n        event (ftrack_api.Event): Event which can be used as source for\n            user id.\n        username (str): Username of user to get it's id. This is slowest\n            way how user id is received.\n        submit_btn_label (str): Label of submit button in ftrack widget.\n\n    \"\"\"\n    if user_id:\n        pass\n\n    elif user:\n        user_id = user[\"id\"]\n\n    elif username:\n        user = self.session.query(\n            \"User where username is \\\"{}\\\"\".format(username)\n        ).first()\n        if not user:\n            raise ValueError((\n                \"ftrack user with username \\\"{}\\\" was not found!\"\n            ).format(username))\n\n        user_id = user[\"id\"]\n\n    elif event:\n        user_id = event[\"source\"][\"user\"][\"id\"]\n\n    if not user_id:\n        return\n\n    target = (\n        \"applicationId=ftrack.client.web and user.id=\\\"{}\\\"\"\n    ).format(user_id)\n\n    event_data = {\n        \"type\": \"widget\",\n        \"items\": items,\n        \"title\": title\n    }\n    if submit_btn_label:\n        event_data[\"submit_button_label\"] = submit_btn_label\n\n    self.session.event_hub.publish(\n        ftrack_api.event.base.Event(\n            topic=\"ftrack.action.trigger-user-interface\",\n            data=event_data,\n            target=target\n        ),\n        on_error=\"ignore\"\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_base_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_base_handler.BaseHandler.show_message","title":"<code>show_message(event, message, success=False)</code>","text":"<p>Shows message to user who triggered event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>Event used for source of user id.</p> required <code>message</code> <code>str</code> <p>Message that will be shown to user.</p> required <code>success</code> <code>bool</code> <p>Define type (color) of message. False -&gt; red color.</p> <code>False</code> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_base_handler.py</code> <pre><code>def show_message(\n    self,\n    event: ftrack_api.event.base.Event,\n    message: str,\n    success: Optional[bool] = False,\n):\n    \"\"\"Shows message to user who triggered event.\n\n    Args:\n        event (ftrack_api.event.base.Event): Event used for source\n            of user id.\n        message (str): Message that will be shown to user.\n        success (bool): Define type (color) of message. False -&gt; red color.\n\n    \"\"\"\n    if not isinstance(success, bool):\n        success = False\n\n    try:\n        message = str(message)\n    except Exception:\n        return\n\n    user_id = event[\"source\"][\"user\"][\"id\"]\n    target = (\n        \"applicationId=ftrack.client.web and user.id=\\\"{}\\\"\"\n    ).format(user_id)\n    self.session.event_hub.publish(\n        ftrack_api.event.base.Event(\n            topic=\"ftrack.action.trigger-user-interface\",\n            data={\n                \"type\": \"message\",\n                \"success\": success,\n                \"message\": message\n            },\n            target=target\n        ),\n        on_error=\"ignore\"\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_event_handler.html","title":"ftrack_event_handler","text":""},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_event_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_event_handler.BaseEventHandler","title":"<code>BaseEventHandler</code>","text":"<p>               Bases: <code>BaseHandler</code></p> <p>Event handler listening to topics.</p> <p>Output of callback is not handled and handler is not designed for actions.</p> <p>By default is listening to \"ftrack.update\". To change it override 'register' method of change 'subscription_topic' attribute.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_event_handler.py</code> <pre><code>class BaseEventHandler(BaseHandler):\n    \"\"\"Event handler listening to topics.\n\n    Output of callback is not handled and handler is not designed for actions.\n\n    By default is listening to \"ftrack.update\". To change it override\n    'register' method of change 'subscription_topic' attribute.\n    \"\"\"\n    __ignore_handler_class: bool = True\n\n    subscription_topic: str = \"ftrack.update\"\n    handler_type: str = \"Event\"\n\n    def register(self):\n        \"\"\"Register to subscription topic.\"\"\"\n        self.session.event_hub.subscribe(\n            \"topic={}\".format(self.subscription_topic),\n            self._process,\n            priority=self.priority\n        )\n\n    def process(self, event: ftrack_api.event.base.Event):\n        \"\"\"Callback triggered on event with matching topic.\n\n        Args:\n            event (ftrack_api.Event): ftrack event to process.\n\n        \"\"\"\n        return self.launch(self.session, event)\n\n    def launch(\n        self,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event\n    ):\n        \"\"\"Deprecated method used for backwards compatibility.\n\n        Override 'process' method rather then 'launch'. Method name 'launch'\n        is derived from action event handler which does not make sense in terms\n        of not action based processing.\n\n        Args:\n            session (ftrack_api.Session): ftrack session which triggered\n                the event.\n            event (ftrack_api.Event): ftrack event to process.\n\n        \"\"\"\n        raise NotImplementedError()\n\n    def _process(self, event: ftrack_api.event.base.Event):\n        return self._launch(event)\n\n    def _launch(self, event: ftrack_api.event.base.Event):\n        \"\"\"Callback kept for backwards compatibility.\n\n        Will be removed when default\n        \"\"\"\n        self.session.rollback()\n        self.session._local_cache.clear()\n\n        try:\n            self.process(event)\n\n        except Exception as exc:\n            self.log.error(\n                \"Event \\\"{}\\\" Failed: {}\".format(\n                    self.__class__.__name__, str(exc)\n                ),\n                exc_info=True\n            )\n            self.session.rollback()\n            self.session._configure_locations()\n\n    def _translate_event(\n        self,\n        event: ftrack_api.event.base.Event,\n        session: Optional[ftrack_api.Session] = None\n    ):\n        \"\"\"Receive entity objects based on event.\n\n        Args:\n            event (ftrack_api.Event): Event to process.\n            session (ftrack_api.Session): Connected ftrack session.\n\n        Returns:\n            List[ftrack_api.Entity]: Queried entities based on event data.\n\n        \"\"\"\n        return self._get_entities(\n            event,\n            session,\n            ignore={\"socialfeed\", \"socialnotification\", \"team\"}\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_event_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_event_handler.BaseEventHandler.launch","title":"<code>launch(session, event)</code>","text":"<p>Deprecated method used for backwards compatibility.</p> <p>Override 'process' method rather then 'launch'. Method name 'launch' is derived from action event handler which does not make sense in terms of not action based processing.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>ftrack session which triggered the event.</p> required <code>event</code> <code>Event</code> <p>ftrack event to process.</p> required Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_event_handler.py</code> <pre><code>def launch(\n    self,\n    session: ftrack_api.Session,\n    event: ftrack_api.event.base.Event\n):\n    \"\"\"Deprecated method used for backwards compatibility.\n\n    Override 'process' method rather then 'launch'. Method name 'launch'\n    is derived from action event handler which does not make sense in terms\n    of not action based processing.\n\n    Args:\n        session (ftrack_api.Session): ftrack session which triggered\n            the event.\n        event (ftrack_api.Event): ftrack event to process.\n\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_event_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_event_handler.BaseEventHandler.process","title":"<code>process(event)</code>","text":"<p>Callback triggered on event with matching topic.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>ftrack event to process.</p> required Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_event_handler.py</code> <pre><code>def process(self, event: ftrack_api.event.base.Event):\n    \"\"\"Callback triggered on event with matching topic.\n\n    Args:\n        event (ftrack_api.Event): ftrack event to process.\n\n    \"\"\"\n    return self.launch(self.session, event)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/common/event_handlers/ftrack_event_handler.html#client.ayon_ftrack.common.event_handlers.ftrack_event_handler.BaseEventHandler.register","title":"<code>register()</code>","text":"<p>Register to subscription topic.</p> Source code in <code>client/ayon_ftrack/common/event_handlers/ftrack_event_handler.py</code> <pre><code>def register(self):\n    \"\"\"Register to subscription topic.\"\"\"\n    self.session.event_hub.subscribe(\n        \"topic={}\".format(self.subscription_topic),\n        self._process,\n        priority=self.priority\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_to_convert/index.html","title":"event_handlers_to_convert","text":""},{"location":"autoapi/client/ayon_ftrack/event_handlers_to_convert/action_delete_old_versions.html","title":"action_delete_old_versions","text":""},{"location":"autoapi/client/ayon_ftrack/event_handlers_to_convert/action_delete_old_versions.html#client.ayon_ftrack.event_handlers_to_convert.action_delete_old_versions.DeleteOldVersions","title":"<code>DeleteOldVersions</code>","text":"<p>               Bases: <code>LocalAction</code></p> Source code in <code>client/ayon_ftrack/event_handlers_to_convert/action_delete_old_versions.py</code> <pre><code>class DeleteOldVersions(LocalAction):\n\n    identifier = \"delete.old.versions\"\n    label = \"AYON Admin\"\n    variant = \"- Delete old versions\"\n    description = (\n        \"Delete files from older publishes so project can be\"\n        \" archived with only lates versions.\"\n    )\n    icon = get_ftrack_icon_url(\"AYONAdmin.svg\")\n\n    settings_key = \"delete_old_versions\"\n\n    inteface_title = \"Choose your preferences\"\n    splitter_item = {\"type\": \"label\", \"value\": \"---\"}\n    sequence_splitter = \"__sequence_splitter__\"\n\n    def discover(self, session, entities, event):\n        \"\"\" Validation. \"\"\"\n        is_valid = False\n        for entity in entities:\n            if entity.entity_type.lower() == \"assetversion\":\n                is_valid = True\n                break\n\n        if is_valid:\n            is_valid = self.valid_roles(session, entities, event)\n        return is_valid\n\n    def interface(self, session, entities, event):\n        # TODO Add roots existence validation\n        items = []\n        values = event[\"data\"].get(\"values\")\n        if values:\n            versions_count = int(values[\"last_versions_count\"])\n            if versions_count &gt;= 1:\n                return\n            items.append({\n                \"type\": \"label\",\n                \"value\": (\n                    \"# You have to keep at least 1 version!\"\n                )\n            })\n\n        items.append({\n            \"type\": \"label\",\n            \"value\": (\n                \"&lt;i&gt;&lt;b&gt;WARNING:&lt;/b&gt; This will remove published files of older\"\n                \" versions from disk so we don't recommend use\"\n                \" this action on \\\"live\\\" project.&lt;/i&gt;\"\n            )\n        })\n\n        items.append(self.splitter_item)\n\n        # How many versions to keep\n        items.append({\n            \"type\": \"label\",\n            \"value\": \"## Choose how many versions you want to keep:\"\n        })\n        items.append({\n            \"type\": \"label\",\n            \"value\": (\n                \"&lt;i&gt;&lt;b&gt;NOTE:&lt;/b&gt; We do recommend to keep 2 versions.&lt;/i&gt;\"\n            )\n        })\n        items.append({\n            \"type\": \"number\",\n            \"name\": \"last_versions_count\",\n            \"label\": \"Versions\",\n            \"value\": 2\n        })\n\n        items.append(self.splitter_item)\n\n        items.append({\n            \"type\": \"label\",\n            \"value\": (\n                \"## Remove publish folder even if there\"\n                \" are other than published files:\"\n            )\n        })\n        items.append({\n            \"type\": \"label\",\n            \"value\": (\n                \"&lt;i&gt;&lt;b&gt;WARNING:&lt;/b&gt; This may remove more than you want.&lt;/i&gt;\"\n            )\n        })\n        items.append({\n            \"type\": \"boolean\",\n            \"name\": \"force_delete_publish_folder\",\n            \"label\": \"Are You sure?\",\n            \"value\": False\n        })\n\n        items.append(self.splitter_item)\n\n        items.append({\n            \"type\": \"label\",\n            \"value\": (\n                \"&lt;i&gt;This will &lt;b&gt;NOT&lt;/b&gt; delete any files and only return the \"\n                \"total size of the files.&lt;/i&gt;\"\n            )\n        })\n        items.append({\n            \"type\": \"boolean\",\n            \"name\": \"only_calculate\",\n            \"label\": \"Only calculate size of files.\",\n            \"value\": False\n        })\n\n        return {\n            \"items\": items,\n            \"title\": self.inteface_title\n        }\n\n    def launch(self, session, entities, event):\n        values = event[\"data\"].get(\"values\")\n        if not values:\n            return\n\n        versions_count = int(values[\"last_versions_count\"])\n        force_to_remove = values[\"force_delete_publish_folder\"]\n        only_calculate = values[\"only_calculate\"]\n\n        _val1 = \"OFF\"\n        if force_to_remove:\n            _val1 = \"ON\"\n\n        _val3 = \"s\"\n        if versions_count == 1:\n            _val3 = \"\"\n\n        self.log.debug((\n            \"Process started. Force to delete publish folder is set to [{0}]\"\n            \" and will keep {1} latest version{2}.\"\n        ).format(_val1, versions_count, _val3))\n\n        project = None\n        folder_paths = []\n        asset_versions_by_parent_id = collections.defaultdict(list)\n        product_names_by_folder_path = collections.defaultdict(list)\n\n        ftrack_assets_by_name = {}\n        for entity in entities:\n            ftrack_asset = entity[\"asset\"]\n\n            parent_ent = ftrack_asset[\"parent\"]\n            parent_ftrack_id = parent_ent[\"id\"]\n\n            path_items = [item[\"name\"] for item in entity[\"link\"]]\n            path_items[0] = \"\"\n            folder_path = \"/\".join(path_items)\n\n            if folder_path not in folder_paths:\n                folder_paths.append(folder_path)\n\n            # Group asset versions by parent entity\n            asset_versions_by_parent_id[parent_ftrack_id].append(entity)\n\n            # Get project\n            if project is None:\n                project = parent_ent[\"project\"]\n\n            # Collect product names per asset\n            product_name = ftrack_asset[\"name\"]\n            product_names_by_folder_path[folder_path].append(product_name)\n\n            if product_name not in ftrack_assets_by_name:\n                ftrack_assets_by_name[product_name] = ftrack_asset\n\n        # Set Mongo collection\n        project_name = project[\"full_name\"]\n        anatomy = Anatomy(project_name)\n        self.log.debug(\"Project is set to {}\".format(project_name))\n\n        # Fetch folders\n        folder_path_by_id = {\n            folder_entity[\"id\"]: folder_entity[\"path\"]\n            for folder_entity in get_folders(\n                project_name, folder_paths=folder_paths\n            )\n        }\n        folder_ids = set(folder_path_by_id.keys())\n\n        self.log.debug(\"Collected assets ({})\".format(len(folder_ids)))\n\n        # Get product entities\n        product_entities_by_id = {\n            product_entity[\"id\"]: product_entity\n            for product_entity in get_products(\n                project_name, folder_ids=folder_ids\n            )\n        }\n        # Filter products by available product names\n        for product_entity in product_entities_by_id.values():\n            folder_id = product_entity[\"folderId\"]\n            folder_path = folder_path_by_id[folder_id]\n\n            available_products = product_names_by_folder_path[folder_path]\n            if product_entity[\"name\"] not in available_products:\n                product_id = product_entity[\"id\"]\n                product_entities_by_id.pop(product_id)\n\n        product_ids = set(product_entities_by_id.keys())\n\n        self.log.debug(\"Collected products ({})\".format(len(product_ids)))\n\n        # Get Versions\n        version_entities_by_id = {\n            version_entity[\"id\"]: version_entity\n            for version_entity in get_versions(\n                project_name,\n                product_ids=product_ids,\n                hero=False,\n                active=None\n            )\n        }\n\n        # Store all versions by product id even inactive entities\n        versions_by_parent = collections.defaultdict(list)\n        for version_entity in version_entities_by_id.values():\n            product_id = version_entity[\"productId\"]\n            versions_by_parent[product_id].append(version_entity)\n\n        def sort_func(ent):\n            return ent[\"version\"]\n\n        # Filter latest versions\n        for parent_id, version_entities in versions_by_parent.items():\n            for idx, version_entity in enumerate(\n                sorted(version_entities, key=sort_func, reverse=True)\n            ):\n                if idx &gt;= versions_count:\n                    break\n                version_entities_by_id.pop(version_entity[\"id\"])\n\n        self.log.debug(\n            \"Collected versions ({})\".format(len(version_entities_by_id))\n        )\n\n        # Update versions_by_parent without filtered versions\n        versions_by_parent = collections.defaultdict(list)\n        for version_entity in version_entities_by_id.values():\n            # Filter already deactivated versions\n            if not version_entity[\"active\"]:\n                continue\n            product_id = version_entity[\"productId\"]\n            versions_by_parent[product_id].append(version_entity)\n\n        version_ids = set(version_entities_by_id.keys())\n\n        self.log.debug(\n            \"Filtered versions to delete ({})\".format(len(version_ids))\n        )\n\n        if not version_ids:\n            msg = \"Skipping processing. Nothing to delete.\"\n            self.log.debug(msg)\n            return {\n                \"success\": True,\n                \"message\": msg\n            }\n\n        repre_entities = list(\n            get_representations(project_name, version_ids=version_ids)\n        )\n\n        self.log.debug(\n            \"Collected representations to remove ({})\".format(\n                len(repre_entities)\n            )\n        )\n\n        dir_paths = {}\n        file_paths_by_dir = collections.defaultdict(list)\n        for repre_entity in repre_entities:\n            file_path, seq_path = self.path_from_represenation(\n                repre_entity, anatomy\n            )\n            if file_path is None:\n                self.log.warning((\n                    \"Could not format path for represenation \\\"{}\\\"\"\n                ).format(str(repre_entity)))\n                continue\n\n            dir_path = os.path.dirname(file_path)\n            dir_id = None\n            for _dir_id, _dir_path in dir_paths.items():\n                if _dir_path == dir_path:\n                    dir_id = _dir_id\n                    break\n\n            if dir_id is None:\n                dir_id = uuid.uuid4()\n                dir_paths[dir_id] = dir_path\n\n            file_paths_by_dir[dir_id].append([file_path, seq_path])\n\n        dir_ids_to_pop = []\n        for dir_id, dir_path in dir_paths.items():\n            if os.path.exists(dir_path):\n                continue\n\n            dir_ids_to_pop.append(dir_id)\n\n        # Pop dirs from both dictionaries\n        for dir_id in dir_ids_to_pop:\n            dir_paths.pop(dir_id)\n            paths = file_paths_by_dir.pop(dir_id)\n            # TODO report of missing directories?\n            paths_msg = \", \".join([\n                \"'{}'\".format(path[0].replace(\"\\\\\", \"/\")) for path in paths\n            ])\n            self.log.warning((\n                \"Folder does not exist. Deleting it's files skipped: {}\"\n            ).format(paths_msg))\n\n        # Size of files.\n        if only_calculate:\n            if force_to_remove:\n                size = self.delete_whole_dir_paths(\n                    dir_paths.values(), delete=False\n                )\n            else:\n                size = self.delete_only_repre_files(\n                    dir_paths, file_paths_by_dir, delete=False\n                )\n\n            msg = \"Total size of files: {}\".format(format_file_size(size))\n\n            self.log.warning(msg)\n\n            return {\"success\": True, \"message\": msg}\n\n        if force_to_remove:\n            size = self.delete_whole_dir_paths(dir_paths.values())\n        else:\n            size = self.delete_only_repre_files(dir_paths, file_paths_by_dir)\n\n        op_session = OperationsSession()\n        for version_entity in version_entities_by_id.values():\n            op_session.update_entity(\n                project_name,\n                \"version\",\n                version_entity[\"id\"],\n                {\"active\": False}\n            )\n\n        op_session.commit()\n\n        # Set attribute `is_published` to `False` on ftrack AssetVersions\n        for product_id, _versions in versions_by_parent.items():\n            product_entity = product_entities_by_id.get(product_id)\n            if product_entity is None:\n                self.log.warning(\n                    f\"Product with ID '{product_id}' was not found.\"\n                )\n                continue\n\n            product_name = product_entity[\"name\"]\n\n            ftrack_asset = ftrack_assets_by_name.get(product_name)\n            if not ftrack_asset:\n                self.log.warning((\n                    \"Could not find ftrack asset with name `{}`\"\n                ).format(product_name))\n                continue\n\n            version_numbers = [int(ver[\"name\"]) for ver in _versions]\n            for version in ftrack_asset[\"versions\"]:\n                if int(version[\"version\"]) in version_numbers:\n                    version[\"is_published\"] = False\n\n        try:\n            session.commit()\n\n        except Exception:\n            msg = (\n                \"Could not set `is_published` attribute to `False`\"\n                \" for selected AssetVersions.\"\n            )\n            self.log.warning(msg, exc_info=True)\n\n            return {\n                \"success\": False,\n                \"message\": msg\n            }\n\n        msg = \"Total size of files deleted: {}\".format(format_file_size(size))\n\n        self.log.warning(msg)\n\n        return {\"success\": True, \"message\": msg}\n\n    def delete_whole_dir_paths(self, dir_paths, delete=True):\n        size = 0\n\n        for dir_path in dir_paths:\n            # Delete all files and fodlers in dir path\n            for root, dirs, files in os.walk(dir_path, topdown=False):\n                for name in files:\n                    file_path = os.path.join(root, name)\n                    size += os.path.getsize(file_path)\n                    if delete:\n                        os.remove(file_path)\n                        self.log.debug(\"Removed file: {}\".format(file_path))\n\n                for name in dirs:\n                    if delete:\n                        os.rmdir(os.path.join(root, name))\n\n            if not delete:\n                continue\n\n            # Delete even the folder and it's parents folders if they are empty\n            while True:\n                if not os.path.exists(dir_path):\n                    dir_path = os.path.dirname(dir_path)\n                    continue\n\n                if len(os.listdir(dir_path)) != 0:\n                    break\n\n                os.rmdir(os.path.join(dir_path))\n\n        return size\n\n    def delete_only_repre_files(self, dir_paths, file_paths, delete=True):\n        size = 0\n\n        for dir_id, dir_path in dir_paths.items():\n            dir_files = os.listdir(dir_path)\n            collections, remainders = clique.assemble(dir_files)\n            for file_path, seq_path in file_paths[dir_id]:\n                file_path_base = os.path.split(file_path)[1]\n                # Just remove file if `frame` key was not in context or\n                # filled path is in remainders (single file sequence)\n                if not seq_path or file_path_base in remainders:\n                    if not os.path.exists(file_path):\n                        self.log.warning(\n                            \"File was not found: {}\".format(file_path)\n                        )\n                        continue\n\n                    size += os.path.getsize(file_path)\n\n                    if delete:\n                        os.remove(file_path)\n                        self.log.debug(\"Removed file: {}\".format(file_path))\n\n                    if file_path_base in remainders:\n                        remainders.remove(file_path_base)\n                    continue\n\n                seq_path_base = os.path.split(seq_path)[1]\n                head, tail = seq_path_base.split(self.sequence_splitter)\n\n                final_col = None\n                for collection in collections:\n                    if head != collection.head or tail != collection.tail:\n                        continue\n                    final_col = collection\n                    break\n\n                if final_col is not None:\n                    # Fill full path to head\n                    final_col.head = os.path.join(dir_path, final_col.head)\n                    for _file_path in final_col:\n                        if os.path.exists(_file_path):\n\n                            size += os.path.getsize(_file_path)\n\n                            if delete:\n                                os.remove(_file_path)\n                                self.log.debug(\n                                    \"Removed file: {}\".format(_file_path)\n                                )\n\n                    _seq_path = final_col.format(\"{head}{padding}{tail}\")\n                    self.log.debug(\"Removed files: {}\".format(_seq_path))\n                    collections.remove(final_col)\n\n                elif os.path.exists(file_path):\n                    size += os.path.getsize(file_path)\n\n                    if delete:\n                        os.remove(file_path)\n                        self.log.debug(\"Removed file: {}\".format(file_path))\n                else:\n                    self.log.warning(\n                        \"File was not found: {}\".format(file_path)\n                    )\n\n        # Delete as much as possible parent folders\n        if not delete:\n            return size\n\n        for dir_path in dir_paths.values():\n            while True:\n                if not os.path.exists(dir_path):\n                    dir_path = os.path.dirname(dir_path)\n                    continue\n\n                if len(os.listdir(dir_path)) != 0:\n                    break\n\n                self.log.debug(\"Removed folder: {}\".format(dir_path))\n                os.rmdir(dir_path)\n\n        return size\n\n    def path_from_represenation(self, representation, anatomy):\n        try:\n            template = representation[\"data\"][\"template\"]\n\n        except KeyError:\n            return (None, None)\n\n        sequence_path = None\n        try:\n            context = representation[\"context\"]\n            context[\"root\"] = anatomy.roots\n            path = StringTemplate.format_strict_template(template, context)\n            if \"frame\" in context:\n                context[\"frame\"] = self.sequence_splitter\n                sequence_path = os.path.normpath(\n                    StringTemplate.format_strict_template(\n                        template, context\n                    )\n                )\n\n        except (KeyError, TemplateUnsolved):\n            # Template references unavailable data\n            return (None, None)\n\n        return (os.path.normpath(path), sequence_path)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_to_convert/action_delete_old_versions.html#client.ayon_ftrack.event_handlers_to_convert.action_delete_old_versions.DeleteOldVersions.discover","title":"<code>discover(session, entities, event)</code>","text":"<p>Validation.</p> Source code in <code>client/ayon_ftrack/event_handlers_to_convert/action_delete_old_versions.py</code> <pre><code>def discover(self, session, entities, event):\n    \"\"\" Validation. \"\"\"\n    is_valid = False\n    for entity in entities:\n        if entity.entity_type.lower() == \"assetversion\":\n            is_valid = True\n            break\n\n    if is_valid:\n        is_valid = self.valid_roles(session, entities, event)\n    return is_valid\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_to_convert/action_fill_workfile_attr.html","title":"action_fill_workfile_attr","text":""},{"location":"autoapi/client/ayon_ftrack/event_handlers_to_convert/action_fill_workfile_attr.html#client.ayon_ftrack.event_handlers_to_convert.action_fill_workfile_attr.FillWorkfileAttributeAction","title":"<code>FillWorkfileAttributeAction</code>","text":"<p>               Bases: <code>LocalAction</code></p> <p>Action fill work filename into custom attribute on tasks.</p> <p>Prerequirements are that the project is synchronized so it is possible to access project anatomy and project/asset documents. Tasks that are not synchronized are skipped too.</p> Source code in <code>client/ayon_ftrack/event_handlers_to_convert/action_fill_workfile_attr.py</code> <pre><code>class FillWorkfileAttributeAction(LocalAction):\n    \"\"\"Action fill work filename into custom attribute on tasks.\n\n    Prerequirements are that the project is synchronized so it is possible to\n    access project anatomy and project/asset documents. Tasks that are not\n    synchronized are skipped too.\n    \"\"\"\n\n    identifier = \"fill.workfile.attr\"\n    label = \"AYON Admin\"\n    variant = \"- Fill workfile attribute\"\n    description = \"Precalculate and fill workfile name into a custom attribute\"\n    icon = get_ftrack_icon_url(\"AYONAdmin.svg\")\n\n    settings_key = \"fill_workfile_attribute\"\n\n    def discover(self, session, entities, event):\n        \"\"\" Validate selection. \"\"\"\n        is_valid = False\n        for ent in event[\"data\"][\"selection\"]:\n            # Ignore entities that are not tasks or projects\n            if ent[\"entityType\"].lower() in [\"show\", \"task\"]:\n                is_valid = True\n                break\n\n        if is_valid:\n            is_valid = self.valid_roles(session, entities, event)\n        return is_valid\n\n    def launch(self, session, entities, event):\n        # Separate entities and get project entity\n        ft_project_entity = None\n        for entity in entities:\n            if ft_project_entity is None:\n                ft_project_entity = self.get_project_from_entity(entity)\n                break\n\n        if not ft_project_entity:\n            return {\n                \"message\": (\n                    \"Couldn't find project entity.\"\n                    \" Could be an issue with permissions.\"\n                ),\n                \"success\": False\n            }\n\n        # Get project settings and check if custom attribute where workfile\n        #   should be set is defined.\n        project_name = ft_project_entity[\"full_name\"]\n        project_settings = get_project_settings(project_name)\n        custom_attribute_key = (\n            project_settings\n            .get(\"ftrack\", {})\n            .get(\"user_handlers\", {})\n            .get(self.settings_key, {})\n            .get(\"custom_attribute_key\")\n        )\n        if not custom_attribute_key:\n            return {\n                \"success\": False,\n                \"message\": \"Custom attribute key is not set in settings\"\n            }\n\n        # Try to find the custom attribute\n        # - get Task type object id\n        task_obj_type = session.query(\n            \"select id from ObjectType where name is \\\"Task\\\"\"\n        ).one()\n        # - get text custom attribute type\n        text_type = session.query(\n            \"select id from CustomAttributeType where name is \\\"text\\\"\"\n        ).one()\n        # - find the attribute\n        attr_conf = session.query(\n            (\n                \"select id, key from CustomAttributeConfiguration\"\n                \" where object_type_id is \\\"{}\\\"\"\n                \" and type_id is \\\"{}\\\"\"\n                \" and key is \\\"{}\\\"\"\n            ).format(\n                task_obj_type[\"id\"], text_type[\"id\"], custom_attribute_key\n            )\n        ).first()\n        if not attr_conf:\n            return {\n                \"success\": False,\n                \"message\": (\n                    \"Could not find Task (text) Custom attribute \\\"{}\\\"\"\n                ).format(custom_attribute_key)\n            }\n\n        # Store report information\n        report = collections.defaultdict(list)\n        user_entity = session.query(\n            \"User where id is {}\".format(event[\"source\"][\"user\"][\"id\"])\n        ).one()\n        job_entity = session.create(\"Job\", {\n            \"user\": user_entity,\n            \"status\": \"running\",\n            \"data\": json.dumps({\n                \"description\": \"(0/3) Fill of workfiles started\"\n            })\n        })\n        session.commit()\n\n        try:\n            self.in_job_process(\n                session,\n                entities,\n                job_entity,\n                ft_project_entity,\n                project_settings,\n                attr_conf,\n                report\n            )\n        except Exception:\n            self.log.error(\n                \"Fill of workfiles to custom attribute failed\", exc_info=True\n            )\n            session.rollback()\n\n            description = \"Fill of workfiles Failed (Download traceback)\"\n            self.add_traceback_to_job(\n                job_entity, session, sys.exc_info(), description\n            )\n            return {\n                \"message\": (\n                    \"Fill of workfiles failed.\"\n                    \" Check job for more information\"\n                ),\n                \"success\": False\n            }\n\n        job_entity[\"status\"] = \"done\"\n        job_entity[\"data\"] = json.dumps({\n            \"description\": \"Fill of workfiles completed.\"\n        })\n        session.commit()\n        if report:\n            temp_obj = tempfile.NamedTemporaryFile(\n                mode=\"w\",\n                prefix=\"ayon_ftrack_\",\n                suffix=\".json\",\n                delete=False\n            )\n            temp_obj.close()\n            temp_filepath = temp_obj.name\n            with open(temp_filepath, \"w\") as temp_file:\n                json.dump(report, temp_file)\n\n            component_name = \"{}_{}\".format(\n                \"FillWorkfilesReport\",\n                datetime.datetime.now().strftime(\"%y-%m-%d-%H%M\")\n            )\n            self.add_file_component_to_job(\n                job_entity, session, temp_filepath, component_name\n            )\n            # Delete temp file\n            os.remove(temp_filepath)\n            self._show_report(event, report, project_name)\n            return {\n                \"message\": (\n                    \"Fill of workfiles finished with few issues.\"\n                    \" Check job for more information\"\n                ),\n                \"success\": True\n            }\n\n        return {\n            \"success\": True,\n            \"message\": \"Finished with filling of work filenames\"\n        }\n\n    def _show_report(self, event, report, project_name):\n        items = []\n        title = \"Fill workfiles report ({}):\".format(project_name)\n\n        for subtitle, lines in report.items():\n            if items:\n                items.append({\n                    \"type\": \"label\",\n                    \"value\": \"---\"\n                })\n            items.append({\n                \"type\": \"label\",\n                \"value\": \"# {}\".format(subtitle)\n            })\n            items.append({\n                \"type\": \"label\",\n                \"value\": '&lt;p&gt;{}&lt;/p&gt;'.format(\"&lt;br&gt;\".join(lines))\n            })\n\n        self.show_interface(\n            items=items,\n            title=title,\n            event=event\n        )\n\n    def in_job_process(\n        self,\n        session,\n        entities,\n        job_entity,\n        ft_project_entity,\n        project_settings,\n        attr_conf,\n        report\n    ):\n        ft_task_entities = []\n        other_entities = []\n        project_selected = False\n        for entity in entities:\n            ent_type_low = entity.entity_type.lower()\n            if ent_type_low == \"project\":\n                project_selected = True\n                break\n\n            elif ent_type_low == \"task\":\n                ft_task_entities.append(entity)\n            else:\n                other_entities.append(entity)\n\n        project_name = ft_project_entity[\"full_name\"]\n\n        # Find matchin asset documents and map them by ftrack task entities\n        # - result stored to 'folder_entities_with_ft_task_entities' is list\n        #   with a tuple `(folder entity, [ftrack task entitis, ...])`\n        # Fetch all folder and task entities\n        folder_entities = list(get_folders(\n            project_name, fields={\"id\", \"folderType\", \"path\", \"attrib\"}\n        ))\n        task_entities_by_folder_id = collections.defaultdict(list)\n        for task_entity in get_tasks(\n            project_name, fields={\"id\", \"taskType\", \"name\", \"folderId\"}\n        ):\n            folder_id = task_entity[\"folderId\"]\n            task_entities_by_folder_id[folder_id].append(task_entity)\n\n        job_entity[\"data\"] = json.dumps({\n            \"description\": \"(1/3) Folder &amp; Task entities queried.\"\n        })\n        session.commit()\n\n        # When project is selected then we can query whole project\n        if project_selected:\n            folder_entities_with_ft_task_entities = (\n                self._get_asset_docs_for_project(\n                    session,\n                    ft_project_entity,\n                    folder_entities,\n                    task_entities_by_folder_id,\n                    report\n                )\n            )\n\n        else:\n            folder_entities_with_ft_task_entities = (\n                self._get_tasks_for_selection(\n                    session,\n                    other_entities,\n                    ft_task_entities,\n                    folder_entities,\n                    task_entities_by_folder_id,\n                    report\n                )\n            )\n\n        job_entity[\"data\"] = json.dumps({\n            \"description\": \"(2/3) Queried related task entities.\"\n        })\n        session.commit()\n\n        # Keep placeholders in the template unfilled\n        host_name = \"{app}\"\n        extension = \"{ext}\"\n        project_entity = get_project(project_name)\n        project_settings = get_project_settings(project_name)\n        anatomy = Anatomy(project_name)\n        templates_by_key = {}\n\n        operations = []\n        for folder_entity, ft_task_entities in (\n            folder_entities_with_ft_task_entities\n        ):\n            folder_id = folder_entity[\"id\"]\n            folder_path = folder_entity[\"path\"]\n            task_entities_by_name = {\n                task_entity[\"name\"]: task_entity\n                for task_entity in task_entities_by_folder_id[folder_id]\n            }\n            task_entities_by_low_name = {\n                name.lower(): task_entity\n                for name, task_entity in task_entities_by_name.items()\n            }\n            for ft_task_entity in ft_task_entities:\n                task_name = ft_task_entity[\"name\"]\n                task_entity = task_entities_by_name.get(task_name)\n                if not task_entity:\n                    task_entity = task_entities_by_low_name.get(\n                        task_name.lower()\n                    )\n\n                if not task_entity:\n                    self.log.warning(\n                        f\"Coulnd't find task entity \\\"{task_name}\\\"\"\n                        f\" for folder \\\"{folder_path}\\\"\"\n                    )\n                    continue\n\n                workfile_data = get_template_data(\n                    project_entity,\n                    folder_entity,\n                    task_entity,\n                    host_name,\n                    project_settings\n                )\n                # Use version 1 for each workfile\n                workfile_data[\"version\"] = 1\n                workfile_data[\"ext\"] = extension\n\n                task_type = task_entity[\"taskType\"]\n                template_key = get_workfile_template_key(\n                    task_type,\n                    host_name,\n                    project_name,\n                    project_settings=project_settings\n                )\n                if template_key in templates_by_key:\n                    template = templates_by_key[template_key]\n                else:\n                    template = StringTemplate(\n                        anatomy.templates[template_key][\"file\"]\n                    )\n                    templates_by_key[template_key] = template\n\n                result = template.format(workfile_data)\n                if not result.solved:\n                    # TODO report\n                    pass\n                else:\n                    table_values = collections.OrderedDict((\n                        (\"configuration_id\", attr_conf[\"id\"]),\n                        (\"entity_id\", ft_task_entity[\"id\"])\n                    ))\n                    operations.append(\n                        ftrack_api.operation.UpdateEntityOperation(\n                            \"ContextCustomAttributeValue\",\n                            table_values,\n                            \"value\",\n                            ftrack_api.symbol.NOT_SET,\n                            str(result)\n                        )\n                    )\n\n        if operations:\n            for sub_operations in create_chunks(operations, 50):\n                for op in sub_operations:\n                    session.recorded_operations.push(op)\n                session.commit()\n\n        job_entity[\"data\"] = json.dumps({\n            \"description\": \"(3/3) Set custom attribute values.\"\n        })\n        session.commit()\n\n    def _get_entity_path(self, entity):\n        path_items = []\n        for item in entity[\"link\"]:\n            if item[\"type\"].lower() != \"project\":\n                path_items.append(item[\"name\"])\n        return \"/\".join(path_items)\n\n    def _get_asset_docs_for_project(\n        self,\n        session,\n        ft_project_entity,\n        folder_entities,\n        task_entities_by_folder_id,\n        report,\n    ):\n        folder_entity_task_names = {}\n        for folder_entity in folder_entities:\n            ftrack_id = folder_entity[\"attrib\"].get(\"ftrackId\")\n            if not ftrack_id:\n                path = folder_entity[\"path\"]\n                report[NOT_SYNCHRONIZED_TITLE].append(path)\n                continue\n\n            folder_id = folder_entity[\"id\"]\n            task_names = {\n                task_entity[\"name\"]\n                for task_entity in task_entities_by_folder_id[folder_id]\n            }\n            folder_entity_task_names[ftrack_id] = (folder_entity, task_names)\n\n        ft_task_entities = session.query((\n            \"select id, name, parent_id, link from Task where project_id is {}\"\n        ).format(ft_project_entity[\"id\"])).all()\n        ft_task_entities_by_parent_id = collections.defaultdict(list)\n        for ft_task_entity in ft_task_entities:\n            parent_id = ft_task_entity[\"parent_id\"]\n            ft_task_entities_by_parent_id[parent_id].append(ft_task_entity)\n\n        output = []\n        for ftrack_id, item in folder_entity_task_names.items():\n            folder_entity, task_names = item\n            valid_ft_task_entities = []\n            for ft_task_entity in ft_task_entities_by_parent_id[ftrack_id]:\n                if ft_task_entity[\"name\"] in task_names:\n                    valid_ft_task_entities.append(ft_task_entity)\n                else:\n                    path = self._get_entity_path(ft_task_entity)\n                    report[NOT_SYNCHRONIZED_TITLE].append(path)\n\n            if valid_ft_task_entities:\n                output.append((folder_entity, valid_ft_task_entities))\n\n        return output\n\n    def _get_tasks_for_selection(\n        self,\n        session,\n        other_entities,\n        ft_task_entities,\n        folder_entities,\n        task_entities_by_folder_id,\n        report,\n    ):\n        all_tasks = object()\n        folder_entities_by_ftrack_id = {}\n        for folder_entity in folder_entities:\n            ftrack_id = folder_entity[\"attrib\"].get(\"ftrackId\")\n            if ftrack_id:\n                folder_entities_by_ftrack_id[ftrack_id] = folder_entity\n\n        missing_entity_ftrack_ids = {}\n        all_tasks_ids = set()\n        task_names_by_ftrack_id = collections.defaultdict(list)\n        for other_entity in other_entities:\n            ftrack_id = other_entity[\"id\"]\n            if ftrack_id not in folder_entities_by_ftrack_id:\n                missing_entity_ftrack_ids[ftrack_id] = None\n                continue\n            all_tasks_ids.add(ftrack_id)\n            task_names_by_ftrack_id[ftrack_id] = all_tasks\n\n        for ft_task_entity in ft_task_entities:\n            parent_id = ft_task_entity[\"parent_id\"]\n            if parent_id not in folder_entities_by_ftrack_id:\n                missing_entity_ftrack_ids[parent_id] = None\n                continue\n\n            if all_tasks_ids not in all_tasks_ids:\n                task_names_by_ftrack_id[ftrack_id].append(ft_task_entity[\"name\"])\n\n        ftrack_ids = set()\n        folder_entity_with_task_names_by_id = {}\n        for ftrack_id, task_names in task_names_by_ftrack_id.items():\n            folder_entity = folder_entities_by_ftrack_id[ftrack_id]\n            folder_id = folder_entity[\"id\"]\n            folder_task_names = {\n                task_entity[\"name\"]\n                for task_entity in task_entities_by_folder_id[folder_id]\n            }\n\n            if task_names is all_tasks:\n                task_names = list(folder_task_names)\n            else:\n                new_task_names = []\n                for task_name in task_names:\n                    if task_name in folder_task_names:\n                        new_task_names.append(task_name)\n                        continue\n\n                    missing_entity_ftrack_ids.setdefault(ftrack_id, [])\n                    if missing_entity_ftrack_ids[ftrack_id] is not None:\n                        missing_entity_ftrack_ids[ftrack_id].append(task_name)\n\n                task_names = new_task_names\n\n            if task_names:\n                ftrack_ids.add(ftrack_id)\n                folder_entity_with_task_names_by_id[ftrack_id] = (\n                    folder_entity, task_names\n                )\n\n        ft_task_entities = session.query((\n            \"select id, name, parent_id from Task where parent_id in ({})\"\n        ).format(self.join_query_keys(ftrack_ids))).all()\n        task_entitiy_by_parent_id = collections.defaultdict(list)\n        for ft_task_entity in ft_task_entities:\n            parent_id = ft_task_entity[\"parent_id\"]\n            task_entitiy_by_parent_id[parent_id].append(ft_task_entity)\n\n        output = []\n        for ftrack_id, item in folder_entity_with_task_names_by_id.items():\n            asset_doc, task_names = item\n            valid_ft_task_entities = []\n            for ft_task_entity in task_entitiy_by_parent_id[ftrack_id]:\n                if ft_task_entity[\"name\"] in task_names:\n                    valid_ft_task_entities.append(ft_task_entity)\n                else:\n                    missing_entity_ftrack_ids.setdefault(ftrack_id, [])\n                    if missing_entity_ftrack_ids[ftrack_id] is not None:\n                        missing_entity_ftrack_ids[ftrack_id].append(task_name)\n            if valid_ft_task_entities:\n                output.append((asset_doc, valid_ft_task_entities))\n\n        # Store report information about not synchronized entities\n        if missing_entity_ftrack_ids:\n            missing_entities = session.query(\n                \"select id, link from TypedContext where id in ({})\".format(\n                    self.join_query_keys(missing_entity_ftrack_ids.keys())\n                )\n            ).all()\n            for missing_entity in missing_entities:\n                path = self._get_entity_path(missing_entity)\n                task_names = missing_entity_ftrack_ids[missing_entity[\"id\"]]\n                if task_names is None:\n                    report[NOT_SYNCHRONIZED_TITLE].append(path)\n                else:\n                    for task_name in task_names:\n                        task_path = \"/\".join([path, task_name])\n                        report[NOT_SYNCHRONIZED_TITLE].append(task_path)\n\n        return output\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_to_convert/action_fill_workfile_attr.html#client.ayon_ftrack.event_handlers_to_convert.action_fill_workfile_attr.FillWorkfileAttributeAction.discover","title":"<code>discover(session, entities, event)</code>","text":"<p>Validate selection.</p> Source code in <code>client/ayon_ftrack/event_handlers_to_convert/action_fill_workfile_attr.py</code> <pre><code>def discover(self, session, entities, event):\n    \"\"\" Validate selection. \"\"\"\n    is_valid = False\n    for ent in event[\"data\"][\"selection\"]:\n        # Ignore entities that are not tasks or projects\n        if ent[\"entityType\"].lower() in [\"show\", \"task\"]:\n            is_valid = True\n            break\n\n    if is_valid:\n        is_valid = self.valid_roles(session, entities, event)\n    return is_valid\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_to_convert/action_store_thumbnails_to_avalon.html","title":"action_store_thumbnails_to_avalon","text":""},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/index.html","title":"event_handlers_user","text":""},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_applications.html","title":"action_applications","text":""},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_applications.html#client.ayon_ftrack.event_handlers_user.action_applications.AppplicationsAction","title":"<code>AppplicationsAction</code>","text":"<p>               Bases: <code>BaseAction</code></p> <p>Applications Action class.</p> Source code in <code>client/ayon_ftrack/event_handlers_user/action_applications.py</code> <pre><code>class AppplicationsAction(BaseAction):\n    \"\"\"Applications Action class.\"\"\"\n\n    type = \"Application\"\n    label = \"Application action\"\n\n    identifier = \"ayon_app\"\n    _launch_identifier_with_id = None\n\n    # 30 seconds\n    cache_lifetime = 30\n\n    def __init__(self, *args, **kwargs):\n        super(AppplicationsAction, self).__init__(*args, **kwargs)\n\n        self._applications_manager = None\n        self._applications_addon = None\n        self._expire_time = 0\n        self._icons_mapping = {}\n\n    @property\n    def applications_addon(self):\n        if self._applications_addon is None:\n            addons_manager = AddonsManager()\n            self._applications_addon = addons_manager.get(\"applications\")\n        return self._applications_addon\n\n    @property\n    def applications_manager(self):\n        \"\"\"\n\n        Applications manager is refreshed in regular interval. Interval is\n            defined by 'cache_lifetime' property.\n\n        Returns:\n            ApplicationManager: Application manager instance.\n        \"\"\"\n\n        current_time = time.time()\n        if self._applications_manager is None:\n            self._applications_manager = (\n                self.applications_addon.get_applications_manager()\n            )\n            self._expire_time = current_time + self.cache_lifetime\n\n        elif self._expire_time &lt; current_time:\n            self._applications_manager.refresh()\n            self._expire_time = current_time + self.cache_lifetime\n        return self._applications_manager\n\n    @property\n    def discover_identifier(self):\n        if self._discover_identifier is None:\n            self._discover_identifier = \"{}.{}\".format(\n                self.identifier, self.process_identifier()\n            )\n        return self._discover_identifier\n\n    @property\n    def launch_identifier(self):\n        if self._launch_identifier is None:\n            self._launch_identifier = \"{}.*\".format(self.identifier)\n        return self._launch_identifier\n\n    @property\n    def launch_identifier_with_id(self):\n        if self._launch_identifier_with_id is None:\n            self._launch_identifier_with_id = \"{}.{}\".format(\n                self.identifier, self.process_identifier()\n            )\n        return self._launch_identifier_with_id\n\n    def construct_requirements_validations(self):\n        # Override validation as this action does not need them\n        return\n\n    def register(self):\n        \"\"\"Registers the action, subscribing the discover and launch topics.\"\"\"\n\n        discovery_subscription = (\n            \"topic=ftrack.action.discover and source.user.username={0}\"\n        ).format(self.session.api_user)\n\n        self.session.event_hub.subscribe(\n            discovery_subscription,\n            self._discover,\n            priority=self.priority\n        )\n\n        launch_subscription = (\n            \"topic=ftrack.action.launch\"\n            \" and data.actionIdentifier={0}\"\n            \" and source.user.username={1}\"\n        ).format(\n            self.launch_identifier,\n            self.session.api_user\n        )\n        self.session.event_hub.subscribe(\n            launch_subscription,\n            self._launch\n        )\n\n    def _discover(self, event):\n        entities = self._translate_event(event)\n        items = self.discover(self.session, entities, event)\n        if items:\n            return {\"items\": items}\n\n    def discover(self, session, entities, event):\n        \"\"\"Return true if we can handle the selected entities.\n\n        Args:\n            session (ftrack_api.Session): Helps to query necessary data.\n            entities (list): Object of selected entities.\n            event (ftrack_api.Event): ftrack event causing discover callback.\n        \"\"\"\n\n        if (\n            len(entities) != 1\n            or entities[0].entity_type.lower() != \"task\"\n        ):\n            return False\n\n        entity = entities[0]\n        if entity[\"parent\"].entity_type.lower() == \"project\":\n            return False\n\n        # TODO we only need project name\n        ft_project = self.get_project_from_entity(entity)\n        project_name = ft_project[\"full_name\"]\n        ayon_project_entity = self.get_ayon_project_from_event(\n            event, project_name\n        )\n        if not ayon_project_entity:\n            return False\n\n        project_settings = self.get_project_settings_from_event(\n            event, project_name\n        )\n        ftrack_settings = project_settings.get(\"ftrack\")\n        if (\n            not ftrack_settings\n            or not is_ftrack_enabled_in_settings(ftrack_settings)\n        ):\n            return False\n\n        folder_path = self._get_folder_path(session, entity[\"parent\"])\n        task_name = entity[\"name\"]\n        folder_entity = ayon_api.get_folder_by_path(project_name, folder_path)\n        task_entity = ayon_api.get_task_by_name(\n            project_name, folder_entity[\"id\"], task_name\n        )\n\n        only_available = project_settings[\"applications\"].get(\n            \"only_available\", False\n        )\n\n        app_names = get_applications_for_context(\n            project_name,\n            folder_entity,\n            task_entity,\n            project_settings=project_settings,\n            project_entity=ayon_project_entity\n        )\n        items = []\n        for app_name in app_names:\n            app = self.applications_manager.applications.get(app_name)\n            if not app or not app.enabled:\n                continue\n\n            # Skip applications without valid executables\n            if only_available and not app.find_executable():\n                continue\n\n            app_icon = self.applications_addon.get_app_icon_url(\n                app.icon, server=False\n            )\n            items.append({\n                \"label\": app.group.label,\n                \"variant\": app.label,\n                \"description\": None,\n                \"actionIdentifier\": \"{}.{}\".format(\n                    self.launch_identifier_with_id, app_name\n                ),\n                \"icon\": self._get_icon_mapping(app_icon),\n            })\n\n        return items\n\n    def _get_icon_mapping(self, icon: Optional[str]):\n        \"\"\"Get icon mapping.\n\n        This function does create and store mapping of icon url. Urls with\n            '127.0.0.1' IP address are replaced with 'localhost'. Otherwise\n            is icon kept as was.\n\n        \"\"\"\n        if not icon:\n            return icon\n\n        if icon not in self._icons_mapping:\n            # ftrack frontend does not allow redirect to IP address, but\n            #   allows redirect to 'localhost'\n            result = urlparse(icon)\n            if result.hostname == \"127.0.0.1\":\n                port = \"\"\n                if result.port:\n                    port = f\":{result.port}\"\n                icon = urlunparse(\n                    result._replace(netloc=f\"localhost{port}\")\n                )\n            self._icons_mapping[icon] = icon\n        return self._icons_mapping[icon]\n\n    def _launch(self, event):\n        event_identifier = event[\"data\"][\"actionIdentifier\"]\n        # Check if identifier is same\n        # - show message that acion may not be triggered on this machine\n        if event_identifier.startswith(self.launch_identifier_with_id):\n            return BaseAction._launch(self, event)\n\n        return {\n            \"success\": False,\n            \"message\": (\n                \"There are running more AYON processes\"\n                \" where Application can be launched.\"\n            )\n        }\n\n    def launch(self, session, entities, event):\n        \"\"\"Callback method for the custom action.\n\n        return either a bool (True if successful or False if the action failed)\n        or a dictionary with they keys `message` and `success`, the message\n        should be a string and will be displayed as feedback to the user,\n        success should be a bool, True if successful or False if the action\n        failed.\n\n        *session* is a `ftrack_api.Session` instance\n\n        *entities* is a list of tuples each containing the entity type and\n        the entity id. If the entity is a hierarchical you will always get\n        the entity type TypedContext, once retrieved through a get operation\n        you will have the \"real\" entity type ie. example Shot, Sequence\n        or Asset Build.\n\n        *event* the unmodified original event\n        \"\"\"\n        identifier = event[\"data\"][\"actionIdentifier\"]\n        id_identifier_len = len(self.launch_identifier_with_id) + 1\n        app_name = identifier[id_identifier_len:]\n\n        entity = entities[0]\n\n        task_name = entity[\"name\"]\n        folder_path = self._get_folder_path(session, entity[\"parent\"])\n        project_name = entity[\"project\"][\"full_name\"]\n        self.log.info(\n            f\"ftrack launch app: \\\"{app_name}\\\"\"\n            f\" on {project_name}{folder_path}/{task_name}\"\n        )\n        try:\n            self.applications_manager.launch(\n                app_name,\n                project_name=project_name,\n                folder_path=folder_path,\n                task_name=task_name\n            )\n\n        except ApplicationExecutableNotFound as exc:\n            self.log.warning(exc.exc_msg)\n            return {\n                \"success\": False,\n                \"message\": exc.msg\n            }\n\n        except ApplicationLaunchFailed as exc:\n            self.log.error(str(exc))\n            return {\n                \"success\": False,\n                \"message\": str(exc)\n            }\n\n        except Exception:\n            msg = \"Unexpected failure of application launch {}\".format(\n                self.label\n            )\n            self.log.error(msg, exc_info=True)\n            return {\n                \"success\": False,\n                \"message\": msg\n            }\n\n        return {\n            \"success\": True,\n            \"message\": \"Launching {0}\".format(self.label)\n        }\n\n    def _get_folder_path(self, session, entity):\n        entity_id = entity[\"id\"]\n        return get_folder_path_for_entities(session, [entity])[entity_id]\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_applications.html#client.ayon_ftrack.event_handlers_user.action_applications.AppplicationsAction.applications_manager","title":"<code>applications_manager</code>  <code>property</code>","text":"<p>Applications manager is refreshed in regular interval. Interval is     defined by 'cache_lifetime' property.</p> <p>Returns:</p> Name Type Description <code>ApplicationManager</code> <p>Application manager instance.</p>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_applications.html#client.ayon_ftrack.event_handlers_user.action_applications.AppplicationsAction.discover","title":"<code>discover(session, entities, event)</code>","text":"<p>Return true if we can handle the selected entities.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Helps to query necessary data.</p> required <code>entities</code> <code>list</code> <p>Object of selected entities.</p> required <code>event</code> <code>Event</code> <p>ftrack event causing discover callback.</p> required Source code in <code>client/ayon_ftrack/event_handlers_user/action_applications.py</code> <pre><code>def discover(self, session, entities, event):\n    \"\"\"Return true if we can handle the selected entities.\n\n    Args:\n        session (ftrack_api.Session): Helps to query necessary data.\n        entities (list): Object of selected entities.\n        event (ftrack_api.Event): ftrack event causing discover callback.\n    \"\"\"\n\n    if (\n        len(entities) != 1\n        or entities[0].entity_type.lower() != \"task\"\n    ):\n        return False\n\n    entity = entities[0]\n    if entity[\"parent\"].entity_type.lower() == \"project\":\n        return False\n\n    # TODO we only need project name\n    ft_project = self.get_project_from_entity(entity)\n    project_name = ft_project[\"full_name\"]\n    ayon_project_entity = self.get_ayon_project_from_event(\n        event, project_name\n    )\n    if not ayon_project_entity:\n        return False\n\n    project_settings = self.get_project_settings_from_event(\n        event, project_name\n    )\n    ftrack_settings = project_settings.get(\"ftrack\")\n    if (\n        not ftrack_settings\n        or not is_ftrack_enabled_in_settings(ftrack_settings)\n    ):\n        return False\n\n    folder_path = self._get_folder_path(session, entity[\"parent\"])\n    task_name = entity[\"name\"]\n    folder_entity = ayon_api.get_folder_by_path(project_name, folder_path)\n    task_entity = ayon_api.get_task_by_name(\n        project_name, folder_entity[\"id\"], task_name\n    )\n\n    only_available = project_settings[\"applications\"].get(\n        \"only_available\", False\n    )\n\n    app_names = get_applications_for_context(\n        project_name,\n        folder_entity,\n        task_entity,\n        project_settings=project_settings,\n        project_entity=ayon_project_entity\n    )\n    items = []\n    for app_name in app_names:\n        app = self.applications_manager.applications.get(app_name)\n        if not app or not app.enabled:\n            continue\n\n        # Skip applications without valid executables\n        if only_available and not app.find_executable():\n            continue\n\n        app_icon = self.applications_addon.get_app_icon_url(\n            app.icon, server=False\n        )\n        items.append({\n            \"label\": app.group.label,\n            \"variant\": app.label,\n            \"description\": None,\n            \"actionIdentifier\": \"{}.{}\".format(\n                self.launch_identifier_with_id, app_name\n            ),\n            \"icon\": self._get_icon_mapping(app_icon),\n        })\n\n    return items\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_applications.html#client.ayon_ftrack.event_handlers_user.action_applications.AppplicationsAction.launch","title":"<code>launch(session, entities, event)</code>","text":"<p>Callback method for the custom action.</p> <p>return either a bool (True if successful or False if the action failed) or a dictionary with they keys <code>message</code> and <code>success</code>, the message should be a string and will be displayed as feedback to the user, success should be a bool, True if successful or False if the action failed.</p> <p>session is a <code>ftrack_api.Session</code> instance</p> <p>entities is a list of tuples each containing the entity type and the entity id. If the entity is a hierarchical you will always get the entity type TypedContext, once retrieved through a get operation you will have the \"real\" entity type ie. example Shot, Sequence or Asset Build.</p> <p>event the unmodified original event</p> Source code in <code>client/ayon_ftrack/event_handlers_user/action_applications.py</code> <pre><code>def launch(self, session, entities, event):\n    \"\"\"Callback method for the custom action.\n\n    return either a bool (True if successful or False if the action failed)\n    or a dictionary with they keys `message` and `success`, the message\n    should be a string and will be displayed as feedback to the user,\n    success should be a bool, True if successful or False if the action\n    failed.\n\n    *session* is a `ftrack_api.Session` instance\n\n    *entities* is a list of tuples each containing the entity type and\n    the entity id. If the entity is a hierarchical you will always get\n    the entity type TypedContext, once retrieved through a get operation\n    you will have the \"real\" entity type ie. example Shot, Sequence\n    or Asset Build.\n\n    *event* the unmodified original event\n    \"\"\"\n    identifier = event[\"data\"][\"actionIdentifier\"]\n    id_identifier_len = len(self.launch_identifier_with_id) + 1\n    app_name = identifier[id_identifier_len:]\n\n    entity = entities[0]\n\n    task_name = entity[\"name\"]\n    folder_path = self._get_folder_path(session, entity[\"parent\"])\n    project_name = entity[\"project\"][\"full_name\"]\n    self.log.info(\n        f\"ftrack launch app: \\\"{app_name}\\\"\"\n        f\" on {project_name}{folder_path}/{task_name}\"\n    )\n    try:\n        self.applications_manager.launch(\n            app_name,\n            project_name=project_name,\n            folder_path=folder_path,\n            task_name=task_name\n        )\n\n    except ApplicationExecutableNotFound as exc:\n        self.log.warning(exc.exc_msg)\n        return {\n            \"success\": False,\n            \"message\": exc.msg\n        }\n\n    except ApplicationLaunchFailed as exc:\n        self.log.error(str(exc))\n        return {\n            \"success\": False,\n            \"message\": str(exc)\n        }\n\n    except Exception:\n        msg = \"Unexpected failure of application launch {}\".format(\n            self.label\n        )\n        self.log.error(msg, exc_info=True)\n        return {\n            \"success\": False,\n            \"message\": msg\n        }\n\n    return {\n        \"success\": True,\n        \"message\": \"Launching {0}\".format(self.label)\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_applications.html#client.ayon_ftrack.event_handlers_user.action_applications.AppplicationsAction.register","title":"<code>register()</code>","text":"<p>Registers the action, subscribing the discover and launch topics.</p> Source code in <code>client/ayon_ftrack/event_handlers_user/action_applications.py</code> <pre><code>def register(self):\n    \"\"\"Registers the action, subscribing the discover and launch topics.\"\"\"\n\n    discovery_subscription = (\n        \"topic=ftrack.action.discover and source.user.username={0}\"\n    ).format(self.session.api_user)\n\n    self.session.event_hub.subscribe(\n        discovery_subscription,\n        self._discover,\n        priority=self.priority\n    )\n\n    launch_subscription = (\n        \"topic=ftrack.action.launch\"\n        \" and data.actionIdentifier={0}\"\n        \" and source.user.username={1}\"\n    ).format(\n        self.launch_identifier,\n        self.session.api_user\n    )\n    self.session.event_hub.subscribe(\n        launch_subscription,\n        self._launch\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_batch_task_creation.html","title":"action_batch_task_creation","text":"<p>Taken from https://github.com/tokejepsen/ftrack-hooks/tree/master/batch_tasks</p>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_batch_task_creation.html#client.ayon_ftrack.event_handlers_user.action_batch_task_creation.BatchTasksAction","title":"<code>BatchTasksAction</code>","text":"<p>               Bases: <code>LocalAction</code></p> <p>Batch Tasks action.</p> Source code in <code>client/ayon_ftrack/event_handlers_user/action_batch_task_creation.py</code> <pre><code>class BatchTasksAction(LocalAction):\n    \"\"\"Batch Tasks action.\"\"\"\n\n    label = \"Batch Task Create\"\n    variant = None\n    identifier = \"ayon.batch-tasks\"\n    description = None\n    icon = get_ftrack_icon_url(\"BatchTasks.svg\")\n\n    def discover(self, session, entities, event):\n        not_allowed = [\"assetversion\", \"project\", \"ReviewSession\"]\n        if entities[0].entity_type.lower() in not_allowed:\n            return False\n\n        return True\n\n    def get_task_form_items(self, session, number_of_tasks):\n        items = []\n\n        task_type_options = [\n            {'label': task_type[\"name\"], 'value': task_type[\"id\"]}\n            for task_type in session.query(\"Type\")\n        ]\n\n        for index in range(0, number_of_tasks):\n            items.extend(\n                [\n                    {\n                        'value': '##Template for Task{0}##'.format(\n                            index\n                        ),\n                        'type': 'label'\n                    },\n                    {\n                        'label': 'Type',\n                        'type': 'enumerator',\n                        'name': 'task_{0}_typeid'.format(index),\n                        'data': task_type_options\n                    },\n                    {\n                        'label': 'Name',\n                        'type': 'text',\n                        'name': 'task_{0}_name'.format(index)\n                    }\n                ]\n            )\n\n        return items\n\n    def ensure_task(self, session, name, task_type, parent):\n\n        # Query for existing task.\n        query = (\n            'Task where type.id is \"{0}\" and name is \"{1}\" '\n            'and parent.id is \"{2}\"'\n        )\n        task = session.query(\n            query.format(\n                task_type[\"id\"],\n                name,\n                parent[\"id\"]\n            )\n        ).first()\n\n        # Create task.\n        if not task:\n            session.create(\n                \"Task\",\n                {\n                    \"name\": name,\n                    \"type\": task_type,\n                    \"parent\": parent\n                }\n            )\n\n    def launch(self, session, entities, event):\n        if 'values' in event['data']:\n            values = event['data']['values']\n            if 'number_of_tasks' in values:\n                return {\n                    'success': True,\n                    'message': '',\n                    'items': self.get_task_form_items(\n                        session, int(values['number_of_tasks'])\n                    )\n                }\n            else:\n                # Create tasks on each entity\n                for entity in entities:\n                    for count in range(0, int(len(values.keys()) / 2)):\n                        task_type = session.query(\n                            'Type where id is \"{0}\"'.format(\n                                values[\"task_{0}_typeid\".format(count)]\n                            )\n                        ).one()\n\n                        # Get name, or assume task type in lower case as name.\n                        name = values[\"task_{0}_name\".format(count)]\n                        if not name:\n                            name = task_type[\"name\"].lower()\n\n                        self.ensure_task(session, name, task_type, entity)\n\n                session.commit()\n\n                return {\n                    'success': True,\n                    'message': 'Action completed successfully'\n                }\n\n        return {\n            'success': True,\n            'message': \"\",\n            'items': [\n                {\n                    'label': 'Number of tasks',\n                    'type': 'number',\n                    'name': 'number_of_tasks',\n                    'value': 2\n                }\n            ]\n        }\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_clean_hierarchical_attributes.html","title":"action_clean_hierarchical_attributes","text":""},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_clean_hierarchical_attributes.html#client.ayon_ftrack.event_handlers_user.action_clean_hierarchical_attributes.CleanHierarchicalAttrsAction","title":"<code>CleanHierarchicalAttrsAction</code>","text":"<p>               Bases: <code>LocalAction</code></p> Source code in <code>client/ayon_ftrack/event_handlers_user/action_clean_hierarchical_attributes.py</code> <pre><code>class CleanHierarchicalAttrsAction(LocalAction):\n    identifier = \"ayon.clean.hierarchical.attr\"\n    label = \"AYON Admin\"\n    variant = \"- Clean hierarchical custom attributes\"\n    description = \"Unset empty hierarchical attribute values.\"\n    icon = get_ftrack_icon_url(\"AYONAdmin.svg\")\n\n    settings_key = \"clean_hierarchical_attr\"\n\n    def discover(self, session, entities, event):\n        \"\"\"Show only on project entity.\"\"\"\n        if (\n            len(entities) != 1\n            or entities[0].entity_type.lower() != \"project\"\n        ):\n            return False\n\n        return self.valid_roles(session, entities, event)\n\n    def launch(self, session, entities, event):\n        project_id = entities[0][\"id\"]\n\n        user_message = \"This may take some time\"\n        self.show_message(event, user_message, True)\n        self.log.debug(\"Preparing entities for cleanup.\")\n\n        all_entities = session.query(\n            \"select id from TypedContext\"\n            f\" where project_id is \\\"{project_id}\\\"\"\n        ).all()\n\n        entity_ids = {\n            entity[\"id\"]\n            for entity in all_entities\n            if entity.entity_type.lower() != \"task\"\n        }\n        self.log.debug(\n            f\"Collected {len(entity_ids)} entities to process.\"\n        )\n\n        all_attr_confs = session.query(\n            \"select id, key, is_hierarchical\"\n            \" from CustomAttributeConfiguration\"\n        ).all()\n        hier_attr_conf_by_id = {\n            attr_conf[\"id\"]: attr_conf\n            for attr_conf in all_attr_confs\n            if attr_conf[\"is_hierarchical\"]\n        }\n        self.log.debug(\n            f\"Looking for cleanup of {len(hier_attr_conf_by_id)}\"\n            \" hierarchical custom attributes.\"\n        )\n        attr_value_items = query_custom_attribute_values(\n            session, hier_attr_conf_by_id.keys(), entity_ids\n        )\n        values_by_attr_id = {\n            attr_id: []\n            for attr_id in hier_attr_conf_by_id\n        }\n        for value_item in attr_value_items:\n            attr_id = value_item[\"configuration_id\"]\n            if value_item[\"value\"] is None:\n                values_by_attr_id[attr_id].append(value_item)\n\n        for attr_id, none_values in values_by_attr_id.items():\n            if not none_values:\n                continue\n\n            attr = hier_attr_conf_by_id[attr_id]\n            attr_key = attr[\"key\"]\n            self.log.debug(\n                f\"Attribute \\\"{attr_key}\\\" has {len(none_values)}\"\n                \" empty values. Cleaning up.\"\n            )\n            for item in none_values:\n                entity_id = item[\"entity_id\"]\n                entity_key = collections.OrderedDict((\n                    (\"configuration_id\", attr_id),\n                    (\"entity_id\", entity_id)\n                ))\n                session.recorded_operations.push(\n                    ftrack_api.operation.DeleteEntityOperation(\n                        \"CustomAttributeValue\",\n                        entity_key\n                    )\n                )\n            session.commit()\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_clean_hierarchical_attributes.html#client.ayon_ftrack.event_handlers_user.action_clean_hierarchical_attributes.CleanHierarchicalAttrsAction.discover","title":"<code>discover(session, entities, event)</code>","text":"<p>Show only on project entity.</p> Source code in <code>client/ayon_ftrack/event_handlers_user/action_clean_hierarchical_attributes.py</code> <pre><code>def discover(self, session, entities, event):\n    \"\"\"Show only on project entity.\"\"\"\n    if (\n        len(entities) != 1\n        or entities[0].entity_type.lower() != \"project\"\n    ):\n        return False\n\n    return self.valid_roles(session, entities, event)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_client_review_sort.html","title":"action_client_review_sort","text":""},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_component_open.html","title":"action_component_open","text":""},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_create_cust_attrs.html","title":"action_create_cust_attrs","text":"<p>This action creates/updates custom attributes.</p>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_create_cust_attrs.html#client.ayon_ftrack.event_handlers_user.action_create_cust_attrs--first-part-take-care-about-special-attributes","title":"First part take care about special attributes","text":"<pre><code>- AYON attributes defined in code because they use constants\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_create_cust_attrs.html#client.ayon_ftrack.event_handlers_user.action_create_cust_attrs--second-part-is-based-on-json-file-in-ftrack-module","title":"Second part is based on json file in ftrack module.","text":"<p>File location: <code>./common/custom_attributes.json</code></p> <p>Data in json file is nested dictionary. Keys in first dictionary level represents ftrack entity type (task, show, assetversion, user, list, asset) and dictionary value define attribute.</p> <p>There is special key for hierchical attributes <code>is_hierarchical</code>.</p> <p>Entity types <code>task</code> requires to define task object type (Folder, Shot, Sequence, Task, Library, Milestone, Episode, Asset Build, etc.) at second dictionary level, task's attributes are nested more.</p> <p>*** Not Changeable *********</p> <p>group (string)     - name of group     - based on attribute <code>common.constants.CUST_ATTR_GROUP</code>         - \"pype\" by default</p> <p>*** Required *********</p> <p>label (string)     - label that will show in ftrack</p> <p>key (string)     - must contain only chars [a-z0-9_]</p> <p>type (string)     - type of custom attribute     - possibilities:         text, boolean, date, enumerator, dynamic enumerator, number</p> <p>*** Required with conditions *******</p> <p>config (dictionary)     - for each attribute type different requirements and possibilities:         - enumerator:             multiSelect = True/False(default: False)             data = {key_1:value_1,key_2:value_2,..,key_n:value_n}                 - 'data' is Required value with enumerator                 - 'key' must contain only chars [a-z0-9_]</p> <pre><code>    - number:\n        isdecimal = True/False(default: False)\n\n    - text:\n        markdown = True/False(default: False)\n</code></pre> <p>*** Presetable keys **********</p> <p>write_security_roles/read_security_roles (array of strings)     - default: [\"ALL\"]     - strings should be role names (e.g.: [\"API\", \"Administrator\"])     - if set to [\"ALL\"] - all roles will be availabled     - if first is 'except' - roles will be set to all except roles in array         - Warning: Be carefull with except - roles can be different by company         - example:             write_security_roles = [\"except\", \"User\"]             read_security_roles = [\"ALL\"] # (User is can only read)</p> <p>default     - default: None     - sets default value for custom attribute:         - text -&gt; string         - number -&gt; integer         - enumerator -&gt; array with string of key/s         - boolean -&gt; bool true/false         - date -&gt; string in format: 'YYYY.MM.DD' or 'YYYY.MM.DD HH:mm:ss'             - example: \"2018.12.24\" / \"2018.1.1 6:0:0\"         - dynamic enumerator -&gt; DON'T HAVE DEFAULT VALUE!!!</p> <p>Example:</p> <pre><code>\"show\": {\n    \"ayon_auto_sync\": {\n      \"label\": \"AYON auto-sync\",\n      \"type\": \"boolean\",\n      \"write_security_roles\": [\"API\", \"Administrator\"],\n      \"read_security_roles\": [\"API\", \"Administrator\"]\n    }\n},\n\"is_hierarchical\": {\n    \"fps\": {\n        \"label\": \"FPS\",\n        \"type\": \"number\",\n        \"config\": {\"isdecimal\": true}\n    }\n},\n\"task\": {\n    \"library\": {\n        \"my_attr_name\": {\n            \"label\": \"My Attr\",\n            \"type\": \"number\"\n        }\n    }\n}\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_create_folders.html","title":"action_create_folders","text":""},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_create_folders.html#client.ayon_ftrack.event_handlers_user.action_create_folders.CreateFolders","title":"<code>CreateFolders</code>","text":"<p>               Bases: <code>LocalAction</code></p> Source code in <code>client/ayon_ftrack/event_handlers_user/action_create_folders.py</code> <pre><code>class CreateFolders(LocalAction):\n    identifier = \"ayon.create.folders\"\n    label = \"Create Folders\"\n    icon = get_ftrack_icon_url(\"CreateFolders.svg\")\n\n    def discover(self, session, entities, event):\n        for entity_item in event[\"data\"][\"selection\"]:\n            if entity_item.get(\"entityType\").lower() in (\"task\", \"show\"):\n                return True\n        return False\n\n    def interface(self, session, entities, event):\n        if event[\"data\"].get(\"values\", {}):\n            return\n\n        with_interface = False\n        for entity in entities:\n            if entity.entity_type.lower() != \"task\":\n                with_interface = True\n                break\n\n        if \"values\" not in event[\"data\"]:\n            event[\"data\"][\"values\"] = {}\n\n        event[\"data\"][\"values\"][\"with_interface\"] = with_interface\n        if not with_interface:\n            return\n\n        title = \"Create folders\"\n\n        entity_name = entity[\"name\"]\n        msg = (\n            \"&lt;h2&gt;Do you want create folders also\"\n            \" for all children of your selection?&lt;/h2&gt;\"\n        )\n        if entity.entity_type.lower() == \"project\":\n            entity_name = entity[\"full_name\"]\n            msg = msg.replace(\" also\", \"\")\n            msg += \"&lt;h3&gt;(Project root won't be created if not checked)&lt;/h3&gt;\"\n        items = [\n            {\n                \"type\": \"label\",\n                \"value\": msg.format(entity_name)\n            },\n            {\n                \"type\": \"label\",\n                \"value\": \"With all chilren entities\"\n            },\n            {\n                \"name\": \"children_included\",\n                \"type\": \"boolean\",\n                \"value\": False\n            },\n            {\n                \"type\": \"hidden\",\n                \"name\": \"with_interface\",\n                \"value\": with_interface\n            }\n        ]\n\n        return {\n            \"items\": items,\n            \"title\": title\n        }\n\n    def launch(self, session, entities, event):\n        if \"values\" not in event[\"data\"]:\n            return\n\n        with_interface = event[\"data\"][\"values\"][\"with_interface\"]\n        with_childrens = True\n        if with_interface:\n            with_childrens = event[\"data\"][\"values\"][\"children_included\"]\n\n        filtered_entities = []\n        for entity in entities:\n            low_context_type = entity[\"context_type\"].lower()\n            if low_context_type in (\"task\", \"show\"):\n                if not with_childrens and low_context_type == \"show\":\n                    continue\n                filtered_entities.append(entity)\n\n        if not filtered_entities:\n            return {\n                \"success\": True,\n                \"message\": \"Nothing was created\"\n            }\n\n        project_entity = self.get_project_from_entity(filtered_entities[0])\n\n        project_name = project_entity[\"full_name\"]\n        ayon_project = ayon_api.get_project(project_name)\n        if not ayon_project:\n            return {\n                \"success\": False,\n                \"message\": f\"Project '{project_name}' was not found in AYON.\",\n            }\n\n        project_code = project_entity[\"name\"]\n\n        task_entities, other_entities = self.get_all_entities(\n            session, entities\n        )\n        hierarchy = self.get_entities_hierarchy(\n            session, task_entities, other_entities\n        )\n        task_types = session.query(\"select id, name from Type\").all()\n        task_type_names_by_id = {\n            task_type[\"id\"]: task_type[\"name\"]\n            for task_type in task_types\n        }\n\n        anatomy = Anatomy(project_name, project_entity=ayon_project)\n\n        work_template = anatomy.get_template_item(\n            \"work\", \"default\", \"directory\"\n        )\n        publish_template = anatomy.get_template_item(\n            \"publish\", \"default\", \"directory\"\n        )\n\n        project_data = {\n            \"project\": {\n                \"name\": project_name,\n                \"code\": project_code\n            }\n        }\n\n        collected_paths = []\n        for item in hierarchy:\n            parent_entity, task_entities = item\n\n            parent_data = copy.deepcopy(project_data)\n\n            parents = parent_entity[\"link\"][1:-1]\n            hierarchy_names = [p[\"name\"] for p in parents]\n            hierarchy = \"/\".join(hierarchy_names)\n\n            if hierarchy_names:\n                parent_name = hierarchy_names[-1]\n            else:\n                parent_name = project_name\n\n            parent_data.update({\n                \"asset\": parent_entity[\"name\"],\n                \"hierarchy\": hierarchy,\n                \"parent\": parent_name,\n                \"folder\": {\n                    \"name\": parent_entity[\"name\"]\n                }\n            })\n\n            if not task_entities:\n                # create path for entity\n                collected_paths.append(self.compute_template(\n                    parent_data, work_template\n                ))\n                collected_paths.append(self.compute_template(\n                    parent_data, publish_template\n                ))\n                continue\n\n            for task_entity in task_entities:\n                task_type_id = task_entity[\"type_id\"]\n                task_type_name = task_type_names_by_id[task_type_id]\n                task_data = copy.deepcopy(parent_data)\n                task_data[\"task\"] = {\n                    \"name\": task_entity[\"name\"],\n                    \"type\": task_type_name\n                }\n\n                # Template wok\n                collected_paths.append(self.compute_template(\n                    task_data, work_template\n                ))\n\n                # Template publish\n                collected_paths.append(self.compute_template(\n                    task_data, publish_template\n                ))\n\n        if len(collected_paths) == 0:\n            return {\n                \"success\": True,\n                \"message\": \"No project folders to create.\"\n            }\n\n        self.log.info(\"Creating folders:\")\n\n        for path in set(collected_paths):\n            self.log.info(path)\n            if not os.path.exists(path):\n                os.makedirs(path)\n\n        return {\n            \"success\": True,\n            \"message\": \"Successfully created project folders.\"\n        }\n\n    def get_all_entities(self, session, entities):\n        \"\"\"\n\n        Args:\n            session (ftrack_api.session.Session): ftrack session.\n            entities (list[ftrack_api.entity.base.Entity]): List of entities.\n\n        Returns:\n            tuple[list, list]: Tuple where first item is list of task entities\n                and second item is list of entities that are not task\n                entities. All are entities that were passed in and\n                their children.\n        \"\"\"\n\n        task_entities = []\n        other_entities = []\n\n        query_queue = collections.deque()\n        query_queue.append(entities)\n        while query_queue:\n            entities = query_queue.popleft()\n            if not entities:\n                continue\n\n            no_task_entities = []\n            for entity in entities:\n                if entity.entity_type.lower() == \"task\":\n                    task_entities.append(entity)\n                else:\n                    no_task_entities.append(entity)\n\n            if not no_task_entities:\n                continue\n\n            other_entities.extend(no_task_entities)\n\n            no_task_entity_ids = {entity[\"id\"] for entity in no_task_entities}\n            next_entities = session.query(\n                (\n                    \"select id, parent_id\"\n                    \" from TypedContext where parent_id in ({})\"\n                ).format(self.join_query_keys(no_task_entity_ids))\n            ).all()\n            query_queue.append(next_entities)\n        return task_entities, other_entities\n\n    def get_entities_hierarchy(self, session, task_entities, other_entities):\n        \"\"\"\n\n        Args:\n            session (ftrack_api.session.Session): ftrack session.\n            task_entities (list[ftrack_api.entity.base.Entity]): List of task\n                entities.\n            other_entities (list[ftrack_api.entity.base.Entity]): List of\n                entities that are not task entities.\n\n        Returns:\n            list[tuple[ftrack_api.entity.base.Entity, list]]: List of tuples\n                where first item is parent entity and second item is list of\n                task entities that are children of parent entity.\n        \"\"\"\n\n        output = []\n        task_entity_ids = {entity[\"id\"] for entity in task_entities}\n        if not task_entity_ids:\n            return output\n\n        full_task_entities = session.query(\n            (\n                \"select id, name, type_id, parent_id\"\n                \" from TypedContext where id in ({})\"\n            ).format(self.join_query_keys(task_entity_ids))\n        ).all()\n        task_entities_by_parent_id = collections.defaultdict(list)\n        for entity in full_task_entities:\n            parent_id = entity[\"parent_id\"]\n            task_entities_by_parent_id[parent_id].append(entity)\n\n        if not task_entities_by_parent_id:\n            return output\n\n        parent_ids = set(task_entities_by_parent_id.keys())\n\n        other_entities_by_id = {\n            entity[\"id\"]: entity\n            for entity in other_entities\n        }\n        parent_ids -= set(other_entities_by_id.keys())\n\n        if parent_ids:\n            parent_entities = session.query(\n                (\n                    \"select id, name from TypedContext where id in ({})\"\n                ).format(self.join_query_keys(parent_ids))\n            ).all()\n            other_entities_by_id.update({\n                entity[\"id\"]: entity\n                for entity in parent_entities\n            })\n\n        for parent_id, parent_entity in other_entities_by_id.items():\n            output.append((\n                parent_entity,\n                task_entities_by_parent_id[parent_id]\n            ))\n\n        return output\n\n    def compute_template(self, data, template):\n        filled_template = template.format(data)\n        if filled_template.solved:\n            return os.path.normpath(filled_template)\n\n        self.log.warning(\n            \"Template \\\"{}\\\" was not fully filled \\\"{}\\\"\".format(\n                filled_template.template, filled_template\n            )\n        )\n        return os.path.normpath(filled_template.split(\"{\")[0])\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_create_folders.html#client.ayon_ftrack.event_handlers_user.action_create_folders.CreateFolders.get_all_entities","title":"<code>get_all_entities(session, entities)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>ftrack session.</p> required <code>entities</code> <code>list[Entity]</code> <p>List of entities.</p> required <p>Returns:</p> Type Description <p>tuple[list, list]: Tuple where first item is list of task entities and second item is list of entities that are not task entities. All are entities that were passed in and their children.</p> Source code in <code>client/ayon_ftrack/event_handlers_user/action_create_folders.py</code> <pre><code>def get_all_entities(self, session, entities):\n    \"\"\"\n\n    Args:\n        session (ftrack_api.session.Session): ftrack session.\n        entities (list[ftrack_api.entity.base.Entity]): List of entities.\n\n    Returns:\n        tuple[list, list]: Tuple where first item is list of task entities\n            and second item is list of entities that are not task\n            entities. All are entities that were passed in and\n            their children.\n    \"\"\"\n\n    task_entities = []\n    other_entities = []\n\n    query_queue = collections.deque()\n    query_queue.append(entities)\n    while query_queue:\n        entities = query_queue.popleft()\n        if not entities:\n            continue\n\n        no_task_entities = []\n        for entity in entities:\n            if entity.entity_type.lower() == \"task\":\n                task_entities.append(entity)\n            else:\n                no_task_entities.append(entity)\n\n        if not no_task_entities:\n            continue\n\n        other_entities.extend(no_task_entities)\n\n        no_task_entity_ids = {entity[\"id\"] for entity in no_task_entities}\n        next_entities = session.query(\n            (\n                \"select id, parent_id\"\n                \" from TypedContext where parent_id in ({})\"\n            ).format(self.join_query_keys(no_task_entity_ids))\n        ).all()\n        query_queue.append(next_entities)\n    return task_entities, other_entities\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_create_folders.html#client.ayon_ftrack.event_handlers_user.action_create_folders.CreateFolders.get_entities_hierarchy","title":"<code>get_entities_hierarchy(session, task_entities, other_entities)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>ftrack session.</p> required <code>task_entities</code> <code>list[Entity]</code> <p>List of task entities.</p> required <code>other_entities</code> <code>list[Entity]</code> <p>List of entities that are not task entities.</p> required <p>Returns:</p> Type Description <p>list[tuple[ftrack_api.entity.base.Entity, list]]: List of tuples where first item is parent entity and second item is list of task entities that are children of parent entity.</p> Source code in <code>client/ayon_ftrack/event_handlers_user/action_create_folders.py</code> <pre><code>def get_entities_hierarchy(self, session, task_entities, other_entities):\n    \"\"\"\n\n    Args:\n        session (ftrack_api.session.Session): ftrack session.\n        task_entities (list[ftrack_api.entity.base.Entity]): List of task\n            entities.\n        other_entities (list[ftrack_api.entity.base.Entity]): List of\n            entities that are not task entities.\n\n    Returns:\n        list[tuple[ftrack_api.entity.base.Entity, list]]: List of tuples\n            where first item is parent entity and second item is list of\n            task entities that are children of parent entity.\n    \"\"\"\n\n    output = []\n    task_entity_ids = {entity[\"id\"] for entity in task_entities}\n    if not task_entity_ids:\n        return output\n\n    full_task_entities = session.query(\n        (\n            \"select id, name, type_id, parent_id\"\n            \" from TypedContext where id in ({})\"\n        ).format(self.join_query_keys(task_entity_ids))\n    ).all()\n    task_entities_by_parent_id = collections.defaultdict(list)\n    for entity in full_task_entities:\n        parent_id = entity[\"parent_id\"]\n        task_entities_by_parent_id[parent_id].append(entity)\n\n    if not task_entities_by_parent_id:\n        return output\n\n    parent_ids = set(task_entities_by_parent_id.keys())\n\n    other_entities_by_id = {\n        entity[\"id\"]: entity\n        for entity in other_entities\n    }\n    parent_ids -= set(other_entities_by_id.keys())\n\n    if parent_ids:\n        parent_entities = session.query(\n            (\n                \"select id, name from TypedContext where id in ({})\"\n            ).format(self.join_query_keys(parent_ids))\n        ).all()\n        other_entities_by_id.update({\n            entity[\"id\"]: entity\n            for entity in parent_entities\n        })\n\n    for parent_id, parent_entity in other_entities_by_id.items():\n        output.append((\n            parent_entity,\n            task_entities_by_parent_id[parent_id]\n        ))\n\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_create_project_structure.html","title":"action_create_project_structure","text":""},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_create_project_structure.html#client.ayon_ftrack.event_handlers_user.action_create_project_structure.CreateProjectFolders","title":"<code>CreateProjectFolders</code>","text":"<p>               Bases: <code>LocalAction</code></p> <p>Action create folder structure and may create hierarchy in ftrack.</p> <p>Creation of folder structure and hierarchy in ftrack is based on settings.</p> <p>Example of content:</p> <pre><code>{\n    \"__project_root__\": {\n        \"prod\" : {},\n        \"resources\" : {\n          \"footage\": {\n            \"plates\": {},\n            \"offline\": {}\n          },\n          \"audio\": {},\n          \"art_dept\": {}\n        },\n        \"editorial\" : {},\n        \"assets[ftrack.Library]\": {\n          \"characters[ftrack]\": {},\n          \"locations[ftrack]\": {}\n        },\n        \"shots[ftrack.Sequence]\": {\n          \"scripts\": {},\n          \"editorial[ftrack.Folder]\": {}\n        }\n    }\n}\n</code></pre> <p>Key \"project_root\" indicates root folder (or entity). Each key in dictionary represents folder name. Value may contain another dictionary with subfolders.</p> <p>Identifier <code>[ftrack]</code> in name says that this should be also created in ftrack hierarchy. It is possible to specify entity type of item with \".\" . If key is <code>assets[ftrack.Library]</code> then in ftrack will be created entity with name \"assets\" and entity type \"Library\". It is expected Library entity type exist in ftrack.</p> Source code in <code>client/ayon_ftrack/event_handlers_user/action_create_project_structure.py</code> <pre><code>class CreateProjectFolders(LocalAction):\n    \"\"\"Action create folder structure and may create hierarchy in ftrack.\n\n    Creation of folder structure and hierarchy in ftrack is based on settings.\n\n    Example of content:\n    ```json\n    {\n        \"__project_root__\": {\n            \"prod\" : {},\n            \"resources\" : {\n              \"footage\": {\n                \"plates\": {},\n                \"offline\": {}\n              },\n              \"audio\": {},\n              \"art_dept\": {}\n            },\n            \"editorial\" : {},\n            \"assets[ftrack.Library]\": {\n              \"characters[ftrack]\": {},\n              \"locations[ftrack]\": {}\n            },\n            \"shots[ftrack.Sequence]\": {\n              \"scripts\": {},\n              \"editorial[ftrack.Folder]\": {}\n            }\n        }\n    }\n    ```\n    Key \"__project_root__\" indicates root folder (or entity). Each key in\n    dictionary represents folder name. Value may contain another dictionary\n    with subfolders.\n\n    Identifier `[ftrack]` in name says that this should be also created in\n    ftrack hierarchy. It is possible to specify entity type of item with \".\" .\n    If key is `assets[ftrack.Library]` then in ftrack will be created entity\n    with name \"assets\" and entity type \"Library\". It is expected Library entity\n    type exist in ftrack.\n    \"\"\"\n\n    identifier = \"ayon.create.project.structure\"\n    label = \"Create Project Structure\"\n    description = \"Creates folder structure\"\n    role_list = [\"Administrator\", \"Project Manager\"]\n    icon = get_ftrack_icon_url(\"CreateProjectFolders.svg\")\n\n    pattern_array = re.compile(r\"\\[.*\\]\")\n    pattern_ftrack = re.compile(r\".*\\[[.]*ftrack[.]*\")\n    pattern_ent_ftrack = re.compile(r\"ftrack\\.[^.,\\],\\s,]*\")\n    pattern_template = re.compile(r\"\\{.*\\}\")\n    project_root_key = \"__project_root__\"\n\n    def discover(self, session, entities, event):\n        if len(entities) != 1:\n            return False\n\n        if entities[0].entity_type.lower() != \"project\":\n            return False\n\n        return True\n\n    def launch(self, session, entities, event):\n        # Get project entity\n        project_entity = self.get_project_from_entity(entities[0])\n        project_name = project_entity[\"full_name\"]\n        ayon_project = ayon_api.get_project(project_name)\n        if not ayon_project:\n            return {\n                \"success\": False,\n                \"message\": f\"Project '{project_name}' was not found in AYON.\",\n            }\n\n        try:\n            # Get paths based on presets\n            basic_paths = get_project_basic_paths(project_name)\n            if not basic_paths:\n                return {\n                    \"success\": False,\n                    \"message\": \"Project structure is not set.\"\n                }\n\n            # Invoking AYON API to create the project folders\n            create_project_folders(project_name, basic_paths)\n            self.create_ftrack_entities(basic_paths, project_entity)\n\n            self.trigger_event(\n                \"ayon.project.structure.created\",\n                {\"project_name\": project_name}\n            )\n\n        except Exception as exc:\n            self.log.warning(\"Creating of structure crashed.\", exc_info=True)\n            session.rollback()\n            return {\n                \"success\": False,\n                \"message\": str(exc)\n            }\n\n        return True\n\n    def get_ftrack_paths(self, paths_items):\n        all_ftrack_paths = []\n        for path_items in paths_items:\n            if not path_items:\n                continue\n\n            ftrack_path_items = []\n            is_ftrack = False\n            for item in reversed(path_items):\n                # QUESTION Why this not validated only on first item?\n                if (\n                    item == self.project_root_key\n                    # Fix to skip any formatting items (I don't like it!)\n                    # - '{root[work]}' and '{project[name]}'\n                    or self.pattern_template.match(item)\n                ):\n                    continue\n\n                if is_ftrack:\n                    ftrack_path_items.append(item)\n                elif self.pattern_ftrack.match(item):\n                    ftrack_path_items.append(item)\n                    is_ftrack = True\n\n            ftrack_path_items = list(reversed(ftrack_path_items))\n            if ftrack_path_items:\n                all_ftrack_paths.append(ftrack_path_items)\n        return all_ftrack_paths\n\n    def compute_ftrack_items(self, in_list, keys):\n        if len(keys) == 0:\n            return in_list\n        key = keys[0]\n        exist = None\n        for index, subdict in enumerate(in_list):\n            if key in subdict:\n                exist = index\n                break\n        if exist is not None:\n            in_list[exist][key] = self.compute_ftrack_items(\n                in_list[exist][key], keys[1:]\n            )\n        else:\n            in_list.append({key: self.compute_ftrack_items([], keys[1:])})\n        return in_list\n\n    def translate_ftrack_items(self, paths_items):\n        main = []\n        for path_items in paths_items:\n            main = self.compute_ftrack_items(main, path_items)\n        return main\n\n    def create_ftrack_entities(self, basic_paths, project_ent):\n        only_ftrack_items = self.get_ftrack_paths(basic_paths)\n        ftrack_paths = self.translate_ftrack_items(only_ftrack_items)\n\n        for separation in ftrack_paths:\n            parent = project_ent\n            self.trigger_creation(separation, parent)\n\n    def trigger_creation(self, separation, parent):\n        for item, subvalues in separation.items():\n            matches = self.pattern_array.findall(item)\n            ent_type = \"Folder\"\n            if len(matches) == 0:\n                name = item\n            else:\n                match = matches[0]\n                name = item.replace(match, \"\")\n                ent_type_match = self.pattern_ent_ftrack.findall(match)\n                if len(ent_type_match) &gt; 0:\n                    ent_type_split = ent_type_match[0].split(\".\")\n                    if len(ent_type_split) == 2:\n                        ent_type = ent_type_split[1]\n            new_parent = self.create_ftrack_entity(name, ent_type, parent)\n            if subvalues:\n                for subvalue in subvalues:\n                    self.trigger_creation(subvalue, new_parent)\n\n    def create_ftrack_entity(self, name, ent_type, parent):\n        for children in parent[\"children\"]:\n            if children[\"name\"] == name:\n                return children\n        data = {\n            \"name\": name,\n            \"parent_id\": parent[\"id\"]\n        }\n        if parent.entity_type.lower() == \"project\":\n            data[\"project_id\"] = parent[\"id\"]\n        else:\n            data[\"project_id\"] = parent[\"project\"][\"id\"]\n\n        existing_entity = self.session.query((\n            \"TypedContext where name is \\\"{}\\\" and \"\n            \"parent_id is \\\"{}\\\" and project_id is \\\"{}\\\"\"\n        ).format(name, data[\"parent_id\"], data[\"project_id\"])).first()\n        if existing_entity:\n            return existing_entity\n\n        new_ent = self.session.create(ent_type, data)\n        self.session.commit()\n        return new_ent\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_delivery.html","title":"action_delivery","text":""},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_delivery.html#client.ayon_ftrack.event_handlers_user.action_delivery.Delivery","title":"<code>Delivery</code>","text":"<p>               Bases: <code>LocalAction</code></p> Source code in <code>client/ayon_ftrack/event_handlers_user/action_delivery.py</code> <pre><code>class Delivery(LocalAction):\n    identifier = \"delivery.action\"\n    label = \"Delivery\"\n    description = \"Deliver data to client\"\n    role_list = [\"Administrator\", \"Project manager\"]\n    icon = get_ftrack_icon_url(\"Delivery.svg\")\n    settings_key = \"delivery_action\"\n\n    def discover(self, session, entities, event):\n        is_valid = False\n        for entity in entities:\n            if entity.entity_type.lower() in (\"assetversion\", \"reviewsession\"):\n                is_valid = True\n                break\n\n        if is_valid:\n            is_valid = self.valid_roles(session, entities, event)\n        return is_valid\n\n    def interface(self, session, entities, event):\n        if event[\"data\"].get(\"values\"):\n            return\n\n        title = \"Delivery data to Client\"\n\n        items = []\n        item_splitter = {\"type\": \"label\", \"value\": \"---\"}\n\n        project_entity = self.get_project_from_entity(entities[0])\n        project_name = project_entity[\"full_name\"]\n        project_entity = get_project(project_name, fields=[\"name\"])\n        if not project_entity:\n            return {\n                \"success\": False,\n                \"message\": f\"Project \\\"{project_name}\\\" not found in AYON.\"\n            }\n\n        review_session_ids = set()\n        for entity in entities:\n            entity_type_low = entity.entity_type.lower()\n            if entity_type_low == \"reviewsession\":\n                review_session_ids.add(entity[\"id\"])\n\n        session_name = None\n        if review_session_ids:\n            joined_ids = self.join_query_keys(review_session_ids)\n            for review_session in session.query(\n                f\"select name from ReviewSession where id in ({joined_ids})\"\n            ).all():\n                session_name = review_session[\"name\"]\n                break\n\n        if session_name is None:\n            datetime_data = get_datetime_data()\n            session_name = \"{yy}{mm}{dd}\".format_map(datetime_data)\n\n        repre_names = self._get_repre_names(project_name, session, entities)\n\n        items.append({\n            \"type\": \"hidden\",\n            \"name\": \"__project_name__\",\n            \"value\": project_name\n        })\n\n        # Prepare anatomy data\n        anatomy = Anatomy(project_name)\n        first = None\n        delivery_templates = anatomy.templates.get(\"delivery\") or {}\n        default_keys = {\n            \"frame\", \"version\", \"frame_padding\", \"version_padding\"\n        }\n        delivery_templates_items = []\n        for key, template in delivery_templates.items():\n            if key in default_keys:\n                continue\n            # Use only keys with `{root}` or `{root[*]}` in value\n            delivery_templates_items.append({\n                \"label\": key,\n                \"value\": key\n            })\n            if first is None:\n                first = key\n\n        skipped = False\n        # Add message if there are any common components\n        if not repre_names or not delivery_templates_items:\n            skipped = True\n            items.append({\n                \"type\": \"label\",\n                \"value\": \"&lt;h1&gt;Something went wrong:&lt;/h1&gt;\"\n            })\n\n        items.append({\n            \"type\": \"hidden\",\n            \"name\": \"__skipped__\",\n            \"value\": skipped\n        })\n\n        if not repre_names:\n            if len(entities) == 1:\n                items.append({\n                    \"type\": \"label\",\n                    \"value\": (\n                        \"- Selected entity doesn't have components to deliver.\"\n                    )\n                })\n            else:\n                items.append({\n                    \"type\": \"label\",\n                    \"value\": (\n                        \"- Selected entities don't have common components.\"\n                    )\n                })\n\n        # Add message if delivery anatomies are not set\n        if not delivery_templates_items:\n            items.append({\n                \"type\": \"label\",\n                \"value\": (\n                    \"- `\\\"delivery\\\"` anatomy key is not set in config.\"\n                )\n            })\n\n        # Skip if there are any data shortcomings\n        if skipped:\n            return {\n                \"items\": items,\n                \"title\": title\n            }\n\n        items.append({\n            \"value\": \"&lt;h2&gt;Session name used in template&lt;/h2&gt;\",\n            \"type\": \"label\",\n        })\n        items.append({\n            \"type\": \"text\",\n            \"value\": session_name,\n            \"name\": \"__session_name__\",\n        })\n\n        items.append({\n            \"value\": \"&lt;h1&gt;Choose Components to deliver&lt;/h1&gt;\",\n            \"type\": \"label\"\n        })\n\n        for repre_name in repre_names:\n            items.append({\n                \"type\": \"boolean\",\n                \"value\": False,\n                \"label\": repre_name,\n                \"name\": repre_name\n            })\n\n        items.append(item_splitter)\n\n        items.append({\n            \"value\": \"&lt;h2&gt;Choose delivery template&lt;/h2&gt;\",\n            \"type\": \"label\",\n        })\n\n        items.append({\n            \"type\": \"enumerator\",\n            \"name\": \"__delivery_template__\",\n            \"data\": delivery_templates_items,\n            \"value\": first,\n        })\n\n        items.append(item_splitter)\n\n        items.append({\n            \"value\": \"&lt;h2&gt;Location for delivery&lt;/h2&gt;\",\n            \"type\": \"label\"\n        })\n\n        items.append({\n            \"type\": \"label\",\n            \"value\": (\n                \"&lt;i&gt;NOTE: It is possible to replace `root` key in anatomy.&lt;/i&gt;\"\n            )\n        })\n\n        items.append({\n            \"type\": \"text\",\n            \"name\": \"__location_path__\",\n            \"empty_text\": \"Type location path here...(Optional)\",\n        })\n\n        return {\n            \"items\": items,\n            \"title\": title\n        }\n\n    def launch(self, session, entities, event):\n        values = event[\"data\"].get(\"values\")\n        if not values:\n            return {\n                \"success\": True,\n                \"message\": \"Nothing to do\"\n            }\n\n        if FTRACK_ID_ATTRIB not in get_attributes_for_type(\"folder\"):\n            return {\n                \"success\": False,\n                \"message\": (\n                    f\"AYON server does not have '{FTRACK_ID_ATTRIB}'\"\n                    \" attribute available.\"\n                )\n            }\n\n        skipped = values.pop(\"__skipped__\")\n        if skipped:\n            return {\n                \"success\": False,\n                \"message\": \"Action skipped\"\n            }\n\n        user_id = event[\"source\"][\"user\"][\"id\"]\n        user_entity = session.query(\n            \"User where id is {}\".format(user_id)\n        ).one()\n\n        job = session.create(\"Job\", {\n            \"user\": user_entity,\n            \"status\": \"running\",\n            \"data\": json.dumps({\n                \"description\": \"Delivery processing.\"\n            })\n        })\n        session.commit()\n\n        try:\n            report = self.real_launch(session, entities, event)\n\n        except Exception as exc:\n            report = {\n                \"success\": False,\n                \"title\": \"Delivery failed\",\n                \"items\": [{\n                    \"type\": \"label\",\n                    \"value\": (\n                        \"Error during delivery action process:&lt;br&gt;{}\"\n                        \"&lt;br&gt;&lt;br&gt;Check logs for more information.\"\n                    ).format(str(exc))\n                }]\n            }\n            self.log.warning(\n                \"Failed during processing delivery action.\",\n                exc_info=True\n            )\n\n        finally:\n            if report[\"success\"]:\n                job[\"status\"] = \"done\"\n            else:\n                job[\"status\"] = \"failed\"\n            session.commit()\n\n        if not report[\"success\"]:\n            self.show_interface(\n                items=report[\"items\"],\n                title=report[\"title\"],\n                event=event\n            )\n            return {\n                \"success\": False,\n                \"message\": \"Errors during delivery process. See report.\"\n            }\n\n        return report\n\n    def real_launch(self, session, entities, event):\n        self.log.info(\"Delivery action just started.\")\n        report_items = collections.defaultdict(list)\n\n        values = event[\"data\"][\"values\"]\n\n        location_path = values.pop(\"__location_path__\")\n        template_name = values.pop(\"__delivery_template__\")\n        project_name = values.pop(\"__project_name__\")\n        session_name = values.pop(\"__session_name__\")\n\n        repre_names = set()\n        for key, value in values.items():\n            if value is True:\n                repre_names.add(key)\n\n        if not repre_names:\n            return {\n                \"success\": True,\n                \"message\": \"No selected components to deliver.\"\n            }\n\n        location_path = location_path.strip()\n        if location_path:\n            location_path = os.path.normpath(location_path)\n            if not os.path.exists(location_path):\n                os.makedirs(location_path)\n\n        self.log.debug(\"Collecting representations to process.\")\n        version_ids = self._get_interest_version_ids(\n            project_name, session, entities\n        )\n        repres_to_deliver = list(get_representations(\n            project_name,\n            representation_names=repre_names,\n            version_ids=version_ids\n        ))\n        repre_ids = {repre[\"id\"] for repre in repres_to_deliver}\n        template_data_by_repre_id = (\n            get_representations_delivery_template_data(\n                project_name, repre_ids\n            )\n        )\n        anatomy = Anatomy(project_name)\n\n        format_dict = get_format_dict(anatomy, location_path)\n\n        datetime_data = get_datetime_data()\n        repres_counter = len(repres_to_deliver)\n        for idx, repre in enumerate(repres_to_deliver):\n            repre_id = repre[\"id\"]\n            repre_path = get_representation_path_with_anatomy(\n                repre, anatomy\n            )\n            self.log.debug(\n                f\"Processing representation {idx + 1}/{repres_counter}\"\n                f\" '{repre_id}'\"\n            )\n            template_data = template_data_by_repre_id[repre_id]\n            if session_name:\n                template_data[\"ftrack\"] = {\n                    \"session_name\": session_name,\n                }\n            new_report_items = check_destination_path(\n                repre_id,\n                anatomy,\n                template_data,\n                datetime_data,\n                template_name\n            )\n\n            if new_report_items:\n                report_items.update(new_report_items)\n                continue\n\n            args = [\n                repre_path,\n                repre,\n                anatomy,\n                template_name,\n                template_data,\n                format_dict,\n                report_items,\n                self.log\n            ]\n            src_paths = []\n            for repre_file in repre[\"files\"]:\n                src_path = anatomy.fill_root(repre_file[\"path\"])\n                src_paths.append(src_path)\n            sources_and_frames = collect_frames(src_paths)\n            for src_path, frame in sources_and_frames.items():\n                args[0] = src_path\n                if frame is not None:\n                    if repre[\"context\"].get(\"frame\"):\n                        template_data[\"frame\"] = frame\n                    elif repre[\"context\"].get(\"udim\"):\n                        template_data[\"udim\"] = frame\n                    else:\n                        # Fallback\n                        self.log.warning(\n                            \"Representation context has no frame or udim\"\n                            \" data. Supplying sequence frame to '{frame}'\"\n                            \" formatting data.\"\n                        )\n                        template_data[\"frame\"] = frame\n                new_report_items, uploaded = deliver_single_file(*args)\n                report_items.update(new_report_items)\n        return self.report(report_items)\n\n    def report(self, report_items):\n        \"\"\"Returns dict with final status of delivery (success, fail etc.).\n\n        Args:\n            report_items (dict[str, Union[str, list[str]]]: Dict with report\n                items to be shown to user.\n\n        Returns:\n            dict[str, Any]: Dict with final status of delivery.\n        \"\"\"\n\n        all_items = []\n\n        for msg, items in report_items.items():\n            if not items:\n                continue\n\n            if all_items:\n                all_items.append({\"type\": \"label\", \"value\": \"---\"})\n\n            all_items.append({\n                \"type\": \"label\",\n                \"value\": \"# {}\".format(msg)\n            })\n            if not isinstance(items, (list, tuple)):\n                items = [items]\n\n            all_items.append({\n                \"type\": \"label\",\n                \"value\": \"&lt;p&gt;{}&lt;/p&gt;\".format(\n                    \"&lt;br&gt;\".join([str(item) for item in items])\n                )\n            })\n\n        if not all_items:\n            return {\n                \"success\": True,\n                \"message\": \"Delivery Finished\"\n            }\n\n        return {\n            \"items\": all_items,\n            \"title\": \"Delivery report\",\n            \"success\": False\n        }\n\n    def _get_repre_names(self, project_name, session, entities):\n        \"\"\"\n\n        Args:\n            project_name (str): Project name.\n            session (ftrack_api.Session): ftrack session.\n            entities (list[ftrack_api.entity.base.Entity]): List of entities.\n\n        Returns:\n            list[str]: List of representation names.\n        \"\"\"\n\n        version_ids = self._get_interest_version_ids(\n            project_name, session, entities\n        )\n        if not version_ids:\n            return []\n        repre_entities = get_representations(\n            project_name,\n            version_ids=version_ids,\n            fields=[\"name\"]\n        )\n        repre_names = {\n            repre_entity[\"name\"]\n            for repre_entity in repre_entities\n        }\n        return list(sorted(repre_names))\n\n    def _get_interest_version_ids(self, project_name, session, entities):\n        \"\"\"\n\n        Args:\n            project_name (str): Project name.\n            session (ftrack_api.Session): ftrack session.\n            entities (list[ftrack_api.entity.base.Entity]): List of entities.\n\n        Returns:\n            set[str]: Set of AYON version ids.\n        \"\"\"\n\n        # Extract AssetVersion entities\n        asset_versions = self._extract_asset_versions(session, entities)\n        # Prepare Asset ids\n        asset_ids = {\n            asset_version[\"asset_id\"]\n            for asset_version in asset_versions\n        }\n        # Query Asset entities\n        assets = session.query((\n            \"select id, name, context_id from Asset where id in ({})\"\n        ).format(self.join_query_keys(asset_ids))).all()\n        assets_by_id = {\n            asset[\"id\"]: asset\n            for asset in assets\n        }\n        parent_ids = set()\n        product_names = set()\n        version_nums = set()\n        for asset_version in asset_versions:\n            asset_id = asset_version[\"asset_id\"]\n            asset = assets_by_id[asset_id]\n\n            parent_ids.add(asset[\"context_id\"])\n            product_names.add(asset[\"name\"])\n            version_nums.add(asset_version[\"version\"])\n\n        folders_by_ftrack_id = self._get_folder_entities(\n            project_name, session, parent_ids\n        )\n        product_entities = self._get_product_entities(\n            project_name,\n            folders_by_ftrack_id,\n            product_names,\n            asset_versions,\n            assets_by_id\n        )\n        version_entities = self._get_version_entities(\n            project_name,\n            folders_by_ftrack_id,\n            product_entities,\n            version_nums,\n            asset_versions,\n            assets_by_id\n        )\n\n        return {version_entity[\"id\"] for version_entity in version_entities}\n\n    def _extract_asset_versions(self, session, entities):\n        asset_version_ids = set()\n        review_session_ids = set()\n        for entity in entities:\n            entity_type_low = entity.entity_type.lower()\n            if entity_type_low == \"assetversion\":\n                asset_version_ids.add(entity[\"id\"])\n            elif entity_type_low == \"reviewsession\":\n                review_session_ids.add(entity[\"id\"])\n\n        for version_id in self._get_asset_version_ids_from_review_sessions(\n            session, review_session_ids\n        ):\n            asset_version_ids.add(version_id)\n\n        asset_versions = session.query((\n            \"select id, version, asset_id from AssetVersion where id in ({})\"\n        ).format(self.join_query_keys(asset_version_ids))).all()\n\n        return asset_versions\n\n    def _get_asset_version_ids_from_review_sessions(\n        self, session, review_session_ids\n    ):\n        if not review_session_ids:\n            return set()\n        review_session_objects = session.query((\n            \"select version_id from ReviewSessionObject\"\n            \" where review_session_id in ({})\"\n        ).format(self.join_query_keys(review_session_ids))).all()\n\n        return {\n            review_session_object[\"version_id\"]\n            for review_session_object in review_session_objects\n        }\n\n    def _get_folder_entities(self, project_name, session, parent_ids):\n        \"\"\"\n\n        Args:\n            project_name (str): Project name.\n            session (ftrack_api.Session): ftrack session.\n            parent_ids (set[str]): Set of ftrack ids parents to Asset.\n\n        Returns:\n            dict[str, dict[str, Any]]: Folder entities by ftrack id.\n        \"\"\"\n\n        folder_entities = list(get_folders(\n            project_name, fields={\n                \"id\",\n                \"path\",\n                f\"attrib.{FTRACK_ID_ATTRIB}\"\n            }\n        ))\n\n        folders_by_id = {}\n        folders_by_path = {}\n        folders_by_ftrack_id = {}\n        for folder_entity in folder_entities:\n            folder_id = folder_entity[\"id\"]\n            folder_path = folder_entity[\"path\"]\n            ftrack_id = folder_entity[\"attrib\"].get(FTRACK_ID_ATTRIB)\n\n            folders_by_id[folder_id] = folder_entity\n            folders_by_path[folder_path] = folder_entity\n            if ftrack_id:\n                folders_by_ftrack_id[ftrack_id] = folder_entity\n\n        attr_def = session.query((\n            \"select id from CustomAttributeConfiguration where key is \\\"{}\\\"\"\n        ).format(CUST_ATTR_KEY_SERVER_ID)).first()\n        if attr_def is None:\n            return folders_by_ftrack_id\n\n        ayon_id_values = query_custom_attribute_values(\n            session, [attr_def[\"id\"]], parent_ids\n        )\n        missing_ids = set(parent_ids)\n        for item in ayon_id_values:\n            if not item[\"value\"]:\n                continue\n            folder_id = item[\"value\"]\n            entity_id = item[\"entity_id\"]\n            folder_entity = folders_by_id.get(folder_id)\n            if folder_entity:\n                folders_by_ftrack_id[entity_id] = folder_entity\n                missing_ids.remove(entity_id)\n\n        entity_ids_by_path = {}\n        if missing_ids:\n            not_found_entities = session.query((\n                \"select id, link from TypedContext where id in ({})\"\n            ).format(self.join_query_keys(missing_ids))).all()\n            for ftrack_entity in not_found_entities:\n                # TODO use 'slugify_name' function\n                link_names = [item[\"name\"] for item in ftrack_entity[\"link\"]]\n                # Change project name to empty string\n                link_names[0] = \"\"\n                entity_path = \"/\".join(link_names)\n                entity_ids_by_path[entity_path] = ftrack_entity[\"id\"]\n\n        for entity_path, ftrack_id in entity_ids_by_path.items():\n            folder_entity = folders_by_path.get(entity_path)\n            if folder_entity:\n                folders_by_ftrack_id[ftrack_id] = folder_entity\n\n        return folders_by_ftrack_id\n\n    def _get_product_entities(\n        self,\n        project_name,\n        folders_by_ftrack_id,\n        product_names,\n        asset_versions,\n        assets_by_id\n    ):\n        \"\"\"\n\n        Args:\n            project_name (str): Project name.\n            folders_by_ftrack_id (dict[str, dict[str, Any]]): Folder entities\n                by ftrack id.\n            product_names (set[str]): Set of product names.\n            asset_versions (list[dict[str, Any]]): ftrack AssetVersion\n                entities.\n            assets_by_id (dict[str, dict[str, Any]]): ftrack Asset entities\n                by id.\n\n        Returns:\n            list[dict[str, Any]]: Product entities.\n        \"\"\"\n\n        output = []\n        if not folders_by_ftrack_id:\n            return output\n\n        folder_ids = {\n            folder[\"id\"]\n            for folder in folders_by_ftrack_id.values()\n        }\n        product_entities = list(get_products(\n            project_name,\n            folder_ids=folder_ids,\n            product_names=product_names\n        ))\n        products_by_folder_id = {}\n        for product in product_entities:\n            folder_id = product[\"folderId\"]\n            product_name = product[\"name\"]\n            products_by_name = products_by_folder_id.setdefault(folder_id, {})\n            products_by_name[product_name] = product\n\n        for asset_version in asset_versions:\n            asset_id = asset_version[\"asset_id\"]\n            asset = assets_by_id[asset_id]\n\n            parent_id = asset[\"context_id\"]\n            folder = folders_by_ftrack_id.get(parent_id)\n            if not folder:\n                continue\n\n            products_by_name = products_by_folder_id.get(folder[\"id\"])\n            if not products_by_name:\n                continue\n\n            product_name = asset[\"name\"]\n            product_entity = products_by_name.get(product_name)\n            if product_entity:\n                output.append(product_entity)\n        return output\n\n    def _get_version_entities(\n        self,\n        project_name,\n        folders_by_ftrack_id,\n        product_entities,\n        version_nums,\n        asset_versions,\n        assets_by_id\n    ):\n        \"\"\"\n\n        Args:\n            project_name (str): Project name.\n            folders_by_ftrack_id (dict[str, dict[str, Any]]): Folder entities\n                by ftrack id.\n            product_entities (list[dict[str, Any]]): Product entities.\n            version_nums (set[str]): Set of version numbers.\n            asset_versions (list[dict[str, Any]]): ftrack AssetVersion\n                entities.\n            assets_by_id (dict[str, dict[str, Any]]): ftrack Asset entities\n                by id.\n\n        Returns:\n            list[dict[str, Any]]: Set of AYON version ids.\n        \"\"\"\n\n        product_entities_by_id = {\n            product_entity[\"id\"]: product_entity\n            for product_entity in product_entities\n        }\n        version_entities = list(get_versions(\n            project_name,\n            product_ids=product_entities_by_id.keys(),\n            versions=version_nums\n        ))\n        version_docs_by_parent_id = {}\n        for version_entity in version_entities:\n            product_id = version_entity[\"productId\"]\n            product_entity = product_entities_by_id[product_id]\n\n            folder_id = product_entity[\"folderId\"]\n            product_name = product_entity[\"name\"]\n            version = version_entity[\"version\"]\n\n            folder_values = version_docs_by_parent_id.setdefault(folder_id, {})\n            product_values = folder_values.setdefault(product_name, {})\n            product_values[version] = version_entity\n\n        filtered_versions = []\n        for asset_version in asset_versions:\n            asset_id = asset_version[\"asset_id\"]\n            version = asset_version[\"version\"]\n\n            asset = assets_by_id[asset_id]\n            parent_id = asset[\"context_id\"]\n            product_name = asset[\"name\"]\n\n            folder_entity = folders_by_ftrack_id.get(parent_id)\n            if not folder_entity:\n                continue\n\n            product_values = version_docs_by_parent_id.get(\n                folder_entity[\"id\"]\n            )\n            if not product_values:\n                continue\n\n            version_entities_by_version = product_values.get(product_name)\n            if not version_entities_by_version:\n                continue\n\n            version_entity = version_entities_by_version.get(version)\n            if version_entity:\n                filtered_versions.append(version_entity)\n\n        return filtered_versions\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_delivery.html#client.ayon_ftrack.event_handlers_user.action_delivery.Delivery.report","title":"<code>report(report_items)</code>","text":"<p>Returns dict with final status of delivery (success, fail etc.).</p> <p>Parameters:</p> Name Type Description Default <code>report_items (dict[str, Union[str, list[str]]]</code> <p>Dict with report items to be shown to user.</p> required <p>Returns:</p> Type Description <p>dict[str, Any]: Dict with final status of delivery.</p> Source code in <code>client/ayon_ftrack/event_handlers_user/action_delivery.py</code> <pre><code>def report(self, report_items):\n    \"\"\"Returns dict with final status of delivery (success, fail etc.).\n\n    Args:\n        report_items (dict[str, Union[str, list[str]]]: Dict with report\n            items to be shown to user.\n\n    Returns:\n        dict[str, Any]: Dict with final status of delivery.\n    \"\"\"\n\n    all_items = []\n\n    for msg, items in report_items.items():\n        if not items:\n            continue\n\n        if all_items:\n            all_items.append({\"type\": \"label\", \"value\": \"---\"})\n\n        all_items.append({\n            \"type\": \"label\",\n            \"value\": \"# {}\".format(msg)\n        })\n        if not isinstance(items, (list, tuple)):\n            items = [items]\n\n        all_items.append({\n            \"type\": \"label\",\n            \"value\": \"&lt;p&gt;{}&lt;/p&gt;\".format(\n                \"&lt;br&gt;\".join([str(item) for item in items])\n            )\n        })\n\n    if not all_items:\n        return {\n            \"success\": True,\n            \"message\": \"Delivery Finished\"\n        }\n\n    return {\n        \"items\": all_items,\n        \"title\": \"Delivery report\",\n        \"success\": False\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_download_reviews.html","title":"action_download_reviews","text":""},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_job_killer.html","title":"action_job_killer","text":""},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_job_killer.html#client.ayon_ftrack.event_handlers_user.action_job_killer.JobKiller","title":"<code>JobKiller</code>","text":"<p>               Bases: <code>LocalAction</code></p> <p>Kill jobs that are marked as running.</p> Source code in <code>client/ayon_ftrack/event_handlers_user/action_job_killer.py</code> <pre><code>class JobKiller(LocalAction):\n    \"\"\"Kill jobs that are marked as running.\"\"\"\n\n    identifier = \"ayon.job.killer\"\n    label = \"AYON Admin\"\n    variant = \"- Job Killer\"\n    description = \"Killing selected running jobs\"\n    icon = get_ftrack_icon_url(\"AYONAdmin.svg\")\n    settings_key = \"job_killer\"\n\n    def discover(self, session, entities, event):\n        \"\"\"Check if action is available for user role.\"\"\"\n        return self.valid_roles(session, entities, event)\n\n    def interface(self, session, entities, event):\n        if event[\"data\"].get(\"values\"):\n            return\n\n        title = \"Select jobs to kill\"\n\n        jobs = session.query(\n            \"select id, user_id, status, created_at, data from Job\"\n            \" where status in (\\\"queued\\\", \\\"running\\\")\"\n        ).all()\n        if not jobs:\n            return {\n                \"success\": True,\n                \"message\": \"Didn't found any running jobs\"\n            }\n\n        # Collect user ids from jobs\n        user_ids = set()\n        for job in jobs:\n            user_id = job[\"user_id\"]\n            if user_id:\n                user_ids.add(user_id)\n\n        # Store usernames by their ids\n        usernames_by_id = {}\n        if user_ids:\n            users = session.query(\n                \"select id, username from User where id in ({})\".format(\n                    self.join_query_keys(user_ids)\n                )\n            ).all()\n            for user in users:\n                usernames_by_id[user[\"id\"]] = user[\"username\"]\n\n        items = []\n        for job in jobs:\n            try:\n                data = json.loads(job[\"data\"])\n                desctiption = data[\"description\"]\n            except Exception:\n                desctiption = \"*No description*\"\n            user_id = job[\"user_id\"]\n            username = usernames_by_id.get(user_id) or \"Unknown user\"\n            created = job[\"created_at\"].strftime(\"%d.%m.%Y %H:%M:%S\")\n            label = \"{} - {} - {}\".format(\n                username, desctiption, created\n            )\n            item_label = {\n                \"type\": \"label\",\n                \"value\": label\n            }\n            item = {\n                \"name\": job[\"id\"],\n                \"type\": \"boolean\",\n                \"value\": False\n            }\n            if len(items) &gt; 0:\n                items.append({\"type\": \"label\", \"value\": \"---\"})\n            items.append(item_label)\n            items.append(item)\n\n        return {\n            \"items\": items,\n            \"title\": title\n        }\n\n    def launch(self, session, entities, event):\n        if \"values\" not in event[\"data\"]:\n            return\n\n        values = event[\"data\"][\"values\"]\n        if len(values) &lt; 1:\n            return {\n                \"success\": True,\n                \"message\": \"No jobs to kill!\"\n            }\n\n        job_ids = set()\n        for job_id, kill_job in values.items():\n            if kill_job:\n                job_ids.add(job_id)\n\n        jobs = session.query(\n            \"select id, status from Job where id in ({})\".format(\n                self.join_query_keys(job_ids)\n            )\n        ).all()\n\n        # Update all the queried jobs, setting the status to failed.\n        for job in jobs:\n            try:\n                origin_status = job[\"status\"]\n                self.log.debug((\n                    'Changing Job ({}) status: {} -&gt; failed'\n                ).format(job[\"id\"], origin_status))\n\n                job[\"status\"] = \"failed\"\n                session.commit()\n\n            except Exception:\n                session.rollback()\n                self.log.warning((\n                    \"Changing Job ({}) has failed\"\n                ).format(job[\"id\"]))\n\n        self.log.info(\"All selected jobs were killed Successfully!\")\n        return {\n            \"success\": True,\n            \"message\": \"All selected jobs were killed Successfully!\"\n        }\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_job_killer.html#client.ayon_ftrack.event_handlers_user.action_job_killer.JobKiller.discover","title":"<code>discover(session, entities, event)</code>","text":"<p>Check if action is available for user role.</p> Source code in <code>client/ayon_ftrack/event_handlers_user/action_job_killer.py</code> <pre><code>def discover(self, session, entities, event):\n    \"\"\"Check if action is available for user role.\"\"\"\n    return self.valid_roles(session, entities, event)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_multiple_notes.html","title":"action_multiple_notes","text":""},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_test.html","title":"action_test","text":""},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_test.html#client.ayon_ftrack.event_handlers_user.action_test.TestAction","title":"<code>TestAction</code>","text":"<p>               Bases: <code>LocalAction</code></p> <p>Action for testing purpose or as base for new actions.</p> Source code in <code>client/ayon_ftrack/event_handlers_user/action_test.py</code> <pre><code>class TestAction(LocalAction):\n    \"\"\"Action for testing purpose or as base for new actions.\"\"\"\n\n    enabled = False\n\n    identifier = \"test.action\"\n    label = \"Test action\"\n    description = \"Test action\"\n    priority = 10000\n    icon = get_ftrack_icon_url(\"TestAction.svg\")\n\n    def discover(self, session, entities, event):\n        return True\n\n    def launch(self, session, entities, event):\n        self.log.info(event)\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_thumbnail_to_childern.html","title":"action_thumbnail_to_childern","text":""},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_thumbnail_to_childern.html#client.ayon_ftrack.event_handlers_user.action_thumbnail_to_childern.ThumbToChildren","title":"<code>ThumbToChildren</code>","text":"<p>               Bases: <code>LocalAction</code></p> Source code in <code>client/ayon_ftrack/event_handlers_user/action_thumbnail_to_childern.py</code> <pre><code>class ThumbToChildren(LocalAction):\n    identifier = \"ayon.thumb.to.children\"\n    label = \"Thumbnail\"\n    variant = \" to Children\"\n    icon = get_ftrack_icon_url(\"Thumbnail.svg\")\n\n    def discover(self, session, entities, event):\n        \"\"\"Show only on project.\"\"\"\n        if entities and entities[0].entity_type != \"Project\":\n            return True\n        return False\n\n    def launch(self, session, entities, event):\n        user_id = event[\"source\"][\"user\"][\"id\"]\n        user = session.query(f\"User where id is {user_id}\").one()\n\n        job = session.create(\"Job\", {\n            \"user\": user,\n            \"status\": \"running\",\n            \"data\": json.dumps({\n                \"description\": \"Push thumbnails to children\"\n            })\n        })\n        session.commit()\n        try:\n            for entity in entities:\n                thumbnail_id = entity[\"thumbnail_id\"]\n                if thumbnail_id:\n                    for child in entity[\"children\"]:\n                        child[\"thumbnail_id\"] = thumbnail_id\n\n            # inform the user that the job is done\n            job[\"status\"] = \"done\"\n        except Exception as exc:\n            session.rollback()\n            # fail the job if something goes wrong\n            job[\"status\"] = \"failed\"\n            raise exc\n        finally:\n            session.commit()\n\n        return {\n            \"success\": True,\n            \"message\": \"Created job for updating thumbnails!\"\n        }\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_thumbnail_to_childern.html#client.ayon_ftrack.event_handlers_user.action_thumbnail_to_childern.ThumbToChildren.discover","title":"<code>discover(session, entities, event)</code>","text":"<p>Show only on project.</p> Source code in <code>client/ayon_ftrack/event_handlers_user/action_thumbnail_to_childern.py</code> <pre><code>def discover(self, session, entities, event):\n    \"\"\"Show only on project.\"\"\"\n    if entities and entities[0].entity_type != \"Project\":\n        return True\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_thumbnail_to_parent.html","title":"action_thumbnail_to_parent","text":""},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_where_run_ask.html","title":"action_where_run_ask","text":""},{"location":"autoapi/client/ayon_ftrack/event_handlers_user/action_where_run_ask.html#client.ayon_ftrack.event_handlers_user.action_where_run_ask.ActionWhereIRun","title":"<code>ActionWhereIRun</code>","text":"<p>               Bases: <code>LocalAction</code></p> <p>Show where same user has running AYON instances.</p> Source code in <code>client/ayon_ftrack/event_handlers_user/action_where_run_ask.py</code> <pre><code>class ActionWhereIRun(LocalAction):\n    \"\"\"Show where same user has running AYON instances.\"\"\"\n\n    identifier = \"ayon.ask.where.i.run\"\n    show_identifier = \"ayon.show.where.i.run\"\n    label = \"AYON Admin\"\n    variant = \"- Where I run\"\n    description = \"Show PC info where user have running AYON\"\n\n    def _discover(self, _event):\n        return {\n            \"items\": [{\n                \"label\": self.label,\n                \"variant\": self.variant,\n                \"description\": self.description,\n                \"actionIdentifier\": self.discover_identifier,\n                \"icon\": self.icon,\n            }]\n        }\n\n    def _launch(self, event):\n        self.trigger_action(self.show_identifier, event)\n\n    def register(self):\n        # Register default action callbacks\n        super(ActionWhereIRun, self).register()\n\n        # Add show identifier\n        show_subscription = (\n            \"topic=ftrack.action.launch\"\n            \" and data.actionIdentifier={}\"\n            \" and source.user.username={}\"\n        ).format(\n            self.show_identifier,\n            self.session.api_user\n        )\n        self.session.event_hub.subscribe(\n            show_subscription,\n            self._show_info\n        )\n\n    def _show_info(self, event):\n        title = \"Where Do I Run?\"\n        msgs = {}\n        all_keys = [\"Hostname\", \"IP\", \"Username\", \"System name\", \"PC name\"]\n        try:\n            host_name = socket.gethostname()\n            msgs[\"Hostname\"] = host_name\n            msgs[\"IP\"] = get_host_ip() or \"N/A\"\n        except Exception:\n            pass\n\n        try:\n            system_name, pc_name, *_ = platform.uname()\n            msgs[\"System name\"] = system_name\n            msgs[\"PC name\"] = pc_name\n        except Exception:\n            pass\n\n        try:\n            msgs[\"Username\"] = getpass.getuser()\n        except Exception:\n            pass\n\n        for key in all_keys:\n            if not msgs.get(key):\n                msgs[key] = \"-Undefined-\"\n\n        items = []\n        first = True\n        separator = {\"type\": \"label\", \"value\": \"---\"}\n        for key, value in msgs.items():\n            if first:\n                first = False\n            else:\n                items.append(separator)\n            self.log.debug(\"{}: {}\".format(key, value))\n\n            subtitle = {\"type\": \"label\", \"value\": \"&lt;h3&gt;{}&lt;/h3&gt;\".format(key)}\n            items.append(subtitle)\n            message = {\"type\": \"label\", \"value\": \"&lt;p&gt;{}&lt;/p&gt;\".format(value)}\n            items.append(message)\n\n        self.show_interface(items, title, event=event)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/launch_hooks/index.html","title":"launch_hooks","text":""},{"location":"autoapi/client/ayon_ftrack/launch_hooks/post_ftrack_changes.html","title":"post_ftrack_changes","text":""},{"location":"autoapi/client/ayon_ftrack/launch_hooks/post_ftrack_changes.html#client.ayon_ftrack.launch_hooks.post_ftrack_changes.PostFtrackHook","title":"<code>PostFtrackHook</code>","text":"<p>               Bases: <code>PostLaunchHook</code></p> Source code in <code>client/ayon_ftrack/launch_hooks/post_ftrack_changes.py</code> <pre><code>class PostFtrackHook(PostLaunchHook):\n    order = None\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        project_name = self.data.get(\"project_name\")\n        project_settings = self.data.get(\"project_settings\")\n        folder_path = self.data.get(\"folder_path\")\n        task_name = self.data.get(\"task_name\")\n\n        missing_context_keys = [\n            key\n            for value, key in (\n                (project_name, \"project_name\"),\n                (project_settings, \"project_settings\"),\n                (folder_path, \"asset_name\"),\n                (task_name, \"task_name\"),\n            )\n            if not value\n        ]\n        if missing_context_keys:\n            missing_keys_str = \", \".join([\n                f\"'{key}'\" for key in missing_context_keys\n            ])\n            self.log.debug(\n                f\"Hook {self.__class__.__name__} skipped.\"\n                f\" Missing required data: {missing_keys_str}\"\n            )\n            return\n\n        if \"ftrack\" not in project_settings:\n            self.log.debug(\n                \"Missing ftrack settings. Skipping post launch logic.\"\n            )\n            return\n\n        if not is_ftrack_enabled_in_settings(project_settings[\"ftrack\"]):\n            self.log.debug(\n                f\"ftrack is disabled for project '{project_name}'. Skipping.\"\n            )\n            return\n\n        required_keys = (\"FTRACK_SERVER\", \"FTRACK_API_USER\", \"FTRACK_API_KEY\")\n        for key in required_keys:\n            if not os.environ.get(key):\n                self.log.debug(\n                    f\"Missing required environment '{key}'\"\n                    \" for ftrack post launch procedure.\"\n                )\n                return\n\n        try:\n            session = ftrack_api.Session(auto_connect_event_hub=False)\n            self.log.debug(\"ftrack session created\")\n        except Exception:\n            self.log.warning(\"Couldn't create ftrack session\")\n            return\n\n        try:\n            entity = self._find_ftrack_task_entity(\n                session, project_name, folder_path, task_name\n            )\n            if entity:\n                self.ftrack_status_change(session, entity, project_name)\n\n        except Exception:\n            self.log.warning(\n                \"Couldn't finish ftrack post launch logic.\",\n                exc_info=True\n            )\n            return\n\n        finally:\n            session.close()\n\n    def ftrack_status_change(self, session, entity, project_name):\n        project_settings = get_project_settings(project_name)\n        status_update = (\n            project_settings\n            [\"ftrack\"]\n            [\"post_launch_hook\"]\n        )\n        if not status_update[\"enabled\"]:\n            self.log.debug(\n                f\"Status changes are disabled for project '{project_name}'\"\n            )\n            return\n\n        status_mapping = status_update[\"mapping\"]\n        if not status_mapping:\n            self.log.warning(\n                f\"Project '{project_name}' does not have set status changes.\"\n            )\n            return\n\n        current_status = entity[\"status\"][\"name\"].lower()\n        already_tested = set()\n        ent_path = \"/\".join(\n            [ent[\"name\"] for ent in entity[\"link\"]]\n        )\n\n        statuses = session.query(\"select id, name from Status\").all()\n        statuses_by_low_name = {\n            status[\"name\"].lower(): status\n            for status in statuses\n        }\n        # TODO refactor\n        while True:\n            next_status_name = None\n            for item in status_mapping:\n                new_status = item[\"name\"].lower()\n                if new_status in already_tested:\n                    continue\n\n                already_tested.add(new_status)\n\n                found_match = False\n                for from_status in item[\"value\"]:\n                    from_status = from_status.lower()\n                    if from_status in (current_status, \"__any__\"):\n                        found_match = True\n                        if new_status != \"__ignore__\":\n                            next_status_name = new_status\n                        break\n\n                if found_match:\n                    break\n\n            if next_status_name is None:\n                break\n\n            status = statuses_by_low_name.get(next_status_name)\n            if status is None:\n                self.log.warning(\n                    f\"Status '{next_status_name}' not found in ftrack.\"\n                )\n                continue\n\n            try:\n                entity[\"status_id\"] = status[\"id\"]\n                session.commit()\n                self.log.debug(\n                    f\"Status changed to \\\"{next_status_name}\\\" &lt;{ent_path}&gt;\"\n                )\n                break\n\n            except Exception:\n                session.rollback()\n                self.log.warning(\n                    f\"Status '{next_status_name}' is not available\"\n                    f\" for ftrack entity type '{entity.entity_type}'\"\n                )\n\n    def _find_ftrack_folder_entity(self, session, folder):\n        \"\"\"\n        Args:\n            session (ftrack_api.Session): ftrack session.\n            folder (dict): AYON folder data.\n\n        Returns:\n            Union[ftrack_api.entity.base.Entity, None]: ftrack folder entity.\n        \"\"\"\n\n        # Find ftrack entity by id stored on folder\n        # - Maybe more options could be used? Find ftrack entity by folder\n        #   path in ftrack custom attributes.\n        if folder:\n            ftrack_id = folder[\"attrib\"].get(FTRACK_ID_ATTRIB)\n            if ftrack_id:\n                entity = session.query(\n                    f\"TypedContext where id is \\\"{ftrack_id}\\\"\"\n                ).first()\n                if entity:\n                    return entity\n        return None\n\n    def _find_ftrack_task_entity(\n        self, session, project_name, folder_path, task_name\n    ):\n        \"\"\"\n\n        Args:\n            session (ftrack_api.Session): ftrack session.\n            project_name (str): Project name.\n            folder_path (str): Folder path.\n            task_name (str): Task name.\n\n        Returns:\n            Union[ftrack_api.entity.base.Entity, None]: ftrack task entity.\n        \"\"\"\n\n        project_entity = session.query(\n            f\"Project where full_name is \\\"{project_name}\\\"\"\n        ).first()\n        if not project_entity:\n            self.log.warning(\n                f\"Couldn't find project '{project_name}' in ftrack.\"\n            )\n            return None\n\n        # TODO use 'folder' entity data from launch context when is available.\n        #   At this moment there is only \"asset doc\".\n        folder = ayon_api.get_folder_by_path(project_name, folder_path)\n        parent_entity = self._find_ftrack_folder_entity(session, folder)\n        if parent_entity is None:\n            self.log.warning(\n                f\"Couldn't find folder '{folder_path}' in ftrack\"\n                f\" project '{project_name}'.\"\n            )\n            return None\n\n        parent_id = parent_entity[\"id\"]\n        task_entity = session.query(\n            f\"Task where parent_id is '{parent_id}' and name is '{task_name}'\"\n        ).first()\n        if task_entity is None:\n            self.log.warning(\n                f\"Couldn't find task '{folder_path}/{task_name}' in ftrack.\"\n            )\n\n        return task_entity\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/lib/index.html","title":"lib","text":""},{"location":"autoapi/client/ayon_ftrack/lib/credentials.html","title":"credentials","text":""},{"location":"autoapi/client/ayon_ftrack/lib/utils.html","title":"utils","text":""},{"location":"autoapi/client/ayon_ftrack/pipeline/index.html","title":"pipeline","text":""},{"location":"autoapi/client/ayon_ftrack/pipeline/plugin.html","title":"plugin","text":""},{"location":"autoapi/client/ayon_ftrack/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_ftrack/plugins/_unused_publish/index.html","title":"_unused_publish","text":""},{"location":"autoapi/client/ayon_ftrack/plugins/_unused_publish/integrate_ftrack_comments.html","title":"integrate_ftrack_comments","text":""},{"location":"autoapi/client/ayon_ftrack/plugins/_unused_publish/integrate_ftrack_comments.html#client.ayon_ftrack.plugins._unused_publish.integrate_ftrack_comments.IntegrateFtrackComments","title":"<code>IntegrateFtrackComments</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Create comments in ftrack.</p> Source code in <code>client/ayon_ftrack/plugins/_unused_publish/integrate_ftrack_comments.py</code> <pre><code>class IntegrateFtrackComments(pyblish.api.InstancePlugin):\n    \"\"\"Create comments in ftrack.\"\"\"\n\n    order = pyblish.api.IntegratorOrder\n    label = \"Integrate Comments to ftrack\"\n    families = [\"shot\"]\n    enabled = False\n\n    def process(self, instance):\n        session = instance.context.data[\"ftrackSession\"]\n\n        entity = session.query(\n            \"Shot where name is \\\"{}\\\"\".format(instance.data[\"item\"].name())\n        ).one()\n\n        notes = []\n        for comment in instance.data[\"comments\"]:\n            notes.append(session.create(\"Note\", {\"content\": comment}))\n\n        entity[\"notes\"].extend(notes)\n\n        try:\n            session.commit()\n        except Exception as exc:\n            session.rollback()\n            raise exc\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/launcher_actions/index.html","title":"launcher_actions","text":""},{"location":"autoapi/client/ayon_ftrack/plugins/launcher_actions/show_in_ftrack.html","title":"show_in_ftrack","text":"<p>Example ftrack URL:</p> <p>https://.ftrackapp.com/#slideEntityId=38c5fec4-0aed-11ea-a454-3e41ec9bc0d6&amp;slideEntityType=show&amp;view=tasks&amp;itemId=projects&amp;entityId=38c5fec4-0aed-11ea-a454-3e41ec9bc0d6&amp;entityType=show"},{"location":"autoapi/client/ayon_ftrack/plugins/launcher_actions/show_in_ftrack.html#client.ayon_ftrack.plugins.launcher_actions.show_in_ftrack--this-is-required-otherwise-is-url-invalid-viewtasksitemidprojectsentityid38c5fec4-0aed-11ea-a454-3e41ec9bc0d6entitytypeshow","title":"This is required otherwise is url invalid view=tasks&amp;itemId=projects&amp;entityId=38c5fec4-0aed-11ea-a454-3e41ec9bc0d6&amp;entityType=show","text":"<ul> <li>\"itemId=projects\" the top category (overview / projects/ reports / ...)     must be 'projects'</li> <li>\"view=tasks\" view category 'tasks' is best</li> <li>\"entityId=38c5fec4-0aed-11ea-a454-3e41ec9bc0d6\" id of entity which is in focus (project id is easiest)</li> <li>\"entityType=show\" entity type of 'entityId'</li> </ul> <p>Entity detail in slide (on right side) can't be used on it's own: slideEntityId=38c5fec4-0aed-11ea-a454-3e41ec9bc0d6&amp;slideEntityType=show - \"slideEntityId=38c5fec4-0aed-11ea-a454-3e41ec9bc0d6\" entity id which is showed in detail - \"slideEntityType=show\" type of 'slideEntityId' entity</p> entityType is not entity_type! <p>entityType \"show\" == entity_type \"Project\" entityType \"task\" == entity_type \"Task\", \"Shot\", \"Library\", \"Folder\", ...</p>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_ftrack/plugins/publish/collect_custom_attributes_data.html","title":"collect_custom_attributes_data","text":"Requires <p>context &gt; ftrackSession context &gt; ftrackEntity instance &gt; ftrackEntity</p> Provides <p>instance &gt; customData &gt; ftrack</p>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/collect_custom_attributes_data.html#client.ayon_ftrack.plugins.publish.collect_custom_attributes_data.CollectFtrackCustomAttributeData","title":"<code>CollectFtrackCustomAttributeData</code>","text":"<p>               Bases: <code>FtrackPublishContextPlugin</code></p> <p>Collect custom attribute values and store them to customData.</p> <p>Data are stored into each instance in context under     instance.data[\"customData\"][\"ftrack\"].</p> <p>Hierarchical attributes are not looked up properly for that functionality custom attribute values lookup must be extended.</p> Source code in <code>client/ayon_ftrack/plugins/publish/collect_custom_attributes_data.py</code> <pre><code>class CollectFtrackCustomAttributeData(plugin.FtrackPublishContextPlugin):\n    \"\"\"Collect custom attribute values and store them to customData.\n\n    Data are stored into each instance in context under\n        instance.data[\"customData\"][\"ftrack\"].\n\n    Hierarchical attributes are not looked up properly for that functionality\n    custom attribute values lookup must be extended.\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.4992\n    label = \"Collect ftrack Custom Attribute Data\"\n\n    # Name of custom attributes for which will be look for\n    custom_attribute_keys = []\n\n    def process(self, context):\n        if not self.custom_attribute_keys:\n            self.log.info(\"Custom attribute keys are not set. Skipping\")\n            return\n\n        ftrack_entities_by_id = {}\n        default_entity_id = None\n\n        context_entity = context.data.get(\"ftrackEntity\")\n        if context_entity:\n            entity_id = context_entity[\"id\"]\n            default_entity_id = entity_id\n            ftrack_entities_by_id[entity_id] = context_entity\n\n        instances_by_entity_id = {\n            default_entity_id: []\n        }\n        for instance in context:\n            entity = instance.data.get(\"ftrackEntity\")\n            if not entity:\n                instances_by_entity_id[default_entity_id].append(instance)\n                continue\n\n            entity_id = entity[\"id\"]\n            ftrack_entities_by_id[entity_id] = entity\n            if entity_id not in instances_by_entity_id:\n                instances_by_entity_id[entity_id] = []\n            instances_by_entity_id[entity_id].append(instance)\n\n        if not ftrack_entities_by_id:\n            self.log.info(\"ftrack entities are not set. Skipping\")\n            return\n\n        session = context.data[\"ftrackSession\"]\n        custom_attr_key_by_id = self.query_attr_confs(session)\n        if not custom_attr_key_by_id:\n            self.log.info((\n                \"Didn't find any of defined custom attributes {}\"\n            ).format(\", \".join(self.custom_attribute_keys)))\n            return\n\n        entity_ids = list(instances_by_entity_id.keys())\n        values_by_entity_id = self.query_attr_values(\n            session, entity_ids, custom_attr_key_by_id\n        )\n\n        for entity_id, instances in instances_by_entity_id.items():\n            if entity_id not in values_by_entity_id:\n                # Use default empty values\n                entity_id = None\n\n            for instance in instances:\n                value = copy.deepcopy(values_by_entity_id[entity_id])\n                if \"customData\" not in instance.data:\n                    instance.data[\"customData\"] = {}\n                instance.data[\"customData\"][\"ftrack\"] = value\n                instance_label = (\n                    instance.data.get(\"label\") or instance.data[\"name\"]\n                )\n                self.log.debug((\n                    \"Added ftrack custom data to instance \\\"{}\\\": {}\"\n                ).format(instance_label, value))\n\n    def query_attr_values(self, session, entity_ids, custom_attr_key_by_id):\n        # Prepare values for query\n        entity_ids_joined = \",\".join([\n            '\"{}\"'.format(entity_id)\n            for entity_id in entity_ids\n        ])\n        conf_ids_joined = \",\".join([\n            '\"{}\"'.format(conf_id)\n            for conf_id in custom_attr_key_by_id.keys()\n        ])\n        # Query custom attribute values\n        value_items = session.query(\n            (\n                \"select value, entity_id, configuration_id\"\n                \" from CustomAttributeValue\"\n                \" where entity_id in ({}) and configuration_id in ({})\"\n            ).format(\n                entity_ids_joined,\n                conf_ids_joined\n            )\n        ).all()\n\n        # Prepare default value output per entity id\n        values_by_key = {\n            key: None for key in self.custom_attribute_keys\n        }\n        # Prepare all entity ids that were queried\n        values_by_entity_id = {\n            entity_id: copy.deepcopy(values_by_key)\n            for entity_id in entity_ids\n        }\n        # Add none entity id which is used as default value\n        values_by_entity_id[None] = copy.deepcopy(values_by_key)\n        # Go through queried data and store them\n        for item in value_items:\n            conf_id = item[\"configuration_id\"]\n            conf_key = custom_attr_key_by_id[conf_id]\n            entity_id = item[\"entity_id\"]\n            values_by_entity_id[entity_id][conf_key] = item[\"value\"]\n        return values_by_entity_id\n\n    def query_attr_confs(self, session):\n        custom_attributes = set(self.custom_attribute_keys)\n        cust_attrs_query = (\n            \"select id, key from CustomAttributeConfiguration\"\n            \" where key in ({})\"\n        ).format(\", \".join(\n            [\"\\\"{}\\\"\".format(attr_name) for attr_name in custom_attributes]\n        ))\n\n        custom_attr_confs = session.query(cust_attrs_query).all()\n        return {\n            conf[\"id\"]: conf[\"key\"]\n            for conf in custom_attr_confs\n        }\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/collect_farm_env_variables.html","title":"collect_farm_env_variables","text":""},{"location":"autoapi/client/ayon_ftrack/plugins/publish/collect_farm_env_variables.html#client.ayon_ftrack.plugins.publish.collect_farm_env_variables.CollectFtrackJobEnvVars","title":"<code>CollectFtrackJobEnvVars</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collect set of environment variables to submit with deadline jobs</p> Source code in <code>client/ayon_ftrack/plugins/publish/collect_farm_env_variables.py</code> <pre><code>class CollectFtrackJobEnvVars(pyblish.api.ContextPlugin):\n    \"\"\"Collect set of environment variables to submit with deadline jobs\"\"\"\n    order = pyblish.api.CollectorOrder - 0.45\n    label = \"Collect ftrack farm environment variables\"\n    targets = [\"local\"]\n\n    def process(self, context):\n        env = context.data.setdefault(FARM_JOB_ENV_DATA_KEY, {})\n        for key in [\n            \"FTRACK_SERVER\",\n            \"FTRACK_API_USER\",\n            \"FTRACK_API_KEY\",\n        ]:\n            value = os.getenv(key)\n            if value:\n                self.log.debug(f\"Setting job env: {key}: {value}\")\n                env[key] = value\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/collect_ftrack_api.html","title":"collect_ftrack_api","text":""},{"location":"autoapi/client/ayon_ftrack/plugins/publish/collect_ftrack_api.html#client.ayon_ftrack.plugins.publish.collect_ftrack_api.CollectFtrackApi","title":"<code>CollectFtrackApi</code>","text":"<p>               Bases: <code>FtrackPublishContextPlugin</code></p> <p>Collects an ftrack session and the current task id.</p> Source code in <code>client/ayon_ftrack/plugins/publish/collect_ftrack_api.py</code> <pre><code>class CollectFtrackApi(plugin.FtrackPublishContextPlugin):\n    \"\"\" Collects an ftrack session and the current task id. \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.4991\n    label = \"Collect ftrack Api\"\n\n    def process(self, context):\n        ftrack_log = logging.getLogger(\"ftrack_api\")\n        ftrack_log.setLevel(logging.WARNING)\n\n        # Collect session\n        # NOTE Import python module here to know if import was successful\n        import ftrack_api\n\n        session = ftrack_api.Session(auto_connect_event_hub=False)\n        self.log.debug(f\"ftrack user: \\\"{session.api_user}\\\"\")\n\n        # Collect task\n        project_name = context.data[\"projectName\"]\n        folder_path = context.data[\"folderPath\"]\n        task_name = context.data[\"task\"]\n\n        # Find project entity\n        project_entity = session.query(\n            f'Project where full_name is \"{project_name}\"'\n        ).first()\n        if project_entity is None:\n            raise PublishError(\n                f\"Failed to find project \\\"{project_name}\\\" in ftrack.\",\n                \"Project not found in ftrack\",\n                (\n                    f\"Project \\\"{project_name}\\\" was not found in ftrack.\"\n                    \" Make sure the project does exist in ftrack and\"\n                    f\" ftrack user \\\"{session.api_user}\\\" has access to it.\"\n                )\n            )\n\n        self.log.debug(f\"Project found: {project_entity}\")\n\n        context_ftrack_entity = None\n        if folder_path:\n            # Find folder entity\n            entities_by_path = self.find_ftrack_entities(\n                session, project_entity, [folder_path]\n            )\n            context_ftrack_entity = entities_by_path[folder_path]\n            if context_ftrack_entity is None:\n                raise PublishError(\n                    (\n                        f\"Entity with path \\\"{folder_path}\\\" not found\"\n                        f\" in ftrack project \\\"{project_name}\\\".\"\n                    ),\n                    \"Entity not found in project\",\n                    (\n                        f\"Entity with path \\\"{folder_path}\\\" was not found in\"\n                        f\" ftrack project \\\"{project_name}\\\". Make sure the\"\n                        \" entity does exist in ftrack and your ftrack user\"\n                        f\" \\\"{session.api_user}\\\" has access to it.\"\n                    )\n                )\n\n        self.log.debug(f\"Folder found: {context_ftrack_entity}\")\n\n        task_entity = None\n        # Find task entity if task is set\n        if context_ftrack_entity is None:\n            self.log.warning(\n                \"Folder entity is not set. Skipping query of task entity.\"\n            )\n        elif not task_name:\n            self.log.warning(\"Task name is not set.\")\n        else:\n            entity_id = context_ftrack_entity[\"id\"]\n            task_entity = session.query(\n                f'Task where name is \"{task_name}\"'\n                f' and parent_id is \"{entity_id}\"'\n            ).first()\n            if task_entity:\n                self.log.debug(f\"Task entity found: {task_entity}\")\n            else:\n                self.log.warning(\n                    f\"Task entity with name \\\"{task_name}\\\" was not found.\"\n                )\n\n        context.data[\"ftrackSession\"] = session\n        context.data[\"ftrackPythonModule\"] = ftrack_api\n        context.data[\"ftrackProject\"] = project_entity\n        context.data[\"ftrackEntity\"] = context_ftrack_entity\n        context.data[\"ftrackTask\"] = task_entity\n\n        self.per_instance_process(\n            context, context_ftrack_entity, task_entity, folder_path\n        )\n\n    def per_instance_process(\n        self,\n        context,\n        context_ftrack_entity,\n        context_task_entity,\n        context_folder_path\n    ):\n        context_task_name = None\n        if context_ftrack_entity and context_task_entity:\n            context_task_name = context_task_entity[\"name\"]\n\n        instance_by_folder_and_task = {}\n        filtered_instances = []\n        for instance in context:\n            if not instance.data.get(\"publish\", True):\n                continue\n            filtered_instances.append(instance)\n            self.log.debug(\n                f\"Checking entities of instance \\\"{instance}\\\"\"\n            )\n            instance_folder_path = instance.data.get(\"folderPath\")\n            instance_task_name = instance.data.get(\"task\")\n\n            folder_path = None\n            task_name = None\n            if not instance_folder_path and not instance_task_name:\n                self.log.debug(\"Instance does not have set context keys.\")\n                instance.data[\"ftrackEntity\"] = context_ftrack_entity\n                instance.data[\"ftrackTask\"] = context_task_entity\n                continue\n\n            elif instance_folder_path and instance_task_name:\n                if (\n                    instance_folder_path == context_folder_path\n                    and instance_task_name == context_task_name\n                ):\n                    self.log.debug(\n                        \"Instance's context is same as in publish context.\"\n                        f\" Folder: {context_folder_path}\"\n                        f\" | Task: {context_task_name}\"\n                    )\n                    instance.data[\"ftrackEntity\"] = context_ftrack_entity\n                    instance.data[\"ftrackTask\"] = context_task_entity\n                    continue\n                folder_path = instance_folder_path\n                task_name = instance_task_name\n\n            elif instance_task_name:\n                if instance_task_name == context_task_name:\n                    self.log.debug(\n                        \"Instance's context task is same as in publish\"\n                        f\" context. Task: {context_task_name}\"\n                    )\n                    instance.data[\"ftrackEntity\"] = context_ftrack_entity\n                    instance.data[\"ftrackTask\"] = context_task_entity\n                    continue\n\n                folder_path = context_folder_path\n                task_name = instance_task_name\n\n            elif instance_folder_path:\n                if instance_folder_path == context_folder_path:\n                    self.log.debug(\n                        \"Instance's context folder is same as in publish\"\n                        f\" context. Folder: {context_folder_path}\"\n                    )\n                    instance.data[\"ftrackEntity\"] = context_ftrack_entity\n                    instance.data[\"ftrackTask\"] = context_task_entity\n                    continue\n\n                # Do not use context's task name\n                task_name = instance_task_name\n                folder_path = instance_folder_path\n\n            instance_by_task = instance_by_folder_and_task.setdefault(\n                folder_path, {})\n            task_instances = (instance_by_task.setdefault(task_name, []))\n            task_instances.append(instance)\n\n        if not instance_by_folder_and_task:\n            return\n\n        session = context.data[\"ftrackSession\"]\n        project_entity = context.data[\"ftrackProject\"]\n        project_name = project_entity[\"full_name\"]\n        folder_paths = set(instance_by_folder_and_task.keys())\n\n        entities_by_path = self.find_ftrack_entities(\n            session, project_entity, folder_paths\n        )\n\n        for folder_path, by_task_data in instance_by_folder_and_task.items():\n            entity = entities_by_path[folder_path]\n            task_entity_by_name = {}\n            if not entity:\n                self.log.warning(\n                    f\"Didn't find folder with path \\\"{folder_path}\\\"\"\n                    f\" in Project \\\"{project_name}\\\"\"\n                )\n            else:\n                entity_id = entity[\"id\"]\n                task_entities = session.query(\n                    \"select id, name from Task\"\n                    f\" where parent_id is \\\"{entity_id}\\\"\"\n                ).all()\n                for task_entity in task_entities:\n                    task_name_low = task_entity[\"name\"].lower()\n                    task_entity_by_name[task_name_low] = task_entity\n\n            for task_name, instances in by_task_data.items():\n                task_entity = None\n                if task_name and entity:\n                    task_entity = task_entity_by_name.get(task_name.lower())\n\n                for instance in instances:\n                    instance.data[\"ftrackEntity\"] = entity\n                    instance.data[\"ftrackTask\"] = task_entity\n\n                    self.log.debug(\n                        f\"Instance {instance} has own ftrack entities\"\n                        \" as has different context.\"\n                        f\" TypedContext: {entity} Task: {task_entity}\"\n                    )\n\n    def find_ftrack_entities(self, session, project_entity, folder_paths):\n        output = {path: None for path in folder_paths}\n        folder_paths_s = set(output.keys())\n\n        # We can't use 'folderEntity' and folders must be queried because\n        #   we must be assured that 'ownAttrib' is used to avoid collisions\n        #   because of hierarchical values.\n        folders = ayon_api.get_folders(\n            project_entity[\"full_name\"],\n            folder_paths=folder_paths_s,\n            fields={\n                \"path\",\n                f\"attrib.{FTRACK_ID_ATTRIB}\",\n            },\n            own_attributes=True\n        )\n        folders_by_path = {\n            folder[\"path\"]: folder\n            for folder in folders\n        }\n\n        folder_path_by_ftrack_id = {}\n        missing_folder_paths = set()\n        for folder_path in folder_paths:\n            folder = folders_by_path.get(folder_path)\n            if folder:\n                ftrack_id = folder[\"ownAttrib\"].get(FTRACK_ID_ATTRIB)\n                if ftrack_id:\n                    folder_path_by_ftrack_id[ftrack_id] = folder_path\n                    continue\n            missing_folder_paths.add(folder_path)\n\n        entities_by_id = {}\n        if folder_path_by_ftrack_id:\n            joined_ftrack_ids = \",\".join({\n                f'\"{ftrack_id}\"'\n                for ftrack_id in folder_path_by_ftrack_id\n            })\n            entities = session.query(\n                f\"TypedContext where id in ({joined_ftrack_ids})\"\n            ).all()\n            entities_by_id = {\n                entity[\"id\"]: entity\n                for entity in entities\n            }\n\n        for ftrack_id, folder_path in folder_path_by_ftrack_id.items():\n            entity = entities_by_id.get(ftrack_id)\n            if entity is None:\n                missing_folder_paths.add(folder_path)\n                continue\n            output[folder_path] = entity\n\n        output.update(self._find_missing_folder_paths(\n            session, project_entity, missing_folder_paths\n        ))\n        return output\n\n    def _find_missing_folder_paths(\n        self, session, project_entity, folder_paths\n    ):\n        output = {}\n        if not folder_paths:\n            return output\n\n        self.log.debug((\n            \"Finding ftrack entities by folder paths\"\n            \" because of missing ftrack id on AYON entity:\\n{}\"\n        ).format(\"\\n\".join(folder_paths)))\n\n        names = set()\n        for folder_path in folder_paths:\n            names |= set(folder_path.split(\"/\"))\n        names.discard(\"\")\n\n        joined_names = \",\".join(f'\"{n}\"' for n in names)\n\n        entities = session.query(\n            (\n                \"select id, name, parent_id from TypedContext\"\n                \" where project_id is \\\"{}\\\" and name in ({})\"\n            ).format(\n                project_entity[\"id\"],\n                joined_names\n            )\n        ).all()\n        entities_by_id = {entity[\"id\"]: entity for entity in entities}\n        entities_by_parent_id = collections.defaultdict(list)\n        for entity in entities:\n            parent_id = entity[\"parent_id\"]\n            entities_by_parent_id[parent_id].append(entity)\n\n        for folder_path in folder_paths:\n            names = folder_path.lstrip(\"/\").split(\"/\")\n            entity_id = project_entity[\"id\"]\n            for name in names:\n                child_id = None\n                for child in entities_by_parent_id[entity_id]:\n                    if child[\"name\"].lower() == name.lower():\n                        child_id = child[\"id\"]\n                        break\n                entity_id = child_id\n                if child_id is None:\n                    break\n            entity = entities_by_id.get(entity_id)\n            if entity is not None:\n                output[folder_path] = entity\n        return output\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/collect_ftrack_family.html","title":"collect_ftrack_family","text":"Requires <p>none</p> Provides <p>instance     -&gt; families ([])</p>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/collect_ftrack_family.html#client.ayon_ftrack.plugins.publish.collect_ftrack_family.CollectFtrackFamily","title":"<code>CollectFtrackFamily</code>","text":"<p>               Bases: <code>FtrackPublishInstancePlugin</code></p> <p>Adds explicitly 'ftrack' to families to upload instance to ftrack.</p> <p>Uses selection by combination of hosts/families/tasks names via profiles resolution.</p> <p>Triggered everywhere, checks instance against configured.</p> <p>Checks advanced filtering which works on 'families' not on main 'family', as some variants dynamically resolves addition of ftrack based on 'families' (editorial drives it by presence of 'review')</p> Source code in <code>client/ayon_ftrack/plugins/publish/collect_ftrack_family.py</code> <pre><code>class CollectFtrackFamily(plugin.FtrackPublishInstancePlugin):\n    \"\"\"Adds explicitly 'ftrack' to families to upload instance to ftrack.\n\n    Uses selection by combination of hosts/families/tasks names via\n    profiles resolution.\n\n    Triggered everywhere, checks instance against configured.\n\n    Checks advanced filtering which works on 'families' not on main\n    'family', as some variants dynamically resolves addition of ftrack\n    based on 'families' (editorial drives it by presence of 'review')\n    \"\"\"\n\n    label = \"Collect ftrack Family\"\n    order = pyblish.api.CollectorOrder + 0.4990\n\n    profiles = None\n\n    def process(self, instance):\n        if not self.profiles:\n            self.log.warning(\"No profiles present for adding ftrack family\")\n            return\n\n        host_name = instance.context.data[\"hostName\"]\n        product_type = instance.data[\"productType\"]\n        task_name = instance.data.get(\"task\")\n\n        filtering_criteria = {\n            \"host_names\": host_name,\n            \"product_types\": product_type,\n            \"task_names\": task_name\n        }\n        profile = filter_profiles(\n            self.profiles,\n            filtering_criteria,\n            logger=self.log\n        )\n\n        add_ftrack_family = False\n        families = instance.data.setdefault(\"families\", [])\n\n        if profile:\n            add_ftrack_family = profile[\"add_ftrack_family\"]\n            additional_filters = profile.get(\"advanced_filtering\")\n            if additional_filters:\n                families_set = set(families) | {product_type}\n                self.log.info(\n                    \"'{}' families used for additional filtering\".format(\n                        families_set))\n                add_ftrack_family = self._get_add_ftrack_f_from_addit_filters(\n                    additional_filters,\n                    families_set,\n                    add_ftrack_family\n                )\n\n        result_str = \"Not adding\"\n        if add_ftrack_family:\n            result_str = \"Adding\"\n            if \"ftrack\" not in families:\n                families.append(\"ftrack\")\n\n        self.log.debug(\"{} 'ftrack' family for instance with '{}'\".format(\n            result_str, product_type\n        ))\n\n    def _get_add_ftrack_f_from_addit_filters(\n        self, additional_filters, families, add_ftrack_family\n    ):\n        \"\"\"Compares additional filters - working on instance's families.\n\n        Triggered for more detailed filtering when main family matches,\n        but content of 'families' actually matter.\n        (For example 'review' in 'families' should result in adding to\n        ftrack)\n\n        Args:\n            additional_filters (dict) - from Setting\n            families (set[str]) - subfamilies\n            add_ftrack_family (bool) - add ftrack to families if True\n        \"\"\"\n\n        override_filter = None\n        override_filter_value = -1\n        for additional_filter in additional_filters:\n            filter_families = set(additional_filter[\"families\"])\n            valid = filter_families &lt;= set(families)  # issubset\n            if not valid:\n                continue\n\n            value = len(filter_families)\n            if value &gt; override_filter_value:\n                override_filter = additional_filter\n                override_filter_value = value\n\n        if override_filter:\n            add_ftrack_family = override_filter[\"add_ftrack_family\"]\n\n        return add_ftrack_family\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/collect_local_ftrack_creds.html","title":"collect_local_ftrack_creds","text":"<p>Collect default Deadline server.</p>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/collect_local_ftrack_creds.html#client.ayon_ftrack.plugins.publish.collect_local_ftrack_creds.CollectLocalFtrackCreds","title":"<code>CollectLocalFtrackCreds</code>","text":"<p>               Bases: <code>FtrackPublishContextPlugin</code></p> <p>Collect default Royal Render path.</p> Source code in <code>client/ayon_ftrack/plugins/publish/collect_local_ftrack_creds.py</code> <pre><code>class CollectLocalFtrackCreds(plugin.FtrackPublishContextPlugin):\n    \"\"\"Collect default Royal Render path.\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.01\n    label = \"Collect local ftrack credentials\"\n    targets = [\"rr_control\"]\n\n    def process(self, context):\n        if (\n            os.getenv(\"FTRACK_API_USER\")\n            and os.getenv(\"FTRACK_API_KEY\")\n            and os.getenv(\"FTRACK_SERVER\")\n        ):\n            return\n        addon = context.data[\"ayonAddonsManager\"].get(\"ftrack\")\n        if addon.enabled:\n            creds = addon.get_credentials()\n            username, api_key = creds\n            os.environ[\"FTRACK_API_USER\"] = username\n            os.environ[\"FTRACK_API_KEY\"] = api_key\n            os.environ[\"FTRACK_SERVER\"] = addon.ftrack_url\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/collect_webpublisher_credentials.html","title":"collect_webpublisher_credentials","text":"<p>Translates uploader's user email to ftrack username.</p> <p>Should run before 'CollectAnatomyContextData' so the user on context is changed before it's stored to context anatomy data or instance anatomy data.</p> Requires <p>instance.data.get(\"user_email\") or os.environ.get(\"USER_EMAIL\")</p> Provides <p>os.environ[\"FTRACK_API_USER\"] context.data[\"user\"]</p>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/collect_webpublisher_credentials.html#client.ayon_ftrack.plugins.publish.collect_webpublisher_credentials.CollectWebpublisherCredentials","title":"<code>CollectWebpublisherCredentials</code>","text":"<p>               Bases: <code>FtrackPublishContextPlugin</code></p> <pre><code>Translates uploader's user email to ftrack username.\n</code></pre> <p>It expects that user email in ftrack is same as user email in Ayon server, ftrack username is needed to load data to ftrack.</p> <p>Resets <code>context.data[\"user\"] to correctly populate</code>version.author<code>and</code>representation.context.username`</p> Source code in <code>client/ayon_ftrack/plugins/publish/collect_webpublisher_credentials.py</code> <pre><code>class CollectWebpublisherCredentials(plugin.FtrackPublishContextPlugin):\n    \"\"\"\n        Translates uploader's user email to ftrack username.\n\n    It expects that user email in ftrack is same as user email in Ayon server,\n    ftrack username is needed to load data to ftrack.\n\n    Resets `context.data[\"user\"] to correctly populate `version.author` and\n    `representation.context.username`\n\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.0015\n    label = \"Collect ftrack credentials for Webpublisher\"\n    hosts = [\"webpublisher\", \"photoshop\"]\n    targets = [\"webpublish\"]\n\n    def process(self, context):\n        service_api_key, service_username = self._get_username_key(context)\n        os.environ[\"FTRACK_API_USER\"] = service_username\n        os.environ[\"FTRACK_API_KEY\"] = service_api_key\n\n        user_email = self._get_user_email(context)\n\n        if not user_email:\n            self.log.warning(\"No email found\")\n            return\n\n        username = self._get_ftrack_username(user_email)\n        os.environ[\"FTRACK_API_USER\"] = username\n\n    def _get_ftrack_username(self, user_email):\n        \"\"\"Queries ftrack api for user with 'user_email'.\n\n        Raises:\n            ValueError: if user not found\n        \"\"\"\n        session = ftrack_api.Session(auto_connect_event_hub=False)\n        user = session.query(\n            \"User where email like '{}'\".format(user_email)\n        ).first()\n        if not user:\n            raise ValueError(\n                \"Couldn't find user with '{}' email\".format(user_email))\n        username = user.get(\"username\")\n        self.log.debug(\"Resolved ftrack username:: '{}'\".format(username))\n        return username\n\n    def _get_user_email(self, context):\n        \"\"\"Collect uploader's email address to lookup user in ftrack\"\"\"\n        # for publishes with studio processing\n        user_email = os.environ.get(\"USER_EMAIL\")\n        self.log.debug(\"Email from env:: {}\".format(user_email))\n        if not user_email:\n            # for basic webpublishes\n            for instance in context:\n                user_email = instance.data.get(\"user_email\")\n                self.log.debug(\"Email from instance:: {}\".format(user_email))\n                break\n        return user_email\n\n    def _get_username_key(self, context):\n        \"\"\"Query settings for ftrack credentials.\"\"\"\n        project_settings = context.data[\"project_settings\"]\n        service_settings = project_settings[\"ftrack\"][\"service_settings\"]\n\n        api_key_secret = service_settings[\"api_key\"]\n        username_secret = service_settings[\"username\"]\n\n        con = ayon_api.get_server_api_connection()\n        with con.as_username(None):\n            secrets_by_name = {\n                secret[\"name\"]: secret[\"value\"]\n                for secret in ayon_api.get_secrets()\n            }\n        api_key = secrets_by_name.get(api_key_secret)\n        username = secrets_by_name.get(username_secret)\n        if not api_key or not username:\n            raise KnownPublishError(\n                \"Missing ftrack credentials in settings. \"\n                \"Please let admin fill in \"\n                \"'ayon+settings://ftrack/service_settings'\"\n            )\n        return api_key, username\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_api.html","title":"integrate_ftrack_api","text":"<p>Integrate components into ftrack</p> Requires <p>context -&gt; ftrackSession - connected ftrack.Session instance -&gt; ftrackComponentsList - list of components to integrate</p> Provides <p>instance -&gt; ftrackIntegratedAssetVersionsData</p>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_api.html#client.ayon_ftrack.plugins.publish.integrate_ftrack_api--legacy","title":"legacy","text":"<p>instance -&gt; ftrackIntegratedAssetVersions</p>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_api.html#client.ayon_ftrack.plugins.publish.integrate_ftrack_api.IntegrateFtrackApi","title":"<code>IntegrateFtrackApi</code>","text":"<p>               Bases: <code>FtrackPublishInstancePlugin</code></p> <p>Commit components to server.</p> Source code in <code>client/ayon_ftrack/plugins/publish/integrate_ftrack_api.py</code> <pre><code>class IntegrateFtrackApi(plugin.FtrackPublishInstancePlugin):\n    \"\"\" Commit components to server. \"\"\"\n\n    order = pyblish.api.IntegratorOrder + 0.499\n    label = \"Integrate ftrack Api\"\n    families = [\"ftrack\"]\n\n    def process(self, instance):\n        component_list = instance.data.get(\"ftrackComponentsList\")\n        if not component_list:\n            self.log.debug(\n                \"Instance doesn't have components to integrate to ftrack.\"\n                \" Skipping.\"\n            )\n            return\n\n        context = instance.context\n        task_entity, parent_entity = self.get_instance_entities(\n            instance, context)\n        if parent_entity is None:\n            self.log.debug((\n                \"Skipping ftrack integration. Instance \\\"{}\\\" does not\"\n                \" have specified ftrack entities.\"\n            ).format(str(instance)))\n            return\n\n        session = context.data[\"ftrackSession\"]\n        # Reset session operations and reconfigure locations\n        session.recorded_operations.clear()\n        session._configure_locations()\n\n        try:\n            self.integrate_to_ftrack(\n                session,\n                instance,\n                task_entity,\n                parent_entity,\n                component_list\n            )\n\n        except Exception:\n            session.reset()\n            raise\n\n    def get_instance_entities(self, instance, context):\n        parent_entity = None\n        task_entity = None\n        # If instance has set \"ftrackEntity\" or \"ftrackTask\" then use them from\n        #   instance. Even if they are set to None. If they are set to None it\n        #   has a reason. (like has different context)\n        if \"ftrackEntity\" in instance.data or \"ftrackTask\" in instance.data:\n            task_entity = instance.data.get(\"ftrackTask\")\n            parent_entity = instance.data.get(\"ftrackEntity\")\n\n        elif \"ftrackEntity\" in context.data or \"ftrackTask\" in context.data:\n            task_entity = context.data.get(\"ftrackTask\")\n            parent_entity = context.data.get(\"ftrackEntity\")\n\n        if task_entity:\n            parent_entity = task_entity[\"parent\"]\n\n        return task_entity, parent_entity\n\n    def integrate_to_ftrack(\n        self,\n        session,\n        instance,\n        task_entity,\n        parent_entity,\n        component_list\n    ):\n        default_asset_name = None\n        if task_entity:\n            default_asset_name = task_entity[\"name\"]\n\n        if not default_asset_name:\n            default_asset_name = parent_entity[\"name\"]\n\n        # Change status on task\n        asset_version_status_ids_by_name = {}\n        project_entity = instance.context.data.get(\"ftrackProject\")\n        if project_entity:\n            project_schema = project_entity[\"project_schema\"]\n            asset_version_statuses = (\n                project_schema.get_statuses(\"AssetVersion\")\n            )\n            asset_version_status_ids_by_name = {\n                status[\"name\"].lower(): status[\"id\"]\n                for status in asset_version_statuses\n            }\n\n        # Prepare AssetTypes\n        asset_types_by_short = self._ensure_asset_types_exists(\n            session, component_list\n        )\n        self._fill_component_locations(session, component_list)\n\n        asset_versions_data_by_id = {}\n        used_asset_versions = []\n\n        # Iterate over components and publish\n        for data in component_list:\n            self.log.debug(\"data: {}\".format(data))\n\n            # AssetType\n            asset_type_short = data[\"assettype_data\"][\"short\"]\n            asset_type_entity = asset_types_by_short[asset_type_short]\n\n            # Asset\n            asset_data = data.get(\"asset_data\") or {}\n            if \"name\" not in asset_data:\n                asset_data[\"name\"] = default_asset_name\n            asset_entity = self._ensure_asset_exists(\n                session,\n                asset_data,\n                asset_type_entity[\"id\"],\n                parent_entity[\"id\"]\n            )\n\n            # Asset Version\n            asset_version_data = data.get(\"assetversion_data\") or {}\n            asset_version_entity = self._ensure_asset_version_exists(\n                session,\n                asset_version_data,\n                asset_entity[\"id\"],\n                task_entity,\n                asset_version_status_ids_by_name\n            )\n\n            # Store asset version and components items that were\n            version_id = asset_version_entity[\"id\"]\n            if version_id not in asset_versions_data_by_id:\n                asset_versions_data_by_id[version_id] = {\n                    \"asset_version\": asset_version_entity,\n                    \"component_items\": []\n                }\n\n            asset_versions_data_by_id[version_id][\"component_items\"].append(\n                data\n            )\n\n            # Backwards compatibility\n            if asset_version_entity not in used_asset_versions:\n                used_asset_versions.append(asset_version_entity)\n\n            # for version attributes `IntegrateVersionAttributes`\n            version_attributes = instance.data.setdefault(\n                \"versionAttributes\", {}\n            )\n            version_attributes[FTRACK_ID_ATTRIB] = version_id\n\n        self._create_components(session, asset_versions_data_by_id)\n\n        instance.data[\"ftrackIntegratedAssetVersionsData\"] = (\n            asset_versions_data_by_id\n        )\n\n        # Backwards compatibility\n        asset_versions_key = \"ftrackIntegratedAssetVersions\"\n        if asset_versions_key not in instance.data:\n            instance.data[asset_versions_key] = []\n\n        for asset_version in used_asset_versions:\n            if asset_version not in instance.data[asset_versions_key]:\n                instance.data[asset_versions_key].append(asset_version)\n\n    def _fill_component_locations(self, session, component_list):\n        components_by_location_name = collections.defaultdict(list)\n        components_by_location_id = collections.defaultdict(list)\n        for component_item in component_list:\n            # Location entity can be prefilled\n            # - this is not recommended as connection to ftrack server may\n            #   be lost and in that case the entity is not valid when gets\n            #   to this plugin\n            location = component_item.get(\"component_location\")\n            if location is not None:\n                continue\n\n            # Collect location id\n            location_id = component_item.get(\"component_location_id\")\n            if location_id:\n                components_by_location_id[location_id].append(\n                    component_item\n                )\n                continue\n\n            location_name = component_item.get(\"component_location_name\")\n            if location_name:\n                components_by_location_name[location_name].append(\n                    component_item\n                )\n                continue\n\n        # Skip if there is nothing to do\n        if not components_by_location_name and not components_by_location_id:\n            return\n\n        # Query locations\n        query_filters = []\n        if components_by_location_id:\n            joined_location_ids = \",\".join([\n                '\"{}\"'.format(location_id)\n                for location_id in components_by_location_id\n            ])\n            query_filters.append(\"id in ({})\".format(joined_location_ids))\n\n        if components_by_location_name:\n            joined_location_names = \",\".join([\n                '\"{}\"'.format(location_name)\n                for location_name in components_by_location_name\n            ])\n            query_filters.append(\"name in ({})\".format(joined_location_names))\n\n        locations = session.query(\n            \"select id, name from Location where {}\".format(\n                \" or \".join(query_filters)\n            )\n        ).all()\n        # Fill locations in components\n        for location in locations:\n            location_id = location[\"id\"]\n            location_name = location[\"name\"]\n            if location_id in components_by_location_id:\n                for component in components_by_location_id[location_id]:\n                    component[\"component_location\"] = location\n\n            if location_name in components_by_location_name:\n                for component in components_by_location_name[location_name]:\n                    component[\"component_location\"] = location\n\n    def _ensure_asset_types_exists(self, session, component_list):\n        \"\"\"Make sure that all AssetType entities exists for integration.\n\n        Returns:\n            dict: All asset types by short name.\n        \"\"\"\n        # Query existing asset types\n        asset_types = session.query(\"select id, short from AssetType\").all()\n        # Stpore all existing short names\n        asset_type_shorts = {asset_type[\"short\"] for asset_type in asset_types}\n        # Check which asset types are missing and store them\n        asset_type_names_by_missing_shorts = {}\n        default_short_name = \"upload\"\n        for data in component_list:\n            asset_type_data = data.get(\"assettype_data\") or {}\n            asset_type_short = asset_type_data.get(\"short\")\n            if not asset_type_short:\n                # Use default asset type name if not set and change the\n                #   input data\n                asset_type_short = default_short_name\n                asset_type_data[\"short\"] = asset_type_short\n                data[\"assettype_data\"] = asset_type_data\n\n            if (\n                # Skip if short name exists\n                asset_type_short in asset_type_shorts\n                # Skip if short name was already added to missing types\n                #   and asset type name is filled\n                # - if asset type name is missing then try use name from other\n                #   data\n                or asset_type_names_by_missing_shorts.get(asset_type_short)\n            ):\n                continue\n\n            asset_type_names_by_missing_shorts[asset_type_short] = (\n                asset_type_data.get(\"name\")\n            )\n\n        # Create missing asset types if there are any\n        if asset_type_names_by_missing_shorts:\n            self.log.info(\"Creating asset types with short names: {}\".format(\n                \", \".join(asset_type_names_by_missing_shorts.keys())\n            ))\n            for missing_short, type_name in (\n                asset_type_names_by_missing_shorts.items()\n            ):\n                # Use short for name if name is not defined\n                if not type_name:\n                    type_name = missing_short\n                # Use short name also for name\n                #   - there is not other source for 'name'\n                session.create(\n                    \"AssetType\",\n                    {\n                        \"short\": missing_short,\n                        \"name\": type_name\n                    }\n                )\n\n            # Commit creation\n            session.commit()\n            # Requery asset types\n            asset_types = session.query(\n                \"select id, short from AssetType\"\n            ).all()\n\n        return {asset_type[\"short\"]: asset_type for asset_type in asset_types}\n\n    def _ensure_asset_exists(\n        self, session, asset_data, asset_type_id, parent_id\n    ):\n        asset_name = asset_data[\"name\"]\n        asset_entity = self._query_asset(\n            session, asset_name, asset_type_id, parent_id\n        )\n        if asset_entity is not None:\n            return asset_entity\n\n        asset_data = {\n            \"name\": asset_name,\n            \"type_id\": asset_type_id,\n            \"context_id\": parent_id\n        }\n        self.log.debug(\"Created new Asset with data: {}.\".format(asset_data))\n        session.create(\"Asset\", asset_data)\n        session.commit()\n        return self._query_asset(session, asset_name, asset_type_id, parent_id)\n\n    def _query_asset(self, session, asset_name, asset_type_id, parent_id):\n        return session.query(\n            (\n                \"select id from Asset\"\n                \" where name is \\\"{}\\\"\"\n                \" and type_id is \\\"{}\\\"\"\n                \" and context_id is \\\"{}\\\"\"\n            ).format(asset_name, asset_type_id, parent_id)\n        ).first()\n\n    def _ensure_asset_version_exists(\n        self,\n        session,\n        asset_version_data,\n        asset_id,\n        task_entity,\n        status_ids_by_name\n    ):\n        task_id = None\n        if task_entity:\n            task_id = task_entity[\"id\"]\n\n        status_name = asset_version_data.pop(\"status_name\", None)\n\n        # Try query asset version by criteria (asset id and version)\n        version = asset_version_data.get(\"version\") or 0\n        asset_version_entity = self._query_asset_version(\n            session, version, asset_id\n        )\n\n        # Prepare comment value\n        comment = asset_version_data.get(\"comment\") or \"\"\n        if asset_version_entity is not None:\n            changed = False\n            if comment != asset_version_entity[\"comment\"]:\n                asset_version_entity[\"comment\"] = comment\n                changed = True\n\n            if task_id != asset_version_entity[\"task_id\"]:\n                asset_version_entity[\"task_id\"] = task_id\n                changed = True\n\n            if changed:\n                session.commit()\n\n        else:\n            # Convert '0' version to string `\"0\"`\n            # - ftrack handles `0` as empty value\n            if version == 0:\n                version = \"0\"\n\n            new_asset_version_data = {\n                \"version\": version,\n                \"asset_id\": asset_id\n            }\n            if task_id:\n                new_asset_version_data[\"task_id\"] = task_id\n\n            if comment:\n                new_asset_version_data[\"comment\"] = comment\n\n            self.log.debug(\"Created new AssetVersion with data {}\".format(\n                new_asset_version_data\n            ))\n            session.create(\"AssetVersion\", new_asset_version_data)\n            session.commit()\n            asset_version_entity = self._query_asset_version(\n                session, version, asset_id\n            )\n\n        if status_name:\n            status_id = status_ids_by_name.get(status_name.lower())\n            if not status_id:\n                self.log.info((\n                    \"ftrack status with name \\\"{}\\\"\"\n                    \" for AssetVersion was not found.\"\n                ).format(status_name))\n\n            elif asset_version_entity[\"status_id\"] != status_id:\n                asset_version_entity[\"status_id\"] = status_id\n                session.commit()\n\n        # Set custom attributes if there were any set\n        custom_attrs = asset_version_data.get(\"custom_attributes\") or {}\n        for attr_key, attr_value in custom_attrs.items():\n            if attr_key in asset_version_entity[\"custom_attributes\"]:\n                try:\n                    asset_version_entity[\"custom_attributes\"][attr_key] = (\n                        attr_value\n                    )\n                    session.commit()\n                    continue\n                except Exception:\n                    session.rollback()\n                    session._configure_locations()\n\n            self.log.warning(\n                (\n                    \"Custom Attribute \\\"{0}\\\" is not available for\"\n                    \" AssetVersion &lt;{1}&gt;. Can't set it's value to: \\\"{2}\\\"\"\n                ).format(\n                    attr_key, asset_version_entity[\"id\"], str(attr_value)\n                )\n            )\n\n        return asset_version_entity\n\n    def _query_asset_version(self, session, version, asset_id):\n        return session.query(\n            (\n                \"select id, task_id, comment from AssetVersion\"\n                \" where version is \\\"{}\\\" and asset_id is \\\"{}\\\"\"\n            ).format(version, asset_id)\n        ).first()\n\n    def create_component(self, session, asset_version_entity, data):\n        component_data = data.get(\"component_data\") or {}\n\n        if not component_data.get(\"name\"):\n            component_data[\"name\"] = \"main\"\n\n        version_id = asset_version_entity[\"id\"]\n        component_data[\"version_id\"] = version_id\n        component_entity = session.query(\n            (\n                \"select id, name from Component where name is \\\"{}\\\"\"\n                \" and version_id is \\\"{}\\\"\"\n            ).format(component_data[\"name\"], version_id)\n        ).first()\n\n        component_overwrite = data.get(\"component_overwrite\", False)\n        location = data.get(\"component_location\", session.pick_location())\n\n        # Overwrite existing component data if requested.\n        if component_entity and component_overwrite:\n            origin_location = session.query(\n                \"Location where name is \\\"ftrack.origin\\\"\"\n            ).one()\n\n            # Removing existing members from location\n            components = list(component_entity.get(\"members\", []))\n            components += [component_entity]\n            for component in components:\n                for loc in component[\"component_locations\"]:\n                    if location[\"id\"] == loc[\"location_id\"]:\n                        location.remove_component(\n                            component, recursive=False\n                        )\n\n            # Deleting existing members on component entity\n            for member in component_entity.get(\"members\", []):\n                session.delete(member)\n\n            session.commit()\n\n            # Reset members in memory\n            if \"members\" in component_entity.keys():\n                component_entity[\"members\"] = []\n\n            # Add components to origin location\n            try:\n                collection = clique.parse(data[\"component_path\"])\n            except ValueError:\n                # Assume its a single file\n                # Changing file type\n                name, ext = os.path.splitext(data[\"component_path\"])\n                component_entity[\"file_type\"] = ext\n\n                origin_location.add_component(\n                    component_entity, data[\"component_path\"]\n                )\n            else:\n                # Changing file type\n                component_entity[\"file_type\"] = collection.format(\"{tail}\")\n\n                # Create member components for sequence.\n                for member_path in collection:\n\n                    size = 0\n                    try:\n                        size = os.path.getsize(member_path)\n                    except OSError:\n                        pass\n\n                    name = collection.match(member_path).group(\"index\")\n\n                    member_data = {\n                        \"name\": name,\n                        \"container\": component_entity,\n                        \"size\": size,\n                        \"file_type\": os.path.splitext(member_path)[-1]\n                    }\n\n                    component = session.create(\n                        \"FileComponent\", member_data\n                    )\n                    origin_location.add_component(\n                        component, member_path, recursive=False\n                    )\n                    component_entity[\"members\"].append(component)\n\n            # Add components to location.\n            location.add_component(\n                component_entity, origin_location, recursive=True\n            )\n\n            data[\"component\"] = component_entity\n            self.log.info(\n                (\n                    \"Overwriting Component with path: {0}, data: {1},\"\n                    \" location: {2}\"\n                ).format(\n                    data[\"component_path\"],\n                    component_data,\n                    location\n                )\n            )\n\n        # Extracting metadata, and adding after entity creation. This is\n        # due to a ftrack_api bug where you can't add metadata on creation.\n        component_metadata = component_data.pop(\"metadata\", {})\n\n        # Create new component if none exists.\n        new_component = False\n        if not component_entity:\n            component_entity = asset_version_entity.create_component(\n                data[\"component_path\"],\n                data=component_data,\n                location=location\n            )\n            data[\"component\"] = component_entity\n            self.log.debug(\n                (\n                    \"Created new Component with path: {0}, data: {1},\"\n                    \" metadata: {2}, location: {3}\"\n                ).format(\n                    data[\"component_path\"],\n                    component_data,\n                    component_metadata,\n                    location\n                )\n            )\n            new_component = True\n\n        # Adding metadata\n        existing_component_metadata = component_entity[\"metadata\"]\n        existing_component_metadata.update(component_metadata)\n        component_entity[\"metadata\"] = existing_component_metadata\n\n        # if component_data['name'] = 'ftrackreview-mp4-mp4':\n        #     assetversion_entity[\"thumbnail_id\"]\n\n        # Setting assetversion thumbnail\n        if data.get(\"thumbnail\"):\n            asset_version_entity[\"thumbnail_id\"] = component_entity[\"id\"]\n\n        # Inform user about no changes to the database.\n        if (\n            component_entity\n            and not component_overwrite\n            and not new_component\n        ):\n            data[\"component\"] = component_entity\n            self.log.info(\n                \"Found existing component, and no request to overwrite. \"\n                \"Nothing has been changed.\"\n            )\n        else:\n            # Commit changes.\n            session.commit()\n\n    def _create_components(self, session, asset_versions_data_by_id):\n        for item in asset_versions_data_by_id.values():\n            asset_version_entity = item[\"asset_version\"]\n            component_items = item[\"component_items\"]\n\n            component_entities = session.query(\n                (\n                    \"select id, name from Component where version_id is \\\"{}\\\"\"\n                ).format(asset_version_entity[\"id\"])\n            ).all()\n\n            existing_component_names = {\n                component[\"name\"]\n                for component in component_entities\n            }\n\n            contain_review = \"ftrackreview-mp4\" in existing_component_names\n            thumbnail_component_item = None\n            for component_item in component_items:\n                component_data = component_item.get(\"component_data\") or {}\n                component_name = component_data.get(\"name\")\n                if component_name == \"ftrackreview-mp4\":\n                    contain_review = True\n                elif component_name == \"ftrackreview-image\":\n                    thumbnail_component_item = component_item\n\n            if contain_review and thumbnail_component_item:\n                thumbnail_component_item[\"component_data\"][\"name\"] = (\n                    \"thumbnail\"\n                )\n\n            # Component\n            for component_item in component_items:\n                self.create_component(\n                    session, asset_version_entity, component_item\n                )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_component_overwrite.html","title":"integrate_ftrack_component_overwrite","text":""},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_component_overwrite.html#client.ayon_ftrack.plugins.publish.integrate_ftrack_component_overwrite.IntegrateFtrackComponentOverwrite","title":"<code>IntegrateFtrackComponentOverwrite</code>","text":"<p>               Bases: <code>FtrackPublishInstancePlugin</code></p> <p>Set <code>component_overwrite</code> to True on all instances <code>ftrackComponentsList</code></p> Source code in <code>client/ayon_ftrack/plugins/publish/integrate_ftrack_component_overwrite.py</code> <pre><code>class IntegrateFtrackComponentOverwrite(plugin.FtrackPublishInstancePlugin):\n    \"\"\"\n    Set `component_overwrite` to True on all instances `ftrackComponentsList`\n    \"\"\"\n\n    order = pyblish.api.IntegratorOrder + 0.49\n    label = \"Overwrite ftrack created versions\"\n    families = [\"clip\"]\n    optional = True\n    active = False\n\n    def process(self, instance):\n        component_list = instance.data.get(\"ftrackComponentsList\")\n        if not component_list:\n            self.log.info(\"No component to overwrite...\")\n            return\n\n        for cl in component_list:\n            cl[\"component_overwrite\"] = True\n            name = cl[\"component_data\"][\"name\"]\n            self.log.debug(\"Component {} overwriting\".format(name))\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_description.html","title":"integrate_ftrack_description","text":"Requires <p>context &gt; comment context &gt; ftrackSession instance &gt; ftrackIntegratedAssetVersionsData</p>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_description.html#client.ayon_ftrack.plugins.publish.integrate_ftrack_description.IntegrateFtrackDescription","title":"<code>IntegrateFtrackDescription</code>","text":"<p>               Bases: <code>FtrackPublishInstancePlugin</code></p> <p>Add description to AssetVersions in ftrack.</p> Source code in <code>client/ayon_ftrack/plugins/publish/integrate_ftrack_description.py</code> <pre><code>class IntegrateFtrackDescription(plugin.FtrackPublishInstancePlugin):\n    \"\"\"Add description to AssetVersions in ftrack.\"\"\"\n\n    # Must be after IntegrateAsset plugin in ayon_core\n    order = pyblish.api.IntegratorOrder + 0.4999\n    label = \"Integrate ftrack description\"\n    families = [\"ftrack\"]\n    optional = True\n\n    # Can be set in settings:\n    # - Allows `intent` and `comment` keys\n    description_template = \"{comment}\"\n\n    def process(self, instance):\n        if not self.description_template:\n            self.log.info(\"Skipping. Description template is not set.\")\n            return\n\n        # Check if there are any integrated AssetVersion entities\n        asset_versions_key = \"ftrackIntegratedAssetVersionsData\"\n        asset_versions_data_by_id = instance.data.get(asset_versions_key)\n        if not asset_versions_data_by_id:\n            self.log.info(\"There are any integrated AssetVersions\")\n            return\n\n        comment = instance.data[\"comment\"]\n        if not comment:\n            self.log.debug(\"Comment is not set.\")\n        else:\n            self.log.debug(\"Comment is set to `{}`\".format(comment))\n\n        intent = instance.context.data.get(\"intent\")\n        if intent and \"{intent}\" in self.description_template:\n            value = intent.get(\"value\")\n            if value:\n                intent = intent.get(\"label\") or value\n\n        if not intent and not comment:\n            self.log.info(\"Skipping. Intent and comment are empty.\")\n            return\n\n        # if intent label is set then format comment\n        # - it is possible that intent_label is equal to \"\" (empty string)\n        if intent:\n            self.log.debug(\"Intent is set to `{}`.\".format(intent))\n        else:\n            self.log.debug(\"Intent is not set.\")\n\n        # If we would like to use more \"optional\" possibilities we would have\n        #   come up with some expressions in templates or speicifc templates\n        #   for all 3 possible combinations when comment and intent are\n        #   set or not (when both are not set then description does not\n        #   make sense).\n        fill_data = {}\n        if comment:\n            fill_data[\"comment\"] = comment\n        if intent:\n            fill_data[\"intent\"] = intent\n\n        description = StringTemplate.format_template(\n            self.description_template, fill_data\n        )\n        if not description.solved:\n            self.log.warning((\n                \"Couldn't solve template \\\"{}\\\" with data {}\"\n            ).format(\n                self.description_template, json.dumps(fill_data, indent=4)\n            ))\n            return\n\n        if not description:\n            self.log.debug((\n                \"Skipping. Result of template is empty string.\"\n                \" Template \\\"{}\\\" Fill data: {}\"\n            ).format(\n                self.description_template, json.dumps(fill_data, indent=4)\n            ))\n            return\n\n        session = instance.context.data[\"ftrackSession\"]\n        for asset_version_data in asset_versions_data_by_id.values():\n            asset_version = asset_version_data[\"asset_version\"]\n\n            # Backwards compatibility for older settings using\n            #   attribute 'note_with_intent_template'\n\n            asset_version[\"comment\"] = description\n\n            try:\n                session.commit()\n                self.log.debug(\"Comment added to AssetVersion \\\"{}\\\"\".format(\n                    str(asset_version)\n                ))\n            except Exception as exc:\n                session.rollback()\n                session._configure_locations()\n                raise exc\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_farm_status.html","title":"integrate_ftrack_farm_status","text":""},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_farm_status.html#client.ayon_ftrack.plugins.publish.integrate_ftrack_farm_status.IntegrateFtrackFarmStatus","title":"<code>IntegrateFtrackFarmStatus</code>","text":"<p>               Bases: <code>FtrackPublishContextPlugin</code></p> <p>Change task status when should be published on farm.</p> <p>Instance which has set \"farm\" key in data to 'True' is considered as will be rendered on farm thus it's status should be changed.</p> Source code in <code>client/ayon_ftrack/plugins/publish/integrate_ftrack_farm_status.py</code> <pre><code>class IntegrateFtrackFarmStatus(plugin.FtrackPublishContextPlugin):\n    \"\"\"Change task status when should be published on farm.\n\n    Instance which has set \"farm\" key in data to 'True' is considered as will\n    be rendered on farm thus it's status should be changed.\n    \"\"\"\n\n    order = pyblish.api.IntegratorOrder + 0.48\n    label = \"Integrate ftrack Farm Status\"\n    farm_status_profiles = []\n\n    def process(self, context):\n        # Quick end\n        if not self.farm_status_profiles:\n            project_name = context.data[\"projectName\"]\n            self.log.info((\n                \"Status profiles are not filled for project \\\"{}\\\". Skipping\"\n            ).format(project_name))\n            return\n\n        filtered_instances = self.filter_instances(context)\n        instances_with_status_names = self.get_instances_with_statuse_names(\n            context, filtered_instances\n        )\n        if instances_with_status_names:\n            self.fill_statuses(context, instances_with_status_names)\n\n    def filter_instances(self, context):\n        filtered_instances = []\n        for instance in context:\n            # Skip disabled instances\n            if instance.data.get(\"publish\") is False:\n                continue\n            product_name = instance.data[\"productName\"]\n            msg_start = \"Skipping instance {}.\".format(product_name)\n            if not instance.data.get(\"farm\"):\n                self.log.debug(\n                    \"{} Won't be rendered on farm.\".format(msg_start)\n                )\n                continue\n\n            task_entity = instance.data.get(\"ftrackTask\")\n            if not task_entity:\n                self.log.debug(\n                    \"{} Does not have filled task\".format(msg_start)\n                )\n                continue\n\n            filtered_instances.append(instance)\n        return filtered_instances\n\n    def get_instances_with_statuse_names(self, context, instances):\n        instances_with_status_names = []\n        for instance in instances:\n            product_type = instance.data[\"productType\"]\n            product_name = instance.data[\"productName\"]\n            task_entity = instance.data[\"ftrackTask\"]\n            host_name = context.data[\"hostName\"]\n            task_name = task_entity[\"name\"]\n            task_type = task_entity[\"type\"][\"name\"]\n            status_profile = filter_profiles(\n                self.farm_status_profiles,\n                {\n                    \"host_names\": host_name,\n                    \"task_types\": task_type,\n                    \"task_names\": task_name,\n                    \"product_types\": product_type,\n                    \"product_names\": product_name,\n                },\n                logger=self.log\n            )\n            if not status_profile:\n                # There already is log in 'filter_profiles'\n                continue\n\n            status_name = status_profile[\"status_name\"]\n            if status_name:\n                instances_with_status_names.append((instance, status_name))\n        return instances_with_status_names\n\n    def fill_statuses(self, context, instances_with_status_names):\n        # Prepare available task statuses on the project\n        project_name = context.data[\"projectName\"]\n        session = context.data[\"ftrackSession\"]\n        project_entity = session.query((\n            \"select project_schema from Project where full_name is \\\"{}\\\"\"\n        ).format(project_name)).one()\n        project_schema = project_entity[\"project_schema\"]\n\n        task_type_ids = set()\n        for item in instances_with_status_names:\n            instance, _ = item\n            task_entity = instance.data[\"ftrackTask\"]\n            task_type_ids.add(task_entity[\"type\"][\"id\"])\n\n        task_statuses_by_type_id = {\n            task_type_id: project_schema.get_statuses(\"Task\", task_type_id)\n            for task_type_id in task_type_ids\n        }\n\n        # Keep track if anything has changed\n        skipped_status_names = set()\n        status_changed = False\n        for item in instances_with_status_names:\n            instance, status_name = item\n            task_entity = instance.data[\"ftrackTask\"]\n            task_statuses = task_statuses_by_type_id[task_entity[\"type\"][\"id\"]]\n            status_name_low = status_name.lower()\n\n            status_id = None\n            status_name = None\n            # Skip if status name was already tried to be found\n            for status in task_statuses:\n                if status[\"name\"].lower() == status_name_low:\n                    status_id = status[\"id\"]\n                    status_name = status[\"name\"]\n                    break\n\n            if status_id is None:\n                if status_name_low not in skipped_status_names:\n                    skipped_status_names.add(status_name_low)\n                    joined_status_names = \", \".join({\n                        '\"{}\"'.format(status[\"name\"])\n                        for status in task_statuses\n                    })\n                    self.log.warning((\n                        \"Status \\\"{}\\\" is not available on project \\\"{}\\\".\"\n                        \" Available statuses are {}\"\n                    ).format(status_name, project_name, joined_status_names))\n                continue\n\n            # Change task status id\n            if status_id != task_entity[\"status_id\"]:\n                task_entity[\"status_id\"] = status_id\n                status_changed = True\n                path = \"/\".join([\n                    item[\"name\"]\n                    for item in task_entity[\"link\"]\n                ])\n                self.log.debug(\"Set status \\\"{}\\\" to \\\"{}\\\"\".format(\n                    status_name, path\n                ))\n\n        if status_changed:\n            session.commit()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_instances.html","title":"integrate_ftrack_instances","text":""},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_instances.html#client.ayon_ftrack.plugins.publish.integrate_ftrack_instances.IntegrateFtrackInstance","title":"<code>IntegrateFtrackInstance</code>","text":"<p>               Bases: <code>FtrackPublishInstancePlugin</code></p> <p>Collect ftrack component data (not integrate yet).</p> <p>Add ftrack component list to instance.</p> Source code in <code>client/ayon_ftrack/plugins/publish/integrate_ftrack_instances.py</code> <pre><code>class IntegrateFtrackInstance(plugin.FtrackPublishInstancePlugin):\n    \"\"\"Collect ftrack component data (not integrate yet).\n\n    Add ftrack component list to instance.\n    \"\"\"\n\n    order = pyblish.api.IntegratorOrder + 0.48\n    label = \"Integrate ftrack Component\"\n    families = [\"ftrack\"]\n\n    metadata_keys_to_label = {\n        \"ayon_ftrack_version\": \"AYON ftrack version\",\n        \"ayon_launcher_version\": \"AYON launcher version\",\n        \"frame_start\": \"Frame start\",\n        \"frame_end\": \"Frame end\",\n        \"duration\": \"Duration\",\n        \"width\": \"Resolution width\",\n        \"height\": \"Resolution height\",\n        \"fps\": \"FPS\",\n        \"codec\": \"Codec\"\n    }\n\n    product_type_mapping = [\n        {\"name\": \"camera\", \"asset_type\": \"cam\"},\n        {\"name\": \"look\", \"asset_type\": \"look\"},\n        {\"name\": \"mayaAscii\", \"asset_type\": \"scene\"},\n        {\"name\": \"model\", \"asset_type\": \"geo\"},\n        {\"name\": \"rig\", \"asset_type\": \"rig\"},\n        {\"name\": \"setdress\", \"asset_type\": \"setdress\"},\n        {\"name\": \"pointcache\", \"asset_type\": \"cache\"},\n        {\"name\": \"render\", \"asset_type\": \"render\"},\n        {\"name\": \"prerender\", \"asset_type\": \"render\"},\n        {\"name\": \"render2d\", \"asset_type\": \"render\"},\n        {\"name\": \"nukescript\", \"asset_type\": \"comp\"},\n        {\"name\": \"write\", \"asset_type\": \"render\"},\n        {\"name\": \"review\", \"asset_type\": \"mov\"},\n        {\"name\": \"plate\", \"asset_type\": \"img\"},\n        {\"name\": \"audio\", \"asset_type\": \"audio\"},\n        {\"name\": \"workfile\", \"asset_type\": \"scene\"},\n        {\"name\": \"animation\", \"asset_type\": \"cache\"},\n        {\"name\": \"image\", \"asset_type\": \"img\"},\n        {\"name\": \"reference\", \"asset_type\": \"reference\"}\n    ]\n    keep_first_product_name_for_review = True\n    upload_reviewable_with_origin_name = False\n    asset_versions_status_profiles = []\n    additional_metadata_keys = []\n\n    def process(self, instance):\n        # QUESTION: should this be operating even for `farm` target?\n        self.log.debug(\"instance {}\".format(instance))\n\n        instance_repres = instance.data.get(\"representations\")\n        if not instance_repres:\n            self.log.info((\n                \"Skipping instance. Does not have any representations {}\"\n            ).format(str(instance)))\n            return\n\n        instance_version = instance.data.get(\"version\")\n        if instance_version is None:\n            raise ValueError(\"Instance version not set\")\n\n        version_number = int(instance_version)\n\n        product_type = instance.data[\"productType\"]\n\n        # Perform case-insensitive family mapping\n        product_type_low = product_type.lower()\n        asset_type = instance.data.get(\"ftrackFamily\")\n        if not asset_type:\n            for item in self.product_type_mapping:\n                if item[\"name\"].lower() == product_type_low:\n                    asset_type = item[\"asset_type\"]\n                    break\n\n        if not asset_type:\n            asset_type = \"upload\"\n\n        self.log.debug(\n            \"Family: {}\\nMapping: {}\".format(\n                product_type_low, self.product_type_mapping)\n        )\n        status_name = self._get_asset_version_status_name(instance)\n\n        # Base of component item data\n        # - create a copy of this object when want to use it\n        version_entity = instance.data.get(\"versionEntity\")\n        av_custom_attributes = {}\n        if version_entity:\n            version_path = \"/\".join([\n                instance.data[\"folderPath\"],\n                instance.data[\"productName\"],\n                \"v{:0&gt;3}\".format(version_entity[\"version\"])\n            ])\n            av_custom_attributes.update({\n                CUST_ATTR_KEY_SERVER_ID: version_entity[\"id\"],\n                CUST_ATTR_KEY_SERVER_PATH: version_path,\n            })\n\n        base_component_item = {\n            \"assettype_data\": {\n                \"short\": asset_type,\n            },\n            \"asset_data\": {\n                \"name\": instance.data[\"productName\"],\n            },\n            \"assetversion_data\": {\n                \"version\": version_number,\n                \"comment\": instance.data.get(\"comment\") or \"\",\n                \"status_name\": status_name,\n                \"custom_attributes\": av_custom_attributes\n            },\n            \"component_overwrite\": False,\n            # This can be change optionally\n            \"thumbnail\": False,\n            # These must be changed for each component\n            \"component_data\": None,\n            \"component_path\": None,\n            \"component_location\": None,\n            \"component_location_name\": None,\n            \"additional_data\": {}\n        }\n\n        # Filter types of representations\n        review_representations = []\n        thumbnail_representations = []\n        other_representations = []\n        has_movie_review = False\n        for repre in instance_repres:\n            repre_tags = repre.get(\"tags\") or []\n            # exclude representations with are going to be published on farm\n            if \"publish_on_farm\" in repre_tags:\n                continue\n\n            self.log.debug(\"Representation {}\".format(repre))\n\n            # include only thumbnail representations\n            repre_path = get_publish_repre_path(instance, repre, False)\n            if repre.get(\"thumbnail\") or \"thumbnail\" in repre_tags:\n                thumbnail_representations.append(repre)\n\n            # include only review representations\n            elif \"ftrackreview\" in repre_tags and repre_path:\n                review_representations.append(repre)\n                if self._is_repre_video(repre):\n                    has_movie_review = True\n\n            else:\n                # include all other representations\n                other_representations.append(repre)\n\n        # check if any outputName keys are in review_representations\n        # also check if any outputName keys are in thumbnail_representations\n        synced_multiple_output_names = []\n        for review_repre in review_representations:\n            review_output_name = review_repre.get(\"outputName\")\n            if not review_output_name:\n                continue\n            for thumb_repre in thumbnail_representations:\n                thumb_output_name = thumb_repre.get(\"outputName\")\n                if (\n                    thumb_output_name\n                    and thumb_output_name == review_output_name\n                    # output name can be added also as tags during intermediate\n                    # files creation\n                    or thumb_output_name in review_repre.get(\"tags\", [])\n                ):\n                    synced_multiple_output_names.append(thumb_output_name)\n\n        self.log.debug(\"Multiple output names: {}\".format(\n            synced_multiple_output_names\n        ))\n        multiple_synced_thumbnails = len(synced_multiple_output_names) &gt; 1\n\n        # Prepare ftrack locations\n        unmanaged_location_name = \"ftrack.unmanaged\"\n        ftrack_server_location_name = \"ftrack.server\"\n\n        # Components data\n        component_list = []\n        thumbnail_data_items = []\n\n        # Create thumbnail components\n        thumbnail_item = None\n        for repre in thumbnail_representations:\n            # get repre path from representation\n            # and return published_path if available\n            # the path is validated and if it does not exists it returns None\n            repre_path = get_publish_repre_path(\n                instance,\n                repre,\n                only_published=False\n            )\n            if not repre_path:\n                self.log.debug(\n                    \"Published path is not set or source was removed.\"\n                )\n                continue\n\n            # Create copy of base comp item and append it\n            thumbnail_item = copy.deepcopy(base_component_item)\n            thumbnail_item.update({\n                \"component_path\": repre_path,\n                \"component_data\": {\n                    \"name\": (\n                        \"thumbnail\"\n                        if review_representations\n                        else \"ftrackreview-image\"\n                    ),\n                    \"metadata\": self._prepare_image_component_metadata(\n                        repre,\n                        repre_path\n                    )\n                },\n                \"thumbnail\": True,\n                \"component_location_name\": ftrack_server_location_name\n            })\n\n            # add thumbnail data to items for future synchronization\n            current_item_data = {\n                \"sync_key\": repre.get(\"outputName\"),\n                \"representation\": repre,\n                \"item\": thumbnail_item\n            }\n            # Create copy of item before setting location\n            if \"delete\" not in repre.get(\"tags\", []):\n                src_comp = self._create_src_component(\n                    instance,\n                    repre,\n                    copy.deepcopy(thumbnail_item),\n                    unmanaged_location_name\n                )\n                component_list.append(src_comp)\n\n                current_item_data[\"src_component\"] = src_comp\n\n            # Add item to component list\n            thumbnail_data_items.append(current_item_data)\n\n        # Filter out image reviews if there is a movie review\n        review_representations = [\n            repre\n            for repre in review_representations\n            if not has_movie_review or self._is_repre_video(repre)\n        ]\n\n        # Create review components\n        # Change asset name of each new component for review\n        multiple_reviewable = len(review_representations) &gt; 1\n        extended_asset_name = None\n        for index, repre in enumerate(review_representations):\n            if not self._is_repre_video(repre) and has_movie_review:\n                self.log.debug(\n                    \"Movie repre has priority from {}\".format(repre)\n                )\n                continue\n            # Create copy of base comp item and append it\n            review_item = copy.deepcopy(base_component_item)\n\n            # get first or synchronize thumbnail item\n            sync_thumbnail_data = self._get_matching_thumbnail_item(\n                repre,\n                thumbnail_data_items,\n                multiple_synced_thumbnails\n            )\n            sync_thumbnail_item = None\n            sync_thumbnail_item_src = None\n            if sync_thumbnail_data:\n                sync_thumbnail_item = sync_thumbnail_data.get(\"item\")\n                sync_thumbnail_item_src = sync_thumbnail_data.get(\n                    \"src_component\")\n\n            \"\"\"\n            Renaming asset name only to those components which are explicitly\n            allowed in settings. Usually clients wanted to keep first component\n            as untouched product name with version and any other assetVersion\n            to be named with extended form. The renaming will only happen if\n            there is more than one reviewable component and extended name is\n            not empty.\n            \"\"\"\n            extended_asset_name = self._make_extended_component_name(\n                base_component_item, repre, index)\n\n            if multiple_reviewable and extended_asset_name:\n                review_item[\"asset_data\"][\"name\"] = extended_asset_name\n                # rename also thumbnail\n                if sync_thumbnail_item:\n                    sync_thumbnail_item[\"asset_data\"][\"name\"] = (\n                        extended_asset_name\n                    )\n                # rename also src_thumbnail\n                if sync_thumbnail_item_src:\n                    sync_thumbnail_item_src[\"asset_data\"][\"name\"] = (\n                        extended_asset_name\n                    )\n\n            # adding thumbnail component to component list\n            if sync_thumbnail_item:\n                component_list.append(copy.deepcopy(sync_thumbnail_item))\n            if sync_thumbnail_item_src:\n                component_list.append(copy.deepcopy(sync_thumbnail_item_src))\n\n            repre_path = get_publish_repre_path(instance, repre, False)\n            # add metadata to review component\n            if self._is_repre_video(repre):\n                component_name = \"ftrackreview-mp4\"\n                metadata = self._prepare_video_component_metadata(\n                    instance, repre, repre_path, True\n                )\n            else:\n                component_name = \"ftrackreview-image\"\n                metadata = self._prepare_image_component_metadata(\n                    repre, repre_path\n                )\n                review_item[\"thumbnail\"] = True\n\n            review_item.update({\n                \"component_path\": repre_path,\n                \"component_data\": {\n                    \"name\": component_name,\n                    \"metadata\": metadata\n                },\n                \"component_location_name\": ftrack_server_location_name\n            })\n\n            # Create copy of item before setting location\n            if \"delete\" not in repre.get(\"tags\", []):\n                src_comp = self._create_src_component(\n                    instance,\n                    repre,\n                    copy.deepcopy(review_item),\n                    unmanaged_location_name\n                )\n                component_list.append(src_comp)\n\n            # Add item to component list\n            component_list.append(review_item)\n\n            if self.upload_reviewable_with_origin_name:\n                origin_name_component = copy.deepcopy(review_item)\n                filename = os.path.basename(repre_path)\n                origin_name_component[\"component_data\"][\"name\"] = (\n                    os.path.splitext(filename)[0]\n                )\n                component_list.append(origin_name_component)\n\n        if not review_representations and thumbnail_item:\n            component_list.append(thumbnail_item)\n\n        # Add others representations as component\n        for repre in other_representations:\n            published_path = get_publish_repre_path(instance, repre, True)\n            if not published_path:\n                continue\n            # Create copy of base comp item and append it\n            other_item = copy.deepcopy(base_component_item)\n\n            # add extended name if any\n            if (\n                multiple_reviewable\n                and not self.keep_first_product_name_for_review\n                and extended_asset_name\n            ):\n                other_item[\"asset_data\"][\"name\"] = extended_asset_name\n\n            other_item.update({\n                \"component_path\": published_path,\n                \"component_data\": {\n                    \"name\": repre[\"name\"],\n                    \"metadata\": self._prepare_component_metadata(\n                        instance, repre, published_path, False\n                    )\n                },\n                \"component_location_name\": unmanaged_location_name,\n            })\n\n            component_list.append(other_item)\n\n        def json_obj_parser(obj):\n            return str(obj)\n\n        self.log.debug(\"Components list: {}\".format(\n            json.dumps(\n                component_list,\n                sort_keys=True,\n                indent=4,\n                default=json_obj_parser\n            )\n        ))\n        instance.data[\"ftrackComponentsList\"] = component_list\n\n    def _get_matching_thumbnail_item(\n        self,\n        review_representation,\n        thumbnail_data_items,\n        are_multiple_synced_thumbnails\n    ):\n        \"\"\"Return matching thumbnail item from list of thumbnail items.\n\n        If a thumbnail item already exists, this should return it.\n        The benefit is that if an `outputName` key is found in\n        representation and is also used as a `sync_key`  in a thumbnail\n        data item, it can sync with that item.\n\n        Args:\n            review_representation (dict[str, Any]): Review representation.\n            thumbnail_data_items (list[dict[str, Any]]): List of thumbnail\n                data items.\n            are_multiple_synced_thumbnails (bool): If there are multiple\n                synced thumbnails.\n\n        Returns:\n            Union[dict[str, Any], None]: Thumbnail data item or None\n        \"\"\"\n\n        if not thumbnail_data_items:\n            return None\n\n        if not are_multiple_synced_thumbnails:\n            return thumbnail_data_items[0]\n\n        output_name = review_representation.get(\"outputName\")\n        tags = review_representation.get(\"tags\", [])\n        for thumb_item in thumbnail_data_items:\n            if (\n                thumb_item[\"sync_key\"] == output_name\n                # intermediate files can have preset name in tags\n                # this is usually aligned with `outputName` distributed\n                # during thumbnail creation in `need_thumbnail` tagging\n                # workflow\n                or thumb_item[\"sync_key\"] in tags\n            ):\n                # return only synchronized thumbnail if multiple\n                return thumb_item\n\n        # WARNING: this can only happen if multiple thumbnails\n        # workflow is broken, since it found multiple matching outputName\n        # in representation but they do not align with any thumbnail item\n        self.log.warning((\n            \"No matching thumbnail item found for output name '{}'\"\n        ).format(output_name))\n        if thumbnail_data_items:\n            # as fallback return first thumbnail item\n            return thumbnail_data_items[0]\n\n        self.log.warning(\"No thumbnail data items found\")\n        return None\n\n    def _make_extended_component_name(\n        self, component_item, repre, iteration_index\n    ):\n        \"\"\" Returns the extended component name\n\n        Name is based on the asset name and representation name.\n\n        Args:\n            component_item (dict): The component item dictionary.\n            repre (dict): The representation dictionary.\n            iteration_index (int): The index of the iteration.\n\n        Returns:\n            str: The extended component name.\n        \"\"\"\n\n        # reset extended if no need for extended asset name\n        if self.keep_first_product_name_for_review and iteration_index == 0:\n            return\n\n        # get asset name and define extended name variant\n        asset_name = component_item[\"asset_data\"][\"name\"]\n        return \"_\".join(\n            (asset_name, repre[\"name\"])\n        )\n\n    def _create_src_component(\n        self, instance, repre, component_item, location\n    ):\n        \"\"\"Create src component for thumbnail.\n\n        This will replicate the input component and change its name to\n        have suffix \"_src\".\n\n        Args:\n            instance (pyblish.api.Instance): Pyblish instance.\n            repre (dict[str, Any]): Representation.\n            component_item (dict[str, Any]): Component item.\n            location (str): Location name.\n\n        Returns:\n            dict[str, Any]: Component item\n        \"\"\"\n\n        # Make sure thumbnail is disabled\n        component_item[\"thumbnail\"] = False\n        # Set location\n        component_item[\"component_location_name\"] = location\n        # Modify name of component to have suffix \"_src\"\n        component_data = component_item[\"component_data\"]\n        component_name = component_data[\"name\"]\n        component_data[\"name\"] = component_name + \"_src\"\n        component_data[\"metadata\"] = self._prepare_component_metadata(\n            instance, repre, component_item[\"component_path\"], False\n        )\n        return component_item\n\n    def _collect_additional_metadata(self, streams):\n        pass\n\n    def _get_asset_version_status_name(self, instance):\n        if not self.asset_versions_status_profiles:\n            return None\n\n        # Prepare filtering data for new asset version status\n        anatomy_data = instance.data[\"anatomyData\"]\n        task_type = anatomy_data.get(\"task\", {}).get(\"type\")\n        filtering_criteria = {\n            \"product_types\": instance.data[\"productType\"],\n            \"host_names\": instance.context.data[\"hostName\"],\n            \"task_types\": task_type\n        }\n        matching_profile = filter_profiles(\n            self.asset_versions_status_profiles,\n            filtering_criteria\n        )\n        if not matching_profile:\n            return None\n\n        return matching_profile[\"status\"] or None\n\n    def _prepare_component_metadata(\n        self, instance, repre, component_path, is_review=None\n    ):\n        \"\"\"Return representation file metadata, like width, height, fps.\n\n        This will only return any data for file formats matching a known\n        video or image extension and may pass with only a warning if it\n        was unable to retrieve the metadata from the image of video file.\n\n        Args:\n            instance (pyblish.api.Instance): Pyblish instance.\n            repre (dict[str, Any]): Representation.\n            component_path (str): Path to a representation file.\n            is_review (Optional[bool]): Component is a review component.\n\n        Returns:\n            dict[str, Any]: Component metadata.\n        \"\"\"\n\n        if self._is_repre_video(repre):\n            return self._prepare_video_component_metadata(\n                instance, repre, component_path, is_review\n            )\n        if self._is_repre_image(repre):\n            return self._prepare_image_component_metadata(\n                repre, component_path\n            )\n        return {}\n\n    def _prepare_video_component_metadata(\n        self, instance, repre, component_path, is_review=None\n    ):\n        metadata = {}\n        for key, value in (\n            (\"ayon_ftrack_version\", __version__),\n            (\"ayon_launcher_version\", get_ayon_launcher_version()),\n        ):\n            if key in self.additional_metadata_keys:\n                label = self.metadata_keys_to_label[key]\n                metadata[label] = value\n\n        extension = os.path.splitext(component_path)[-1]\n        streams = []\n        try:\n            streams = get_ffprobe_streams(component_path)\n        except Exception:\n            self.log.debug(\n                \"Failed to retrieve information about \"\n                \"input {}\".format(component_path))\n\n        # Find video streams\n        video_streams = [\n            stream\n            for stream in streams\n            if stream[\"codec_type\"] == \"video\"\n        ]\n        # Skip if there are no video streams\n        #   - exr is special case which can have issues with reading through\n        #       ffmpeg, but we want to set fps for it\n        if not video_streams and extension != \".exr\":\n            return metadata\n\n        stream_width = None\n        stream_height = None\n        stream_fps = None\n        frame_out = None\n        codec_label = None\n        for video_stream in video_streams:\n            codec_label = video_stream.get(\"codec_long_name\")\n            if not codec_label:\n                codec_label = video_stream.get(\"codec\")\n\n            if codec_label:\n                pix_fmt = video_stream.get(\"pix_fmt\")\n                if pix_fmt:\n                    codec_label += \" ({})\".format(pix_fmt)\n\n            tmp_width = video_stream.get(\"width\")\n            tmp_height = video_stream.get(\"height\")\n            if tmp_width and tmp_height:\n                stream_width = tmp_width\n                stream_height = tmp_height\n\n            input_framerate = video_stream.get(\"r_frame_rate\")\n            stream_duration = video_stream.get(\"duration\")\n            if input_framerate is None or stream_duration is None:\n                continue\n            try:\n                stream_fps = convert_ffprobe_fps_to_float(\n                    input_framerate\n                )\n            except ValueError:\n                self.log.warning(\n                    \"Could not convert ffprobe \"\n                    \"fps to float \\\"{}\\\"\".format(input_framerate))\n                continue\n\n            stream_width = tmp_width\n            stream_height = tmp_height\n            self.log.debug(\"FPS from stream is {} and duration is {}\".format(\n                input_framerate, stream_duration\n            ))\n            frame_out = float(stream_duration) * stream_fps\n            break\n\n        # Prepare FPS\n        instance_fps = instance.data.get(\"fps\")\n        if instance_fps is None:\n            instance_fps = instance.context.data[\"fps\"]\n\n        repre_fps = repre.get(\"fps\")\n        if repre_fps is not None:\n            repre_fps = float(repre_fps)\n\n        fps = stream_fps or repre_fps or instance_fps\n\n        # Prepare frame ranges\n        frame_start = repre.get(\"frameStartFtrack\")\n        frame_end = repre.get(\"frameEndFtrack\")\n        if frame_start is None or frame_end is None:\n            frame_start = instance.data[\"frameStart\"]\n            frame_end = instance.data[\"frameEnd\"]\n        duration = (frame_end - frame_start) + 1\n\n        for key, value in [\n            (\"fps\", fps),\n            (\"frame_start\", frame_start),\n            (\"frame_end\", frame_end),\n            (\"duration\", duration),\n            (\"width\", stream_width),\n            (\"height\", stream_height),\n            (\"fps\", fps),\n            (\"codec\", codec_label)\n        ]:\n            if not value or key not in self.additional_metadata_keys:\n                continue\n            label = self.metadata_keys_to_label[key]\n            metadata[label] = value\n\n        if not is_review:\n            ftr_meta = {}\n            if fps:\n                ftr_meta[\"frameRate\"] = fps\n\n            if stream_width and stream_height:\n                ftr_meta[\"width\"] = int(stream_width)\n                ftr_meta[\"height\"] = int(stream_height)\n            metadata[\"ftr_meta\"] = json.dumps(ftr_meta)\n            return metadata\n\n        # Frame end of uploaded video file should be duration in frames\n        # - frame start is always 0\n        # - frame end is duration in frames\n        if not frame_out:\n            frame_out = duration\n\n        # ftrack documentation says that it is required to have\n        #   'width' and 'height' in review component. But with those values\n        #   review video does not play.\n        metadata[\"ftr_meta\"] = json.dumps({\n            \"frameIn\": 0,\n            \"frameOut\": frame_out,\n            \"frameRate\": float(fps)\n        })\n        return metadata\n\n    def _prepare_image_component_metadata(self, repre, component_path):\n        width = repre.get(\"width\")\n        height = repre.get(\"height\")\n        if not width or not height:\n            streams = []\n            try:\n                streams = get_ffprobe_streams(component_path)\n            except Exception:\n                self.log.debug(\n                    \"Failed to retrieve information \"\n                    \"about input {}\".format(component_path))\n\n            for stream in streams:\n                if \"width\" in stream and \"height\" in stream:\n                    width = stream[\"width\"]\n                    height = stream[\"height\"]\n                    break\n\n        metadata = {}\n        if width and height:\n            metadata = {\n                \"ftr_meta\": json.dumps({\n                    \"width\": width,\n                    \"height\": height,\n                    \"format\": \"image\"\n                })\n            }\n\n        return metadata\n\n    def _is_repre_video(self, repre):\n        repre_ext = \".{}\".format(repre[\"ext\"])\n        return repre_ext in VIDEO_EXTENSIONS\n\n    def _is_repre_image(self, repre):\n        repre_ext = \".{}\".format(repre[\"ext\"])\n        return repre_ext in IMAGE_EXTENSIONS\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_status.html","title":"integrate_ftrack_status","text":""},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_status.html#client.ayon_ftrack.plugins.publish.integrate_ftrack_status.CollectFtrackTaskStatuses","title":"<code>CollectFtrackTaskStatuses</code>","text":"<p>               Bases: <code>FtrackPublishContextPlugin</code></p> <p>Collect available task statuses on the project.</p> <p>This is preparation for integration of task statuses.</p> Requirements <p>ftrackSession (ftrack_api.Session): Prepared ftrack session.</p> Provides <p>ftrackTaskStatuses (dict[str, list[Any]]): Dictionary of available     task statuses on project by task type id. ftrackStatusByTaskId (dict[str, str]): Empty dictionary of task     statuses by task id. Status on task can be set only once.     Value should be a name of status.</p> Source code in <code>client/ayon_ftrack/plugins/publish/integrate_ftrack_status.py</code> <pre><code>class CollectFtrackTaskStatuses(plugin.FtrackPublishContextPlugin):\n    \"\"\"Collect available task statuses on the project.\n\n    This is preparation for integration of task statuses.\n\n    Requirements:\n        ftrackSession (ftrack_api.Session): Prepared ftrack session.\n\n    Provides:\n        ftrackTaskStatuses (dict[str, list[Any]]): Dictionary of available\n            task statuses on project by task type id.\n        ftrackStatusByTaskId (dict[str, str]): Empty dictionary of task\n            statuses by task id. Status on task can be set only once.\n            Value should be a name of status.\n    \"\"\"\n\n    # After 'CollectFtrackApi'\n    order = pyblish.api.CollectorOrder + 0.4992\n    label = \"Collect ftrack Task Statuses\"\n\n    def process(self, context):\n        ftrack_session = context.data(\"ftrackSession\")\n        if ftrack_session is None:\n            self.log.info(\"ftrack session is not created.\")\n            return\n\n        # Prepare available task statuses on the project\n        project_name = context.data[\"projectName\"]\n        project_entity = ftrack_session.query((\n            \"select project_schema from Project where full_name is \\\"{}\\\"\"\n        ).format(project_name)).one()\n        project_schema = project_entity[\"project_schema\"]\n\n        task_type_ids = {\n            task_type[\"id\"]\n            for task_type in ftrack_session.query(\"select id from Type\").all()\n        }\n        task_statuses_by_type_id = {\n            task_type_id: project_schema.get_statuses(\"Task\", task_type_id)\n            for task_type_id in task_type_ids\n        }\n        context.data[\"ftrackTaskStatuses\"] = task_statuses_by_type_id\n        context.data[\"ftrackStatusByTaskId\"] = {}\n        self.log.debug(\"Collected ftrack task statuses.\")\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_status.html#client.ayon_ftrack.plugins.publish.integrate_ftrack_status.IntegrateFtrackFarmStatus","title":"<code>IntegrateFtrackFarmStatus</code>","text":"<p>               Bases: <code>IntegrateFtrackStatusBase</code></p> <p>Collect task status names for instances that are sent to farm.</p> <p>Instance which has set \"farm\" key in data to 'True' is considered as will be rendered on farm thus it's status should be changed.</p> Requirements <p>projectName (str): Name of the project. hostName (str): Name of the host. ftrackSession (ftrack_api.Session): Prepared ftrack session. ftrackTaskStatuses (dict[str, list[Any]]): Dictionary of available     task statuses on project by task type id. ftrackStatusByTaskId (dict[str, str]): Empty dictionary of task     statuses by task id. Status on task can be set only once.     Value should be a name of status.</p> Source code in <code>client/ayon_ftrack/plugins/publish/integrate_ftrack_status.py</code> <pre><code>class IntegrateFtrackFarmStatus(IntegrateFtrackStatusBase):\n    \"\"\"Collect task status names for instances that are sent to farm.\n\n    Instance which has set \"farm\" key in data to 'True' is considered as will\n    be rendered on farm thus it's status should be changed.\n\n    Requirements:\n        projectName (str): Name of the project.\n        hostName (str): Name of the host.\n        ftrackSession (ftrack_api.Session): Prepared ftrack session.\n        ftrackTaskStatuses (dict[str, list[Any]]): Dictionary of available\n            task statuses on project by task type id.\n        ftrackStatusByTaskId (dict[str, str]): Empty dictionary of task\n            statuses by task id. Status on task can be set only once.\n            Value should be a name of status.\n    \"\"\"\n\n    order = pyblish.api.IntegratorOrder + 0.48\n    label = \"ftrack Task Status To Farm Status\"\n    active = True\n\n    farm_status_profiles = []\n    status_profiles = None\n\n    def is_valid_instance(self, context, instance):\n        if not instance.data.get(\"farm\"):\n            self.log.debug(\"{} Won't be rendered on farm.\".format(\n                instance.data[\"productName\"]\n            ))\n            return False\n        return super(IntegrateFtrackFarmStatus, self).is_valid_instance(\n            context, instance)\n\n    def get_status_profiles(self):\n        if self.status_profiles is None:\n            profiles = copy.deepcopy(self.farm_status_profiles)\n            self.status_profiles = profiles\n        return self.status_profiles\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_status.html#client.ayon_ftrack.plugins.publish.integrate_ftrack_status.IntegrateFtrackLocalStatus","title":"<code>IntegrateFtrackLocalStatus</code>","text":"<p>               Bases: <code>IntegrateFtrackStatusBase</code></p> <p>Collect task status names for instances that are published locally.</p> <p>Instance which has set \"farm\" key in data to 'True' is considered as will be rendered on farm thus it's status should be changed.</p> Requirements <p>projectName (str): Name of the project. hostName (str): Name of the host. ftrackSession (ftrack_api.Session): Prepared ftrack session. ftrackTaskStatuses (dict[str, list[Any]]): Dictionary of available     task statuses on project by task type id. ftrackStatusByTaskId (dict[str, str]): Empty dictionary of task     statuses by task id. Status on task can be set only once.     Value should be a name of status.</p> Source code in <code>client/ayon_ftrack/plugins/publish/integrate_ftrack_status.py</code> <pre><code>class IntegrateFtrackLocalStatus(IntegrateFtrackStatusBase):\n    \"\"\"Collect task status names for instances that are published locally.\n\n    Instance which has set \"farm\" key in data to 'True' is considered as will\n    be rendered on farm thus it's status should be changed.\n\n    Requirements:\n        projectName (str): Name of the project.\n        hostName (str): Name of the host.\n        ftrackSession (ftrack_api.Session): Prepared ftrack session.\n        ftrackTaskStatuses (dict[str, list[Any]]): Dictionary of available\n            task statuses on project by task type id.\n        ftrackStatusByTaskId (dict[str, str]): Empty dictionary of task\n            statuses by task id. Status on task can be set only once.\n            Value should be a name of status.\n    \"\"\"\n\n    order = IntegrateFtrackFarmStatus.order + 0.001\n    label = \"ftrack Task Status Local Publish\"\n    active = True\n    targets = [\"local\"]\n    settings_key = \"ftrack_task_status_local_publish\"\n\n    def is_valid_instance(self, context, instance):\n        if instance.data.get(\"farm\"):\n            self.log.debug(\"{} Will be rendered on farm.\".format(\n                instance.data[\"productName\"]\n            ))\n            return False\n        return super(IntegrateFtrackLocalStatus, self).is_valid_instance(\n            context, instance)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_status.html#client.ayon_ftrack.plugins.publish.integrate_ftrack_status.IntegrateFtrackOnFarmStatus","title":"<code>IntegrateFtrackOnFarmStatus</code>","text":"<p>               Bases: <code>IntegrateFtrackStatusBase</code></p> <p>Collect task status names for instances that are published on farm.</p> Requirements <p>projectName (str): Name of the project. hostName (str): Name of the host. ftrackSession (ftrack_api.Session): Prepared ftrack session. ftrackTaskStatuses (dict[str, list[Any]]): Dictionary of available     task statuses on project by task type id. ftrackStatusByTaskId (dict[str, str]): Empty dictionary of task     statuses by task id. Status on task can be set only once.     Value should be a name of status.</p> Source code in <code>client/ayon_ftrack/plugins/publish/integrate_ftrack_status.py</code> <pre><code>class IntegrateFtrackOnFarmStatus(IntegrateFtrackStatusBase):\n    \"\"\"Collect task status names for instances that are published on farm.\n\n    Requirements:\n        projectName (str): Name of the project.\n        hostName (str): Name of the host.\n        ftrackSession (ftrack_api.Session): Prepared ftrack session.\n        ftrackTaskStatuses (dict[str, list[Any]]): Dictionary of available\n            task statuses on project by task type id.\n        ftrackStatusByTaskId (dict[str, str]): Empty dictionary of task\n            statuses by task id. Status on task can be set only once.\n            Value should be a name of status.\n    \"\"\"\n\n    order = IntegrateFtrackLocalStatus.order + 0.001\n    label = \"Ftrack Task Status On Farm Status\"\n    active = True\n    targets = [\"farm\"]\n    settings_key = \"ftrack_task_status_on_farm_publish\"\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_status.html#client.ayon_ftrack.plugins.publish.integrate_ftrack_status.IntegrateFtrackStatusBase","title":"<code>IntegrateFtrackStatusBase</code>","text":"<p>               Bases: <code>FtrackPublishInstancePlugin</code></p> <p>Base plugin for status collection.</p> Requirements <p>projectName (str): Name of the project. hostName (str): Name of the host. ftrackSession (ftrack_api.Session): Prepared ftrack session. ftrackTaskStatuses (dict[str, list[Any]]): Dictionary of available     task statuses on project by task type id. ftrackStatusByTaskId (dict[str, str]): Empty dictionary of task     statuses by task id. Status on task can be set only once.     Value should be a name of status.</p> Source code in <code>client/ayon_ftrack/plugins/publish/integrate_ftrack_status.py</code> <pre><code>class IntegrateFtrackStatusBase(plugin.FtrackPublishInstancePlugin):\n    \"\"\"Base plugin for status collection.\n\n    Requirements:\n        projectName (str): Name of the project.\n        hostName (str): Name of the host.\n        ftrackSession (ftrack_api.Session): Prepared ftrack session.\n        ftrackTaskStatuses (dict[str, list[Any]]): Dictionary of available\n            task statuses on project by task type id.\n        ftrackStatusByTaskId (dict[str, str]): Empty dictionary of task\n            statuses by task id. Status on task can be set only once.\n            Value should be a name of status.\n    \"\"\"\n\n    active = False\n    settings_key = None\n    status_profiles = []\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        if not cls.is_ftrack_enabled(project_settings):\n            cls.enabled = False\n            return\n\n        settings_key = cls.settings_key\n        if settings_key is None:\n            settings_key = cls.__name__\n\n        try:\n            settings = project_settings[\"ftrack\"][\"publish\"][settings_key]\n        except KeyError:\n            return\n\n        for key, value in settings.items():\n            setattr(cls, key, value)\n\n    def process(self, instance):\n        context = instance.context\n        # No profiles -&gt; skip\n        profiles = self.get_status_profiles()\n        if not profiles:\n            project_name = context.data[\"projectName\"]\n            self.log.debug((\n                \"Status profiles are not filled for project \\\"{}\\\". Skipping\"\n            ).format(project_name))\n            return\n\n        # Task statuses were not collected -&gt; skip\n        task_statuses_by_type_id = context.data.get(\"ftrackTaskStatuses\")\n        if not task_statuses_by_type_id:\n            self.log.debug(\n                \"ftrack task statuses are not collected. Skipping.\")\n            return\n\n        self.prepare_status_names(context, instance, profiles)\n\n    def get_status_profiles(self):\n        \"\"\"List of profiles to determine status name.\n\n        Example profile item:\n            {\n                \"host_names\": [\"nuke\"],\n                \"task_types\": [\"Compositing\"],\n                \"task_names\": [\"Comp\"],\n                \"product_types\": [\"render\"],\n                \"product_names\": [\"renderComp\"],\n                \"status_name\": \"Rendering\",\n            }\n\n        Returns:\n            list[dict[str, Any]]: List of profiles.\n        \"\"\"\n\n        return self.status_profiles\n\n    def prepare_status_names(self, context, instance, profiles):\n        if not self.is_valid_instance(context, instance):\n            return\n\n        filter_data = self.get_profile_filter_data(context, instance)\n        status_profile = filter_profiles(\n            profiles,\n            filter_data,\n            logger=self.log\n        )\n        if not status_profile:\n            return\n\n        status_name = status_profile[\"status_name\"]\n        if status_name:\n            self.fill_status(context, instance, status_name)\n\n    def get_profile_filter_data(self, context, instance):\n        task_entity = instance.data[\"ftrackTask\"]\n        return {\n            \"host_names\": context.data[\"hostName\"],\n            \"task_types\": task_entity[\"type\"][\"name\"],\n            \"task_names\": task_entity[\"name\"],\n            \"product_types\": instance.data[\"productType\"],\n            \"product_names\": instance.data[\"productName\"],\n        }\n\n    def is_valid_instance(self, context, instance):\n        \"\"\"Filter instances that should be processed.\n\n        Ignore instances that are not enabled for publishing or don't have\n        filled task. Also skip instances with tasks that already have defined\n        status.\n\n        Plugin should do more filtering which is custom for plugin logic.\n\n        Args:\n            context (pyblish.api.Context): Pyblish context.\n            instance (pyblish.api.Instance): Instance to process.\n\n        Returns:\n            list[pyblish.api.Instance]: List of instances that should be\n                processed.\n        \"\"\"\n\n        ftrack_status_by_task_id = context.data[\"ftrackStatusByTaskId\"]\n        # Skip disabled instances\n        if instance.data.get(\"publish\") is False:\n            return False\n\n        task_entity = instance.data.get(\"ftrackTask\")\n        if not task_entity:\n            self.log.debug(\n                \"Skipping instance {}. Does not have filled task\".format(\n                    instance.data[\"productName\"]))\n            return False\n\n        task_id = task_entity[\"id\"]\n        if task_id in ftrack_status_by_task_id:\n            self.log.debug(\"Status for task {} was already defined\".format(\n                task_entity[\"name\"]\n            ))\n            return False\n\n        return True\n\n    def fill_status(self, context, instance, status_name):\n        \"\"\"Fill status for instance task.\n\n        If task already had set status, it will be skipped.\n\n        Args:\n            context (pyblish.api.Context): Pyblish context.\n            instance (pyblish.api.Instance): Pyblish instance.\n            status_name (str): Name of status to set.\n        \"\"\"\n\n        task_entity = instance.data[\"ftrackTask\"]\n        task_id = task_entity[\"id\"]\n        ftrack_status_by_task_id = context.data[\"ftrackStatusByTaskId\"]\n        if task_id in ftrack_status_by_task_id:\n            self.log.debug(\"Status for task {} was already defined\".format(\n                task_entity[\"name\"]\n            ))\n            return\n\n        ftrack_status_by_task_id[task_id] = status_name\n        self.log.info((\n            \"Task {} will be set to \\\"{}\\\" status.\"\n        ).format(task_entity[\"name\"], status_name))\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_status.html#client.ayon_ftrack.plugins.publish.integrate_ftrack_status.IntegrateFtrackStatusBase.fill_status","title":"<code>fill_status(context, instance, status_name)</code>","text":"<p>Fill status for instance task.</p> <p>If task already had set status, it will be skipped.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context</code> <p>Pyblish context.</p> required <code>instance</code> <code>Instance</code> <p>Pyblish instance.</p> required <code>status_name</code> <code>str</code> <p>Name of status to set.</p> required Source code in <code>client/ayon_ftrack/plugins/publish/integrate_ftrack_status.py</code> <pre><code>def fill_status(self, context, instance, status_name):\n    \"\"\"Fill status for instance task.\n\n    If task already had set status, it will be skipped.\n\n    Args:\n        context (pyblish.api.Context): Pyblish context.\n        instance (pyblish.api.Instance): Pyblish instance.\n        status_name (str): Name of status to set.\n    \"\"\"\n\n    task_entity = instance.data[\"ftrackTask\"]\n    task_id = task_entity[\"id\"]\n    ftrack_status_by_task_id = context.data[\"ftrackStatusByTaskId\"]\n    if task_id in ftrack_status_by_task_id:\n        self.log.debug(\"Status for task {} was already defined\".format(\n            task_entity[\"name\"]\n        ))\n        return\n\n    ftrack_status_by_task_id[task_id] = status_name\n    self.log.info((\n        \"Task {} will be set to \\\"{}\\\" status.\"\n    ).format(task_entity[\"name\"], status_name))\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_status.html#client.ayon_ftrack.plugins.publish.integrate_ftrack_status.IntegrateFtrackStatusBase.get_status_profiles","title":"<code>get_status_profiles()</code>","text":"<p>List of profiles to determine status name.</p> Example profile item <p>{     \"host_names\": [\"nuke\"],     \"task_types\": [\"Compositing\"],     \"task_names\": [\"Comp\"],     \"product_types\": [\"render\"],     \"product_names\": [\"renderComp\"],     \"status_name\": \"Rendering\", }</p> <p>Returns:</p> Type Description <p>list[dict[str, Any]]: List of profiles.</p> Source code in <code>client/ayon_ftrack/plugins/publish/integrate_ftrack_status.py</code> <pre><code>def get_status_profiles(self):\n    \"\"\"List of profiles to determine status name.\n\n    Example profile item:\n        {\n            \"host_names\": [\"nuke\"],\n            \"task_types\": [\"Compositing\"],\n            \"task_names\": [\"Comp\"],\n            \"product_types\": [\"render\"],\n            \"product_names\": [\"renderComp\"],\n            \"status_name\": \"Rendering\",\n        }\n\n    Returns:\n        list[dict[str, Any]]: List of profiles.\n    \"\"\"\n\n    return self.status_profiles\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_status.html#client.ayon_ftrack.plugins.publish.integrate_ftrack_status.IntegrateFtrackStatusBase.is_valid_instance","title":"<code>is_valid_instance(context, instance)</code>","text":"<p>Filter instances that should be processed.</p> <p>Ignore instances that are not enabled for publishing or don't have filled task. Also skip instances with tasks that already have defined status.</p> <p>Plugin should do more filtering which is custom for plugin logic.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context</code> <p>Pyblish context.</p> required <code>instance</code> <code>Instance</code> <p>Instance to process.</p> required <p>Returns:</p> Type Description <p>list[pyblish.api.Instance]: List of instances that should be processed.</p> Source code in <code>client/ayon_ftrack/plugins/publish/integrate_ftrack_status.py</code> <pre><code>def is_valid_instance(self, context, instance):\n    \"\"\"Filter instances that should be processed.\n\n    Ignore instances that are not enabled for publishing or don't have\n    filled task. Also skip instances with tasks that already have defined\n    status.\n\n    Plugin should do more filtering which is custom for plugin logic.\n\n    Args:\n        context (pyblish.api.Context): Pyblish context.\n        instance (pyblish.api.Instance): Instance to process.\n\n    Returns:\n        list[pyblish.api.Instance]: List of instances that should be\n            processed.\n    \"\"\"\n\n    ftrack_status_by_task_id = context.data[\"ftrackStatusByTaskId\"]\n    # Skip disabled instances\n    if instance.data.get(\"publish\") is False:\n        return False\n\n    task_entity = instance.data.get(\"ftrackTask\")\n    if not task_entity:\n        self.log.debug(\n            \"Skipping instance {}. Does not have filled task\".format(\n                instance.data[\"productName\"]))\n        return False\n\n    task_id = task_entity[\"id\"]\n    if task_id in ftrack_status_by_task_id:\n        self.log.debug(\"Status for task {} was already defined\".format(\n            task_entity[\"name\"]\n        ))\n        return False\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_status.html#client.ayon_ftrack.plugins.publish.integrate_ftrack_status.IntegrateFtrackTaskStatus","title":"<code>IntegrateFtrackTaskStatus</code>","text":"<p>               Bases: <code>FtrackPublishContextPlugin</code></p> Source code in <code>client/ayon_ftrack/plugins/publish/integrate_ftrack_status.py</code> <pre><code>class IntegrateFtrackTaskStatus(plugin.FtrackPublishContextPlugin):\n    # Use order of Integrate ftrack Api plugin and offset it before or after\n    base_order = pyblish.api.IntegratorOrder + 0.499\n    # By default is after Integrate ftrack Api\n    order = base_order + 0.0001\n    label = \"Integrate ftrack Task Status\"\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        \"\"\"Apply project settings to plugin.\n\n        Args:\n            project_settings (dict[str, Any]): Project settings.\n        \"\"\"\n\n        if not cls.is_ftrack_enabled(project_settings):\n            cls.enabled = False\n            return\n\n        settings = (\n            project_settings[\"ftrack\"][\"publish\"][\"IntegrateFtrackTaskStatus\"]\n        )\n        diff = 0.001\n        if not settings[\"after_version_statuses\"]:\n            diff = -diff\n        cls.order = cls.base_order + diff\n\n    def process(self, context):\n        task_statuses_by_type_id = context.data.get(\"ftrackTaskStatuses\")\n        if not task_statuses_by_type_id:\n            self.log.debug(\"ftrack task statuses are not collected. Skipping.\")\n            return\n\n        status_by_task_id = self._get_status_by_task_id(context)\n        if not status_by_task_id:\n            self.log.debug(\"No statuses to set. Skipping.\")\n            return\n\n        ftrack_session = context.data[\"ftrackSession\"]\n\n        task_entities = self._get_task_entities(\n            ftrack_session, status_by_task_id)\n\n        for task_entity in task_entities:\n            task_path = \"/\".join([\n                item[\"name\"] for item in task_entity[\"link\"]\n            ])\n            task_id = task_entity[\"id\"]\n            type_id = task_entity[\"type_id\"]\n            new_status = None\n            status_name = status_by_task_id[task_id]\n            self.log.debug(\n                \"Status to set {} on task {}.\".format(status_name, task_path))\n            status_name_low = status_name.lower()\n            available_statuses = task_statuses_by_type_id[type_id]\n            for status in available_statuses:\n                if status[\"name\"].lower() == status_name_low:\n                    new_status = status\n                    break\n\n            if new_status is None:\n                joined_statuses = \", \".join([\n                    \"'{}'\".format(status[\"name\"])\n                    for status in available_statuses\n                ])\n                self.log.debug((\n                    \"Status '{}' was not found in available statuses: {}.\"\n                ).format(status_name, joined_statuses))\n                continue\n\n            if task_entity[\"status_id\"] != new_status[\"id\"]:\n                task_entity[\"status_id\"] = new_status[\"id\"]\n\n                self.log.debug(\"Changing status of task '{}' to '{}'\".format(\n                    task_path, status_name\n                ))\n                ftrack_session.commit()\n\n    def _get_status_by_task_id(self, context):\n        status_by_task_id = context.data[\"ftrackStatusByTaskId\"]\n        return {\n            task_id: status_name\n            for task_id, status_name in status_by_task_id.items()\n            if status_name\n        }\n\n    def _get_task_entities(self, ftrack_session, status_by_task_id):\n        task_entities = []\n        for chunk_ids in create_chunks(status_by_task_id.keys()):\n            joined_ids = \",\".join(\n                ['\"{}\"'.format(task_id) for task_id in chunk_ids]\n            )\n            task_entities.extend(ftrack_session.query((\n                \"select id, type_id, status_id, link from Task\"\n                \" where id in ({})\"\n            ).format(joined_ids)).all())\n        return task_entities\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_ftrack_status.html#client.ayon_ftrack.plugins.publish.integrate_ftrack_status.IntegrateFtrackTaskStatus.apply_settings","title":"<code>apply_settings(project_settings)</code>  <code>classmethod</code>","text":"<p>Apply project settings to plugin.</p> <p>Parameters:</p> Name Type Description Default <code>project_settings</code> <code>dict[str, Any]</code> <p>Project settings.</p> required Source code in <code>client/ayon_ftrack/plugins/publish/integrate_ftrack_status.py</code> <pre><code>@classmethod\ndef apply_settings(cls, project_settings):\n    \"\"\"Apply project settings to plugin.\n\n    Args:\n        project_settings (dict[str, Any]): Project settings.\n    \"\"\"\n\n    if not cls.is_ftrack_enabled(project_settings):\n        cls.enabled = False\n        return\n\n    settings = (\n        project_settings[\"ftrack\"][\"publish\"][\"IntegrateFtrackTaskStatus\"]\n    )\n    diff = 0.001\n    if not settings[\"after_version_statuses\"]:\n        diff = -diff\n    cls.order = cls.base_order + diff\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_hierarchy_ftrack.html","title":"integrate_hierarchy_ftrack","text":""},{"location":"autoapi/client/ayon_ftrack/plugins/publish/integrate_hierarchy_ftrack.html#client.ayon_ftrack.plugins.publish.integrate_hierarchy_ftrack.IntegrateHierarchyToFtrack","title":"<code>IntegrateHierarchyToFtrack</code>","text":"<p>               Bases: <code>FtrackPublishContextPlugin</code></p> <p>Create entities in ftrack based on collected data from premiere Example of entry data: {     \"ProjectXS\": {         \"entity_type\": \"project\",         \"attributes\": {             \"fps\": 24,             ...         },         \"tasks\": [             \"Compositing\",             \"Lighting\",             ... task must exist as task type in project schema         ],         \"children\": {             \"sq01\": {                 \"entity_type\": \"folder\",                 \"folder_type\": \"Sequence\",                 ...             }         }     } }</p> Source code in <code>client/ayon_ftrack/plugins/publish/integrate_hierarchy_ftrack.py</code> <pre><code>class IntegrateHierarchyToFtrack(plugin.FtrackPublishContextPlugin):\n    \"\"\"\n    Create entities in ftrack based on collected data from premiere\n    Example of entry data:\n    {\n        \"ProjectXS\": {\n            \"entity_type\": \"project\",\n            \"attributes\": {\n                \"fps\": 24,\n                ...\n            },\n            \"tasks\": [\n                \"Compositing\",\n                \"Lighting\",\n                ... *task must exist as task type in project schema*\n            ],\n            \"children\": {\n                \"sq01\": {\n                    \"entity_type\": \"folder\",\n                    \"folder_type\": \"Sequence\",\n                    ...\n                }\n            }\n        }\n    }\n    \"\"\"\n\n    order = pyblish.api.IntegratorOrder - 0.04\n    label = \"Integrate Hierarchy To ftrack\"\n    families = [\"shot\"]\n    hosts = [\n        \"hiero\",\n        \"resolve\",\n        \"standalonepublisher\",\n        \"flame\",\n        \"traypublisher\"\n    ]\n    optional = False\n    create_task_status_profiles = []\n\n    def process(self, context):\n        if \"hierarchyContext\" not in context.data:\n            return\n\n        hierarchy_context = self._get_active_hierarchy(context)\n        self.log.debug(\"__ hierarchy_context: {}\".format(hierarchy_context))\n\n        session = context.data[\"ftrackSession\"]\n        project_name = context.data[\"projectName\"]\n        ft_project = session.query(\n            'select id, full_name from Project where full_name is \"{}\"'.format(\n                project_name\n            )\n        ).first()\n        if not ft_project:\n            raise KnownPublishError(\n                \"Project \\\"{}\\\" was not found on ftrack.\".format(project_name)\n            )\n\n        # import ftrack hierarchy\n        self.import_to_ftrack(\n            session, ft_project, context, project_name, hierarchy_context\n        )\n\n    def query_ftrack_entitites(self, session, ft_project):\n        project_id = ft_project[\"id\"]\n        entities = session.query((\n            \"select id, name, parent_id\"\n            \" from TypedContext where project_id is \\\"{}\\\"\"\n        ).format(project_id)).all()\n\n        entities_by_id = {}\n        entities_by_parent_id = collections.defaultdict(list)\n        for entity in entities:\n            entities_by_id[entity[\"id\"]] = entity\n            parent_id = entity[\"parent_id\"]\n            entities_by_parent_id[parent_id].append(entity)\n\n        ftrack_hierarchy = []\n        ftrack_id_queue = collections.deque()\n        ftrack_id_queue.append((project_id, ftrack_hierarchy))\n        while ftrack_id_queue:\n            item = ftrack_id_queue.popleft()\n            ftrack_id, parent_list = item\n            if ftrack_id == project_id:\n                entity = ft_project\n                name = entity[\"full_name\"]\n            else:\n                entity = entities_by_id[ftrack_id]\n                name = entity[\"name\"]\n\n            children = []\n            parent_list.append({\n                \"name\": name,\n                \"low_name\": name.lower(),\n                \"entity\": entity,\n                \"children\": children,\n            })\n            for child in entities_by_parent_id[ftrack_id]:\n                ftrack_id_queue.append((child[\"id\"], children))\n        return ftrack_hierarchy\n\n    def find_matching_ftrack_entities(\n        self, hierarchy_context, ftrack_hierarchy\n    ):\n        walk_queue = collections.deque()\n        for entity_name, entity_data in hierarchy_context.items():\n            walk_queue.append(\n                (entity_name, entity_data, ftrack_hierarchy)\n            )\n\n        matching_ftrack_entities = []\n        while walk_queue:\n            item = walk_queue.popleft()\n            entity_name, entity_data, ft_children = item\n            matching_ft_child = None\n            for ft_child in ft_children:\n                if ft_child[\"low_name\"] == entity_name.lower():\n                    matching_ft_child = ft_child\n                    break\n\n            if matching_ft_child is None:\n                continue\n\n            entity = matching_ft_child[\"entity\"]\n            entity_data[\"ft_entity\"] = entity\n            matching_ftrack_entities.append(entity)\n\n            hierarchy_children = entity_data.get(\"children\")\n            if not hierarchy_children:\n                continue\n\n            for child_name, child_data in hierarchy_children.items():\n                walk_queue.append(\n                    (child_name, child_data, matching_ft_child[\"children\"])\n                )\n        return matching_ftrack_entities\n\n    def query_custom_attribute_values(self, session, entities, attr_ids):\n        entity_ids = {\n            entity[\"id\"]\n            for entity in entities\n        }\n        output = {\n            entity_id: {}\n            for entity_id in entity_ids\n        }\n\n        for value_item in query_custom_attribute_values(\n            session, attr_ids, entity_ids\n        ):\n            attr_id = value_item[\"configuration_id\"]\n            entity_id = value_item[\"entity_id\"]\n            output[entity_id][attr_id] = value_item[\"value\"]\n\n        return output\n\n    def import_to_ftrack(\n        self, session, ft_project, context, project_name, hierarchy_context\n    ):\n        ft_task_types = self.get_all_task_types(ft_project)\n        ft_task_statuses = self.get_task_statuses(ft_project)\n        project_settings = context.data[\"project_settings\"]\n        attr_confs = get_all_attr_configs(session)\n        attrs_mapping = get_custom_attributes_mapping(\n            session, project_settings[\"ftrack\"], attr_confs\n        )\n\n        mapped_confs_by_id = {}\n        for attr_conf in attr_confs:\n            if attr_conf[\"key\"] in {\n                CUST_ATTR_KEY_SERVER_ID,\n                CUST_ATTR_KEY_SERVER_PATH,\n                CUST_ATTR_KEY_SYNC_FAIL,\n            }:\n                mapped_confs_by_id[attr_conf[\"id\"]] = attr_conf\n\n        for mapping_item in attrs_mapping.values():\n            for mapped_conf in mapping_item.attr_confs:\n                mapped_confs_by_id[mapped_conf[\"id\"]] = mapped_conf\n\n        # Query user entity (for comments)\n        user = session.query(\n            f\"User where username is \\\"{session.api_user}\\\"\"\n        ).first()\n        if not user:\n            self.log.warning(\n                \"Was not able to query current User {}\".format(\n                    session.api_user\n                )\n            )\n\n        # Query ftrack hierarchy with parenting\n        ftrack_hierarchy = self.query_ftrack_entitites(\n            session, ft_project)\n\n        # Fill ftrack entities to hierarchy context\n        # - there is no need to query entities again\n        matching_entities = self.find_matching_ftrack_entities(\n            hierarchy_context, ftrack_hierarchy)\n        # Query custom attribute values of each entity\n        custom_attr_values_by_id = self.query_custom_attribute_values(\n            session, matching_entities, set(mapped_confs_by_id.keys()))\n\n        # Get ftrack api module (as they are different per python version)\n        ftrack_api = context.data[\"ftrackPythonModule\"]\n\n        self.log.debug(\n            \"Available task types in ftrack: %s\",\n            str(ft_task_types)\n        )\n        self.log.debug(\n            \"Available task statuses in ftrack: %s\",\n            str(ft_task_statuses)\n        )\n\n        object_types_by_lower_name = {\n            obj_type[\"name\"].lower(): obj_type\n            for obj_type in ft_project[\"project_schema\"][\"object_types\"]\n        }\n\n        # Use queue of hierarchy items to process\n        import_queue = collections.deque()\n        for entity_name, entity_data in hierarchy_context.items():\n            import_queue.append(\n                (entity_name, entity_data, None, \"\")\n            )\n\n        while import_queue:\n            item = import_queue.popleft()\n            entity_name, entity_data, parent, parent_path = item\n\n            # Entity name did sometimes contain entity path in OpenPype 3.17.7\n            # TODO remove this split when we're sure the version is not used\n            entity_name = entity_name.split(\"/\")[-1]\n\n            entity_type = entity_data[\"entity_type\"]\n            self.log.debug(entity_data)\n\n            entity = entity_data.get(\"ft_entity\")\n            if entity is None and entity_type.lower() == \"project\":\n                raise KnownPublishError(\n                    \"Collected items are not in right order!\"\n                )\n\n            # Create entity if not exists\n            if entity is None:\n                # Sanitize against case sensitive folder types.\n                folder_type_low = entity_data[\"folder_type\"].lower()\n                object_type = object_types_by_lower_name[folder_type_low]\n                entity_type = object_type[\"name\"].replace(\" \", \"\")\n\n                entity = session.create(entity_type, {\n                    \"name\": entity_name,\n                    \"parent\": parent\n                })\n                entity_data[\"ft_entity\"] = entity\n\n            entity_path = \"\"\n            if entity_type.lower() != \"project\":\n                entity_path = f\"{parent_path}/{entity_name}\"\n\n            # CUSTOM ATTRIBUTES\n            attributes = entity_data.get(\"attributes\", {})\n            instances = []\n            for instance in context:\n                instance_folder_path = instance.data.get(\"folderPath\")\n\n                if (\n                    instance_folder_path\n                    and instance_folder_path.lower() == entity_path.lower()\n                ):\n                    instances.append(instance)\n\n            for instance in instances:\n                instance.data[\"ftrackEntity\"] = entity\n\n            for key, cust_attr_value in attributes.items():\n                if cust_attr_value is None:\n                    continue\n\n                mapping_item = attrs_mapping.get(key)\n                attr_conf = None\n                if mapping_item is not None:\n                    attr_conf = mapping_item.get_attr_conf_for_entity(entity)\n\n                if attr_conf is None:\n                    self.log.warning(\n                        f\"Missing ftrack custom attribute with name '{key}'\"\n                    )\n                    continue\n\n                attr_id = attr_conf[\"id\"]\n                entity_values = custom_attr_values_by_id.get(entity[\"id\"], {})\n                # New value is defined by having id in values\n                # - it can be set to 'None' (ftrack allows that using API)\n                is_new_value = attr_id not in entity_values\n                attr_value = entity_values.get(attr_id)\n\n                # Use ftrack operations method to set hiearchical\n                # attribute value.\n                # - this is because there may be non hiearchical custom\n                #   attributes with different properties\n                entity_key = collections.OrderedDict((\n                    (\"configuration_id\", attr_conf[\"id\"]),\n                    (\"entity_id\", entity[\"id\"])\n                ))\n                op = None\n                if is_new_value:\n                    op = ftrack_api.operation.CreateEntityOperation(\n                        \"CustomAttributeValue\",\n                        entity_key,\n                        {\"value\": cust_attr_value}\n                    )\n\n                elif attr_value != cust_attr_value:\n                    op = ftrack_api.operation.UpdateEntityOperation(\n                        \"CustomAttributeValue\",\n                        entity_key,\n                        \"value\",\n                        attr_value,\n                        cust_attr_value\n                    )\n\n                if op is not None:\n                    session.recorded_operations.push(op)\n\n            if session.recorded_operations:\n                try:\n                    session.commit()\n                except Exception as exc:\n                    session.rollback()\n                    session._configure_locations()\n                    raise exc\n\n            # TASKS\n            instances_by_task_name = collections.defaultdict(list)\n            for instance in instances:\n                task_name = instance.data.get(\"task\")\n                if task_name:\n                    instances_by_task_name[task_name.lower()].append(instance)\n\n            ftrack_status_by_task_id = context.data[\"ftrackStatusByTaskId\"]\n            tasks = entity_data.get(\"tasks\", [])\n            existing_tasks = []\n            tasks_to_create = []\n            for child in entity[\"children\"]:\n                if child.entity_type.lower() == \"task\":\n                    task_name_low = child[\"name\"].lower()\n                    existing_tasks.append(task_name_low)\n\n                    for instance in instances_by_task_name[task_name_low]:\n                        instance.data[\"ftrackTask\"] = child\n\n            for task_name in tasks:\n                task_type = tasks[task_name][\"type\"]\n                if task_name.lower() in existing_tasks:\n                    print(\"Task {} already exists\".format(task_name))\n                    continue\n                tasks_to_create.append((task_name, task_type))\n\n            for task_name, task_type in tasks_to_create:\n                task_entity = self.create_task(\n                    session,\n                    task_name,\n                    task_type,\n                    entity,\n                    ft_task_types,\n                    ft_task_statuses,\n                    ftrack_status_by_task_id\n                )\n                for instance in instances_by_task_name[task_name.lower()]:\n                    instance.data[\"ftrackTask\"] = task_entity\n\n            # Incoming links.\n            self.create_links(session, project_name, entity_data, entity)\n            try:\n                session.commit()\n            except Exception as exc:\n                session.rollback()\n                session._configure_locations()\n                raise exc\n\n            # Create notes.\n            entity_comments = entity_data.get(\"comments\")\n            if user and entity_comments:\n                for comment in entity_comments:\n                    entity.create_note(comment, user)\n\n                try:\n                    session.commit()\n                except Exception as exc:\n                    session.rollback()\n                    session._configure_locations()\n                    raise exc\n\n            # Import children.\n            children = entity_data.get(\"children\")\n            if not children:\n                continue\n\n            for entity_name, entity_data in children.items():\n                import_queue.append(\n                    (entity_name, entity_data, entity, entity_path)\n                )\n\n    def create_links(self, session, project_name, entity_data, entity):\n        # WARNING Don't know how does this work?\n        #   The logic looks only for 'AssetBuild' entities. Not sure where\n        #   value of 'inputs' on entity data comes from.\n\n        # Clear existing links.\n        for link in entity.get(\"incoming_links\", []):\n            session.delete(link)\n            try:\n                session.commit()\n            except Exception as exc:\n                session.rollback()\n                session._configure_locations()\n                raise exc\n\n        # Create new links.\n        input_folder_ids = {\n            folder_id\n            for folder_id in entity_data.get(\"inputs\", [])\n        }\n        folder_entities = {}\n        if input_folder_ids:\n            folder_entities = {\n                folder_entity[\"id\"]: folder_entity\n                for folder_entity in ayon_api.get_folders(\n                    project_name, folder_ids=input_folder_ids\n                )\n            }\n\n        for folder_id in input_folder_ids:\n            folder_entity = folder_entities.get(folder_id)\n            ftrack_id = None\n            if folder_entity:\n                ftrack_id = folder_entity[\"attrib\"].get(\"ftrackId\")\n            if not ftrack_id:\n                continue\n\n            assetbuild = session.get(\"AssetBuild\", ftrack_id)\n            self.log.debug(\n                \"Creating link from {0} to {1}\".format(\n                    assetbuild[\"name\"], entity[\"name\"]\n                )\n            )\n            session.create(\n                \"TypedContextLink\", {\"from\": assetbuild, \"to\": entity}\n            )\n\n    def get_all_task_types(self, project):\n        tasks = {}\n        proj_template = project[\"project_schema\"]\n        temp_task_types = proj_template[\"_task_type_schema\"][\"types\"]\n\n        for type in temp_task_types:\n            if type[\"name\"] not in tasks:\n                tasks[type[\"name\"]] = type\n\n        return tasks\n\n    def get_task_statuses(self, project_entity):\n        project_schema = project_entity[\"project_schema\"]\n        task_workflow_statuses = project_schema[\"_task_workflow\"][\"statuses\"]\n        return {\n            status[\"id\"]: status\n            for status in task_workflow_statuses\n        }\n\n    def create_task(\n        self,\n        session,\n        name,\n        task_type,\n        parent,\n        ft_task_types,\n        ft_task_statuses,\n        ftrack_status_by_task_id\n    ):\n        filter_data = {\n            \"task_names\": name,\n            \"task_types\": task_type\n        }\n        profile = filter_profiles(\n            self.create_task_status_profiles,\n            filter_data\n        )\n        status_id = None\n        if profile:\n            status_name = profile[\"status_name\"]\n            status_name_low = status_name.lower()\n            for _status_id, status in ft_task_statuses.items():\n                if status[\"name\"].lower() == status_name_low:\n                    status_id = _status_id\n                    status_name = status[\"name\"]\n                    break\n\n            if status_id is None:\n                self.log.warning(\n                    \"Task status \\\"{}\\\" was not found\".format(status_name)\n                )\n\n        task = session.create(\"Task\", {\n            \"name\": name,\n            \"parent\": parent\n        })\n        # TODO not secured!!! - check if task_type exists\n        self.log.debug(task_type)\n        task[\"type\"] = ft_task_types[task_type]\n        if status_id is not None:\n            task[\"status_id\"] = status_id\n\n        try:\n            session.commit()\n        except Exception as exc:\n            session.rollback()\n            session._configure_locations()\n            raise exc\n\n        if status_id is not None:\n            ftrack_status_by_task_id[task[\"id\"]] = None\n        return task\n\n    def _get_active_hierarchy(self, context):\n        \"\"\"Filter hierarchy context to active folders only.\"\"\"\n\n        active_folder_paths = set()\n        # filter only the active publishing insatnces\n        for instance in context:\n            if instance.data.get(\"publish\") is False:\n                continue\n\n            folder_path = instance.data.get(\"asset\")\n            if folder_path:\n                active_folder_paths.add(folder_path)\n\n        # remove duplicity in list\n        self.log.debug(\n            \"Active folders:\\n{}\".format(\n                \"\\n\".join(sorted(active_folder_paths))\n            )\n        )\n\n        hierarchy_context = deepcopy(context.data[\"hierarchyContext\"])\n\n        hierarchy_queue = collections.deque()\n        for name, item in hierarchy_context.items():\n            hierarchy_queue.append(\n                (name, item, \"/\" + name, hierarchy_context)\n            )\n\n        while hierarchy_queue:\n            (name, item, path, parent_item) = hierarchy_queue.popleft()\n            children = item.get(\"children\")\n            if children:\n                for child_name, child_item in children.items():\n                    child_path = \"/\".join([path, child_name])\n                    hierarchy_queue.append(\n                        (child_name, child_item, child_path, item)\n                    )\n\n            elif path not in active_folder_paths:\n                parent_item.pop(name, None)\n\n        return hierarchy_context\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/plugins/publish/validate_custom_ftrack_attributes.html","title":"validate_custom_ftrack_attributes","text":""},{"location":"autoapi/client/ayon_ftrack/plugins/publish/validate_custom_ftrack_attributes.html#client.ayon_ftrack.plugins.publish.validate_custom_ftrack_attributes.ValidateFtrackAttributes","title":"<code>ValidateFtrackAttributes</code>","text":"<p>               Bases: <code>FtrackPublishInstancePlugin</code></p> <p>This will validate attributes in ftrack against data in scene.</p> <p>This is array (list) of checks in format: [     [, , ] ] <p>Where  is name of ftrack attribute,  is one of: <pre><code>\"is\", is_not\", \"greater_than\", \"less_than\", \"contains\", \"not_contains\",\n\"starts_with\", \"ends_with\"\n</code></pre> <p> is python code that is evaluated by validator. This allows you to fetch whatever value in scene you want, for example in Maya: <p>[     \"fps\", \"is\",     \"from maya import mel; out = mel.eval('currentTimeUnitToFPS()')\" ]</p> <p>will test if ftrack fps attribute on current Task parent is same as fps info we get from maya. Store the value you need to compare in variable <code>out</code> in your expression.</p> Source code in <code>client/ayon_ftrack/plugins/publish/validate_custom_ftrack_attributes.py</code> <pre><code>class ValidateFtrackAttributes(plugin.FtrackPublishInstancePlugin):\n    \"\"\"\n    This will validate attributes in ftrack against data in scene.\n\n    This is array (list) of checks in format:\n    [\n        [&lt;attribute&gt;, &lt;operator&gt;, &lt;expression&gt;]\n    ]\n\n    Where &lt;attribute&gt; is name of ftrack attribute, &lt;operator&gt; is one of:\n\n        \"is\", is_not\", \"greater_than\", \"less_than\", \"contains\", \"not_contains\",\n        \"starts_with\", \"ends_with\"\n\n    &lt;expression&gt; is python code that is evaluated by validator. This allows\n    you to fetch whatever value in scene you want, for example in Maya:\n\n    [\n        \"fps\", \"is\",\n        \"from maya import mel; out = mel.eval('currentTimeUnitToFPS()')\"\n    ]\n\n    will test if ftrack fps attribute on current Task parent is same as fps\n    info we get from maya. Store the value you need to compare in\n    variable `out` in your expression.\n    \"\"\"\n\n    label = \"Validate Custom ftrack Attributes\"\n    order = ValidateContentsOrder\n    families = [\"ftrack\"]\n    optional = True\n\n    # Ignore standalone host, because it does not have an ftrack entity\n    # associated.\n    hosts = [\n        \"blender\",\n        \"fusion\",\n        \"harmony\",\n        \"houdini\",\n        \"maya\",\n        \"nuke\",\n        \"hiero\",\n        \"photoshop\",\n        \"premiere\",\n        \"resolve\",\n        \"unreal\"\n    ]\n\n    def process(self, instance):\n        context = instance.context\n        task = context.data.get('ftrackTask', False)\n        if not task:\n            self._raise(AttributeError,\n                        \"Missing ftrack Task entity in context\")\n\n        host = pyblish.api.current_host()\n        to_check = self.ftrack_custom_attributes.get(host, {})\n\n        if not to_check:\n            self.log.warning(\"ftrack_attributes preset not found\")\n            return\n\n        self.log.info(\"getting attributes from ftrack ...\")\n        # get parent of task\n        custom_attributes = {}\n        try:\n            parent = task[\"parent\"]\n            custom_attributes = parent[\"custom_attributes\"].items()\n        except KeyError:\n            self._raise(KeyError, \"missing `parent` or `attributes`\")\n\n        custom_attributes = dict(custom_attributes)\n\n        # get list of hierarchical attributes from ftrack\n        session = context.data[\"ftrackSession\"]\n\n        custom_hier_attributes = self._get_custom_hier_attrs(session)\n        custom_attributes = {}\n        _nonhier = {}\n        custom_hier_attributes = {k: None for k in custom_hier_attributes}\n\n        for key, value in dict(parent[\"custom_attributes\"]).items():\n            if key in custom_hier_attributes:\n                custom_hier_attributes[key] = value\n            else:\n                _nonhier[key] = value\n\n        custom_hier_values = self._get_hierarchical_values(\n            custom_hier_attributes, parent)\n\n        custom_hier_values.update(_nonhier)\n\n        errors = []\n        attribs = custom_hier_values\n        for check in to_check:\n            ev = {}\n            # WARNING(Ondrej Samohel): This is really not secure as we are\n            # basically executing user code. But there's no other way to make\n            # it flexible enough for users to get stuff from\n            exec(str(check[2]), {}, ev)\n            if not ev.get(\"out\"):\n                errors.append(\"{} code doesn't return 'out': '{}'\".format(\n                    check[0], check[2]))\n                continue\n            if check[0] in attribs:\n                if check[1] == \"is\":\n                    if attribs[check[0]] != ev[\"out\"]:\n                        errors.append(\"{}: {} is not {}\".format(\n                            check[0], attribs[check[0]], ev[\"out\"]))\n                elif check[1] == \"is_not\":\n                    if attribs[check[0]] == ev[\"out\"]:\n                        errors.append(\"{}: {} is {}\".format(\n                            check[0], attribs[check[0]], ev[\"out\"]))\n                elif check[1] == \"less_than\":\n                    if attribs[check[0]] &lt; ev[\"out\"]:\n                        errors.append(\"{}: {} is greater {}\".format(\n                            check[0], attribs[check[0]], ev[\"out\"]))\n                elif check[1] == \"greater_than\":\n                    if attribs[check[0]] &lt; ev[\"out\"]:\n                        errors.append(\"{}: {} is less {}\".format(\n                            check[0], attribs[check[0]], ev[\"out\"]))\n                elif check[1] == \"contains\":\n                    if attribs[check[0]] in ev[\"out\"]:\n                        errors.append(\"{}: {} does not contain {}\".format(\n                            check[0], attribs[check[0]], ev[\"out\"]))\n                elif check[1] == \"not_contains\":\n                    if attribs[check[0]] not in ev[\"out\"]:\n                        errors.append(\"{}: {} contains {}\".format(\n                            check[0], attribs[check[0]], ev[\"out\"]))\n                elif check[1] == \"starts_with\":\n                    if attribs[check[0]].startswith(ev[\"out\"]):\n                        errors.append(\"{}: {} does not starts with {}\".format(\n                            check[0], attribs[check[0]], ev[\"out\"]))\n                elif check[1] == \"ends_with\":\n                    if attribs[check[0]].endswith(ev[\"out\"]):\n                        errors.append(\"{}: {} does not end with {}\".format(\n                            check[0], attribs[check[0]], ev[\"out\"]))\n\n        if errors:\n            self.log.error('There are invalid values for attributes:')\n            for e in errors:\n                self.log.error(e)\n            raise ValueError(\"ftrack attributes doesn't match\")\n\n    def _get_custom_hier_attrs(self, session):\n        hier_custom_attributes = []\n        cust_attrs_query = (\n            \"select id, entity_type, object_type_id, is_hierarchical\"\n            \" from CustomAttributeConfiguration\"\n        )\n        all_attrs = session.query(cust_attrs_query).all()\n        for cust_attr in all_attrs:\n            if cust_attr[\"is_hierarchical\"]:\n                hier_custom_attributes.append(cust_attr[\"key\"])\n\n        return hier_custom_attributes\n\n    def _get_hierarchical_values(self, keys_dict, entity):\n        # check values already set\n        _set_keys = []\n        for key, value in keys_dict.items():\n            if value is not None:\n                _set_keys.append(key)\n\n        # pop set values from keys_dict\n        set_keys = {}\n        for key in _set_keys:\n            set_keys[key] = keys_dict.pop(key)\n\n        # find if entity has set values and pop them out\n        keys_to_pop = []\n        for key in keys_dict.keys():\n            _val = entity[\"custom_attributes\"][key]\n            if _val:\n                keys_to_pop.append(key)\n                set_keys[key] = _val\n\n        for key in keys_to_pop:\n            keys_dict.pop(key)\n\n        # if there are not keys to find value return found\n        if not keys_dict:\n            return set_keys\n\n        # end recursion if entity is project\n        if entity.entity_type.lower() == \"project\":\n            for key, value in keys_dict.items():\n                set_keys[key] = value\n\n        else:\n            result = self._get_hierarchical_values(keys_dict, entity[\"parent\"])\n            for key, value in result.items():\n                set_keys[key] = value\n\n        return set_keys\n\n    def _raise(self, exc, msg):\n        self.log.error(msg)\n        raise exc(msg)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/resources/index.html","title":"resources","text":""},{"location":"autoapi/client/ayon_ftrack/resources/index.html#client.ayon_ftrack.resources.get_resource","title":"<code>get_resource(*args)</code>","text":"<p>Serves to simple resources access</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>should contain subfolder names and filename of       resource from resources folder</p> <code>()</code> <p>Returns:     str: Path to resource.</p> Source code in <code>client/ayon_ftrack/resources/__init__.py</code> <pre><code>def get_resource(*args):\n    \"\"\" Serves to simple resources access\n\n    Args:\n        *args: should contain *subfolder* names and *filename* of\n                  resource from resources folder\n    Returns:\n        str: Path to resource.\n\n    \"\"\"\n    return os.path.normpath(os.path.join(RESOURCES_DIR, *args))\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/scripts/index.html","title":"scripts","text":""},{"location":"autoapi/client/ayon_ftrack/scripts/sub_user_server.html","title":"sub_user_server","text":""},{"location":"autoapi/client/ayon_ftrack/tray/index.html","title":"tray","text":""},{"location":"autoapi/client/ayon_ftrack/tray/ftrack_tray.html","title":"ftrack_tray","text":""},{"location":"autoapi/client/ayon_ftrack/tray/login_dialog.html","title":"login_dialog","text":""},{"location":"autoapi/client/ayon_ftrack/tray/login_tools.html","title":"login_tools","text":""},{"location":"autoapi/client/ayon_ftrack/tray/login_tools.html#client.ayon_ftrack.tray.login_tools.LoginServerHandler","title":"<code>LoginServerHandler</code>","text":"<p>               Bases: <code>BaseHTTPRequestHandler</code></p> <p>Login server handler.</p> Source code in <code>client/ayon_ftrack/tray/login_tools.py</code> <pre><code>class LoginServerHandler(BaseHTTPRequestHandler):\n    \"\"\"Login server handler.\"\"\"\n\n    message_filepath = get_resource(\"sign_in_message.html\")\n\n    def __init__(self, login_callback, *args, **kw):\n        \"\"\"Initialise handler.\"\"\"\n        self.login_callback = login_callback\n        BaseHTTPRequestHandler.__init__(self, *args, **kw)\n\n    def log_message(self, format_str, *args):\n        \"\"\"Override method of BaseHTTPRequestHandler.\n\n        Goal is to use `print` instead of `sys.stderr.write`\n        \"\"\"\n        # Change\n        print(\"%s - - [%s] %s\\n\" % (\n            self.client_address[0],\n            self.log_date_time_string(),\n            format_str % args\n        ))\n\n    def do_GET(self):\n        \"\"\"Override to handle requests ourselves.\"\"\"\n        parsed_path = parse.urlparse(self.path)\n        query = parsed_path.query\n\n        api_user = None\n        api_key = None\n        login_credentials = None\n        if \"api_user\" and \"api_key\" in query:\n            login_credentials = parse.parse_qs(query)\n            api_user = login_credentials[\"api_user\"][0]\n            api_key = login_credentials[\"api_key\"][0]\n\n            with open(self.message_filepath, \"r\") as message_file:\n                sign_in_message = message_file.read()\n\n            # formatting html code for python\n            replacements = (\n                (\"{\", \"{{\"),\n                (\"}\", \"}}\"),\n                (\"{{}}\", \"{}\")\n            )\n            for replacement in (replacements):\n                sign_in_message = sign_in_message.replace(*replacement)\n            message = sign_in_message.format(api_user)\n        else:\n            message = \"&lt;h1&gt;Failed to sign in&lt;/h1&gt;\"\n\n        self.send_response(200)\n        self.end_headers()\n        self.wfile.write(message.encode())\n\n        if login_credentials:\n            self.login_callback(\n                api_user,\n                api_key\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/tray/login_tools.html#client.ayon_ftrack.tray.login_tools.LoginServerHandler.__init__","title":"<code>__init__(login_callback, *args, **kw)</code>","text":"<p>Initialise handler.</p> Source code in <code>client/ayon_ftrack/tray/login_tools.py</code> <pre><code>def __init__(self, login_callback, *args, **kw):\n    \"\"\"Initialise handler.\"\"\"\n    self.login_callback = login_callback\n    BaseHTTPRequestHandler.__init__(self, *args, **kw)\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/tray/login_tools.html#client.ayon_ftrack.tray.login_tools.LoginServerHandler.do_GET","title":"<code>do_GET()</code>","text":"<p>Override to handle requests ourselves.</p> Source code in <code>client/ayon_ftrack/tray/login_tools.py</code> <pre><code>def do_GET(self):\n    \"\"\"Override to handle requests ourselves.\"\"\"\n    parsed_path = parse.urlparse(self.path)\n    query = parsed_path.query\n\n    api_user = None\n    api_key = None\n    login_credentials = None\n    if \"api_user\" and \"api_key\" in query:\n        login_credentials = parse.parse_qs(query)\n        api_user = login_credentials[\"api_user\"][0]\n        api_key = login_credentials[\"api_key\"][0]\n\n        with open(self.message_filepath, \"r\") as message_file:\n            sign_in_message = message_file.read()\n\n        # formatting html code for python\n        replacements = (\n            (\"{\", \"{{\"),\n            (\"}\", \"}}\"),\n            (\"{{}}\", \"{}\")\n        )\n        for replacement in (replacements):\n            sign_in_message = sign_in_message.replace(*replacement)\n        message = sign_in_message.format(api_user)\n    else:\n        message = \"&lt;h1&gt;Failed to sign in&lt;/h1&gt;\"\n\n    self.send_response(200)\n    self.end_headers()\n    self.wfile.write(message.encode())\n\n    if login_credentials:\n        self.login_callback(\n            api_user,\n            api_key\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/tray/login_tools.html#client.ayon_ftrack.tray.login_tools.LoginServerHandler.log_message","title":"<code>log_message(format_str, *args)</code>","text":"<p>Override method of BaseHTTPRequestHandler.</p> <p>Goal is to use <code>print</code> instead of <code>sys.stderr.write</code></p> Source code in <code>client/ayon_ftrack/tray/login_tools.py</code> <pre><code>def log_message(self, format_str, *args):\n    \"\"\"Override method of BaseHTTPRequestHandler.\n\n    Goal is to use `print` instead of `sys.stderr.write`\n    \"\"\"\n    # Change\n    print(\"%s - - [%s] %s\\n\" % (\n        self.client_address[0],\n        self.log_date_time_string(),\n        format_str % args\n    ))\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/tray/login_tools.html#client.ayon_ftrack.tray.login_tools.LoginServerThread","title":"<code>LoginServerThread</code>","text":"<p>               Bases: <code>Thread</code></p> <p>Login server thread.</p> Source code in <code>client/ayon_ftrack/tray/login_tools.py</code> <pre><code>class LoginServerThread(threading.Thread):\n    \"\"\"Login server thread.\"\"\"\n\n    def __init__(self, url, callback):\n        self.url = url\n        self.callback = callback\n        self._server = None\n        super(LoginServerThread, self).__init__()\n\n    def _handle_login(self, api_user, api_key):\n        \"\"\"Login to server with *api_user* and *api_key*.\"\"\"\n        self.callback(api_user, api_key)\n\n    def stop(self):\n        if self._server:\n            self._server.server_close()\n\n    def run(self):\n        \"\"\"Listen for events.\"\"\"\n        self._server = HTTPServer(\n            (\"localhost\", 0),\n            functools.partial(\n                LoginServerHandler, self._handle_login\n            )\n        )\n        url = (\n            f\"{self.url}/user/api_credentials\"\n            f\"?redirect_url=http://localhost:{self._server.server_port}\"\n        )\n        webbrowser.open_new_tab(url)\n        self._server.handle_request()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/tray/login_tools.html#client.ayon_ftrack.tray.login_tools.LoginServerThread.run","title":"<code>run()</code>","text":"<p>Listen for events.</p> Source code in <code>client/ayon_ftrack/tray/login_tools.py</code> <pre><code>def run(self):\n    \"\"\"Listen for events.\"\"\"\n    self._server = HTTPServer(\n        (\"localhost\", 0),\n        functools.partial(\n            LoginServerHandler, self._handle_login\n        )\n    )\n    url = (\n        f\"{self.url}/user/api_credentials\"\n        f\"?redirect_url=http://localhost:{self._server.server_port}\"\n    )\n    webbrowser.open_new_tab(url)\n    self._server.handle_request()\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/tray/user_server.html","title":"user_server","text":""},{"location":"autoapi/client/ayon_ftrack/tray/user_server.html#client.ayon_ftrack.tray.user_server.CustomEventHubSession","title":"<code>CustomEventHubSession</code>","text":"<p>               Bases: <code>Session</code></p> <p>An isolated session for interaction with an ftrack server.</p> Source code in <code>client/ayon_ftrack/tray/user_server.py</code> <pre><code>class CustomEventHubSession(ftrack_api.session.Session):\n    '''An isolated session for interaction with an ftrack server.'''\n    def __init__(\n        self, server_url=None, api_key=None, api_user=None, auto_populate=True,\n        plugin_paths=None, cache=None, cache_key_maker=None,\n        auto_connect_event_hub=False, schema_cache_path=None,\n        plugin_arguments=None, timeout=60, **kwargs\n    ):\n        self.kwargs = kwargs\n\n        super(ftrack_api.session.Session, self).__init__()\n        self.logger = logging.getLogger(\n            __name__ + '.' + self.__class__.__name__\n        )\n        self._closed = False\n\n        if server_url is None:\n            server_url = os.environ.get('FTRACK_SERVER')\n\n        if not server_url:\n            raise TypeError(\n                'Required \"server_url\" not specified. Pass as argument or set '\n                'in environment variable FTRACK_SERVER.'\n            )\n\n        self._server_url = server_url\n\n        if api_key is None:\n            api_key = os.environ.get(\n                'FTRACK_API_KEY',\n                # Backwards compatibility\n                os.environ.get('FTRACK_APIKEY')\n            )\n\n        if not api_key:\n            raise TypeError(\n                'Required \"api_key\" not specified. Pass as argument or set in '\n                'environment variable FTRACK_API_KEY.'\n            )\n\n        self._api_key = api_key\n\n        if api_user is None:\n            api_user = os.environ.get('FTRACK_API_USER')\n            if not api_user:\n                try:\n                    api_user = getpass.getuser()\n                except Exception:\n                    pass\n\n        if not api_user:\n            raise TypeError(\n                'Required \"api_user\" not specified. Pass as argument, set in '\n                'environment variable FTRACK_API_USER or one of the standard '\n                'environment variables used by Python\\'s getpass module.'\n            )\n\n        self._api_user = api_user\n\n        # Currently pending operations.\n        self.recorded_operations = ftrack_api.operation.Operations()\n\n        # AYON change - In new API are operations properties\n        new_api = hasattr(self.__class__, \"record_operations\")\n\n        if new_api:\n            self._record_operations = collections.defaultdict(\n                lambda: True\n            )\n            self._auto_populate = collections.defaultdict(\n                lambda: auto_populate\n            )\n        else:\n            self.record_operations = True\n            self.auto_populate = auto_populate\n\n        self.cache_key_maker = cache_key_maker\n        if self.cache_key_maker is None:\n            self.cache_key_maker = ftrack_api.cache.StringKeyMaker()\n\n        # Enforce always having a memory cache at top level so that the same\n        # in-memory instance is returned from session.\n        self.cache = ftrack_api.cache.LayeredCache([\n            ftrack_api.cache.MemoryCache()\n        ])\n\n        if cache is not None:\n            if callable(cache):\n                cache = cache(self)\n\n            if cache is not None:\n                self.cache.caches.append(cache)\n\n        if new_api:\n            self.merge_lock = threading.RLock()\n\n        self._managed_request = None\n        self._request = requests.Session()\n        self._request.auth = ftrack_api.session.SessionAuthentication(\n            self._api_key, self._api_user\n        )\n        self.request_timeout = timeout\n\n        # Fetch server information and in doing so also check credentials.\n        self._server_information = self._fetch_server_information()\n\n        # Now check compatibility of server based on retrieved information.\n        self.check_server_compatibility()\n\n        # Construct event hub and load plugins.\n        self._event_hub = self._create_event_hub()\n\n        self._auto_connect_event_hub_thread = None\n        if auto_connect_event_hub:\n            # Connect to event hub in background thread so as not to block main\n            # session usage waiting for event hub connection.\n            self._auto_connect_event_hub_thread = threading.Thread(\n                target=self._event_hub.connect\n            )\n            self._auto_connect_event_hub_thread.daemon = True\n            self._auto_connect_event_hub_thread.start()\n\n        # Register to auto-close session on exit.\n        atexit.register(WeakMethod(self.close))\n\n        self._plugin_paths = plugin_paths\n        if self._plugin_paths is None:\n            self._plugin_paths = os.environ.get(\n                'FTRACK_EVENT_PLUGIN_PATH', ''\n            ).split(os.pathsep)\n\n        self._discover_plugins(plugin_arguments=plugin_arguments)\n\n        # TODO: Make schemas read-only and non-mutable (or at least without\n        # rebuilding types)?\n        if schema_cache_path is not False:\n            if schema_cache_path is None:\n                schema_cache_path = platformdirs.user_cache_dir()\n                schema_cache_path = os.environ.get(\n                    'FTRACK_API_SCHEMA_CACHE_PATH', schema_cache_path\n                )\n\n            schema_cache_path = os.path.join(\n                schema_cache_path, 'ftrack_api_schema_cache.json'\n            )\n\n        self.schemas = self._load_schemas(schema_cache_path)\n        self.types = self._build_entity_type_classes(self.schemas)\n\n        ftrack_api._centralized_storage_scenario.register(self)\n\n        self._configure_locations()\n        self.event_hub.publish(\n            ftrack_api.event.base.Event(\n                topic='ftrack.api.session.ready',\n                data=dict(\n                    session=self\n                )\n            ),\n            synchronous=True\n        )\n\n    def _create_event_hub(self):\n        return ftrack_api.event.hub.EventHub(\n            self._server_url,\n            self._api_user,\n            self._api_key\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/tray/user_server.html#client.ayon_ftrack.tray.user_server.SocketBaseEventHub","title":"<code>SocketBaseEventHub</code>","text":"<p>               Bases: <code>EventHub</code></p> Source code in <code>client/ayon_ftrack/tray/user_server.py</code> <pre><code>class SocketBaseEventHub(ftrack_api.event.hub.EventHub):\n    hearbeat_msg = b\"hearbeat\"\n    heartbeat_callbacks = []\n\n    def __init__(self, *args, **kwargs):\n        self.sock = kwargs.pop(\"sock\")\n        super(SocketBaseEventHub, self).__init__(*args, **kwargs)\n\n    def _handle_packet(self, code, packet_identifier, path, data):\n        \"\"\"Override `_handle_packet` which extend heartbeat\"\"\"\n        code_name = self._code_name_mapping[code]\n        if code_name == \"heartbeat\":\n            # Reply with heartbeat.\n            for callback in self.heartbeat_callbacks:\n                callback()\n\n            self.sock.sendall(self.hearbeat_msg)\n            return self._send_packet(self._code_name_mapping[\"heartbeat\"])\n\n        return super(SocketBaseEventHub, self)._handle_packet(\n            code, packet_identifier, path, data\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_ftrack/tray/user_server.html#client.ayon_ftrack.tray.user_server.SocketThread","title":"<code>SocketThread</code>","text":"<p>               Bases: <code>Thread</code></p> <p>Thread that checks subprocess of storer of processor of events</p> Source code in <code>client/ayon_ftrack/tray/user_server.py</code> <pre><code>class SocketThread(threading.Thread):\n    \"\"\"Thread that checks subprocess of storer of processor of events\"\"\"\n\n    MAX_TIMEOUT = 45\n\n    def __init__(self, name, port, filepath, additional_args=None):\n        super(SocketThread, self).__init__()\n        if additional_args is None:\n            additional_args = []\n        self.log = Logger.get_logger(self.__class__.__name__)\n        self.setName(name)\n        self.name = name\n        self.port = port\n        self.filepath = filepath\n        self.additional_args = additional_args\n\n        self.sock = None\n        self.subproc = None\n        self.connection = None\n        self._is_running = False\n        self.finished = False\n\n        self._temp_data = {}\n\n    def stop(self):\n        self._is_running = False\n\n    def run(self):\n        self._is_running = True\n        time_socket = time.time()\n        # Create a TCP/IP socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.sock = sock\n\n        # Bind the socket to the port - skip already used ports\n        while True:\n            try:\n                server_address = (\"localhost\", self.port)\n                sock.bind(server_address)\n                break\n            except OSError:\n                self.port += 1\n\n        self.log.debug(\n            \"Running Socked thread on {}:{}\".format(*server_address)\n        )\n\n        env = os.environ.copy()\n        # AYON executable (with path to start script if not build)\n        args = get_ayon_launcher_args(\n            # Add `run` command\n            \"run\",\n            self.filepath,\n            *self.additional_args,\n            str(self.port)\n        )\n        kwargs = {\n            \"env\": env,\n            \"stdin\": subprocess.PIPE\n        }\n        if not sys.stdout:\n            # Redirect to devnull if stdout is None\n            kwargs[\"stdout\"] = subprocess.DEVNULL\n            kwargs[\"stderr\"] = subprocess.DEVNULL\n\n        self.subproc = subprocess.Popen(args, **kwargs)\n\n        # Listen for incoming connections\n        sock.listen(1)\n        sock.settimeout(1.0)\n        while True:\n            if not self._is_running:\n                break\n            try:\n                connection, client_address = sock.accept()\n                time_socket = time.time()\n                connection.settimeout(1.0)\n                self.connection = connection\n\n            except socket.timeout:\n                if (time.time() - time_socket) &gt; self.MAX_TIMEOUT:\n                    self.log.error(\"Connection timeout passed. Terminating.\")\n                    self._is_running = False\n                    self.subproc.terminate()\n                    break\n                continue\n\n            try:\n                time_con = time.time()\n                # Receive the data in small chunks and retransmit it\n                while True:\n                    try:\n                        if not self._is_running:\n                            break\n                        data = None\n                        try:\n                            data = self.get_data_from_con(connection)\n                            time_con = time.time()\n\n                        except socket.timeout:\n                            if (time.time() - time_con) &gt; self.MAX_TIMEOUT:\n                                self.log.error(\n                                    \"Connection timeout passed. Terminating.\"\n                                )\n                                self._is_running = False\n                                self.subproc.terminate()\n                                break\n                            continue\n\n                        except ConnectionResetError:\n                            self._is_running = False\n                            break\n\n                        self._handle_data(connection, data)\n\n                    except Exception:\n                        self.log.error(\n                            \"Event server process failed\", exc_info=True\n                        )\n\n            finally:\n                # Clean up the connection\n                connection.close()\n                if self.subproc.poll() is None:\n                    self.subproc.terminate()\n\n                self.finished = True\n\n    def get_data_from_con(self, connection):\n        return connection.recv(16)\n\n    def _handle_data(self, connection, data):\n        if not data:\n            return\n\n        connection.sendall(data)\n</code></pre>"},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/index.html#server.FtrackAddon","title":"<code>FtrackAddon</code>","text":"<p>               Bases: <code>BaseServerAddon</code></p> Source code in <code>server/__init__.py</code> <pre><code>class FtrackAddon(BaseServerAddon):\n    settings_model: Type[FtrackSettings] = FtrackSettings\n\n    async def get_default_settings(self):\n        settings_model_cls = self.get_settings_model()\n        return settings_model_cls(**DEFAULT_VALUES)\n\n    async def pre_setup(self):\n        \"\"\"Make sure older version of addon use the new way of attributes.\"\"\"\n\n        # Force older addon versions to skip creation of attributes\n        #   - this was added in version 0.2.2\n        instance = AddonLibrary.getinstance()\n        app_defs = instance.data.get(self.name)\n        my_version = semver.Version.parse(self.version)\n        for version, addon in app_defs.versions.items():\n            if version == self.version:\n                continue\n            try:\n                addon_version = semver.Version.parse(version)\n                if addon_version &gt; my_version:\n                    continue\n            except Exception:\n                pass\n            if hasattr(addon, \"create_ftrack_attributes\"):\n                addon.create_ftrack_attributes = (\n                    self._empty_create_ftrack_attributes)\n\n    async def setup(self):\n        need_restart = await self.create_ftrack_attributes()\n        if need_restart:\n            self.request_server_restart()\n\n    def initialize(self) -&gt; None:\n        self.add_endpoint(\n            \"/customProcessorHandlers\",\n            self.get_custom_processor_handlers,\n            method=\"GET\",\n        )\n        self.add_endpoint(\n            \"/ftrackProjects\",\n            self.get_ftrack_projects_info,\n            method=\"GET\",\n        )\n\n    async def get_custom_processor_handlers(\n        self,\n        variant: str = Query(\"production\"),\n    ) -&gt; {}:\n        bundles = await Postgres.fetch(\n            \"SELECT name, is_production, is_staging,\"\n            \" is_dev, data-&gt;'addons' as addons FROM bundles\"\n        )\n        bundles_by_variant = {\n            \"production\": None,\n            \"staging\": None\n        }\n        for bundle in bundles:\n            if bundle[\"is_dev\"]:\n                bundles_by_variant[bundle[\"name\"]] = bundle\n                continue\n\n            if bundle[\"is_production\"]:\n                bundles_by_variant[\"production\"] = bundle\n\n            if bundle[\"is_staging\"]:\n                bundles_by_variant[\"staging\"] = bundle\n\n        handlers = []\n        output = {\"custom_handlers\": handlers}\n        if variant not in bundles_by_variant:\n            return output\n        addons = bundles_by_variant[variant][\"addons\"]\n        addon_library = AddonLibrary.getinstance()\n        for addon_name, addon_version in addons.items():\n            addons_mapping = addon_library.get(addon_name) or {}\n            addon = addons_mapping.get(addon_version)\n            if not hasattr(addon, \"get_custom_ftrack_handlers_endpoint\"):\n                continue\n            try:\n                endpoint = addon.get_custom_ftrack_handlers_endpoint()\n                if endpoint:\n                    handlers.append({\n                        \"addon_name\": addon_name,\n                        \"addon_version\": addon_version,\n                        \"endpoint\": endpoint,\n                    })\n            except BaseException as exc:\n                logging.warning(\n                    f\"Failed to receive ftrack handlers from addon\"\n                    f\" {addon_name} {addon_version}. {exc}\"\n                )\n\n        return output\n\n    async def _prepare_ftrack_session(\n        self, variant: str, settings_model: FtrackSettings | None\n    ) -&gt; FtrackSession:\n        # TODO validate user permissions\n        # - What permissions user must have to allow this endpoint?\n        if settings_model is None:\n            settings_model = await self.get_studio_settings(variant)\n        ftrack_server_url = settings_model.ftrack_server\n        service_settings = settings_model.service_settings\n        api_key_secret = service_settings.api_key\n        username_secret = service_settings.username\n\n        if not ftrack_server_url or not api_key_secret or not username_secret:\n            raise InvalidSettingsException(\"Required settings are not set.\")\n\n        ftrack_api_key = await Secrets.get(api_key_secret)\n        ftrack_username = await Secrets.get(username_secret)\n\n        if not ftrack_api_key or not ftrack_username:\n            raise InvalidSettingsException(\n                \"Invalid service settings, secrets are not set.\"\n            )\n\n        session = FtrackSession(\n            ftrack_server_url, ftrack_api_key, ftrack_username\n        )\n        try:\n            await session.validate()\n        except InvalidCredentials:\n            raise InvalidSettingsException(\n                \"Service settings contain invalid credentials.\"\n            )\n        except ServerError as exc:\n            raise AyonException(\n                \"Unknown error occurred while connecting to ftrack server.\"\n                f\" {exc}\"\n            )\n        return session\n\n    async def get_ftrack_projects_info(\n        self,\n        user: CurrentUser,\n        variant: str = Query(\"production\"),\n    ) -&gt; {}:\n        # TODO validate user permissions\n        # - What permissions user must have to allow this endpoint?\n        session = await self._prepare_ftrack_session(variant)\n        projects = [\n            {\n                \"id\": project[\"id\"],\n                \"name\": project[\"full_name\"],\n                \"code\": project[\"name\"],\n                \"active\": project[\"status\"] == \"active\",\n            }\n            async for project in await session.get_projects()\n        ]\n\n        return {\n            \"projects\": projects,\n        }\n\n    async def _empty_create_ftrack_attributes(self):\n        return False\n\n    async def create_ftrack_attributes(self) -&gt; bool:\n        \"\"\"Make sure there are required attributes which ftrack addon needs.\n\n        Returns:\n            bool: 'True' if an attribute was created or updated.\n        \"\"\"\n\n        query = \"SELECT name, position, scope, data from public.attributes\"\n        ftrack_id_attribute_data = {\n            \"type\": \"string\",\n            \"title\": \"ftrack id\",\n            \"inherit\": False,\n        }\n        ftrack_path_attribute_data = {\n            \"type\": \"string\",\n            \"title\": \"ftrack path\",\n            \"inherit\": False,\n        }\n        ftrack_id_expected_scope = [\n            \"project\", \"folder\", \"task\", \"version\", \"list\"\n        ]\n        ftrack_path_expected_scope = [\"project\", \"folder\", \"task\"]\n\n        ftrack_id_match_position = None\n        ftrack_id_matches = False\n        ftrack_path_match_position = None\n        ftrack_path_matches = False\n        position = 1\n        if Postgres.pool is None:\n            await Postgres.connect()\n        async for row in Postgres.iterate(query):\n            position += 1\n            if row[\"name\"] == FTRACK_ID_ATTRIB:\n                # Check if scope is matching ftrack addon requirements\n                if not set(ftrack_id_expected_scope) - set(row[\"scope\"]):\n                    ftrack_id_matches = True\n                ftrack_id_match_position = row[\"position\"]\n\n            elif row[\"name\"] == FTRACK_PATH_ATTRIB:\n                if not set(ftrack_path_expected_scope) - set(row[\"scope\"]):\n                    ftrack_path_matches = True\n                ftrack_path_match_position = row[\"position\"]\n\n        if ftrack_id_matches and ftrack_path_matches:\n            return False\n\n        postgre_query = \"\\n\".join((\n            \"INSERT INTO public.attributes\",\n            \"    (name, position, scope, data)\",\n            \"VALUES\",\n            \"    ($1, $2, $3, $4)\",\n            \"ON CONFLICT (name)\",\n            \"DO UPDATE SET\",\n            \"    scope = $3,\",\n            \"    data = $4\",\n        ))\n        if not ftrack_id_matches:\n            # Reuse position from found attribute\n            if ftrack_id_match_position is None:\n                ftrack_id_match_position = position\n                position += 1\n\n            await Postgres.execute(\n                postgre_query,\n                FTRACK_ID_ATTRIB,\n                ftrack_id_match_position,\n                ftrack_id_expected_scope,\n                ftrack_id_attribute_data,\n            )\n\n        if not ftrack_path_matches:\n            if ftrack_path_match_position is None:\n                ftrack_path_match_position = position\n                position += 1\n\n            await Postgres.execute(\n                postgre_query,\n                FTRACK_PATH_ATTRIB,\n                ftrack_path_match_position,\n                ftrack_path_expected_scope,\n                ftrack_path_attribute_data,\n            )\n        return True\n\n    async def convert_settings_overrides(\n        self,\n        source_version: str,\n        overrides: dict[str, Any],\n    ) -&gt; dict[str, Any]:\n        await convert_settings_overrides(source_version, overrides)\n        return await super().convert_settings_overrides(\n            source_version, overrides\n        )\n</code></pre>"},{"location":"autoapi/server/index.html#server.FtrackAddon.create_ftrack_attributes","title":"<code>create_ftrack_attributes()</code>  <code>async</code>","text":"<p>Make sure there are required attributes which ftrack addon needs.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>'True' if an attribute was created or updated.</p> Source code in <code>server/__init__.py</code> <pre><code>async def create_ftrack_attributes(self) -&gt; bool:\n    \"\"\"Make sure there are required attributes which ftrack addon needs.\n\n    Returns:\n        bool: 'True' if an attribute was created or updated.\n    \"\"\"\n\n    query = \"SELECT name, position, scope, data from public.attributes\"\n    ftrack_id_attribute_data = {\n        \"type\": \"string\",\n        \"title\": \"ftrack id\",\n        \"inherit\": False,\n    }\n    ftrack_path_attribute_data = {\n        \"type\": \"string\",\n        \"title\": \"ftrack path\",\n        \"inherit\": False,\n    }\n    ftrack_id_expected_scope = [\n        \"project\", \"folder\", \"task\", \"version\", \"list\"\n    ]\n    ftrack_path_expected_scope = [\"project\", \"folder\", \"task\"]\n\n    ftrack_id_match_position = None\n    ftrack_id_matches = False\n    ftrack_path_match_position = None\n    ftrack_path_matches = False\n    position = 1\n    if Postgres.pool is None:\n        await Postgres.connect()\n    async for row in Postgres.iterate(query):\n        position += 1\n        if row[\"name\"] == FTRACK_ID_ATTRIB:\n            # Check if scope is matching ftrack addon requirements\n            if not set(ftrack_id_expected_scope) - set(row[\"scope\"]):\n                ftrack_id_matches = True\n            ftrack_id_match_position = row[\"position\"]\n\n        elif row[\"name\"] == FTRACK_PATH_ATTRIB:\n            if not set(ftrack_path_expected_scope) - set(row[\"scope\"]):\n                ftrack_path_matches = True\n            ftrack_path_match_position = row[\"position\"]\n\n    if ftrack_id_matches and ftrack_path_matches:\n        return False\n\n    postgre_query = \"\\n\".join((\n        \"INSERT INTO public.attributes\",\n        \"    (name, position, scope, data)\",\n        \"VALUES\",\n        \"    ($1, $2, $3, $4)\",\n        \"ON CONFLICT (name)\",\n        \"DO UPDATE SET\",\n        \"    scope = $3,\",\n        \"    data = $4\",\n    ))\n    if not ftrack_id_matches:\n        # Reuse position from found attribute\n        if ftrack_id_match_position is None:\n            ftrack_id_match_position = position\n            position += 1\n\n        await Postgres.execute(\n            postgre_query,\n            FTRACK_ID_ATTRIB,\n            ftrack_id_match_position,\n            ftrack_id_expected_scope,\n            ftrack_id_attribute_data,\n        )\n\n    if not ftrack_path_matches:\n        if ftrack_path_match_position is None:\n            ftrack_path_match_position = position\n            position += 1\n\n        await Postgres.execute(\n            postgre_query,\n            FTRACK_PATH_ATTRIB,\n            ftrack_path_match_position,\n            ftrack_path_expected_scope,\n            ftrack_path_attribute_data,\n        )\n    return True\n</code></pre>"},{"location":"autoapi/server/index.html#server.FtrackAddon.pre_setup","title":"<code>pre_setup()</code>  <code>async</code>","text":"<p>Make sure older version of addon use the new way of attributes.</p> Source code in <code>server/__init__.py</code> <pre><code>async def pre_setup(self):\n    \"\"\"Make sure older version of addon use the new way of attributes.\"\"\"\n\n    # Force older addon versions to skip creation of attributes\n    #   - this was added in version 0.2.2\n    instance = AddonLibrary.getinstance()\n    app_defs = instance.data.get(self.name)\n    my_version = semver.Version.parse(self.version)\n    for version, addon in app_defs.versions.items():\n        if version == self.version:\n            continue\n        try:\n            addon_version = semver.Version.parse(version)\n            if addon_version &gt; my_version:\n                continue\n        except Exception:\n            pass\n        if hasattr(addon, \"create_ftrack_attributes\"):\n            addon.create_ftrack_attributes = (\n                self._empty_create_ftrack_attributes)\n</code></pre>"},{"location":"autoapi/server/ftrack_session.html","title":"ftrack_session","text":""},{"location":"autoapi/server/settings/index.html","title":"settings","text":""},{"location":"autoapi/server/settings/index.html#server.settings.FtrackSettings","title":"<code>FtrackSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>ftrack addon settings.</p> Source code in <code>server/settings/main.py</code> <pre><code>class FtrackSettings(BaseSettingsModel):\n    \"\"\"ftrack addon settings.\"\"\"\n\n    enabled: bool = SettingsField(True)\n    ftrack_server: str = SettingsField(\n        \"\",\n        title=\"ftrack server url\",\n        scope=[\"studio\"],\n    )\n    service_settings: FtrackServiceSettings = SettingsField(\n        default_factory=FtrackServiceSettings,\n        title=\"Service settings\",\n        scope=[\"studio\"],\n    )\n\n    service_event_handlers: FtrackServiceHandlers = SettingsField(\n        default_factory=FtrackServiceHandlers,\n        title=\"Server Actions/Events\",\n    )\n    post_launch_hook: PostLaunchHookSettings = SettingsField(\n        default_factory=PostLaunchHookSettings,\n        title=\"Status change on application launch\"\n    )\n    user_handlers: FtrackDesktopAppHandlers = SettingsField(\n        default_factory=FtrackDesktopAppHandlers,\n        title=\"User Actions/Events\",\n    )\n    publish: FtrackPublishPlugins = SettingsField(\n        default_factory=FtrackPublishPlugins,\n        title=\"Publish plugins\"\n    )\n    custom_attributes: CustomAttributesModel = SettingsField(\n        title=\"Custom Attributes\",\n        default_factory=CustomAttributesModel,\n        scope=[\"studio\"],\n    )\n</code></pre>"},{"location":"autoapi/server/settings/common.html","title":"common","text":""},{"location":"autoapi/server/settings/common.html#server.settings.common.DictWithStrList","title":"<code>DictWithStrList</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Common model for Dictionary like object with list of strings as value.</p> <p>This model requires 'ensure_unique_names' validation.</p> Source code in <code>server/settings/common.py</code> <pre><code>class DictWithStrList(BaseSettingsModel):\n    \"\"\"Common model for Dictionary like object with list of strings as value.\n\n    This model requires 'ensure_unique_names' validation.\n    \"\"\"\n\n    _layout = \"expanded\"\n    name: str = SettingsField(\"\")\n    value: list[str] = SettingsField(default_factory=list)\n</code></pre>"},{"location":"autoapi/server/settings/conversions.html","title":"conversions","text":""},{"location":"autoapi/server/settings/custom_attributes.html","title":"custom_attributes","text":""},{"location":"autoapi/server/settings/desktopapp_handlers.html","title":"desktopapp_handlers","text":""},{"location":"autoapi/server/settings/desktopapp_handlers.html#server.settings.desktopapp_handlers.ApplicationLaunchStatuses","title":"<code>ApplicationLaunchStatuses</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Application launch statuses</p> <p>Change task's status to left side if current task status     is in list on right side</p> Source code in <code>server/settings/desktopapp_handlers.py</code> <pre><code>class ApplicationLaunchStatuses(BaseSettingsModel):\n    \"\"\"Application launch statuses\n\n    Change task's status to left side if current task status\n        is in list on right side\n    \"\"\"\n    enabled: bool = True\n    ignored_statuses: list[str] = SettingsField(\n        default_factory=list,\n        title=\"Do not change status if current status is\",\n    )\n    status_change: list[DictWithStrList] = SettingsField(\n        title=\"Status change\",\n        default_factory=list,\n    )\n\n    @validator(\"status_change\")\n    def ensure_unique_names(cls, value):\n        \"\"\"Ensure name fields within the lists have unique names.\"\"\"\n\n        ensure_unique_names(value)\n        return value\n</code></pre>"},{"location":"autoapi/server/settings/desktopapp_handlers.html#server.settings.desktopapp_handlers.ApplicationLaunchStatuses.ensure_unique_names","title":"<code>ensure_unique_names(value)</code>","text":"<p>Ensure name fields within the lists have unique names.</p> Source code in <code>server/settings/desktopapp_handlers.py</code> <pre><code>@validator(\"status_change\")\ndef ensure_unique_names(cls, value):\n    \"\"\"Ensure name fields within the lists have unique names.\"\"\"\n\n    ensure_unique_names(value)\n    return value\n</code></pre>"},{"location":"autoapi/server/settings/desktopapp_handlers.html#server.settings.desktopapp_handlers.FtrackDesktopAppHandlers","title":"<code>FtrackDesktopAppHandlers</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Settings for event handlers running in ftrack service.</p> Source code in <code>server/settings/desktopapp_handlers.py</code> <pre><code>class FtrackDesktopAppHandlers(BaseSettingsModel):\n    \"\"\"Settings for event handlers running in ftrack service.\"\"\"\n\n    create_update_attributes: CreateUpdateCustomAttributesAction = (\n        SettingsField(\n            title=\"Create/Update Custom Attributes\",\n            default_factory=CreateUpdateCustomAttributesAction,\n        )\n    )\n    prepare_project: PrepareProjectAction = SettingsField(\n        title=\"Prepare Project\",\n        default_factory=PrepareProjectAction,\n    )\n    clean_hierarchical_attr: SimpleLocalAction = SettingsField(\n        title=\"Clean hierarchical custom attributes\",\n        default_factory=SimpleLocalAction\n    )\n    delete_old_versions: SimpleLocalAction = SettingsField(\n        title=\"Delete old versions\",\n        default_factory=SimpleLocalAction,\n    )\n    delivery_action: SimpleLocalAction = SettingsField(\n        title=\"Delivery action\",\n        default_factory=SimpleLocalAction,\n    )\n    job_killer: SimpleLocalAction = SettingsField(\n        title=\"Job Killer\",\n        default_factory=SimpleLocalAction,\n    )\n    fill_workfile_attribute: FillWorkfileAttr = SettingsField(\n        title=\"Fill workfile Custom attribute\",\n        default_factory=FillWorkfileAttr,\n    )\n</code></pre>"},{"location":"autoapi/server/settings/main.html","title":"main","text":""},{"location":"autoapi/server/settings/main.html#server.settings.main.FtrackServiceSettings","title":"<code>FtrackServiceSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>ftrack service cares about handling ftrack event and synchronization.</p> <p>To be able do that work it is required to listen and process events as one of ftrack users. It is recommended to use special user for that purposes so you can see which changes happened from service.</p> Source code in <code>server/settings/main.py</code> <pre><code>class FtrackServiceSettings(BaseSettingsModel):\n    \"\"\"ftrack service cares about handling ftrack event and synchronization.\n\n    To be able do that work it is required to listen and process events as one\n    of ftrack users. It is recommended to use special user for that purposes\n    so you can see which changes happened from service.\n    \"\"\"\n\n    username: str = SettingsField(\n        enum_resolver=secrets_enum,\n        title=\"ftrack user name\"\n    )\n    api_key: str = SettingsField(\n        enum_resolver=secrets_enum,\n        title=\"ftrack API key\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/main.html#server.settings.main.FtrackSettings","title":"<code>FtrackSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>ftrack addon settings.</p> Source code in <code>server/settings/main.py</code> <pre><code>class FtrackSettings(BaseSettingsModel):\n    \"\"\"ftrack addon settings.\"\"\"\n\n    enabled: bool = SettingsField(True)\n    ftrack_server: str = SettingsField(\n        \"\",\n        title=\"ftrack server url\",\n        scope=[\"studio\"],\n    )\n    service_settings: FtrackServiceSettings = SettingsField(\n        default_factory=FtrackServiceSettings,\n        title=\"Service settings\",\n        scope=[\"studio\"],\n    )\n\n    service_event_handlers: FtrackServiceHandlers = SettingsField(\n        default_factory=FtrackServiceHandlers,\n        title=\"Server Actions/Events\",\n    )\n    post_launch_hook: PostLaunchHookSettings = SettingsField(\n        default_factory=PostLaunchHookSettings,\n        title=\"Status change on application launch\"\n    )\n    user_handlers: FtrackDesktopAppHandlers = SettingsField(\n        default_factory=FtrackDesktopAppHandlers,\n        title=\"User Actions/Events\",\n    )\n    publish: FtrackPublishPlugins = SettingsField(\n        default_factory=FtrackPublishPlugins,\n        title=\"Publish plugins\"\n    )\n    custom_attributes: CustomAttributesModel = SettingsField(\n        title=\"Custom Attributes\",\n        default_factory=CustomAttributesModel,\n        scope=[\"studio\"],\n    )\n</code></pre>"},{"location":"autoapi/server/settings/main.html#server.settings.main.PostLaunchHookSettings","title":"<code>PostLaunchHookSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Change task status on application launch.</p> <p>Change of status is based on mapping. Each item in mapping defines new status which is used based on current status(es). Special value for current statuses is <code>__any__</code>, in that case the new status is always used. And if new status name is <code>__ignore__</code>, the change of status is skipped if current status is in current statuses list.</p> Source code in <code>server/settings/main.py</code> <pre><code>class PostLaunchHookSettings(BaseSettingsModel):\n    \"\"\"Change task status on application launch.\n\n    Change of status is based on mapping. Each item in mapping defines new\n    status which is used based on current status(es). Special value for current\n    statuses is `__any__`, in that case the new status is always used. And if\n    new status name is `__ignore__`, the change of status is skipped if current\n    status is in current statuses list.\n    \"\"\"\n\n    enabled: bool = True\n    mapping: list[PostLaunchHookMapping] = SettingsField(default_factory=list)\n\n    @validator(\"mapping\")\n    def ensure_unique_names(cls, value):\n        \"\"\"Ensure name fields within the lists have unique names.\"\"\"\n\n        ensure_unique_names(value)\n        return value\n</code></pre>"},{"location":"autoapi/server/settings/main.html#server.settings.main.PostLaunchHookSettings.ensure_unique_names","title":"<code>ensure_unique_names(value)</code>","text":"<p>Ensure name fields within the lists have unique names.</p> Source code in <code>server/settings/main.py</code> <pre><code>@validator(\"mapping\")\ndef ensure_unique_names(cls, value):\n    \"\"\"Ensure name fields within the lists have unique names.\"\"\"\n\n    ensure_unique_names(value)\n    return value\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html","title":"publish_plugins","text":""},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.FtrackPublishPlugins","title":"<code>FtrackPublishPlugins</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Settings for event handlers running in ftrack service.</p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>class FtrackPublishPlugins(BaseSettingsModel):\n    \"\"\"Settings for event handlers running in ftrack service.\"\"\"\n\n    CollectFtrackFamily: CollectFtrackFamilyPlugin = SettingsField(\n        title=\"Collect ftrack Family\",\n        default_factory=CollectFtrackFamilyPlugin,\n    )\n    CollectFtrackCustomAttributeData: CollectFtrackCustomAttributeDataModel = (\n        SettingsField(\n            title=\"Collect Custom Attribute Data\",\n            default_factory=CollectFtrackCustomAttributeDataModel,\n            description=(\n                \"Collect custom attributes from ftrack for ftrack entities\"\n                \" that can be used in some templates during publishing.\"\n            )\n        )\n    )\n    ValidateFtrackAttributes: ValidateFtrackAttributesModel = SettingsField(\n        title=\"Validate ftrack Attributes\",\n        default_factory=ValidateFtrackAttributesModel,\n    )\n    IntegrateHierarchyToFtrack: IntegrateHierarchyToFtrackModel = (\n        SettingsField(\n            title=\"Integrate Hierarchy to ftrack\",\n            default_factory=IntegrateHierarchyToFtrackModel,\n            description=(\n                \"Set task status on new task creation.\"\n                \" ftrack's default status is used otherwise.\"\n            )\n        )\n    )\n    IntegrateFtrackDescription: IntegrateFtrackDescriptionModel = (\n        SettingsField(\n            title=\"Integrate ftrack Description\",\n            default_factory=IntegrateFtrackDescriptionModel,\n            description=\"Add description to integrated AssetVersion.\",\n        )\n    )\n    IntegrateFtrackComponentOverwrite: IntegrateFtrackComponentOverwriteModel = SettingsField(\n        title=\"Integrate ftrack Component Overwrite\",\n        default_factory=IntegrateFtrackComponentOverwriteModel,\n    )\n    IntegrateFtrackInstance: IntegrateFtrackInstanceModel = SettingsField(\n        title=\"Integrate ftrack Instance\",\n        default_factory=IntegrateFtrackInstanceModel,\n    )\n    IntegrateFtrackFarmStatus: IntegrateFtrackFarmStatusModel = SettingsField(\n        title=\"Integrate ftrack Farm Status\",\n        default_factory=IntegrateFtrackFarmStatusModel,\n        description=(\n            \"Change status of task when it's product is submitted to farm\"\n        ),\n    )\n    ftrack_task_status_local_publish: FtrackTaskStatusLocalModel = (\n        SettingsField(\n            default_factory=FtrackTaskStatusLocalModel,\n            title=\"ftrack Status Local Integration\",\n        )\n    )\n    ftrack_task_status_on_farm_publish: FtrackTaskStatusOnFarmModel = (\n        SettingsField(\n            default_factory=FtrackTaskStatusOnFarmModel,\n            title=\"ftrack Status On Farm Integration\",\n        )\n    )\n    IntegrateFtrackTaskStatus: IntegrateFtrackTaskStatusModel = SettingsField(\n        default_factory=IntegrateFtrackTaskStatusModel,\n        title=\"Integrate ftrack Task Status\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.ValidateFtrackAttributesModel","title":"<code>ValidateFtrackAttributesModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>class ValidateFtrackAttributesModel(BaseSettingsModel):\n    _isGroup = True\n    enabled: bool = True\n    ftrack_custom_attributes: str = SettingsField(\n        \"{}\",\n        title=\"Custom attributes to validate\",\n        widget=\"textarea\",\n    )\n\n    @validator(\"ftrack_custom_attributes\")\n    def json_parse(cls, value):\n        \"\"\"Ensure name fields within the lists have unique names.\"\"\"\n\n        parsed_data = json.loads(value)\n        if not isinstance(parsed_data, dict):\n            raise AssertionError(\n                \"Parsed value is {} but object is expected\".format(\n                    str(type(parsed_data))))\n        return value\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.ValidateFtrackAttributesModel.json_parse","title":"<code>json_parse(value)</code>","text":"<p>Ensure name fields within the lists have unique names.</p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>@validator(\"ftrack_custom_attributes\")\ndef json_parse(cls, value):\n    \"\"\"Ensure name fields within the lists have unique names.\"\"\"\n\n    parsed_data = json.loads(value)\n    if not isinstance(parsed_data, dict):\n        raise AssertionError(\n            \"Parsed value is {} but object is expected\".format(\n                str(type(parsed_data))))\n    return value\n</code></pre>"},{"location":"autoapi/server/settings/service_handlers.html","title":"service_handlers","text":""},{"location":"autoapi/server/settings/service_handlers.html#server.settings.service_handlers.CreateDailyListsModel","title":"<code>CreateDailyListsModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Create list with AssetVersions by filter criteria.</p> Source code in <code>server/settings/service_handlers.py</code> <pre><code>class CreateDailyListsModel(BaseSettingsModel):\n    \"\"\"Create list with AssetVersions by filter criteria.\"\"\"\n\n    _isGroup = True\n    enabled: bool = True\n    cycle_hour_start: str = SettingsField(\n        \"00:00:00\",\n        title=\"Create daily lists at\",\n        description=\"This may take affect on next day\",\n        widget=\"time\",\n        regex=r\"(?:[01]\\d|2[0123]):(?:[012345]\\d):(?:[012345]\\d)\",\n        section=\"Automated execution\",\n        scope=[\"studio\"],\n    )\n    cycle_days: list[str] = SettingsField(\n        title=\"Days of week\",\n        default_factory=default_week_days,\n        enum_resolver=week_days,\n        scope=[\"studio\"],\n    )\n    lists: list[DailyListItemModel] = SettingsField(\n        title=\"Lists\",\n        default_factory=list,\n    )\n    role_list: list[str] = SettingsField(\n        section=\"---\",\n        title=ROLES_TITLE,\n        default_factory=list,\n    )\n</code></pre>"},{"location":"autoapi/server/settings/service_handlers.html#server.settings.service_handlers.DailyListItemModel","title":"<code>DailyListItemModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Create list with AssetVersions by filter criteria.</p> Source code in <code>server/settings/service_handlers.py</code> <pre><code>class DailyListItemModel(BaseSettingsModel):\n    \"\"\"Create list with AssetVersions by filter criteria.\"\"\"\n\n    _layout = \"expanded\"\n    name_template: str = SettingsField(\"{yy}{mm}{dd}\", title=\"Name template\")\n    category: str = SettingsField(\n        \"Dailies\",\n        title=\"List category\",\n        enum_resolver=lambda: [\"Default\", \"Clients\", \"Dailies\"],\n    )\n    cycle_enabled: bool = SettingsField(\n        False,\n        title=\"Run automatically\",\n    )\n    filters: list[DailyListFilterModel] = SettingsField(\n        title=\"Asset version filters\",\n        default_factory=list,\n    )\n</code></pre>"},{"location":"autoapi/server/settings/service_handlers.html#server.settings.service_handlers.FtrackServiceHandlers","title":"<code>FtrackServiceHandlers</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Settings for event handlers running in ftrack service.</p> Source code in <code>server/settings/service_handlers.py</code> <pre><code>class FtrackServiceHandlers(BaseSettingsModel):\n    \"\"\"Settings for event handlers running in ftrack service.\"\"\"\n\n    prepare_project: SimpleServiceAction = SettingsField(\n        title=\"Prepare Project\",\n        default_factory=SimpleServiceAction,\n    )\n    sync_from_ftrack: SyncFromFtrackModel = SettingsField(\n        title=\"Sync to AYON\",\n        default_factory=SyncFromFtrackModel,\n    )\n    sync_users_from_ftrack: SimpleServiceAction = SettingsField(\n        title=\"Sync Users to AYON\",\n        default_factory=SimpleServiceAction,\n    )\n    sync_hier_entity_attributes: SyncHierarchicalAttributes = SettingsField(\n        title=\"Sync Hierarchical and Entity Attributes\",\n        default_factory=SyncHierarchicalAttributes,\n    )\n    clone_review_session: CloneReviewAction = SettingsField(\n        title=\"Clone Review Session\",\n        default_factory=CloneReviewAction,\n    )\n    delete_ayon_entities: SimpleServiceAction = SettingsField(\n        title=\"Delete Folders/Products\",\n        default_factory=SimpleServiceAction,\n    )\n    thumbnail_updates: ThumbnailHierarchyUpdates = SettingsField(\n        title=\"Update Hierarchy thumbnails\",\n        default_factory=ThumbnailHierarchyUpdates,\n    )\n    status_task_to_parent: SyncStatusTaskToParent = SettingsField(\n        title=\"Sync status from Task to Parent\",\n        default_factory=SyncStatusTaskToParent,\n    )\n    status_task_to_version: SyncStatusTaskToVersion = SettingsField(\n        title=\"Sync status from Task to Version\",\n        default_factory=SyncStatusTaskToVersion,\n    )\n    status_version_to_task: SyncStatusVersionToTask = SettingsField(\n        title=\"Sync status from Version to Task\",\n        default_factory=SyncStatusVersionToTask,\n    )\n    next_task_update: NextTaskUpdate = SettingsField(\n        title=\"Update status on next task\",\n        default_factory=NextTaskUpdate,\n    )\n    transfer_values_of_hierarchical_attributes: TransferHierNonHierAttrsAction = SettingsField(\n        title=\"Action to transfer hierarchical attribute values\",\n        default_factory=TransferHierNonHierAttrsAction,\n    )\n    # create_daily_review_session: CreateDailyReviewSession = SettingsField(\n    #     title=\"Create daily review session\",\n    #     default_factory=CreateDailyReviewSession,\n    # )\n    create_daily_lists: CreateDailyListsModel = SettingsField(\n        title=\"Create daily lists\",\n        default_factory=CreateDailyListsModel,\n    )\n    project_components_sizes: ComponentsSizeCalcModel = SettingsField(\n        title=\"Calculate project component sizes\",\n        default_factory=ComponentsSizeCalcModel,\n    )\n</code></pre>"},{"location":"autoapi/server/settings/service_handlers.html#server.settings.service_handlers.NextTaskUpdate","title":"<code>NextTaskUpdate</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> Source code in <code>server/settings/service_handlers.py</code> <pre><code>class NextTaskUpdate(BaseSettingsModel):\n    _isGroup = True\n    enabled: bool = True\n    mapping: list[NextTaskStatusMapping] = SettingsField(\n        title=\"Status Mappings\",\n        default_factory=list,\n    )\n    ignored_statuses: list[str] = SettingsField(\n        title=\"Ignored statuses\",\n        default_factory=list,\n    )\n    name_sorting: bool = True\n\n    @validator(\"mapping\")\n    def ensure_unique_names(cls, value):\n        \"\"\"Ensure name fields within the lists have unique names.\"\"\"\n\n        ensure_unique_names(value)\n        return value\n</code></pre>"},{"location":"autoapi/server/settings/service_handlers.html#server.settings.service_handlers.NextTaskUpdate.ensure_unique_names","title":"<code>ensure_unique_names(value)</code>","text":"<p>Ensure name fields within the lists have unique names.</p> Source code in <code>server/settings/service_handlers.py</code> <pre><code>@validator(\"mapping\")\ndef ensure_unique_names(cls, value):\n    \"\"\"Ensure name fields within the lists have unique names.\"\"\"\n\n    ensure_unique_names(value)\n    return value\n</code></pre>"},{"location":"autoapi/server/settings/service_handlers.html#server.settings.service_handlers.SyncStatusTaskToVersion","title":"<code>SyncStatusTaskToVersion</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> Source code in <code>server/settings/service_handlers.py</code> <pre><code>class SyncStatusTaskToVersion(BaseSettingsModel):\n    _isGroup = True\n    enabled: bool = True\n    mapping: list[DictWithStrList] = SettingsField(\n        title=\"Status mapping\",\n        default_factory=list,\n    )\n    asset_types_filter_type: str = SettingsField(\n        title=\"Asset types Allow/Deny\",\n        default=\"allow_list\",\n        enum_resolver=_allow_deny_enum,\n    )\n    asset_types: list[str] = SettingsField(\n        title=\"Asset types (short)\",\n        default_factory=list,\n    )\n\n    @validator(\"mapping\")\n    def ensure_unique_names(cls, value):\n        \"\"\"Ensure name fields within the lists have unique names.\"\"\"\n\n        ensure_unique_names(value)\n        return value\n</code></pre>"},{"location":"autoapi/server/settings/service_handlers.html#server.settings.service_handlers.SyncStatusTaskToVersion.ensure_unique_names","title":"<code>ensure_unique_names(value)</code>","text":"<p>Ensure name fields within the lists have unique names.</p> Source code in <code>server/settings/service_handlers.py</code> <pre><code>@validator(\"mapping\")\ndef ensure_unique_names(cls, value):\n    \"\"\"Ensure name fields within the lists have unique names.\"\"\"\n\n    ensure_unique_names(value)\n    return value\n</code></pre>"},{"location":"autoapi/server/settings/service_handlers.html#server.settings.service_handlers.SyncStatusVersionToTask","title":"<code>SyncStatusVersionToTask</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> Source code in <code>server/settings/service_handlers.py</code> <pre><code>class SyncStatusVersionToTask(BaseSettingsModel):\n    _isGroup = True\n    enabled: bool = True\n    mapping: list[DictWithStrList] = SettingsField(\n        title=\"Status mapping\",\n        default_factory=list,\n    )\n    asset_types_filter_type: str = SettingsField(\n        title=\"Asset types Allow/Deny\",\n        default=\"deny_list\",\n        enum_resolver=_allow_deny_enum,\n    )\n    asset_types: list[str] = SettingsField(\n        title=\"Asset types (short)\",\n        default_factory=list,\n    )\n\n    @validator(\"mapping\")\n    def ensure_unique_names(cls, value):\n        \"\"\"Ensure name fields within the lists have unique names.\"\"\"\n\n        ensure_unique_names(value)\n        return value\n</code></pre>"},{"location":"autoapi/server/settings/service_handlers.html#server.settings.service_handlers.SyncStatusVersionToTask.ensure_unique_names","title":"<code>ensure_unique_names(value)</code>","text":"<p>Ensure name fields within the lists have unique names.</p> Source code in <code>server/settings/service_handlers.py</code> <pre><code>@validator(\"mapping\")\ndef ensure_unique_names(cls, value):\n    \"\"\"Ensure name fields within the lists have unique names.\"\"\"\n\n    ensure_unique_names(value)\n    return value\n</code></pre>"},{"location":"autoapi/server/settings/service_handlers.html#server.settings.service_handlers.ThumbnailHierarchyUpdates","title":"<code>ThumbnailHierarchyUpdates</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Push thumbnail from version, up through multiple hierarchy levels.</p> Source code in <code>server/settings/service_handlers.py</code> <pre><code>class ThumbnailHierarchyUpdates(BaseSettingsModel):\n    \"\"\"Push thumbnail from version, up through multiple hierarchy levels.\"\"\"\n\n    enabled: bool = True\n    levels: int = SettingsField(1, title=\"Levels\", ge=0)\n</code></pre>"},{"location":"autoapi/service_tools/main.html","title":"main","text":""},{"location":"autoapi/services/leecher/leecher/index.html","title":"leecher","text":""},{"location":"autoapi/services/leecher/leecher/__main__.html","title":"__main__","text":""},{"location":"autoapi/services/leecher/leecher/listener.html","title":"listener","text":""},{"location":"autoapi/services/processor/processor/index.html","title":"processor","text":""},{"location":"autoapi/services/processor/processor/__main__.html","title":"__main__","text":""},{"location":"autoapi/services/processor/processor/download_utils.html","title":"download_utils","text":""},{"location":"autoapi/services/processor/processor/download_utils.html#services.processor.processor.download_utils.extract_archive_file","title":"<code>extract_archive_file(archive_file, dst_folder=None)</code>","text":"<p>Extract archived file to a directory.</p> <p>Parameters:</p> Name Type Description Default <code>archive_file</code> <code>str</code> <p>Path to a archive file.</p> required <code>dst_folder</code> <code>Optional[str]</code> <p>Directory where content will be extracted. By default, same folder where archive file is.</p> <code>None</code> Source code in <code>services/processor/processor/download_utils.py</code> <pre><code>def extract_archive_file(archive_file, dst_folder=None):\n    \"\"\"Extract archived file to a directory.\n\n    Args:\n        archive_file (str): Path to a archive file.\n        dst_folder (Optional[str]): Directory where content will be extracted.\n            By default, same folder where archive file is.\n\n    \"\"\"\n    if not dst_folder:\n        dst_folder = os.path.dirname(archive_file)\n\n    os.makedirs(dst_folder, exist_ok=True)\n\n    archive_ext, archive_type = get_archive_ext_and_type(archive_file)\n\n    print(f\"Extracting {archive_file} -&gt; {dst_folder}\")\n    if archive_type is None:\n        _, ext = os.path.splitext(archive_file)\n        raise ValueError((\n            f\"Invalid file extension \\\"{ext}\\\".\"\n            f\" Expected {', '.join(IMPLEMENTED_ARCHIVE_FORMATS)}\"\n        ))\n\n    if archive_type == \"zip\":\n        with zipfile.ZipFile(archive_file) as zip_file:\n            zip_file.extractall(dst_folder)\n\n    elif archive_type == \"tar\":\n        if archive_ext == \".tar\":\n            tar_type = \"r:\"\n        elif archive_ext.endswith(\".xz\"):\n            tar_type = \"r:xz\"\n        elif archive_ext.endswith(\".gz\"):\n            tar_type = \"r:gz\"\n        elif archive_ext.endswith(\".bz2\"):\n            tar_type = \"r:bz2\"\n        else:\n            tar_type = \"r:*\"\n\n        with tarfile.open(archive_file, tar_type) as tar_file:\n            tar_file.extractall(dst_folder)\n</code></pre>"},{"location":"autoapi/services/processor/processor/download_utils.html#services.processor.processor.download_utils.get_archive_ext_and_type","title":"<code>get_archive_ext_and_type(archive_file)</code>","text":"<p>Get archive extension and type.</p> <p>Parameters:</p> Name Type Description Default <code>archive_file</code> <code>str</code> <p>Path to archive file.</p> required <p>Returns:</p> Type Description <p>Tuple[str, str]: Archive extension and type.</p> Source code in <code>services/processor/processor/download_utils.py</code> <pre><code>def get_archive_ext_and_type(archive_file):\n    \"\"\"Get archive extension and type.\n\n    Args:\n        archive_file (str): Path to archive file.\n\n    Returns:\n        Tuple[str, str]: Archive extension and type.\n    \"\"\"\n\n    tmp_name = archive_file.lower()\n    if tmp_name.endswith(\".zip\"):\n        return \".zip\", \"zip\"\n\n    for ext in (\n        \".tar\",\n        \".tgz\",\n        \".tar.gz\",\n        \".tar.xz\",\n        \".tar.bz2\",\n    ):\n        if tmp_name.endswith(ext):\n            return ext, \"tar\"\n\n    return None, None\n</code></pre>"},{"location":"autoapi/services/processor/processor/ftrack_session.html","title":"ftrack_session","text":""},{"location":"autoapi/services/processor/processor/ftrack_session.html#services.processor.processor.ftrack_session.CustomEventHubSession","title":"<code>CustomEventHubSession</code>","text":"<p>               Bases: <code>Session</code></p> <p>An isolated session for interaction with an ftrack server.</p> Source code in <code>services/processor/processor/ftrack_session.py</code> <pre><code>class CustomEventHubSession(ftrack_api.session.Session):\n    \"\"\"An isolated session for interaction with an ftrack server.\"\"\"\n\n    def __init__(\n        self,\n        server_url=None,\n        api_key=None,\n        api_user=None,\n        auto_populate=True,\n        plugin_paths=None,\n        cache=None,\n        cache_key_maker=None,\n        auto_connect_event_hub=False,\n        schema_cache_path=None,\n        plugin_arguments=None,\n        timeout=60,\n        **kwargs,\n    ):\n        self.kwargs = kwargs\n\n        super(ftrack_api.session.Session, self).__init__()\n        self.logger = logging.getLogger(\n            __name__ + \".\" + self.__class__.__name__\n        )\n        self._closed = False\n\n        if server_url is None:\n            server_url = os.environ.get(\"FTRACK_SERVER\")\n\n        if not server_url:\n            raise TypeError(\n                'Required \"server_url\" not specified. Pass as argument or set '\n                \"in environment variable FTRACK_SERVER.\"\n            )\n\n        self._server_url = server_url\n\n        if api_key is None:\n            api_key = os.environ.get(\n                \"FTRACK_API_KEY\",\n                # Backwards compatibility\n                os.environ.get(\"FTRACK_APIKEY\"),\n            )\n\n        if not api_key:\n            raise TypeError(\n                'Required \"api_key\" not specified. Pass as argument or set in '\n                \"environment variable FTRACK_API_KEY.\"\n            )\n\n        self._api_key = api_key\n\n        if api_user is None:\n            api_user = os.environ.get(\"FTRACK_API_USER\")\n            if not api_user:\n                try:\n                    api_user = getpass.getuser()\n                except Exception:\n                    pass\n\n        if not api_user:\n            raise TypeError(\n                'Required \"api_user\" not specified. Pass as argument, set in '\n                \"environment variable FTRACK_API_USER or one of the standard \"\n                \"environment variables used by Python's getpass module.\"\n            )\n\n        self._api_user = api_user\n\n        # Currently pending operations.\n        self.recorded_operations = ftrack_api.operation.Operations()\n\n        # AYON change - In new API are operations properties\n        new_api = hasattr(self.__class__, \"record_operations\")\n\n        if new_api:\n            self._record_operations = collections.defaultdict(lambda: True)\n            self._auto_populate = collections.defaultdict(\n                lambda: auto_populate\n            )\n        else:\n            self.record_operations = True\n            self.auto_populate = auto_populate\n\n        self.cache_key_maker = cache_key_maker\n        if self.cache_key_maker is None:\n            self.cache_key_maker = ftrack_api.cache.StringKeyMaker()\n\n        # Enforce always having a memory cache at top level so that the same\n        # in-memory instance is returned from session.\n        self.cache = ftrack_api.cache.LayeredCache(\n            [ftrack_api.cache.MemoryCache()]\n        )\n\n        if cache is not None:\n            if callable(cache):\n                cache = cache(self)\n\n            if cache is not None:\n                self.cache.caches.append(cache)\n\n        if new_api:\n            self.merge_lock = threading.RLock()\n\n        self._managed_request = None\n        self._request = requests.Session()\n        self._request.auth = ftrack_api.session.SessionAuthentication(\n            self._api_key, self._api_user\n        )\n        self.request_timeout = timeout\n\n        # Fetch server information and in doing so also check credentials.\n        self._server_information = self._fetch_server_information()\n\n        # Now check compatibility of server based on retrieved information.\n        self.check_server_compatibility()\n\n        # Construct event hub and load plugins.\n        self._event_hub = self._create_event_hub()\n\n        self._auto_connect_event_hub_thread = None\n        if auto_connect_event_hub:\n            # Connect to event hub in background thread so as not to block main\n            # session usage waiting for event hub connection.\n            self._auto_connect_event_hub_thread = threading.Thread(\n                target=self._event_hub.connect\n            )\n            self._auto_connect_event_hub_thread.daemon = True\n            self._auto_connect_event_hub_thread.start()\n\n        # Register to auto-close session on exit.\n        atexit.register(WeakMethod(self.close))\n\n        self._plugin_paths = plugin_paths\n        if self._plugin_paths is None:\n            env_paths = os.environ.get(\"FTRACK_EVENT_PLUGIN_PATH\", \"\")\n            self._plugin_paths = env_paths.split(os.pathsep)\n\n        self._discover_plugins(plugin_arguments=plugin_arguments)\n\n        # TODO: Make schemas read-only and non-mutable (or at least without\n        # rebuilding types)?\n        if schema_cache_path is not False:\n            if schema_cache_path is None:\n                schema_cache_path = appdirs.user_cache_dir()\n                schema_cache_path = os.environ.get(\n                    \"FTRACK_API_SCHEMA_CACHE_PATH\", schema_cache_path\n                )\n\n            schema_cache_path = os.path.join(\n                schema_cache_path, \"ftrack_api_schema_cache.json\"\n            )\n\n        self.schemas = self._load_schemas(schema_cache_path)\n        self.types = self._build_entity_type_classes(self.schemas)\n\n        ftrack_api._centralized_storage_scenario.register(self)\n\n        self._configure_locations()\n        self.event_hub.publish(\n            ftrack_api.event.base.Event(\n                topic=\"ftrack.api.session.ready\", data=dict(session=self)\n            ),\n            synchronous=True,\n        )\n\n    def _create_event_hub(self):\n        return ftrack_api.event.hub.EventHub(\n            self._server_url, self._api_user, self._api_key\n        )\n</code></pre>"},{"location":"autoapi/services/processor/processor/ftrack_session.html#services.processor.processor.ftrack_session.ProcessEventHub","title":"<code>ProcessEventHub</code>","text":"<p>               Bases: <code>EventHub</code></p> Source code in <code>services/processor/processor/ftrack_session.py</code> <pre><code>class ProcessEventHub(ftrack_api.event.hub.EventHub):\n    _server_con = None\n\n    def get_next_ftrack_event(self):\n        if not self.connected:\n            return None\n        return enroll_event_job(\n            source_topic=\"ftrack.leech\",\n            target_topic=\"ftrack.proc\",\n            sender=get_service_name(),\n            description=\"Event processing\",\n            sequential=True,\n        )\n\n    def finish_job(self, job):\n        event_id = job[\"id\"]\n        source_id = job[\"dependsOn\"]\n        source_event = get_event(event_id)\n        print(f\"Processed event... {source_id}\")\n\n        description = f\"Processed {source_event['description']}\"\n\n        update_event(\n            event_id,\n            sender=get_service_name(),\n            status=\"finished\",\n            description=description,\n        )\n\n    def load_event_from_jobs(self):\n        job = self.get_next_ftrack_event()\n        if not job:\n            return False\n\n        src_job = get_event(job[\"dependsOn\"])\n        ftrack_event = ftrack_api.event.base.Event(**src_job[\"payload\"])\n        self._event_queue.put((ftrack_event, job))\n        return True\n\n    def wait(self, duration=None):\n        \"\"\"Overridden wait\n        Event are loaded from Mongo DB when queue is empty. Handled event is\n        set as processed in Mongo DB.\n        \"\"\"\n\n        started = time.time()\n        last_loaded_job = 0\n        while True:\n            job = None\n            empty_queue = False\n            try:\n                item = self._event_queue.get(timeout=0.1)\n                if isinstance(item, tuple):\n                    event, job = item\n                else:\n                    event = item\n\n            except queue.Empty:\n                empty_queue = True\n\n            # Do not do this under except handling to avoid confusing\n            #   traceback if something happens\n            if empty_queue:\n                if not self.connected:\n                    break\n\n                if self.load_event_from_jobs():\n                    last_loaded_job = time.time()\n                elif time.time() - last_loaded_job &gt; 5 * 60:\n                    if not self._check_stuck_events():\n                        time.sleep(5)\n                else:\n                    time.sleep(0.1)\n                continue\n\n            self._handle(event)\n\n            if job is not None:\n                self.finish_job(job)\n\n            # Additional special processing of events.\n            if event[\"topic\"] == \"ftrack.meta.disconnected\":\n                break\n\n            if duration is not None:\n                if (time.time() - started) &gt; duration:\n                    break\n\n    def _handle_packet(self, code, packet_identifier, path, data):\n        \"\"\"Override `_handle_packet` which skip events and extend heartbeat\"\"\"\n        code_name = self._code_name_mapping[code]\n        if code_name == \"event\":\n            return\n\n        return super()._handle_packet(code, packet_identifier, path, data)\n\n    def _check_stuck_events(self) -&gt; bool:\n        \"\"\"Check if there are stuck events and mark them as failed\"\"\"\n        now = arrow.utcnow()\n        changed_status = False\n        for event in get_events(\n            topics={\"ftrack.proc\"},\n            statuses={\"pending\"},\n        ):\n            created_at = arrow.get(event[\"createdAt\"]).to(\"local\")\n            delta = now - created_at\n            if delta.seconds &gt; EVENT_PROCESS_TIMEOUT:\n                event_id = event[\"id\"]\n                print(f\"Failing stuck event '{event_id}'\")\n                changed_status = True\n                update_event(\n                    event_id,\n                    sender=get_service_name(),\n                    status=\"failed\",\n                    description=\"Stuck event\",\n                )\n        return changed_status\n</code></pre>"},{"location":"autoapi/services/processor/processor/ftrack_session.html#services.processor.processor.ftrack_session.ProcessEventHub.wait","title":"<code>wait(duration=None)</code>","text":"<p>Overridden wait Event are loaded from Mongo DB when queue is empty. Handled event is set as processed in Mongo DB.</p> Source code in <code>services/processor/processor/ftrack_session.py</code> <pre><code>def wait(self, duration=None):\n    \"\"\"Overridden wait\n    Event are loaded from Mongo DB when queue is empty. Handled event is\n    set as processed in Mongo DB.\n    \"\"\"\n\n    started = time.time()\n    last_loaded_job = 0\n    while True:\n        job = None\n        empty_queue = False\n        try:\n            item = self._event_queue.get(timeout=0.1)\n            if isinstance(item, tuple):\n                event, job = item\n            else:\n                event = item\n\n        except queue.Empty:\n            empty_queue = True\n\n        # Do not do this under except handling to avoid confusing\n        #   traceback if something happens\n        if empty_queue:\n            if not self.connected:\n                break\n\n            if self.load_event_from_jobs():\n                last_loaded_job = time.time()\n            elif time.time() - last_loaded_job &gt; 5 * 60:\n                if not self._check_stuck_events():\n                    time.sleep(5)\n            else:\n                time.sleep(0.1)\n            continue\n\n        self._handle(event)\n\n        if job is not None:\n            self.finish_job(job)\n\n        # Additional special processing of events.\n        if event[\"topic\"] == \"ftrack.meta.disconnected\":\n            break\n\n        if duration is not None:\n            if (time.time() - started) &gt; duration:\n                break\n</code></pre>"},{"location":"autoapi/services/processor/processor/server.html","title":"server","text":""},{"location":"autoapi/services/processor/processor/default_handlers/index.html","title":"default_handlers","text":""},{"location":"autoapi/services/processor/processor/default_handlers/action_clone_review_session.html","title":"action_clone_review_session","text":""},{"location":"autoapi/services/processor/processor/default_handlers/action_clone_review_session.html#services.processor.processor.default_handlers.action_clone_review_session.CloneReviewSession","title":"<code>CloneReviewSession</code>","text":"<p>               Bases: <code>ServerAction</code></p> <p>Generate Client Review action.</p> Source code in <code>services/processor/processor/default_handlers/action_clone_review_session.py</code> <pre><code>class CloneReviewSession(ServerAction):\n    \"\"\"Generate Client Review action.\"\"\"\n    label = \"Clone Review Session (AYON)\"\n    variant = None\n    identifier = \"ayon.clone-review-session\"\n    description = None\n    settings_key = \"clone_review_session\"\n\n    def discover(self, session, entities, event):\n        is_valid = (\n            len(entities) == 1\n            and entities[0].entity_type == \"ReviewSession\"\n        )\n        if is_valid:\n            is_valid = self.valid_roles(session, entities, event)\n        return is_valid\n\n    def launch(self, session, entities, event):\n        userId = event['source']['user']['id']\n        user = session.query('User where id is ' + userId).one()\n        job = session.create(\n            'Job',\n            {\n                'user': user,\n                'status': 'running',\n                'data': json.dumps({\n                    'description': 'Cloning Review Session.'\n                })\n            }\n        )\n        session.commit()\n\n        try:\n            clone_review_session(session, entities[0])\n\n            job['status'] = 'done'\n            session.commit()\n        except Exception:\n            session.rollback()\n            job[\"status\"] = \"failed\"\n            session.commit()\n            self.log.error(\n                \"Cloning review session failed ({})\", exc_info=True\n            )\n\n        return {\n            'success': True,\n            'message': 'Action completed successfully'\n        }\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_create_lists.html","title":"action_create_lists","text":""},{"location":"autoapi/services/processor/processor/default_handlers/action_create_lists.html#services.processor.processor.default_handlers.action_create_lists.CreateDailyListServerAction","title":"<code>CreateDailyListServerAction</code>","text":"<p>               Bases: <code>ServerAction</code></p> Source code in <code>services/processor/processor/default_handlers/action_create_lists.py</code> <pre><code>class CreateDailyListServerAction(ServerAction):\n    identifier = \"create.daily.lists\"\n    label = \"AYON Admin\"\n    variant = \"- Create Daily Lists (Server)\"\n    icon = get_service_ftrack_icon_url(\"AYONAdmin.svg\")\n    description = \"Manually create daily lists\"\n    role_list = {\"Administrator\", \"Project Manager\"}\n\n    automated_topic = \"{}.automated\".format(identifier)\n    settings_key = \"create_daily_lists\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        self._cycle_timers_by_id = {}\n        self._day_delta = datetime.timedelta(days=1)\n\n    def discover(self, session, entities, event):\n        \"\"\"Show action only on AssetVersions.\"\"\"\n\n        valid_selection = False\n        for ent in event[\"data\"][\"selection\"]:\n            # Ignore entities that are not tasks or projects\n            if ent[\"entityType\"].lower() in (\n                \"show\", \"task\", \"reviewsession\", \"assetversion\"\n            ):\n                valid_selection = True\n                break\n\n        if not valid_selection:\n            return False\n        return self.valid_roles(session, entities, event)\n\n    def interface(self, session, entities, event):\n        values = event[\"data\"].get(\"values\")\n        if values:\n            return None\n\n        project_entity = self.get_project_from_entity(entities[0], session)\n        project_name = project_entity[\"full_name\"]\n        project_settings = self.get_project_settings_from_event(\n            event, project_name\n        )\n        action_settings = self._extract_action_settings(project_settings)\n        action_lists = copy.deepcopy(action_settings[\"lists\"])\n        if not action_lists:\n            return {\n                \"type\": \"message\",\n                \"success\": False,\n                \"message\": \"There are no list presets in settings to create.\"\n            }\n\n        items = [\n            {\n                \"type\": \"label\",\n                \"value\": \"# Select lists to create:\",\n            },\n        ]\n        for action_list in action_lists:\n            action_id = uuid.uuid4().hex\n            action_list[\"id\"] = action_id\n            label = \"## {} - &lt;b&gt;{}&lt;/b&gt;\".format(\n                action_list[\"category\"],\n                action_list[\"name_template\"],\n            )\n            items.extend([\n                {\"type\": \"label\", \"value\": \"---\"},\n                {\"type\": \"label\", \"value\": label},\n                {\n                    \"type\": \"boolean\",\n                    \"name\": action_id,\n                    \"value\": False,\n                },\n            ])\n        items.append({\n            \"type\": \"hidden\",\n            \"value\": json.dumps(action_lists),\n            \"name\": \"action_lists\",\n        })\n\n        return {\n            \"title\": \"Create Lists\",\n            \"items\": items,\n            \"submit_button_label\": \"Confirm\",\n        }\n\n    def launch(self, session, entities, event):\n        values = event[\"data\"].get(\"values\")\n        if not values:\n            return\n\n        action_lists = json.loads(values[\"action_lists\"])\n        selected_action_lists = [\n            action_list\n            for action_list in action_lists\n            if values.get(action_list[\"id\"])\n        ]\n\n        project_entity = self.get_project_from_entity(entities[0], session)\n        project_name = project_entity[\"full_name\"]\n        project_name_by_id = {\n            project_entity[\"id\"]: project_name\n        }\n        list_defs_by_id = {\n            project_entity[\"id\"]: selected_action_lists\n        }\n\n        self._process_lists_creation(\n            session, list_defs_by_id, project_name_by_id\n        )\n        return True\n\n    def _calculate_next_cycle_delta(self, action_settings=None):\n        if action_settings is None:\n            service_settings = get_service_addon_settings()\n            action_settings = (\n                service_settings\n                [self.settings_frack_subkey]\n                [self.settings_key]\n            )\n        cycle_hour_start = action_settings.get(\"cycle_hour_start\")\n        if not cycle_hour_start:\n            h = m = s = 0\n        else:\n            h, m, s = [int(v) for v in cycle_hour_start.split(\":\")]\n\n        # Create threading timer which will trigger creation of report\n        #   at the 00:00:01 of next day\n        # - callback will trigger another timer which will have 1 day offset\n        now = datetime.datetime.now()\n        # Create object of today morning\n        expected_next_trigger = datetime.datetime(\n            now.year, now.month, now.day, h, m, s\n        )\n        if expected_next_trigger &lt;= now:\n            expected_next_trigger += self._day_delta\n        return (expected_next_trigger - now).total_seconds()\n\n    def register(self, *args, **kwargs):\n        \"\"\"Override register to be able trigger \"\"\"\n        # Register server action as would be normally\n        super().register(*args, **kwargs)\n\n        self.session.event_hub.subscribe(\n            \"topic={}\".format(self.automated_topic),\n            self._automated_run,\n            priority=self.priority\n        )\n\n        self._add_timer_callback()\n\n    def cleanup(self):\n        for timer_id in list(self._cycle_timers_by_id.keys()):\n            timer = self._cycle_timers_by_id.pop(timer_id, None)\n            if timer is not None:\n                timer.cancel()\n\n    def _add_timer_callback(self):\n        seconds_delta = self._calculate_next_cycle_delta()\n\n        timer_id = uuid.uuid4().hex\n        cycle_timer = threading.Timer(\n            seconds_delta, self._timer_callback, [timer_id]\n        )\n        self._cycle_timers_by_id[timer_id] = cycle_timer\n        cycle_timer.start()\n\n    def _timer_callback(self, timer_id):\n        timer = self._cycle_timers_by_id.pop(timer_id, None)\n        if timer is None:\n            return\n\n        # Stop chrono callbacks if session is closed\n        if self.session.closed:\n            return\n\n        service_settings = get_service_addon_settings()\n        action_settings = (\n            service_settings\n            [self.settings_frack_subkey]\n            [self.settings_key]\n        )\n\n        self._add_timer_callback()\n\n        datetime_obj = datetime.datetime.now()\n        weekday = WEEKDAY_MAPPING[datetime_obj.weekday()]\n\n        if weekday not in action_settings[\"cycle_days\"]:\n            self.log.debug(\n                f\"Automated run on day {weekday}\"\n                f\" skipped by settings definition.\"\n            )\n            return\n\n        timestamp = datetime_obj.strftime(\"%Y%m%d\")\n        user = self.session.query(\n            f\"User where username is '{self.session.api_user}'\"\n        ).one()\n\n        event_hash = f\"{self.automated_topic}{timestamp}\"\n        event_ui = uuid.uuid4().hex\n        event_data = {\n            \"id\": event_ui,\n            \"data\": {},\n            \"sent\": None,\n            \"topic\": self.automated_topic,\n            \"source\": {\n                \"user\": {\n                    \"id\": user[\"id\"],\n                    \"username\": user[\"username\"]\n                }\n            },\n            \"target\": \"\",\n            \"in_reply_to_event\": None\n        }\n        response = ayon_api.post(\n            \"events\",\n            topic=\"ftrack.leech\",\n            sender=ayon_api.ServiceContext.service_name,\n            hash=event_hash,\n            payload=event_data,\n            description=f\"Automated chrono action '{self.automated_topic}'\"\n        )\n        try:\n            response.raise_for_status()\n            self.log.debug(f\"Created automated task {self.automated_topic}.\")\n        except Exception:\n            self.log.debug(\n                f\"Failed to created automated task {self.automated_topic}.\"\n                \" Probably was already created by another running service.\"\n            )\n\n    def _automated_run(self, event):\n        session = self.session\n        ayon_project_names = {\n            project[\"name\"]\n            for project in ayon_api.get_projects(fields=[\"name\"])\n        }\n        project_entities = session.query(\n            \"select id, full_name from Project\"\n        ).all()\n        project_names_by_id = {\n            project_entity[\"id\"]: project_entity[\"full_name\"]\n            for project_entity in project_entities\n            if project_entity[\"full_name\"] in ayon_project_names\n        }\n\n        action_settings_by_project_id = self._get_action_settings(\n            project_names_by_id\n        )\n        lists_by_project_id = {}\n        for item in action_settings_by_project_id.items():\n            project_id, action_settings = item\n            if not action_settings.get(\"enabled\"):\n                continue\n            action_lists = [\n                item\n                for item in action_settings[\"lists\"]\n                if item[\"cycle_enabled\"]\n            ]\n            if action_lists:\n                lists_by_project_id[project_id] = action_lists\n\n        if not lists_by_project_id:\n            self.log.info((\n                \"There are no projects that have enabled\"\n                \" cycle review sesison creation\"\n            ))\n\n        else:\n            self._process_lists_creation(\n                session,\n                lists_by_project_id,\n                project_names_by_id\n            )\n\n        session.close()\n\n    def _process_lists_creation(\n        self,\n        session: ftrack_api.Session,\n        list_defs_by_project_id: dict[str, list[dict[str, Any]]],\n        project_names_by_id: dict[str, str]\n    ):\n        project_lists = session.query((\n            \"select id, name, project_id\"\n            \" from List where project_id in ({})\"\n            \" and system_type is 'assetversion'\"\n        ).format(self.join_query_keys(list_defs_by_project_id))).all()\n\n        project_lists_by_project_id = collections.defaultdict(list)\n        for project_list in project_lists:\n            project_id = project_list[\"project_id\"]\n            project_lists_by_project_id[project_id].append(project_list)\n\n        statuses = session.query(\"select id, name from Status\").all()\n        status_id_by_low_name = {\n            status[\"name\"].lower(): status[\"id\"]\n            for status in statuses\n        }\n\n        cust_attrs = session.query(\n            \"select id, key, default, is_hierarchical\"\n            \" from CustomAttributeConfiguration\"\n            \" where entity_type is AssetVersion or is_hierarchical is True\"\n        ).all()\n        cust_attrs_by_key = collections.defaultdict(list)\n        for cust_attr in cust_attrs:\n            cust_attrs_by_key[cust_attr[\"key\"]].append(cust_attr)\n\n        # Prepare fill data for today's review sesison and yesterdays\n        now = datetime.datetime.now()\n        today_obj = datetime.datetime(\n            now.year, now.month, now.day, 0, 0, 0\n        )\n\n        fill_data = get_datetime_data(today_obj)\n        for project_id, list_defs in list_defs_by_project_id.items():\n            project_lists = project_lists_by_project_id[project_id]\n            project_name = project_names_by_id[project_id]\n            self._create_lists(\n                session,\n                project_name,\n                project_id,\n                list_defs,\n                project_lists,\n                cust_attrs_by_key,\n                status_id_by_low_name,\n                fill_data,\n            )\n\n    def _query_all_project_entity_ids(\n        self, session: ftrack_api.Session, project_id: str\n    ) -&gt; set[str]:\n        \"\"\"Query all entity ids in ftrack project hierarchy.\n\n        All 'TypedContext' entities except 'Task'.\n\n        Args:\n            session (ftrack_api.Session): Connected ftrack session.\n            project_id (str): Project id.\n\n        Returns:\n            set[str]: All entity ids in project hierarchy.\n        \"\"\"\n\n        chunk_size = 100\n        query_parent_ids = [project_id]\n        task_type = session.query(\n            \"select id from ObjectType where name is 'Task'\"\n        ).one()\n        task_type_id = task_type[\"id\"]\n        entity_ids = set()\n        while query_parent_ids:\n            _chunk_size = chunk_size\n            if len(query_parent_ids) &lt; chunk_size:\n                _chunk_size = len(query_parent_ids)\n            query_parent_ids_chunk = query_parent_ids[:_chunk_size]\n            query_parent_ids = query_parent_ids[_chunk_size:]\n            joined_parent_ids = self.join_query_keys(query_parent_ids_chunk)\n            entities = session.query(\n                \"select id from TypedContext\"\n                f\" where parent_id in ({joined_parent_ids})\"\n                f\" and object_type_id != '{task_type_id}' \"\n            )\n            for entity in entities:\n                entity_id = entity[\"id\"]\n                entity_ids.add(entity_id)\n                query_parent_ids.append(entity_id)\n        return entity_ids\n\n    def _query_asset_versions(\n        self,\n        session: ftrack_api.Session,\n        project_id: str,\n        all_filter_statuses: set[str],\n        all_statuses: bool\n    ) -&gt; list[ftrack_api.entity.base.Entity]:\n        \"\"\"Query all asset versions in project hierarchy based on filters.\n\n        Using status filter makes this function much faster. Anyway this\n        is still querying all entities in project with all their Asset\n        entities.\n\n        Args:\n            session (ftrack_api.Session): Connected ftrack session.\n            project_id (str): Project id.\n            all_filter_statuses (set[str]): All filter statuses.\n            all_statuses (bool): All statuses enabled.\n\n        Returns:\n            list[ftrack_api.entity.base.Entity]: All queried versions.\n        \"\"\"\n\n        entity_ids = self._query_all_project_entity_ids(session, project_id)\n        status_filter = \"\"\n        if not all_statuses:\n            joined_status_ids = self.join_query_keys(all_filter_statuses)\n            status_filter = f\" and status_id in ({joined_status_ids})\"\n\n        asset_ids = set()\n        for chunk in create_chunks(entity_ids):\n            joined_parent_ids = self.join_query_keys(chunk)\n            assets = session.query(\n                \"select id, context_id from Asset\"\n                f\" where context_id in ({joined_parent_ids})\"\n            ).all()\n            asset_ids |= {asset[\"id\"] for asset in assets}\n\n        all_asset_versions = []\n        for chunk in create_chunks(asset_ids):\n            joined_asset_ids = self.join_query_keys(chunk)\n            asset_versions = session.query(\n                \"select id, status_id from AssetVersion\"\n                f\" where asset_id in ({joined_asset_ids}){status_filter}\"\n            ).all()\n            all_asset_versions.extend(asset_versions)\n        return all_asset_versions\n\n    def _query_attr_values(\n        self,\n        session: ftrack_api.Session,\n        attr_confs: list[ftrack_api.entity.base.Entity],\n        asset_versions: list[ftrack_api.entity.base.Entity],\n    ) -&gt; dict[str, dict[str, Any]]:\n        \"\"\"Query non-hierarchical attribute values for asset versions.\n\n        Args:\n            session (ftrack_api.Session): Connected ftrack session.\n            attr_confs (list[ftrack_api.entity.base.Entity]): Attribute\n                configurations.\n            asset_versions (list[ftrack_api.entity.base.Entity]): Asset\n                versions.\n\n        Returns:\n            dict[str, dict[str, Any]]: Values by asset version id\n                and attribute configuration id.\n        \"\"\"\n\n        attr_name_by_id = {\n            attr_conf[\"id\"]: attr_conf[\"key\"]\n            for attr_conf in attr_confs\n        }\n        default_value_by_attr_key = {\n            attr_conf[\"key\"]: attr_conf[\"default\"]\n            for attr_conf in attr_confs\n        }\n        values_by_attr_conf_key = {\n            asset_version[\"id\"]: copy.deepcopy(default_value_by_attr_key)\n            for asset_version in asset_versions\n        }\n        value_items = query_custom_attribute_values(\n            session,\n            attr_name_by_id.keys(),\n            values_by_attr_conf_key.keys()\n        )\n        for value_item in value_items:\n            value = value_item[\"value\"]\n            if value is None:\n                continue\n            conf_id = value_item[\"configuration_id\"]\n            attr_name = attr_name_by_id[conf_id]\n            entity_id = value_item[\"entity_id\"]\n            values_by_attr_conf_key[entity_id][attr_name] = value\n        return values_by_attr_conf_key\n\n    def _filter_asset_versions_for_list_def(\n        self,\n        session: ftrack_api.Session,\n        list_def: dict[str, Any],\n        asset_versions: list[ftrack_api.entity.base.Entity],\n        status_id_by_low_name: dict[str, str],\n        cust_attrs_by_key: dict[str, ftrack_api.entity.base.Entity],\n    ) -&gt; list[ftrack_api.entity.base.Entity]:\n        av_filters = list_def[\"filters\"]\n        for av_filter in av_filters:\n            status_names = av_filter[\"statuses\"]\n            custom_attribute_filters = av_filter[\"custom_attributes\"]\n            if not status_names and not custom_attribute_filters:\n                return asset_versions\n\n        all_filtered_asset_versions = {}\n        for av_filter in av_filters:\n            filtered_asset_versions = self._filter_avs_by_list_filter(\n                session,\n                asset_versions,\n                av_filter,\n                status_id_by_low_name,\n                cust_attrs_by_key,\n            )\n            for asset_version in filtered_asset_versions:\n                asset_version_id = asset_version[\"id\"]\n                all_filtered_asset_versions[asset_version_id] = asset_version\n        return list(all_filtered_asset_versions.values())\n\n    def _filter_avs_by_list_filter(\n        self,\n        session: ftrack_api.Session,\n        asset_versions: list,\n        av_filter: dict,\n        status_id_by_low_name: dict,\n        cust_attrs_by_key,\n    ) -&gt; list[ftrack_api.entity.base.Entity]:\n        status_names = av_filter[\"statuses\"]\n        custom_attribute_filters = av_filter[\"custom_attributes\"]\n        list_versions = list(asset_versions)\n        if status_names:\n            status_ids = set()\n            for status_name in status_names:\n                status_id = status_id_by_low_name.get(status_name.lower())\n                if status_id:\n                    status_ids.add(status_id)\n            # Skip, none of requested status names are available\n            if not status_ids:\n                return []\n            list_versions = [\n                asset_version\n                for asset_version in list_versions\n                if asset_version[\"status_id\"] in status_ids\n            ]\n\n        if not list_versions or not custom_attribute_filters:\n            return list_versions\n\n        attr_names = {\n            attr_info[\"attr_name\"]\n            for attr_info in custom_attribute_filters\n        }\n\n        expected_values = {\n            attr_info[\"attr_name\"]: attr_info[attr_info[\"attr_type\"]]\n            for attr_info in custom_attribute_filters\n        }\n\n        attr_conf_by_name = {}\n        hier_attr_conf_by_name = {}\n        for attr_name in attr_names:\n            attr_confs = cust_attrs_by_key.get(attr_name, [])\n            matching_attr_conf = None\n            for attr_conf in attr_confs:\n                if (\n                    matching_attr_conf is None\n                    # Prefer non-hierarchical over hierarchical attributes\n                    or not attr_conf[\"is_hierarchical\"]\n                ):\n                    matching_attr_conf = attr_conf\n\n            # Attribute not found -&gt; filter not met skipping\n            if not matching_attr_conf:\n                self.log.info(f\"Attribute '{attr_name}' not found\")\n                return []\n\n            if matching_attr_conf[\"is_hierarchical\"]:\n                hier_attr_conf_by_name[attr_name] = matching_attr_conf\n            else:\n                attr_conf_by_name[attr_name] = matching_attr_conf\n\n        # Standard attributes\n        if attr_conf_by_name:\n            attr_values_by_id = self._query_attr_values(\n                session, list(attr_conf_by_name.values()), list_versions\n            )\n            new_list_versions = []\n            for asset_version in list_versions:\n                version_id = asset_version[\"id\"]\n                values = attr_values_by_id[version_id]\n                valid = True\n                for attr_name in attr_conf_by_name.keys():\n                    expected_value = expected_values[attr_name]\n                    if values[attr_name] != expected_value:\n                        valid = False\n                        break\n                if valid:\n                    new_list_versions.append(asset_version)\n            list_versions = new_list_versions\n\n        if not list_versions:\n            return list_versions\n\n        # Hierarchical attributes\n        # - are a little bit more complicated\n        hierarchy_ids = set()\n        for asset_version in list_versions:\n            for item in asset_version[\"link\"]:\n                hierarchy_ids.add(item[\"id\"])\n\n        default_values_by_id = {\n            attr[\"id\"]: attr[\"default\"]\n            for attr in hier_attr_conf_by_name.values()\n        }\n        value_items = query_custom_attribute_values(\n            session,\n            default_values_by_id.keys(),\n            hierarchy_ids\n        )\n        values_by_ids = {\n            attr_id: {}\n            for attr_id in default_values_by_id\n        }\n        for value_item in value_items:\n            value = value_item[\"value\"]\n            if value is None:\n                continue\n            conf_id = value_item[\"configuration_id\"]\n            entity_id = value_item[\"entity_id\"]\n            values_by_ids[conf_id][entity_id] = value\n\n        output = []\n        for asset_version in list_versions:\n            valid = True\n            for attr_name, attr in hier_attr_conf_by_name.items():\n                expected_value = expected_values[attr_name]\n                attr_id = attr[\"id\"]\n                attr_values = values_by_ids[attr_id]\n                value = default_values_by_id[attr_id]\n                for item in asset_version[\"link\"]:\n                    item_id = item[\"id\"]\n                    if item_id in attr_values:\n                        value = attr_values[item_id]\n\n                if expected_value != value:\n                    valid = False\n                    break\n\n            if valid:\n                output.append(asset_version)\n        return output\n\n    def _create_project_list(\n        self, session, project_id, name, category_id\n    ):\n        session.create(\n            \"List\",\n            {\n                \"project_id\": project_id,\n                \"name\": name,\n                \"is_open\": True,\n                \"category_id\": category_id,\n                \"system_type\": \"assetversion\",\n            }\n        )\n        session.commit()\n        return session.query(\n            \"select id, name, category_id from List\"\n            f\" where project_id is '{project_id}'\"\n            f\" and category_id is '{category_id}'\"\n            f\" and name is '{name}'\"\n        ).one()\n\n    def _create_list_object(\n        self,\n        session: ftrack_api.Session,\n        list_entity: ftrack_api.entity.base.Entity,\n        asset_versions: list[ftrack_api.entity.base.Entity]\n    ):\n        list_id = list_entity[\"id\"]\n        list_objects = session.query(\n            f\"select entity_id from ListObject where list_id is '{list_id}'\"\n        ).all()\n        list_object_ids = {obj[\"entity_id\"] for obj in list_objects}\n        asset_version_ids = {\n            asset_version[\"id\"]\n            for asset_version in asset_versions\n        }\n        for entity_id in (asset_version_ids - list_object_ids):\n            session.create(\n                \"ListObject\",\n                {\n                    \"list_id\": list_id,\n                    \"entity_id\": entity_id,\n                }\n            )\n        session.commit()\n\n    def _create_lists(\n        self,\n        session: ftrack_api.Session,\n        project_name: str,\n        project_id: str,\n        list_defs: list[dict[str, Any]],\n        project_lists: list[ftrack_api.entity.base.Entity],\n        cust_attrs_by_key: dict[str, ftrack_api.entity.base.Entity],\n        status_id_by_low_name: dict[str, str],\n        fill_data: dict[str, Any],\n    ):\n        # Find out status filters for '_query_asset_versions'\n        all_statuses = False\n        all_filter_statuses = set()\n        for list_def in list_defs:\n            av_filters = list_def[\"filters\"]\n            for av_filter in av_filters:\n                status_names = av_filter[\"statuses\"]\n                if not status_names:\n                    all_statuses = True\n                    break\n\n                for status_name in status_names:\n                    status_id = status_id_by_low_name.get(status_name.lower())\n                    if status_id:\n                        all_filter_statuses.add(status_id)\n\n        asset_versions = self._query_asset_versions(\n            session, project_id, all_filter_statuses, all_statuses\n        )\n\n        category_objects = session.query(\n            \"select id, name from ListCategory\"\n        ).all()\n        category_id_by_name = {\n            obj[\"name\"]: obj[\"id\"]\n            for obj in category_objects\n        }\n\n        for list_def in list_defs:\n            name_template = list_def[\"name_template\"]\n            list_name = self._fill_list_name_template(name_template, fill_data)\n            if list_name is None:\n                continue\n\n            category_name = list_def[\"category\"]\n            category_id = category_id_by_name[category_name]\n            asset_versions = self._filter_asset_versions_for_list_def(\n                session,\n                list_def,\n                asset_versions,\n                status_id_by_low_name,\n                cust_attrs_by_key,\n            )\n            if not asset_versions:\n                self.log.debug(\n                    \"There are no asset versions matching list definition\"\n                    f\" filters in project '{project_name}'.\"\n                )\n                continue\n\n            existing_list = next(\n                (\n                    project_list\n                    for project_list in project_lists\n                    if (\n                        project_list[\"name\"] == list_name\n                        and project_list[\"category_id\"] == category_id\n                    )\n                ),\n                None\n            )\n            if existing_list is None:\n                existing_list = self._create_project_list(\n                    session, project_id, list_name, category_id\n                )\n                project_lists.append(existing_list)\n\n            self._create_list_object(session, existing_list, asset_versions)\n\n    def _get_action_settings(\n        self, project_names_by_id: dict[str, str]\n    ) -&gt; dict[str, Any]:\n        settings_by_project_id = {}\n        for project_id, project_name in project_names_by_id.items():\n            ftrack_project_settings = get_addon_settings(\n                get_service_addon_name(),\n                get_service_addon_version(),\n                project_name,\n            )\n            project_settings = {\"ftrack\": ftrack_project_settings}\n            if is_ftrack_enabled_in_settings(ftrack_project_settings):\n                action_settings = self._extract_action_settings(\n                    project_settings\n                )\n            else:\n                action_settings = {}\n            settings_by_project_id[project_id] = action_settings\n        return settings_by_project_id\n\n    def _extract_action_settings(\n        self, project_settings: dict[str, Any]\n    ) -&gt; dict[str, Any]:\n        return (\n            project_settings\n            .get(\"ftrack\", {})\n            .get(self.settings_frack_subkey, {})\n            .get(self.settings_key)\n        ) or {}\n\n    def _fill_list_name_template(\n        self, template: str, data: dict[str, Any]\n    ) -&gt; Union[str, None]:\n        output = None\n        try:\n            output = template.format(**data)\n        except Exception:\n            self.log.warning(\n                (\n                    \"Failed to fill list template {} with data {}\"\n                ).format(template, data),\n                exc_info=True\n            )\n        return output\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_create_lists.html#services.processor.processor.default_handlers.action_create_lists.CreateDailyListServerAction.discover","title":"<code>discover(session, entities, event)</code>","text":"<p>Show action only on AssetVersions.</p> Source code in <code>services/processor/processor/default_handlers/action_create_lists.py</code> <pre><code>def discover(self, session, entities, event):\n    \"\"\"Show action only on AssetVersions.\"\"\"\n\n    valid_selection = False\n    for ent in event[\"data\"][\"selection\"]:\n        # Ignore entities that are not tasks or projects\n        if ent[\"entityType\"].lower() in (\n            \"show\", \"task\", \"reviewsession\", \"assetversion\"\n        ):\n            valid_selection = True\n            break\n\n    if not valid_selection:\n        return False\n    return self.valid_roles(session, entities, event)\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_create_lists.html#services.processor.processor.default_handlers.action_create_lists.CreateDailyListServerAction.register","title":"<code>register(*args, **kwargs)</code>","text":"<p>Override register to be able trigger</p> Source code in <code>services/processor/processor/default_handlers/action_create_lists.py</code> <pre><code>def register(self, *args, **kwargs):\n    \"\"\"Override register to be able trigger \"\"\"\n    # Register server action as would be normally\n    super().register(*args, **kwargs)\n\n    self.session.event_hub.subscribe(\n        \"topic={}\".format(self.automated_topic),\n        self._automated_run,\n        priority=self.priority\n    )\n\n    self._add_timer_callback()\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_delete_entities.html","title":"action_delete_entities","text":""},{"location":"autoapi/services/processor/processor/default_handlers/action_delete_entities.html#services.processor.processor.default_handlers.action_delete_entities.AyonData","title":"<code>AyonData</code>","text":"<p>Helper structure to hold AYON data.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>folders_by_id</code> <code>dict[str, dict[str, Any]]</code> <p>Folders by id.</p> required <code>folders_by_path</code> <code>dict[str, dict[str, Any]]</code> <p>Folders by path.</p> required <code>folders_by_parent_id</code> <code>dict[str, list[dict[str, Any]]]</code> <p>Folders by parent id.</p> required <code>not_found_paths</code> <code>set[str]</code> <p>Folder paths not found in AYON.</p> required <code>selected_folder_ids</code> <code>set[str]</code> <p>Selected folder ids.</p> required <code>folder_ids_to_delete</code> <code>set[str]</code> <p>Folder ids to delete. Contains all folder children of selected folder ids.</p> required Source code in <code>services/processor/processor/default_handlers/action_delete_entities.py</code> <pre><code>class AyonData:\n    \"\"\"Helper structure to hold AYON data.\n\n    Args:\n        project_name (str): Project name.\n        folders_by_id (dict[str, dict[str, Any]]): Folders by id.\n        folders_by_path (dict[str, dict[str, Any]]): Folders by path.\n        folders_by_parent_id (dict[str, list[dict[str, Any]]]): Folders by\n            parent id.\n        not_found_paths (set[str]): Folder paths not found in AYON.\n        selected_folder_ids (set[str]): Selected folder ids.\n        folder_ids_to_delete (set[str]): Folder ids to delete. Contains all\n            folder children of selected folder ids.\n    \"\"\"\n\n    def __init__(\n        self,\n        project_name,\n        folders_by_id,\n        folders_by_path,\n        folders_by_parent_id,\n        not_found_paths,\n        selected_folder_ids,\n        folder_ids_to_delete,\n    ):\n        self.project_name = project_name\n        self.folders_by_id = folders_by_id\n        self.folders_by_path = folders_by_path\n        self.folders_by_parent_id = folders_by_parent_id\n        self.not_found_paths = not_found_paths\n        self.selected_folder_ids = selected_folder_ids\n        self.folder_ids_to_delete = folder_ids_to_delete\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_delete_entities.html#services.processor.processor.default_handlers.action_delete_entities.DeleteEntitiesAction","title":"<code>DeleteEntitiesAction</code>","text":"<p>               Bases: <code>ServerAction</code></p> Source code in <code>services/processor/processor/default_handlers/action_delete_entities.py</code> <pre><code>class DeleteEntitiesAction(ServerAction):\n    identifier = \"delete.ayon.entities\"\n    label = \"Delete Folders/Products\"\n    description = (\n        \"Remove entities from AYON and from ftrack with all children\"\n    )\n    icon = get_service_ftrack_icon_url(\"DeleteAsset.svg\")\n\n    settings_key = \"delete_ayon_entities\"\n\n    def discover(self, session, entities, event):\n        \"\"\"\n\n        Args:\n            session (ftrack_api.Session): ftrack session processing event.\n            entities (list[ftrack_api.entity.base.Entity]): List of entities\n                selected in ftrack.\n            event (ftrack_api.event.base.Event): Event data.\n\n        Returns:\n            bool: True if action is valid for given selection.\n        \"\"\"\n\n        task_ids = set()\n        for ent_info in event[\"data\"][\"selection\"]:\n            if ent_info.get(\"entityType\") == \"task\":\n                task_ids.add(ent_info[\"entityId\"])\n\n        is_valid = False\n        for entity in entities:\n            if (\n                entity[\"id\"] in task_ids\n                and entity.entity_type.lower() != \"task\"\n            ):\n                is_valid = True\n                break\n\n        if not is_valid:\n            return False\n        return self.valid_roles(session, entities, event)\n\n    def launch(self, session, entities, event):\n        values = event[\"data\"].get(\"values\")\n        if not values:\n            return self._first_interface(session, entities, event)\n\n        # Entity type interface should be showed to select which entities\n        #   should be deleted\n        if not self._waits_for_confirmation(event):\n            self.show_message(event, \"Preparing data...\", True)\n            project_selected, ftrack_ids = self._filter_selection_from_event(\n                entities, event\n            )\n            if project_selected:\n                msg = (\n                    \"It is not possible to use this action on project entity.\"\n                )\n                self.show_message(event, msg, True)\n\n            if values.get(\"entity_type\") == \"folders\":\n                return self._interface_folders(\n                    session, entities, event, ftrack_ids\n                )\n            return self._interface_products(\n                session, entities, event, ftrack_ids\n            )\n\n        # Confirmation fails (misspelled 'delete' etc.)\n        if not self._is_confirmed(event):\n            return self._prepare_delete_interface(event)\n        # User confirmed deletion\n        project_selected, ftrack_ids = self._filter_selection_from_event(\n            entities, event\n        )\n        if values.get(\"entity_type\") == \"folders\":\n            return self._delete_folders(session, entities, event, ftrack_ids)\n        return self._delete_products(session, entities, event, ftrack_ids)\n\n    def _event_values_to_hidden(self, values):\n        \"\"\"Take event values and convert them to hidden items.\n\n        Args:\n            values (dict[str, Any]): ftrack event values.\n\n        Returns:\n            list[dict[str, Any]]: List of hidden items.\n        \"\"\"\n\n        return [\n            {\n                \"type\": \"hidden\",\n                \"name\": key,\n                \"value\": value\n            }\n            for key, value in values.items()\n        ]\n\n    def _waits_for_confirmation(self, event):\n        \"\"\"Check if action waits for confirmation.\n\n        Args:\n            event (ftrack_api.event.base.Event): Event data.\n\n        Returns:\n            bool: True if action waits for confirmation.\n        \"\"\"\n\n        values = event[\"data\"].get(\"values\")\n        if values:\n            return \"delete_confirm_value\" in values\n        return False\n\n    def _is_confirmed(self, event):\n        values = event[\"data\"].get(\"values\")\n        if values is None:\n            return False\n\n        confirm_value = values.get(\"delete_confirm_value\") or \"\"\n        expected_value = values.get(\"delete_confirm_expected\")\n        return confirm_value.lower() == expected_value\n\n    def _prepare_delete_interface(self, event, post_items=None):\n        # Create copy of values to be able to create hidden items\n        values = copy.deepcopy(event[\"data\"][\"values\"])\n        attempt = values.pop(\"delete_attempt_count\", 0) + 1\n\n        # Make sure post items is iterable\n        if post_items is None:\n            post_items = json.loads(values.pop(\"post_items\"))\n\n        post_item_names = {\n            post_item.get(\"name\")\n            for post_item in post_items\n        }\n        post_item_names.discard(None)\n\n        for key in {\n            \"delete_confirm_value\",\n            \"delete_confirm_expected\",\n        } | post_item_names:\n            values.pop(key, None)\n\n        if values[\"action_type\"] == \"delete\":\n            submit_button_label = \"Delete\"\n            expected_value = \"delete\"\n        else:\n            submit_button_label = \"Archive\"\n            expected_value = \"archive\"\n\n        items = [\n            {\n                \"type\": \"label\",\n                \"value\": f\"# Please enter '{expected_value}' to confirm #\"\n            }\n        ]\n        if attempt &gt; 3:\n            additional_info = (\n                \"Read the instructions carefully please.\"\n                f\" You've failed {attempt - 1}\"\n                f\" times to enter '{expected_value}'.\"\n            )\n            if attempt &gt; 4:\n                additional_info += \"&lt;br/&gt;(Can I hear the grass grow?)\"\n            items.append({\n                \"type\": \"label\",\n                \"value\": additional_info\n            })\n\n        items.extend([\n            {\n                \"name\": \"delete_confirm_value\",\n                \"type\": \"text\",\n                \"value\": \"\",\n                \"empty_text\": f\"Type {expected_value} here...\",\n            },\n            {\n                \"type\": \"hidden\",\n                \"name\": \"delete_confirm_expected\",\n                \"value\": expected_value,\n            },\n            {\n                \"type\": \"hidden\",\n                \"name\": \"delete_attempt_count\",\n                \"value\": attempt,\n            },\n            {\n                \"type\": \"hidden\",\n                \"name\": \"post_items\",\n                \"value\": json.dumps(post_items),\n            }\n        ])\n        items.extend(self._event_values_to_hidden(values))\n        items.extend(post_items)\n\n        return {\n            \"items\": items,\n            \"title\": f\"Confirm {expected_value} action\",\n            \"submit_button_label\": submit_button_label,\n        }\n\n    def _filter_selection_from_event(self, entities, event):\n        \"\"\"\n\n        Args:\n            entities (list[ftrack_api.entity.base.Entity]): List of entities\n                selected in ftrack.\n            event (ftrack_api.event.base.Event): Event data.\n\n        Returns:\n            tuple[bool, set[str]]: Project is selected and set of selected\n                ftrack ids.\n        \"\"\"\n\n        project_in_selection = False\n        ftrack_ids = set()\n        selection = event[\"data\"].get(\"selection\")\n        if not selection:\n            return project_in_selection, ftrack_ids\n\n        for entity in selection:\n            entity_type = (entity.get(\"entityType\") or \"\").lower()\n            if entity_type == \"show\":\n                project_in_selection = True\n\n            elif entity_type == \"task\":\n                ftrack_id = entity.get(\"entityId\")\n                if ftrack_id:\n                    ftrack_ids.add(ftrack_id)\n\n        # Filter event even more (skip task entities)\n        # - task entities are not relevant for AYON delete\n        for entity in entities:\n            ftrack_id = entity[\"id\"]\n            if (\n                ftrack_id in ftrack_ids\n                and entity.entity_type.lower() == \"task\"\n            ):\n                ftrack_ids.discard(ftrack_id)\n\n        return project_in_selection, ftrack_ids\n\n    def _get_ayon_data_from_selection(self, session, entities, ftrack_ids):\n        \"\"\"Get folders from selection.\n\n        Args:\n            session (ftrack_api.Session): ftrack session processing event.\n            entities (list[ftrack_api.entity.base.Entity]): List of entities\n                selected in ftrack.\n            ftrack_ids (set[str]): Selected ftrack ids.\n\n        Returns:\n            AyonData: Folders data.\n        \"\"\"\n\n        filtered_entities = [\n            entity\n            for entity in entities\n            if entity[\"id\"] in ftrack_ids\n        ]\n\n        project = self.get_project_from_entity(entities[0], session)\n        project_name = project[\"full_name\"]\n\n        folder_entities = list(get_folders(\n            project_name,\n            fields={\"id\", \"path\", \"parentId\"}\n        ))\n        folders_by_id = {}\n        folders_by_path = {}\n        folders_by_parent_id = collections.defaultdict(list)\n        for folder_entity in folder_entities:\n            folders_by_id[folder_entity[\"id\"]] = folder_entity\n            folders_by_path[folder_entity[\"path\"]] = folder_entity\n            folders_by_parent_id[folder_entity[\"parentId\"]].append(\n                folder_entity\n            )\n\n        not_found_paths = set()\n        selected_folder_ids = set()\n        for entity in filtered_entities:\n            # TODO use slugify name\n            ent_path_items = [ent[\"name\"] for ent in entity[\"link\"]]\n            # Replace project name with empty string\n            ent_path_items[0] = \"\"\n            path = \"/\".join(ent_path_items)\n\n            folder_entity = folders_by_path.get(path)\n            if folder_entity:\n                selected_folder_ids.add(folder_entity[\"id\"])\n            else:\n                not_found_paths.add(path)\n\n        folder_ids_queue = collections.deque(selected_folder_ids)\n        folder_ids_to_delete = set()\n        while folder_ids_queue:\n            folder_id = folder_ids_queue.popleft()\n            folder_ids_to_delete.add(folder_id)\n            for folder_entity in folders_by_parent_id[folder_id]:\n                folder_ids_queue.append(folder_entity[\"id\"])\n\n        return AyonData(\n            project_name,\n            folders_by_id,\n            folders_by_path,\n            folders_by_parent_id,\n            not_found_paths,\n            selected_folder_ids,\n            folder_ids_to_delete,\n        )\n\n    def _interface_folders(self, session, entities, event, ftrack_ids):\n        \"\"\"Interface for folder entities.\n\n        Args:\n            session (ftrack_api.Session): ftrack session processing event.\n            entities (list[ftrack_api.entity.base.Entity]): List of entities\n                selected in ftrack.\n            event (ftrack_api.event.base.Event): Event data.\n            ftrack_ids (set[str]): Selected ftrack ids.\n\n        Returns:\n            dict[str, Any]: Interface data.\n        \"\"\"\n\n        ayon_data = self._get_ayon_data_from_selection(\n            session, entities, ftrack_ids\n        )\n        # TODO prepare main label\n        count = len(ayon_data.folder_ids_to_delete)\n        main_label = (\n            f\"You're going to delete {count} folders with all children from\"\n            f\" ftrack and AYON. &lt;b&gt;This action cannot be undone&lt;/b&gt;.\"\n        )\n        return self._prepare_delete_interface(\n            event,\n            [\n                {\"type\": \"label\", \"value\": \"---\"},\n                {\"type\": \"label\", \"value\": main_label},\n            ]\n        )\n\n    def _interface_products_selection(\n        self, session, entities, event, ftrack_ids\n    ):\n        \"\"\"\n\n        Args:\n            session (ftrack_api.Session): ftrack session processing event.\n            entities (list[ftrack_api.entity.base.Entity]): List of entities\n                selected in ftrack.\n            event (ftrack_api.event.base.Event): Event data.\n            ftrack_ids (set[str]): Selected ftrack ids.\n\n        Returns:\n            Union[dict[str, Any], None]: Interface data.\n        \"\"\"\n\n        ayon_data = self._get_ayon_data_from_selection(\n            session, entities, ftrack_ids\n        )\n        values = event[\"data\"][\"values\"]\n        if values[\"entity_type\"] == \"products_all\":\n            folder_ids = set(ayon_data.folder_ids_to_delete)\n        else:\n            folder_ids = set(ayon_data.selected_folder_ids)\n        products = get_products(\n            ayon_data.project_name,\n            folder_ids=folder_ids,\n            fields={\"name\"}\n        )\n        counts_by_product_name = {}\n        for product in products:\n            product_name = product[\"name\"]\n            counts_by_product_name.setdefault(product_name, 0)\n            counts_by_product_name[product_name] += 1\n\n        if not counts_by_product_name:\n            self.show_interface(\n                items=[{\n                    \"type\": \"label\",\n                    \"value\": \"No products found for selected entities.\"\n                }],\n                title=\"No products to delete found\",\n                submit_btn_label=\"Close\",\n                event=event,\n            )\n            return None\n\n        product_names = list(sorted(counts_by_product_name.keys()))\n        product_name_items = [\n            {\"label\": product_name, \"value\": product_name}\n            for product_name in product_names\n        ]\n        items = [\n            {\n                \"type\": \"label\",\n                \"value\": \"## Products to delete ##\",\n            },\n            {\n                \"type\": \"label\",\n                \"value\": \"Uncheck product names you want to keep.\",\n            },\n            {\n                \"type\": \"hidden\",\n                \"name\": \"counts_by_product_name\",\n                \"value\": json.dumps(counts_by_product_name),\n            },\n            {\n                \"type\": \"enumerator\",\n                \"multi_select\": True,\n                \"name\": \"product_names\",\n                \"data\": product_name_items,\n                \"value\": product_names\n            },\n        ]\n        items.extend(self._event_values_to_hidden(values))\n        return {\n            \"title\": \"Choose product names to delete\",\n            \"submit_button_label\": \"Confirm action\",\n            \"items\": items,\n        }\n\n    def _interface_products(self, session, entities, event, ftrack_ids):\n        \"\"\"Interface for product entities.\n\n        Args:\n            session (ftrack_api.Session): ftrack session processing event.\n            entities (list[ftrack_api.entity.base.Entity]): List of entities\n                selected in ftrack.\n            event (ftrack_api.event.base.Event): Event data.\n        \"\"\"\n\n        values = event[\"data\"][\"values\"]\n        # Ask which product names should be removed first\n        if \"counts_by_product_name\" not in values:\n            return self._interface_products_selection(\n                session, entities, event, ftrack_ids\n            )\n\n        counts_by_product_name = json.loads(values.pop(\n            \"counts_by_product_name\"\n        ))\n        product_names_to_delete = values.pop(\"product_names\")\n        if not product_names_to_delete:\n            return {\n                \"success\": True,\n                \"message\": \"Nothing was selected to delete\"\n            }\n\n        all_count = 0\n        for product_name in product_names_to_delete:\n            all_count += counts_by_product_name[product_name]\n\n        # TODO prepare main label\n        main_label = (\n            f\"You're going to delete {all_count} products with all versions\"\n            \" from ftrack and AYON. &lt;b&gt;This action cannot be undone&lt;/b&gt;.\"\n        )\n        return self._prepare_delete_interface(\n            event,\n            [\n                {\"type\": \"label\", \"value\": \"---\"},\n                {\"type\": \"label\", \"value\": main_label},\n                {\n                    \"type\": \"hidden\",\n                    \"name\": \"product_names\",\n                    \"value\": json.dumps(product_names_to_delete),\n                },\n            ]\n        )\n\n    def _first_interface(self, session, entities, event):\n        \"\"\"First interface asks for action type and entity type.\n\n        Action type is to choose if entities in AYON should be deactived\n            or deleted.\n        Entity type is to choose if user wants to work with folders\n            or products.\n\n        Args:\n            session (ftrack_api.Session): ftrack session processing event.\n            entities (list[ftrack_api.entity.base.Entity]): List of entities\n                selected in ftrack.\n            event (ftrack_api.event.base.Event): Event data.\n\n        Returns:\n            dict[str, Any]: Interface data.\n        \"\"\"\n\n        # Check if project exists in AYON\n        project = self.get_project_from_entity(entities[0], session)\n        project_name = project[\"full_name\"]\n        ayon_project = self.get_ayon_project_from_event(event, project_name)\n        if not ayon_project:\n            return {\n                \"success\": False,\n                \"message\": f\"Project '{project_name}' not found in AYON.\"\n            }\n\n        # Validate selection\n        project_selected, ftrack_ids = self._filter_selection_from_event(\n            entities, event\n        )\n        if not ftrack_ids:\n            return {\n                \"success\": False,\n                \"message\": \"Invalid selection for this action.\"\n            }\n\n        return {\n            \"title\": \"Choose action\",\n            \"submit_button_label\": \"Confirm action\",\n            \"items\": [\n                {\n                    \"type\": \"label\",\n                    \"value\": (\n                        \"This action will delete entities from ftrack\"\n                        \" and archive or delete them from AYON.\"\n                        \"&lt;br/&gt;&lt;br/&gt;NOTE: Does not remove files on disk.\"\n                    )\n                },\n                {\"type\": \"label\", \"value\": \"---\"},\n                {\n                    \"type\": \"enumerator\",\n                    \"name\": \"entity_type\",\n                    \"label\": \"Entity type:\",\n                    \"value\": \"folders\",\n                    \"data\": [\n                        {\n                            \"label\": \"Folders\",\n                            \"value\": \"folders\"\n                        },\n                        {\n                            \"label\": \"Products (Selected folders only)\",\n                            \"value\": \"products_selection\"\n                        },\n                        {\n                            \"label\": \"Products (Selected + children folders)\",\n                            \"value\": \"products_all\"\n                        },\n                    ]\n                },\n                {\n                    \"type\": \"enumerator\",\n                    \"name\": \"action_type\",\n                    \"label\": \"Action in AYON:\",\n                    \"value\": \"archive\",\n                    \"data\": [\n                        {\n                            \"label\": \"Archive\",\n                            \"value\": \"archive\"\n                        },\n                        {\n                            \"label\": \"Delete\",\n                            \"value\": \"delete\"\n                        }\n                    ]\n                },\n                {\"type\": \"label\", \"value\": \"---\"},\n                {\n                    \"type\": \"label\",\n                    \"value\": (\n                        \"- Option &lt;b&gt;'Archive in AYON'&lt;/b&gt; only hide\"\n                        \" selected entities in AYON UI without actually\"\n                        \" deleting them.\"\n                    )\n                },\n                {\n                    \"type\": \"label\",\n                    \"value\": (\n                        \"- Option &lt;b&gt;'Delete in AYON'&lt;/b&gt; will delete\"\n                        \" selected entities from AYON with all children.\"\n                        \"&lt;br/&gt;&lt;b&gt;WARNING: There is no way back.&lt;/b&gt;\"\n                    )\n                },\n            ],\n        }\n\n    def _query_ftrack_entities(self, session, ftrack_ids, fields=None):\n        \"\"\"Query ftrack hierarchy entities with all children.\n\n        Args:\n            session (ftrack_api.Session): ftrack session processing event.\n            ftrack_ids (set[str]): Selected ftrack ids.\n            fields (Optional[Iterable[str]]): Fields to query.\n\n        Returns:\n            list[ftrack_api.entity.base.Entity]: List of ftrack entities.\n        \"\"\"\n\n        if not fields:\n            fields = {\"id\", \"parent_id\", \"object_type_id\"}\n\n        joined_fields = \", \".join(fields)\n\n        joined_ids = self.join_query_keys(ftrack_ids)\n        all_entities = session.query(\n            f\"select {joined_fields} from TypedContext\"\n            f\" where id in ({joined_ids})\"\n        ).all()\n        ftrack_ids_queue = collections.deque()\n        ftrack_ids_queue.append(ftrack_ids)\n        while ftrack_ids_queue:\n            ftrack_ids = ftrack_ids_queue.popleft()\n            if not ftrack_ids:\n                continue\n\n            joined_ids = self.join_query_keys(ftrack_ids)\n            entities = session.query(\n                \"select id, parent_id, object_type_id from TypedContext\"\n                f\" where parent_id in ({joined_ids})\"\n            ).all()\n            all_entities.extend(entities)\n            new_ftrack_ids = {\n                entity[\"id\"]\n                for entity in entities\n                if entity.entity_type.lower() != \"task\"\n            }\n            ftrack_ids_queue.append(new_ftrack_ids)\n        return all_entities\n\n    def _archive_folders_in_ayon(self, ayon_data):\n        \"\"\"Archive folders in AYON.\n\n        Args:\n            ayon_data (AyonData): Folders data.\n        \"\"\"\n\n        operations = [\n            {\n                \"type\": \"update\",\n                \"entityType\": \"folder\",\n                \"entityId\": folder_id,\n                \"data\": {\n                    \"active\": False\n                }\n            }\n            for folder_id in ayon_data.selected_folder_ids\n        ]\n\n        self.log.debug(\"Archiving ({}) folders:\\n{}\".format(\n            len(ayon_data.selected_folder_ids),\n            \", \".join(ayon_data.selected_folder_ids),\n        ))\n        send_batch_operations(ayon_data.project_name, operations)\n\n    def _delete_folders_in_ayon(self, ayon_data):\n        \"\"\"Delete folders in AYON.\n\n        Args:\n            ayon_data (AyonData): Folders data.\n        \"\"\"\n\n        project_name = ayon_data.project_name\n        # First find all products and delete them.\n        #   Folders cannot be deleted if they contain products.\n        product_ids = {\n            product[\"id\"]\n            for product in get_products(\n                project_name,\n                folder_ids=ayon_data.folder_ids_to_delete,\n                fields={\"id\"},\n            )\n        }\n        self.log.debug(\"Deleting {} products\".format(len(product_ids)))\n        for chunk_ids in create_chunks(product_ids):\n            send_batch_operations(\n                project_name,\n                [\n                    {\n                        \"type\": \"delete\",\n                        \"entityType\": \"product\",\n                        \"entityId\": product_id,\n                    }\n                    for product_id in chunk_ids\n                ]\n            )\n\n        # Delete folders in correct order from bottom to top.\n        #   This is just to avoid errors AYON.\n        folder_ids_by_parent_id = collections.defaultdict(set)\n        parents_queue = collections.deque()\n        for folder_id in ayon_data.folder_ids_to_delete:\n            parents_queue.append(folder_id)\n            folder_entity = ayon_data.folders_by_id[folder_id]\n            folder_ids_by_parent_id[folder_entity[\"parentId\"]].add(folder_id)\n\n        sorted_folder_ids = []\n        while parents_queue:\n            folder_id = parents_queue.popleft()\n            if folder_ids_by_parent_id[folder_id]:\n                parents_queue.append(folder_id)\n                continue\n\n            sorted_folder_ids.append(folder_id)\n            folder_entity = ayon_data.folders_by_id[folder_id]\n            parent_id = folder_entity[\"parentId\"]\n            if parent_id in folder_ids_by_parent_id:\n                folder_ids_by_parent_id[parent_id].discard(folder_id)\n\n        self.log.debug(\"Deleting {} folders\".format(len(sorted_folder_ids)))\n        for chunk_ids in create_chunks(sorted_folder_ids):\n            send_batch_operations(\n                project_name,\n                [\n                    {\n                        \"type\": \"delete\",\n                        \"entityType\": \"folder\",\n                        \"entityId\": folder_id,\n                    }\n                    for folder_id in chunk_ids\n                ]\n            )\n\n    def _delete_folders(self, session, entities, event, ftrack_ids):\n        \"\"\"Delete folders in AYON and ftrack.\n\n        Args:\n            session (ftrack_api.Session): ftrack session processing event.\n            entities (list[ftrack_api.entity.base.Entity]): List of entities\n                selected in ftrack.\n            event (ftrack_api.event.base.Event): Event data.\n            ftrack_ids (set[str]): Selected ftrack ids.\n        \"\"\"\n\n        values = event[\"data\"][\"values\"]\n        ayon_data = self._get_ayon_data_from_selection(\n            session, entities, ftrack_ids\n        )\n        if values[\"action_type\"] == \"archive\":\n            message = \"Archiving folders finished.\"\n            self._archive_folders_in_ayon(ayon_data)\n        else:\n            message = \"Delete folders finished.\"\n            self._delete_folders_in_ayon(ayon_data)\n\n        entities = self._query_ftrack_entities(session, ftrack_ids)\n        task_entities = []\n        entities_by_id = {}\n        for entity in entities:\n            if entity.entity_type.lower() == \"task\":\n                task_entities.append(entity)\n            else:\n                entities_by_id[entity[\"id\"]] = entity\n\n        for task_entity in task_entities:\n            session.delete(task_entity)\n        session.commit()\n\n        entity_ids_by_parent_id = collections.defaultdict(set)\n        parents_queue = collections.deque()\n        for entity_id, entity in entities_by_id.items():\n            parents_queue.append(entity_id)\n            entity_ids_by_parent_id[entity[\"parent_id\"]].add(entity_id)\n\n        while parents_queue:\n            entity_id = parents_queue.popleft()\n            entity = entities_by_id[entity_id]\n            if entity_ids_by_parent_id[entity_id]:\n                parents_queue.append(entity_id)\n                continue\n            parent_id = entity[\"parent_id\"]\n\n            session.delete(entity)\n            session.commit()\n\n            if parent_id not in entity_ids_by_parent_id:\n                continue\n            entity_ids_by_parent_id[parent_id].discard(entity_id)\n\n        return {\n            \"success\": True,\n            \"message\": message\n        }\n\n    def _handle_products_in_ayon(\n        self, ayon_data, product_names, selection_only, archive\n    ):\n        \"\"\"Archive products in AYON.\n\n        Args:\n            ayon_data (AyonData): Folders data.\n            product_names (list[str]): List of product names to archive.\n            selection_only (bool): True if only selected folders should be\n                used.\n            archive (bool): True if products should be archived.\n        \"\"\"\n\n        if selection_only:\n            folder_ids = ayon_data.selected_folder_ids\n        else:\n            folder_ids = ayon_data.folder_ids_to_delete\n        product_ids = {\n            product[\"id\"]\n            for product in get_products(\n                ayon_data.project_name,\n                product_names=product_names,\n                folder_ids=folder_ids,\n                fields={\"id\"},\n            )\n        }\n        if archive:\n            base_operation = {\n                \"type\": \"update\",\n                \"entityType\": \"product\",\n                \"data\": {\"active\": False}\n            }\n        else:\n            base_operation = {\n                \"type\": \"delete\",\n                \"entityType\": \"product\",\n            }\n\n        for chunk_ids in create_chunks(product_ids):\n            operations = []\n            for product_id in chunk_ids:\n                operation = copy.deepcopy(base_operation)\n                operation[\"entityId\"] = product_id\n                operations.append(operation)\n\n            send_batch_operations(ayon_data.project_name, operations)\n\n    def _delete_products(self, session, entities, event, ftrack_ids):\n        \"\"\"Delete or archive products in AYON and ftrack.\n\n        Args:\n            session (ftrack_api.Session): ftrack session processing event.\n            entities (list[ftrack_api.entity.base.Entity]): List of entities\n                selected in ftrack.\n            event (ftrack_api.event.base.Event): Event data.\n            ftrack_ids (set[str]): Selected ftrack ids.\n        \"\"\"\n\n        values = event[\"data\"][\"values\"]\n        product_names = json.loads(values[\"product_names\"])\n        ayon_data = self._get_ayon_data_from_selection(\n            session, entities, ftrack_ids\n        )\n        selection_only = values[\"entity_type\"] == \"products_selection\"\n        archive = values[\"action_type\"] == \"archive\"\n\n        if archive:\n            message = \"Archiving products finished.\"\n        else:\n            message = \"Delete products finished.\"\n\n        self._handle_products_in_ayon(\n            ayon_data, product_names, selection_only, archive\n        )\n\n        ftrack_entities = self._query_ftrack_entities(\n            session, ftrack_ids, {\"id\"}\n        )\n        all_ftrack_ids = {\n            entity[\"id\"]\n            for entity in ftrack_entities\n        }\n        # Delete assets in ftrack - that should automatically delete all\n        #   their asset versions\n        for chunk in create_chunks(all_ftrack_ids):\n            joined_ids = self.join_query_keys(chunk)\n            for asset in session.query(\n                \"select id, name from Asset\"\n                f\" where context_id in ({joined_ids})\"\n            ).all():\n                # NOTE: Asset name may also contain representation name\n                #   '{product[name]}_{representation}', not sure if we should\n                #   try to resolve that here?\n                if asset[\"name\"] in product_names:\n                    session.delete(asset)\n            session.commit()\n\n        return {\n            \"success\": True,\n            \"message\": message\n        }\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_delete_entities.html#services.processor.processor.default_handlers.action_delete_entities.DeleteEntitiesAction.discover","title":"<code>discover(session, entities, event)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>ftrack session processing event.</p> required <code>entities</code> <code>list[Entity]</code> <p>List of entities selected in ftrack.</p> required <code>event</code> <code>Event</code> <p>Event data.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if action is valid for given selection.</p> Source code in <code>services/processor/processor/default_handlers/action_delete_entities.py</code> <pre><code>def discover(self, session, entities, event):\n    \"\"\"\n\n    Args:\n        session (ftrack_api.Session): ftrack session processing event.\n        entities (list[ftrack_api.entity.base.Entity]): List of entities\n            selected in ftrack.\n        event (ftrack_api.event.base.Event): Event data.\n\n    Returns:\n        bool: True if action is valid for given selection.\n    \"\"\"\n\n    task_ids = set()\n    for ent_info in event[\"data\"][\"selection\"]:\n        if ent_info.get(\"entityType\") == \"task\":\n            task_ids.add(ent_info[\"entityId\"])\n\n    is_valid = False\n    for entity in entities:\n        if (\n            entity[\"id\"] in task_ids\n            and entity.entity_type.lower() != \"task\"\n        ):\n            is_valid = True\n            break\n\n    if not is_valid:\n        return False\n    return self.valid_roles(session, entities, event)\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_multiple_notes.html","title":"action_multiple_notes","text":""},{"location":"autoapi/services/processor/processor/default_handlers/action_multiple_notes.html#services.processor.processor.default_handlers.action_multiple_notes.MultipleNotesServer","title":"<code>MultipleNotesServer</code>","text":"<p>               Bases: <code>ServerAction</code></p> <p>Action adds same note for muliple AssetVersions.</p> <p>Note is added to selection of AssetVersions. Note is created with user who triggered the action. It is possible to define note category of note.</p> Source code in <code>services/processor/processor/default_handlers/action_multiple_notes.py</code> <pre><code>class MultipleNotesServer(ServerAction):\n    \"\"\"Action adds same note for muliple AssetVersions.\n\n    Note is added to selection of AssetVersions. Note is created with user\n    who triggered the action. It is possible to define note category of note.\n    \"\"\"\n\n    identifier = \"ayon.multiple.notes.server\"\n    label = \"Multiple Notes (Server - AYON)\"\n    description = \"Add same note to multiple Asset Versions\"\n\n    _none_category = \"__NONE__\"\n\n    def discover(self, session, entities, event):\n        \"\"\"Show action only on AssetVersions.\"\"\"\n        if not entities:\n            return False\n\n        for entity in entities:\n            if entity.entity_type.lower() != \"assetversion\":\n                return False\n        return True\n\n    def interface(self, session, entities, event):\n        event_source = event[\"source\"]\n        user_info = event_source.get(\"user\") or {}\n        user_id = user_info.get(\"id\")\n        if not user_id:\n            return None\n\n        values = event[\"data\"].get(\"values\")\n        if values:\n            return None\n\n        note_label = {\n            \"type\": \"label\",\n            \"value\": \"# Enter note: #\"\n        }\n\n        note_value = {\n            \"name\": \"note\",\n            \"type\": \"textarea\"\n        }\n\n        category_label = {\n            \"type\": \"label\",\n            \"value\": \"## Category: ##\"\n        }\n\n        category_data = []\n        category_data.append({\n            \"label\": \"- None -\",\n            \"value\": self._none_category\n        })\n        all_categories = session.query(\n            \"select id, name from NoteCategory\"\n        ).all()\n        for cat in all_categories:\n            category_data.append({\n                \"label\": cat[\"name\"],\n                \"value\": cat[\"id\"]\n            })\n        category_value = {\n            \"type\": \"enumerator\",\n            \"name\": \"category\",\n            \"data\": category_data,\n            \"value\": self._none_category\n        }\n\n        splitter = {\n            \"type\": \"label\",\n            \"value\": \"---\"\n        }\n\n        return [\n            note_label,\n            note_value,\n            splitter,\n            category_label,\n            category_value\n        ]\n\n    def launch(self, session, entities, event):\n        if \"values\" not in event[\"data\"]:\n            return None\n\n        values = event[\"data\"][\"values\"]\n        if len(values) &lt;= 0 or \"note\" not in values:\n            return False\n\n        # Get Note text\n        note_value = values[\"note\"]\n        if note_value.lower().strip() == \"\":\n            return {\n                \"success\": True,\n                \"message\": \"Note was not entered. Skipping\"\n            }\n\n        # Get User\n        event_source = event[\"source\"]\n        user_info = event_source.get(\"user\") or {}\n        user_id = user_info.get(\"id\")\n        user = None\n        if user_id:\n            user = session.query(\n                'User where id is \"{}\"'.format(user_id)\n            ).first()\n\n        if not user:\n            return {\n                \"success\": False,\n                \"message\": \"Couldn't get user information.\"\n            }\n\n        # Logging message preparation\n        # - username\n        username = user.get(\"username\") or \"N/A\"\n\n        # - AssetVersion ids\n        asset_version_ids_str = \",\".join([entity[\"id\"] for entity in entities])\n\n        # Base note data\n        note_data = {\n            \"content\": note_value,\n            \"author\": user\n        }\n\n        # Get category\n        category_id = values[\"category\"]\n        if category_id == self._none_category:\n            category_id = None\n\n        category_name = None\n        if category_id is not None:\n            category = session.query(\n                \"select id, name from NoteCategory where id is \\\"{}\\\"\".format(\n                    category_id\n                )\n            ).first()\n            if category:\n                note_data[\"category\"] = category\n                category_name = category[\"name\"]\n\n        category_msg = \"\"\n        if category_name:\n            category_msg = \" with category: \\\"{}\\\"\".format(category_name)\n\n        self.log.warning((\n            \"Creating note{} as User \\\"{}\\\" on \"\n            \"AssetVersions: {} with value \\\"{}\\\"\"\n        ).format(category_msg, username, asset_version_ids_str, note_value))\n\n        # Create notes for entities\n        for entity in entities:\n            new_note = session.create(\"Note\", note_data)\n            entity[\"notes\"].append(new_note)\n            session.commit()\n        return True\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_multiple_notes.html#services.processor.processor.default_handlers.action_multiple_notes.MultipleNotesServer.discover","title":"<code>discover(session, entities, event)</code>","text":"<p>Show action only on AssetVersions.</p> Source code in <code>services/processor/processor/default_handlers/action_multiple_notes.py</code> <pre><code>def discover(self, session, entities, event):\n    \"\"\"Show action only on AssetVersions.\"\"\"\n    if not entities:\n        return False\n\n    for entity in entities:\n        if entity.entity_type.lower() != \"assetversion\":\n            return False\n    return True\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_prepare_project.html","title":"action_prepare_project","text":""},{"location":"autoapi/services/processor/processor/default_handlers/action_prepare_project.html#services.processor.processor.default_handlers.action_prepare_project.PrepareProjectServer","title":"<code>PrepareProjectServer</code>","text":"<p>               Bases: <code>ServerAction</code></p> <p>Prepare project attributes in Anatomy.</p> Source code in <code>services/processor/processor/default_handlers/action_prepare_project.py</code> <pre><code>class PrepareProjectServer(ServerAction):\n    \"\"\"Prepare project attributes in Anatomy.\"\"\"\n\n    default_preset_name = \"__default__\"\n    identifier = \"ayon.prepare.project.server\"\n    label = \"AYON Admin\"\n    variant = \"- Prepare Project for AYON\"\n    description = \"Set basic attributes on the project\"\n    icon = get_service_ftrack_icon_url(\"AYONAdmin.svg\")\n\n    role_list = [\"Administrator\", \"Project Manager\"]\n\n    settings_key = \"prepare_project\"\n\n    item_splitter = {\"type\": \"label\", \"value\": \"---\"}\n\n    def discover(self, session, entities, event):\n        \"\"\"Show only on project.\"\"\"\n        if (\n            len(entities) != 1\n            or entities[0].entity_type.lower() != \"project\"\n        ):\n            return False\n\n        return self.valid_roles(session, entities, event)\n\n    def _get_list_items(self, attr_name, attr_def, default):\n        default = default or []\n        title = attr_def[\"title\"] or attr_name\n        output = [\n            {\n                \"type\": \"label\",\n                \"value\": \"---\"\n            },\n            {\n                \"type\": \"label\",\n                \"value\": f\"Attribute '{title}' selection:\"\n            }\n        ]\n        mapping = {}\n        for item in attr_def[\"enum\"]:\n            value = item[\"value\"]\n            name = uuid.uuid4().hex\n            mapping[name] = value\n            output.append({\n                \"type\": \"boolean\",\n                \"label\": item[\"label\"],\n                \"name\": name,\n                \"value\": value in default\n            })\n        output.append({\n            \"type\": \"hidden\",\n            \"value\": json.dumps(mapping),\n            \"name\": f\"attr_list_{attr_name}\"\n        })\n        return output\n\n    def _get_autosync_value(self, session, project_entity):\n        auto_sync_attr = session.query(\n            \"select id\"\n            \" from CustomAttributeConfiguration\"\n            f\" where key is '{CUST_ATTR_AUTO_SYNC}'\"\n        ).first()\n        if auto_sync_attr is None:\n            return None\n\n        project_id = project_entity[\"id\"]\n        attr_id = auto_sync_attr[\"id\"]\n        value_items = query_custom_attribute_values(\n            session, [attr_id], [project_id]\n        )\n        for item in value_items:\n            value = item[\"value\"]\n            if value is not None:\n                return value\n        return True\n\n    def _first_interface(self, session, project_entity):\n        # Inform user that this may take a while\n        self.log.debug(\"Preparing data which will be shown\")\n\n        primary_preset = self.default_preset_name\n        anatomy_presets = [\n            {\"label\": \"Default\", \"value\": self.default_preset_name}\n        ]\n        for anatomy_preset in ayon_api.get_project_anatomy_presets():\n            name = anatomy_preset[\"name\"]\n            anatomy_presets.append({\"label\": name, \"value\": name})\n            if anatomy_preset[\"primary\"]:\n                primary_preset = name\n\n        ayon_autosync_value = self._get_autosync_value(\n            session, project_entity)\n        items = [\n            {\n                \"type\": \"hidden\",\n                \"name\": \"in_attribute_set\",\n                \"value\": False\n            },\n            {\n                \"type\": \"label\",\n                \"value\": \"### Choose Anatomy Preset\"\n            },\n            {\n                \"label\": \"AYON Anatomy Preset\",\n                \"type\": \"enumerator\",\n                \"name\": \"anatomy_preset\",\n                \"data\": anatomy_presets,\n                \"value\": primary_preset\n            }\n        ]\n        if ayon_autosync_value is not None:\n            items.append({\n                \"label\": \"Enable auto-sync\",\n                \"type\": \"boolean\",\n                \"name\": \"auto_sync_project\",\n                \"value\": ayon_autosync_value\n            })\n        else:\n            items.append({\n                \"type\": \"hidden\",\n                \"name\": \"auto_sync_project\",\n                \"value\": False\n            })\n\n        return {\n            \"title\": \"Choose AYON Anatomy Preset\",\n            \"submit_button_label\": \"Continue\",\n            \"items\": items\n        }\n\n    def _attributes_interface(self, event_values):\n        anatomy_preset = event_values[\"anatomy_preset\"]\n        attribute_items = [\n            {\n                \"type\": \"hidden\",\n                \"name\": \"in_attribute_set\",\n                \"value\": True\n            },\n            {\n                \"type\": \"hidden\",\n                \"name\": \"anatomy_preset\",\n                \"value\": anatomy_preset\n            },\n            {\n                \"type\": \"hidden\",\n                \"name\": \"auto_sync_project\",\n                \"value\": event_values[\"auto_sync_project\"]\n            },\n            {\n                \"type\": \"label\",\n                \"value\": (\n                    \"&lt;b&gt;You can validate or change your default\"\n                    \" project attributes.&lt;/b&gt;\"\n                )\n            }\n        ]\n        if anatomy_preset == self.default_preset_name:\n            anatomy_preset = None\n        anatomy_preset_values = ayon_api.get_project_anatomy_preset(\n            anatomy_preset)\n        anatomy_attribute_values = anatomy_preset_values[\"attributes\"]\n        project_attributes = ayon_api.get_attributes_for_type(\"project\")\n        unknown_attributes = []\n        list_attr_defs = []\n        for attr_name, attr_def in project_attributes.items():\n            if attr_name in (\n                FTRACK_ID_ATTRIB,\n                FTRACK_PATH_ATTRIB,\n                \"startDate\",\n                \"endDate\",\n                \"description\",\n            ):\n                continue\n            attr_type = attr_def[\"type\"]\n            default = anatomy_attribute_values.get(attr_name)\n            if default is None:\n                default = attr_def[\"default\"]\n\n            # Not sure how to show this\n            if attr_type == \"list_of_integers\":\n                continue\n\n            # List of strings is handled differently\n            if attr_type == \"list_of_strings\":\n                list_attr_defs.append((attr_name, attr_def, default))\n                continue\n\n            item_base = {\n                \"name\": f\"attr_{attr_name}\",\n                \"label\": attr_def[\"title\"] or attr_name,\n                \"value\": default\n            }\n            if attr_type in (\"float\", \"integer\",):\n                item_base[\"type\"] = \"number\"\n\n            elif attr_type == \"datetime\":\n                item_base[\"type\"] = \"date\"\n\n            elif attr_type == \"boolean\":\n                item_base[\"type\"] = \"boolean\"\n\n            elif attr_type == \"string\":\n                item_base[\"type\"] = \"text\"\n\n            elif attr_type in (\"list_of_strings\", \"list_of_integers\"):\n                item_base[\"type\"] = \"enumerator\"\n                item_base[\"data\"] = attr_def[\"enum\"]\n\n            else:\n                unknown_attributes.append({\n                    \"type\": \"label\",\n                    \"value\": f\"{attr_name}: {attr_type}\"\n                })\n                self.log.info(\"Unknown attribute type: {}\".format(attr_type))\n                continue\n            attribute_items.append(item_base)\n\n        for item in list_attr_defs:\n            attribute_items.extend(self._get_list_items(*item))\n\n        if unknown_attributes:\n            attribute_items.append(\n                {\"type\": \"label\", \"value\": \"Unknown types\"}\n            )\n            attribute_items.extend(unknown_attributes)\n\n        return {\n            \"title\": \"Default project attributes\",\n            \"submit_button_label\": \"Confirm\",\n            \"items\": attribute_items\n        }\n\n    def interface(self, session, entities, event):\n        event_values = event[\"data\"].get(\"values\")\n\n        project_entity = entities[0]\n        result = self._slugify_name_handling(session, event, project_entity)\n        if result is not None:\n            return result\n\n        # Check if project already exists\n        # TODO maybe this should be handled with slugify? Give option to\n        #   change name/code.\n        project_codes = set()\n        project_names = set()\n        for project in ayon_api.get_projects(fields={\"name\", \"code\"}):\n            project_codes.add(project[\"code\"])\n            project_names.add(project[\"name\"])\n\n        project_name = project_entity[\"full_name\"]\n        project_code = project_entity[\"name\"]\n        exists_error = None\n        if project_name in project_names:\n            exists_error = f\"name '{project_name}'\"\n        elif project_code in project_codes:\n            exists_error = f\"code '{project_code}'\"\n\n        if exists_error:\n            return {\n                \"message\": f\"Project {exists_error} already exists in AYON.\",\n                \"success\": True\n            }\n\n        self.show_message(event, \"Preparing data... Please wait\", True)\n        if not event_values or \"in_attribute_set\" not in event_values:\n            return self._first_interface(session, project_entity)\n\n        # Exit interface once attributes are confirmed\n        if event_values[\"in_attribute_set\"]:\n            return\n\n        # User did not want to modify default attributes\n        return self._attributes_interface(event_values)\n\n    def _rename_project_handling(self, session, event, project_entity):\n        \"\"\"\n\n        Args:\n            session (ftrack_api.Session): ftrack session.\n            event (ftrack_api.event.base.Event): Event entity.\n            project_entity (ftrack_api.entity.base.Entity): Project entity.\n\n        Returns:\n            Union[None, Dict[str, Any]]: None if both name and code are valid,\n                otherwise returns interface items or ending messages.\n        \"\"\"\n\n        event_values = event[\"data\"].get(\"values\") or {}\n        action = event_values.get(\"invalid_name_action\")\n        if action is None or action == \"skip_prep\":\n            return {\n                \"success\": False,\n                \"message\": \"Project was &lt;b&gt;not&lt;/b&gt; prepared in AYON.\"\n            }\n\n        new_name = event_values.get(\"new_project_name\")\n        new_slugified_name = None\n        if new_name is not None:\n            new_slugified_name = ayon_api.slugify_string(new_name)\n\n        new_code = event_values.get(\"new_project_code\")\n        new_slugified_code = None\n        if new_code is not None:\n            new_slugified_code = ayon_api.slugify_string(new_code)\n\n        name_is_valid = new_slugified_name == new_name\n        code_is_valid = new_slugified_code == new_code\n        if not name_is_valid or not code_is_valid:\n            return self._get_rename_project_items(\n                project_entity,\n                new_slugified_name,\n                new_slugified_code,\n                new_name,\n                new_code,\n            )\n\n        if new_slugified_name is not None:\n            project_entity[\"full_name\"] = new_slugified_name\n        if new_slugified_code is not None:\n            project_entity[\"name\"] = new_slugified_code\n        session.commit()\n        return None\n\n    def _slugify_name_handling(self, session, event, project_entity):\n        \"\"\"\n\n        Args:\n            session (ftrack_api.Session): ftrack session.\n            event (ftrack_api.event.base.Event): Event entity.\n            project_entity (ftrack_api.entity.base.Entity): Project entity.\n\n        Returns:\n            Union[None, Dict[str, Any]]: None if both name and code are valid,\n                otherwise returns interface items or ending messages.\n        \"\"\"\n\n        # TODO validate project code too\n        project_name = project_entity[\"full_name\"]\n        project_code = project_entity[\"name\"]\n        slugified_name = ayon_api.slugify_string(project_name)\n        slugified_code = ayon_api.slugify_string(project_code)\n\n        if slugified_name == project_name:\n            slugified_name = None\n\n        if slugified_code == project_code:\n            slugified_code = None\n\n        # Both name and code are valid\n        if (\n            slugified_name is None\n            and slugified_code is None\n        ):\n            return None\n\n        # Validate user inputs\n        if event[\"data\"].get(\"values\"):\n            return self._rename_project_handling(\n                session, event, project_entity\n            )\n\n        # Show interface to user\n        return self._get_rename_project_items(\n            project_entity,\n            slugified_name,\n            slugified_code,\n        )\n\n    def _get_rename_project_items(\n        self,\n        project_entity,\n        new_name_hint,\n        new_code_hint,\n        new_name=None,\n        new_code=None,\n    ):\n        \"\"\"\n\n        Args:\n            project_entity (ftrack_api.entity.base.Entity): Project entity.\n            new_name_hint (Union[None, str]): New name hint. Slugified current\n                name to valid value. Or None if name is valid.\n            new_code_hint (Union[None, str]): New code hint. Slugified current\n                name to valid value. Or None if code is valid.\n            new_name (Optional[str]): New name entered by user.\n            new_code (Optional[str]): New code entered by user.\n\n        Returns:\n            dict[str, Any]: Interface items.\n        \"\"\"\n\n        project_name = project_entity[\"full_name\"]\n        project_code = project_entity[\"name\"]\n        invalid_keys = []\n        if new_name_hint is not None:\n            invalid_keys.append(\"name\")\n        if new_code_hint is not None:\n            invalid_keys.append(\"code\")\n        invalid_keys_s = \" and \".join(invalid_keys)\n        ending = \"s\" if len(invalid_keys) &gt; 1 else \"\"\n        repeated = new_name is not None or new_code is not None\n\n        intro_message = (\n            f\"Project {invalid_keys_s} contain{ending} invalid\"\n            \" characters. Only alphanumeric characters and underscore\"\n            \" are allowed (a-Z0-9_).\"\n            f\"&lt;br/&gt;&lt;br/&gt;- Project name: {project_name}\"\n            f\"&lt;br/&gt;- Project code: {project_code}\"\n        )\n        if repeated:\n            intro_message = (\n                \"Entered values are &lt;b&gt;not valid&lt;/b&gt;.&lt;br/&gt;&lt;br/&gt;\"\n            ) + intro_message\n\n        items = [\n            {\n                \"type\": \"label\",\n                \"value\": \"# Introduction\",\n            },\n            {\n                \"type\": \"label\",\n                \"value\": intro_message,\n            },\n            {\"type\": \"label\", \"value\": \"---\"},\n            {\n                \"type\": \"label\",\n                \"value\": \"# Choose action\",\n            },\n            {\n                \"type\": \"enumerator\",\n                \"label\": \"Action\",\n                \"name\": \"invalid_name_action\",\n                \"value\": \"rename\" if repeated else \"skip_prep\",\n                \"data\": [\n                    {\n                        \"label\": \"Skip project preparation\",\n                        \"value\": \"skip_prep\",\n                    },\n                    {\n                        \"label\": \"Rename project\",\n                        \"value\": \"rename\",\n                    },\n                ],\n            },\n            {\"type\": \"label\", \"value\": \"---\"},\n            {\n                \"type\": \"label\",\n                \"value\": \"# Rename\",\n            },\n            {\n                \"type\": \"label\",\n                \"value\": (\n                    \"Ignore if \\\"&lt;b&gt;Skip project preparation&lt;/b&gt;\\\" is\"\n                    \" selected.\"\n                ),\n            }\n        ]\n\n        if new_name_hint is not None:\n            label = \"New project name\"\n            if new_name_hint == new_name:\n                label += \" (valid)\"\n            elif new_name is not None:\n                label += \" (invalid)\"\n            items.extend([\n                {\"type\": \"label\", \"value\": \"---\"},\n                {\"type\": \"label\", \"value\": label},\n                {\n                    \"type\": \"text\",\n                    \"name\": \"new_project_name\",\n                    \"value\": new_name_hint,\n                }\n            ])\n\n        if new_code_hint is not None:\n            label = \"New project code\"\n            if new_code_hint == new_code:\n                label += \" (valid)\"\n            elif new_code is not None:\n                label += \" (invalid)\"\n\n            items.extend([\n                {\"type\": \"label\", \"value\": \"---\"},\n                {\"type\": \"label\", \"value\": label},\n                {\n                    \"type\": \"text\",\n                    \"name\": \"new_project_code\",\n                    \"value\": new_code_hint,\n                }\n            ])\n        items.append({\n            \"type\": \"label\",\n            \"value\": (\n                \"&lt;br/&gt;&lt;b&gt;WARNING&lt;/b&gt;: Rename action will change the\"\n                \" project values in ftrack.\"\n            ),\n        })\n\n        return {\n            \"title\": f\"Invalid project {invalid_keys_s}\",\n            \"submit_button_label\": \"Confirm\",\n            \"items\": items,\n        }\n\n    def _convert_value_for_attr_conf(\n        self, value, attr_conf, attr_type_names_by_id\n    ):\n        # TODO validate all value types\n        if not isinstance(value, list):\n            return value\n\n        attr_name = attr_conf[\"key\"]\n        attr_type_name = attr_type_names_by_id[attr_conf[\"type_id\"]]\n        attr_config = json.loads(attr_conf[\"config\"])\n        # Skip if value is not multiselection enumerator\n        if (\n            attr_type_name != \"enumerator\"\n            or attr_config[\"multiSelect\"] is False\n        ):\n            self.log.info(\n                f\"Skipped attribute '{attr_name}' because value\"\n                f\" type (list) does not match\"\n                f\" ftrack attribute type ({attr_type_name}).\"\n            )\n            return None\n\n        attr_config_data = attr_config[\"data\"]\n        if isinstance(attr_config_data, str):\n            attr_config_data = json.loads(attr_config_data)\n\n        available_values = {\n            item[\"value\"]\n            for item in attr_config_data\n        }\n        new_value = [\n            item\n            for item in value\n            if item in available_values\n        ]\n        value_diff = set(value) - set(new_value)\n        if value_diff:\n            joined_values = \", \".join({f'\"{item}\"'for item in value_diff})\n            self.log.info(\n                f\"Skipped invalid '{attr_name}' enumerator\"\n                f\" values {joined_values}.\"\n            )\n        return new_value\n\n    def _set_ftrack_attributes(\n        self, session, project_entity, values\n    ):\n        attr_confs = get_all_attr_configs(session)\n        auto_sync_attr = next(\n            (\n                attr\n                for attr in attr_confs\n                if attr[\"key\"] == CUST_ATTR_AUTO_SYNC\n            ),\n            None\n        )\n        ftrack_settings = ayon_api.get_addons_settings()[\"ftrack\"]\n        attrs_mapping = get_custom_attributes_mapping(\n            session,\n            ftrack_settings,\n            attr_confs,\n        )\n        project_attrs = []\n        hier_custom_attrs = []\n        for attr_conf in attr_confs:\n            if attr_conf[\"is_hierarchical\"]:\n                hier_custom_attrs.append(attr_conf)\n            elif attr_conf[\"entity_type\"] == \"show\":\n                project_attrs.append(attr_conf)\n\n        attr_ids = {attr[\"id\"] for attr in attr_confs}\n        value_items = query_custom_attribute_values(\n            session, attr_ids, [project_entity[\"id\"]]\n        )\n        values_by_attr_id = {}\n        for value_item in value_items:\n            value = value_item[\"value\"]\n            attr_id = value_item[\"configuration_id\"]\n            values_by_attr_id[attr_id] = value\n\n        attr_type_names_by_id = {\n            attr_type[\"id\"]: attr_type[\"name\"]\n            for attr_type in session.query(\n                \"select id, name from CustomAttributeType\"\n            ).all()\n        }\n        for attr_name, attr_value in values.items():\n            if attr_name == CUST_ATTR_AUTO_SYNC:\n                attr = auto_sync_attr\n            else:\n                mapping_item = attrs_mapping.get(attr_name)\n                if mapping_item is None:\n                    continue\n                attr = mapping_item.get_attr_conf_for_entity(project_entity)\n\n            if attr is None:\n                continue\n            attr_value = self._convert_value_for_attr_conf(\n                attr_value, attr, attr_type_names_by_id\n            )\n            if attr_value is None:\n                continue\n\n            attr_id = attr[\"id\"]\n            is_new = attr_id not in values_by_attr_id\n            current_value = values_by_attr_id.get(attr_id)\n\n            entity_key = collections.OrderedDict((\n                (\"configuration_id\", attr_id),\n                (\"entity_id\", project_entity[\"id\"])\n            ))\n            op = None\n            if is_new:\n                op = ftrack_api.operation.CreateEntityOperation(\n                    \"CustomAttributeValue\",\n                    entity_key,\n                    {\"value\": attr_value}\n                )\n\n            elif current_value != attr_value:\n                op = ftrack_api.operation.UpdateEntityOperation(\n                    \"CustomAttributeValue\",\n                    entity_key,\n                    \"value\",\n                    current_value,\n                    attr_value\n                )\n\n            if op is not None:\n                session.recorded_operations.push(op)\n\n        if session.recorded_operations:\n            session.commit()\n\n    def launch(self, session, entities, event):\n        event_values = event[\"data\"].get(\"values\")\n        if not event_values:\n            return\n\n        project_entity = entities[0]\n        project_name = project_entity[\"full_name\"]\n        syncer = SyncFromFtrack(session, project_name, self.log)\n        # TODO validate project code too\n        if syncer.project_exists_in_ayon():\n            return {\n                \"message\": \"Project already exists in AYON.\",\n                \"success\": True\n            }\n\n        if not syncer.ensure_mandatory_custom_attributes_exists(session):\n            report_items = syncer.report_items\n            if report_items:\n                self.show_interface(\n                    report_items,\n                    title=\"Prepare Project report\",\n                    event=event\n                )\n            msg = (\n                \"Failed to create AYON mandatory custom attributes\"\n                \" in ftrack.\"\n            )\n            self.log.info(msg)\n            return {\n                \"success\": False,\n                \"message\": msg,\n            }\n\n        attributes = {}\n        list_mapping = {}\n        for key, value in event_values.items():\n            if key.startswith(\"attr_list_\"):\n                attr_name = key[10:]\n                list_mapping[attr_name] = json.loads(value)\n            elif key.startswith(\"attr_\"):\n                attributes[key[5:]] = value\n\n        for attr_name, mapping in list_mapping.items():\n            final_value = []\n            for item_id, value in mapping.items():\n                item_value = event_values[item_id]\n                if item_value:\n                    final_value.append(value)\n\n            attributes[attr_name] = final_value\n\n        anatomy_preset = event_values[\"anatomy_preset\"]\n        if anatomy_preset == self.default_preset_name:\n            anatomy_preset = None\n\n        ayon_users_to_clean_roles = self.get_ayon_users_to_clean_roles(\n            session, project_entity\n        )\n\n        syncer.create_project(anatomy_preset, attributes)\n\n        for ayon_username in ayon_users_to_clean_roles:\n            user = ayon_api.get_user(ayon_username)\n            user_data = user[\"data\"]\n            user_access_groups = user_data.setdefault(\"accessGroups\", {})\n            user_access_groups[project_name] = []\n            ayon_api.patch(f\"users/{ayon_username}\", data=user_data)\n\n        ayon_project = ayon_api.get_project(project_entity[\"full_name\"])\n        values = copy.deepcopy(ayon_project[\"attrib\"])\n        auto_sync_project = event_values[\"auto_sync_project\"]\n        values[CUST_ATTR_AUTO_SYNC] = auto_sync_project\n        self._set_ftrack_attributes(\n            session, project_entity, values\n        )\n\n        if not auto_sync_project:\n            event_data = {\n                \"actionIdentifier\": \"sync.from.ftrack.to.ayon\",\n                \"selection\": [{\n                    \"entityId\": project_entity[\"id\"],\n                    \"entityType\": \"show\"\n                }]\n            }\n            user = session.query(\n                f\"User where username is \\\"{session.api_user}\\\"\"\n            ).one()\n            user_data = {\n                \"username\": user[\"username\"],\n                \"id\": user[\"id\"]\n            }\n            self.trigger_event(\n                \"ftrack.action.launch\",\n                event_data=event_data,\n                session=session,\n                source=user_data,\n                event=event,\n                on_error=\"ignore\"\n            )\n\n        report_items = syncer.report_items\n        if report_items:\n            self.show_interface(\n                report_items,\n                title=\"Prepare Project report\",\n                event=event\n            )\n        self.log.info(f\"Project '{project_name}' prepared\")\n        return {\n            \"message\": \"Project created in AYON.\",\n            \"success\": True\n        }\n\n    def get_ayon_users_to_clean_roles(\n        self, session, project_entity\n    ):\n        \"\"\"Get AYON usernames that should have removed roles from a project.\n\n        If project is private in ftrack we do remove roles from AYON users if\n        they should not see it.\n\n        Args:\n            session (ftrack_api.Session): ftrack session.\n            project_entity (ftrack_api.entity.base.Entity): Project entity.\n\n        \"\"\"\n        if not project_entity[\"is_private\"]:\n            return []\n\n        ayon_users = [\n            ayon_user\n            for ayon_user in ayon_api.get_users()\n            if (\n                not ayon_user[\"isAdmin\"]\n                and not ayon_user[\"isManager\"]\n                and not ayon_user[\"isService\"]\n            )\n        ]\n        ayon_usernames = [\n            ayon_user[\"name\"]\n            for ayon_user in ayon_users\n        ]\n\n        project_id = project_entity[\"id\"]\n        role_ids = [\n            role[\"user_security_role_id\"]\n            for role in session.query(\n                \"select user_security_role_id\"\n                \" from UserSecurityRoleProject\"\n                f\" where project_id is '{project_id}'\"\n            ).all()\n        ]\n        if not role_ids:\n            return ayon_usernames\n        joined_role_ids = self.join_filter_values(role_ids)\n        user_ids = {\n            role[\"user_id\"]\n            for role in session.query(\n                \"select user_id\"\n                \" from UserSecurityRole\"\n                f\" where security_role_id in ({joined_role_ids})\"\n            ).all()\n        }\n        ftrack_users = []\n        if user_ids:\n            joined_user_ids = self.join_filter_values(user_ids)\n            ftrack_users = session.query(\n                \"select id, username, email from User\"\n                f\" where id in ({joined_user_ids})\"\n            ).all()\n        users_mapping = map_ftrack_users_to_ayon_users(\n            ftrack_users,\n            ayon_users\n        )\n\n        for ftrack_id, ayon_username in users_mapping.items():\n            if ayon_username is None:\n                continue\n\n            if ftrack_id not in user_ids:\n                ayon_usernames.remove(ayon_username)\n\n        return ayon_usernames\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_prepare_project.html#services.processor.processor.default_handlers.action_prepare_project.PrepareProjectServer.discover","title":"<code>discover(session, entities, event)</code>","text":"<p>Show only on project.</p> Source code in <code>services/processor/processor/default_handlers/action_prepare_project.py</code> <pre><code>def discover(self, session, entities, event):\n    \"\"\"Show only on project.\"\"\"\n    if (\n        len(entities) != 1\n        or entities[0].entity_type.lower() != \"project\"\n    ):\n        return False\n\n    return self.valid_roles(session, entities, event)\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_prepare_project.html#services.processor.processor.default_handlers.action_prepare_project.PrepareProjectServer.get_ayon_users_to_clean_roles","title":"<code>get_ayon_users_to_clean_roles(session, project_entity)</code>","text":"<p>Get AYON usernames that should have removed roles from a project.</p> <p>If project is private in ftrack we do remove roles from AYON users if they should not see it.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>ftrack session.</p> required <code>project_entity</code> <code>Entity</code> <p>Project entity.</p> required Source code in <code>services/processor/processor/default_handlers/action_prepare_project.py</code> <pre><code>def get_ayon_users_to_clean_roles(\n    self, session, project_entity\n):\n    \"\"\"Get AYON usernames that should have removed roles from a project.\n\n    If project is private in ftrack we do remove roles from AYON users if\n    they should not see it.\n\n    Args:\n        session (ftrack_api.Session): ftrack session.\n        project_entity (ftrack_api.entity.base.Entity): Project entity.\n\n    \"\"\"\n    if not project_entity[\"is_private\"]:\n        return []\n\n    ayon_users = [\n        ayon_user\n        for ayon_user in ayon_api.get_users()\n        if (\n            not ayon_user[\"isAdmin\"]\n            and not ayon_user[\"isManager\"]\n            and not ayon_user[\"isService\"]\n        )\n    ]\n    ayon_usernames = [\n        ayon_user[\"name\"]\n        for ayon_user in ayon_users\n    ]\n\n    project_id = project_entity[\"id\"]\n    role_ids = [\n        role[\"user_security_role_id\"]\n        for role in session.query(\n            \"select user_security_role_id\"\n            \" from UserSecurityRoleProject\"\n            f\" where project_id is '{project_id}'\"\n        ).all()\n    ]\n    if not role_ids:\n        return ayon_usernames\n    joined_role_ids = self.join_filter_values(role_ids)\n    user_ids = {\n        role[\"user_id\"]\n        for role in session.query(\n            \"select user_id\"\n            \" from UserSecurityRole\"\n            f\" where security_role_id in ({joined_role_ids})\"\n        ).all()\n    }\n    ftrack_users = []\n    if user_ids:\n        joined_user_ids = self.join_filter_values(user_ids)\n        ftrack_users = session.query(\n            \"select id, username, email from User\"\n            f\" where id in ({joined_user_ids})\"\n        ).all()\n    users_mapping = map_ftrack_users_to_ayon_users(\n        ftrack_users,\n        ayon_users\n    )\n\n    for ftrack_id, ayon_username in users_mapping.items():\n        if ayon_username is None:\n            continue\n\n        if ftrack_id not in user_ids:\n            ayon_usernames.remove(ayon_username)\n\n    return ayon_usernames\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_private_project_detection.html","title":"action_private_project_detection","text":""},{"location":"autoapi/services/processor/processor/default_handlers/action_private_project_detection.html#services.processor.processor.default_handlers.action_private_project_detection.PrivateProjectDetectionAction","title":"<code>PrivateProjectDetectionAction</code>","text":"<p>               Bases: <code>ServerAction</code></p> <p>Action helps to identify if does not have access to project.</p> Source code in <code>services/processor/processor/default_handlers/action_private_project_detection.py</code> <pre><code>class PrivateProjectDetectionAction(ServerAction):\n    \"\"\"Action helps to identify if does not have access to project.\"\"\"\n\n    identifier = \"ayon.server.missing.perm.private.project\"\n    label = \"Missing permissions (AYON)\"\n    description = (\n        \"Main ftrack event server does not have access to this project.\"\n    )\n\n    def _discover(self, event):\n        \"\"\"Show action only if there is a selection in event data.\"\"\"\n        entities = self._translate_event(event)\n        if entities:\n            return None\n\n        selection = event[\"data\"].get(\"selection\")\n        if not selection:\n            return None\n\n        return {\n            \"items\": [{\n                \"label\": self.label,\n                \"variant\": self.variant,\n                \"description\": self.description,\n                \"actionIdentifier\": self.discover_identifier,\n                \"icon\": self.icon,\n            }]\n        }\n\n    def _launch(self, event):\n        # Ignore if there are values in event data\n        # - somebody clicked on submit button\n        values = event[\"data\"].get(\"values\")\n        if values:\n            return None\n\n        title = \"# Private project (missing permissions) #\"\n        msg = (\n            \"User ({}) or API Key used on ftrack event server\"\n            \" does not have permissions to access this private project.\"\n        ).format(self.session.api_user)\n        return {\n            \"type\": \"form\",\n            \"title\": \"Missing permissions\",\n            \"items\": [\n                {\"type\": \"label\", \"value\": title},\n                {\"type\": \"label\", \"value\": msg},\n                # Add hidden to be able detect if was clicked on submit\n                {\"type\": \"hidden\", \"value\": \"1\", \"name\": \"hidden\"}\n            ],\n            \"submit_button_label\": \"Got it\"\n        }\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_project_component_sizes.html","title":"action_project_component_sizes","text":""},{"location":"autoapi/services/processor/processor/default_handlers/action_project_component_sizes.html#services.processor.processor.default_handlers.action_project_component_sizes.ProjectComponentsSizes","title":"<code>ProjectComponentsSizes</code>","text":"<p>               Bases: <code>ServerAction</code></p> <p>Calculate project components sizes.</p> <p>Action can calculate sizes of all available project or single project.</p> Source code in <code>services/processor/processor/default_handlers/action_project_component_sizes.py</code> <pre><code>class ProjectComponentsSizes(ServerAction):\n    \"\"\"Calculate project components sizes.\n\n    Action can calculate sizes of all available project or single project.\n    \"\"\"\n\n    identifier = \"project.components.sizes\"\n    label = \"AYON Admin\"\n    variant = \"- Calculate project component sizes\"\n    description = \"Calculate component sizes of all versions on ftrack server\"\n    icon = get_service_ftrack_icon_url(\"AYONAdmin.svg\")\n    settings_key = \"project_components_sizes\"\n\n    def discover(self, session, entities, event):\n        \"\"\"Check if action is available for user role.\"\"\"\n        ftrack_settings = self.get_ftrack_settings(session, event, entities)\n        settings = (\n            ftrack_settings[self.settings_frack_subkey][self.settings_key]\n        )\n        if settings[\"enabled\"]:\n            return self.valid_roles(session, entities, event)\n        return False\n\n    def interface(self, session, entities, event):\n        self.log.info(json.dumps(dict(event.items()), indent=4, default=str))\n        if event[\"data\"].get(\"values\"):\n            return\n\n        title = \"Confirm your workflow\"\n        enum_items = [\n            {\n                \"label\": \"All projects\",\n                \"value\": \"all_projects\"\n            }\n        ]\n        items = [\n            {\n                \"name\": \"workflow\",\n                \"label\": \"Workflow\",\n                \"type\": \"enumerator\",\n                \"value\": \"all_projects\",\n                \"data\": enum_items\n            }\n        ]\n\n        project = None\n        for entity in entities:\n            project = self.get_project_from_entity(entity, session)\n            if project:\n                break\n        label = \"Couldn't find a project in your selection.\"\n        if project:\n            enum_items.append({\n                \"label\": \"Selected project\",\n                \"value\": \"selected_project\"\n            })\n            label = f\"Selected project is '{project['full_name']}'.\"\n\n        items.append({\n            \"type\": \"label\",\n            \"value\": f\"&lt;b&gt;NOTE:&lt;/b&gt; {label}\"\n        })\n\n        return {\n            \"items\": items,\n            \"title\": title,\n            \"submit_button_label\": \"Confirm\"\n        }\n\n    def launch(self, session, entities, event):\n        if \"values\" not in event[\"data\"]:\n            return\n\n        values = event[\"data\"][\"values\"]\n        workflow = values[\"workflow\"]\n        current_date = datetime.datetime.now().strftime(\"%y-%m-%d-%H%M\")\n        self.log.debug(f\"User selected '{workflow}' workflow\")\n        if workflow == \"selected_project\":\n            project = None\n            for entity in entities:\n                project = self.get_project_from_entity(entity, session)\n                if project:\n                    break\n\n            if not project:\n                return {\n                    \"type\": \"message\",\n                    \"success\": False,\n                    \"message\": (\n                        \"Had issue to find a project in your selection.\"\n                    )\n                }\n            project_name = project[\"full_name\"]\n            component_base_name = f\"{project_name}_size\"\n            project_entities = [project]\n        else:\n            project_entities = session.query(\n                \"select id, full_name from Project\").all()\n            component_base_name = \"AllProjects_size\"\n\n        if not project_entities:\n            self.log.info(\"There are no projects to calculate size on.\")\n            return {\n                \"type\": \"message\",\n                \"success\": False,\n                \"message\": (\n                    \"Had issue to find a project in your selection.\"\n                )\n            }\n\n        component_name = f\"{component_base_name}_{current_date}\"\n\n        user_entity = session.query(\n            \"User where id is {}\".format(event[\"source\"][\"user\"][\"id\"])\n        ).one()\n        username = user_entity.get(\"username\")\n        if not username:\n            username = (\n                f\"{user_entity['first_name']} {user_entity['last_name']}\"\n            )\n\n        job_entity = session.create(\n            \"Job\",\n            {\n                \"user\": user_entity,\n                \"status\": \"running\",\n                \"data\": json.dumps({\n                    \"description\": \"Size calculation started\"\n                })\n            }\n        )\n        session.commit()\n\n        try:\n            output = self._create_calculate_jobs(\n                session, project_entities, job_entity, event, component_name\n            )\n            self.log.debug(\n                f\"Created job for '{username}'. Calculation started.\")\n\n        except Exception as exc:\n            # Get exc info before changes in logging to be able to upload it\n            #   to the job.\n            exc_info = sys.exc_info()\n            self.log.warning(\n                \"Calculation of project size failed.\", exc_info=exc)\n            session.rollback()\n\n            description = \"Size calculation Failed (Download traceback)\"\n            self.add_traceback_to_job(\n                job_entity, session, exc_info, description\n            )\n            output = {\n                \"type\": \"message\",\n                \"success\": False,\n                \"message\": (\n                    \"Failed to calculate sizes.\"\n                    \" Error details can be found in a job.\"\n                )\n            }\n\n        return output\n\n    def _create_calculate_jobs(\n        self, session, projects, job_entity, event, component_name\n    ):\n        description_template = (\n            f\"Size calculation ({{}}/{len(projects)})\")\n        job_data = json.loads(job_entity[\"data\"])\n        job_data.update({\n            \"desc_template\": description_template,\n            \"component_name\": component_name,\n            \"project_data\": {\n                project[\"id\"]: {\n                    \"size\": -1,\n                    \"attempts\": 0,\n                    \"done\": False,\n                    \"name\": project[\"full_name\"],\n                }\n                for project in projects\n            }\n        })\n        job_entity[\"data\"] = json.dumps(job_data)\n        session.commit()\n\n        for project in projects:\n            project_id = project[\"id\"]\n\n            self.trigger_event(\n                \"ayon.calculate.project.component.size\",\n                event_data={\n                    \"project_id\": project_id,\n                    \"job_id\": job_entity[\"id\"]\n                },\n                session=session,\n                source=event[\"source\"],\n                event=event,\n                on_error=\"ignore\"\n            )\n\n        return {\n            \"type\": \"message\",\n            \"success\": True,\n            \"message\": (\n                \"This may take some time. Look into jobs to check progress.\"\n            )\n        }\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_project_component_sizes.html#services.processor.processor.default_handlers.action_project_component_sizes.ProjectComponentsSizes.discover","title":"<code>discover(session, entities, event)</code>","text":"<p>Check if action is available for user role.</p> Source code in <code>services/processor/processor/default_handlers/action_project_component_sizes.py</code> <pre><code>def discover(self, session, entities, event):\n    \"\"\"Check if action is available for user role.\"\"\"\n    ftrack_settings = self.get_ftrack_settings(session, event, entities)\n    settings = (\n        ftrack_settings[self.settings_frack_subkey][self.settings_key]\n    )\n    if settings[\"enabled\"]:\n        return self.valid_roles(session, entities, event)\n    return False\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_project_component_sizes.html#services.processor.processor.default_handlers.action_project_component_sizes.format_file_size","title":"<code>format_file_size(file_size, suffix=None)</code>","text":"<p>Returns formatted string with size in appropriate unit.</p> <p>Parameters:</p> Name Type Description Default <code>file_size</code> <code>int</code> <p>Size of file in bytes.</p> required <code>suffix</code> <code>str</code> <p>Suffix for formatted size. Default is 'B' (as bytes).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>Formatted size using proper unit and passed suffix (e.g. 7 MiB).</p> Source code in <code>services/processor/processor/default_handlers/action_project_component_sizes.py</code> <pre><code>def format_file_size(file_size, suffix=None):\n    \"\"\"Returns formatted string with size in appropriate unit.\n\n    Args:\n        file_size (int): Size of file in bytes.\n        suffix (str): Suffix for formatted size. Default is 'B' (as bytes).\n\n    Returns:\n        str: Formatted size using proper unit and passed suffix (e.g. 7 MiB).\n    \"\"\"\n\n    if suffix is None:\n        suffix = \"B\"\n\n    for unit in [\"\", \"Ki\", \"Mi\", \"Gi\", \"Ti\", \"Pi\", \"Ei\", \"Zi\"]:\n        if abs(file_size) &lt; 1024.0:\n            return \"%3.1f%s%s\" % (file_size, unit, suffix)\n        file_size /= 1024.0\n    return \"%.1f%s%s\" % (file_size, \"Yi\", suffix)\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_push_frame_values_to_task.html","title":"action_push_frame_values_to_task","text":""},{"location":"autoapi/services/processor/processor/default_handlers/action_push_frame_values_to_task.html#services.processor.processor.default_handlers.action_push_frame_values_to_task.PushHierValuesToNonHier","title":"<code>PushHierValuesToNonHier</code>","text":"<p>               Bases: <code>ServerAction</code></p> <p>Action push hierarchical custom attribute values to non-hierarchical.</p> <p>Hierarchical value is also pushed to their task entities.</p> <p>Action has 3 configurable attributes: - <code>role_list</code>: List of use roles that can discover the action. - <code>interest_attributes</code>: Keys of custom attributes that will be looking     for to push values. Attribute key must have both custom attribute types     hierarchical and on specific object type (entity type). - <code>interest_entity_types</code>: Entity types that will be in focus of pushing     hierarchical to object type's custom attribute.</p> <p>EXAMPLE: * Before action | Project   | Shot1     - hierarchical custom attribute value: <code>frameStart</code>: 1001     - custom attribute for <code>Shot</code>: frameStart: 1     |_ Task1         - hierarchical custom attribute value: <code>frameStart</code>: 10         - custom attribute for <code>Task</code>: frameStart: 0</p> <ul> <li>After action | Project   | Shot1<ul> <li>hierarchical custom attribute value: <code>frameStart</code>: 1001</li> <li>custom attribute for <code>Shot</code>: frameStart: 1001 |_ Task1<ul> <li>hierarchical custom attribute value: <code>frameStart</code>: 1001</li> <li>custom attribute for <code>Task</code>: frameStart: 1001</li> </ul> </li> </ul> </li> </ul> Source code in <code>services/processor/processor/default_handlers/action_push_frame_values_to_task.py</code> <pre><code>class PushHierValuesToNonHier(ServerAction):\n    \"\"\"Action push hierarchical custom attribute values to non-hierarchical.\n\n    Hierarchical value is also pushed to their task entities.\n\n    Action has 3 configurable attributes:\n    - `role_list`: List of use roles that can discover the action.\n    - `interest_attributes`: Keys of custom attributes that will be looking\n        for to push values. Attribute key must have both custom attribute types\n        hierarchical and on specific object type (entity type).\n    - `interest_entity_types`: Entity types that will be in focus of pushing\n        hierarchical to object type's custom attribute.\n\n    EXAMPLE:\n    * Before action\n    |_ Project\n      |_ Shot1\n        - hierarchical custom attribute value: `frameStart`: 1001\n        - custom attribute for `Shot`: frameStart: 1\n        |_ Task1\n            - hierarchical custom attribute value: `frameStart`: 10\n            - custom attribute for `Task`: frameStart: 0\n\n    * After action\n    |_ Project\n      |_ Shot1\n        - hierarchical custom attribute value: `frameStart`: 1001\n        - custom attribute for `Shot`: frameStart: 1001\n        |_ Task1\n            - hierarchical custom attribute value: `frameStart`: 1001\n            - custom attribute for `Task`: frameStart: 1001\n    \"\"\"\n\n    identifier = \"ayon.admin.push_hier_values_to_non_hier\"\n    label = \"AYON Admin\"\n    variant = \"- Push Hierarchical values To Non-Hierarchical\"\n    icon = get_service_ftrack_icon_url(\"AYONAdmin.svg\")\n\n    entities_query_by_project = (\n        \"select id, parent_id, object_type_id from TypedContext\"\n        \" where project_id is \\\"{}\\\"\"\n    )\n    cust_attrs_query = (\n        \"select id, key, object_type_id, is_hierarchical, default\"\n        \" from CustomAttributeConfiguration\"\n        \" where key in ({})\"\n    )\n\n    # configurable\n    settings_key = \"sync_hier_entity_attributes\"\n    settings_enabled_key = \"action_enabled\"\n\n    def discover(self, session, entities, event):\n        \"\"\" Validation \"\"\"\n        # Check if selection is valid\n        is_valid = False\n        for ent in event[\"data\"][\"selection\"]:\n            # Ignore entities that are not tasks or projects\n            if ent[\"entityType\"].lower() in (\"task\", \"show\"):\n                is_valid = True\n                break\n\n        if is_valid:\n            is_valid = self.valid_roles(session, entities, event)\n        return is_valid\n\n    def launch(self, session, entities, event):\n        self.log.debug(\"{}: Creating job\".format(self.label))\n\n        user_entity = session.query(\n            \"User where id is {}\".format(event[\"source\"][\"user\"][\"id\"])\n        ).one()\n        job = session.create(\"Job\", {\n            \"user\": user_entity,\n            \"status\": \"running\",\n            \"data\": json.dumps({\n                \"description\": \"Propagation of Frame attribute values to task.\"\n            })\n        })\n        session.commit()\n\n        try:\n            result = self.propagate_values(session, event, entities)\n\n        except Exception as exc:\n            msg = \"Pushing Custom attribute values to task Failed\"\n\n            self.log.warning(msg, exc_info=True)\n\n            session.rollback()\n\n            description = \"{} (Download traceback)\".format(msg)\n            self.add_traceback_to_job(\n                job, session, sys.exc_info(), description\n            )\n\n            return {\n                \"success\": False,\n                \"message\": \"Error: {}\".format(str(exc))\n            }\n\n        job[\"status\"] = \"done\"\n        session.commit()\n\n        return result\n\n    def attrs_configurations(self, session, object_ids, interest_attributes):\n        attrs = session.query(self.cust_attrs_query.format(\n            self.join_query_keys(interest_attributes),\n            self.join_query_keys(object_ids)\n        )).all()\n\n        attrs_by_obj_id = collections.defaultdict(list)\n        hiearchical = []\n        for attr in attrs:\n            if attr[\"is_hierarchical\"]:\n                hiearchical.append(attr)\n                continue\n            obj_id = attr[\"object_type_id\"]\n            attrs_by_obj_id[obj_id].append(attr)\n        return attrs_by_obj_id, hiearchical\n\n    def query_attr_value(\n        self,\n        session,\n        hier_attrs,\n        attrs_by_obj_id,\n        dst_object_type_ids,\n        task_entity_ids,\n        non_task_entity_ids,\n        parent_id_by_entity_id\n    ):\n        all_non_task_ids_with_parents = set()\n        for entity_id in non_task_entity_ids:\n            all_non_task_ids_with_parents.add(entity_id)\n            _entity_id = entity_id\n            while True:\n                parent_id = parent_id_by_entity_id.get(_entity_id)\n                if (\n                    parent_id is None\n                    or parent_id in all_non_task_ids_with_parents\n                ):\n                    break\n                all_non_task_ids_with_parents.add(parent_id)\n                _entity_id = parent_id\n\n        all_entity_ids = (\n            set(all_non_task_ids_with_parents)\n            | set(task_entity_ids)\n        )\n        attr_ids = {attr[\"id\"] for attr in hier_attrs}\n        for obj_id in dst_object_type_ids:\n            attrs = attrs_by_obj_id.get(obj_id)\n            if attrs is not None:\n                for attr in attrs:\n                    attr_ids.add(attr[\"id\"])\n\n        real_values_by_entity_id = {\n            entity_id: {}\n            for entity_id in all_entity_ids\n        }\n\n        attr_values = query_custom_attribute_values(\n            session, attr_ids, all_entity_ids\n        )\n        for item in attr_values:\n            entity_id = item[\"entity_id\"]\n            attr_id = item[\"configuration_id\"]\n            real_values_by_entity_id[entity_id][attr_id] = item[\"value\"]\n\n        # Fill hierarchical values\n        hier_attrs_key_by_id = {\n            hier_attr[\"id\"]: hier_attr\n            for hier_attr in hier_attrs\n        }\n        hier_values_per_entity_id = {}\n        for entity_id in all_non_task_ids_with_parents:\n            real_values = real_values_by_entity_id[entity_id]\n            hier_values_per_entity_id[entity_id] = {}\n            for attr_id, attr in hier_attrs_key_by_id.items():\n                key = attr[\"key\"]\n                hier_values_per_entity_id[entity_id][key] = (\n                    real_values.get(attr_id)\n                )\n\n        output = {}\n        for entity_id in non_task_entity_ids:\n            output[entity_id] = {}\n            for attr in hier_attrs_key_by_id.values():\n                key = attr[\"key\"]\n                value = hier_values_per_entity_id[entity_id][key]\n                tried_ids = set()\n                if value is None:\n                    tried_ids.add(entity_id)\n                    _entity_id = entity_id\n                    while value is None:\n                        parent_id = parent_id_by_entity_id.get(_entity_id)\n                        if not parent_id:\n                            break\n                        value = hier_values_per_entity_id[parent_id][key]\n                        if value is not None:\n                            break\n                        _entity_id = parent_id\n                        tried_ids.add(parent_id)\n\n                if value is None:\n                    value = attr[\"default\"]\n\n                if value is not None:\n                    for ent_id in tried_ids:\n                        hier_values_per_entity_id[ent_id][key] = value\n\n                output[entity_id][key] = value\n\n        return real_values_by_entity_id, output\n\n    def propagate_values(self, session, event, selected_entities):\n        ftrack_settings = self.get_ftrack_settings(\n            session, event, selected_entities\n        )\n        action_settings = (\n            ftrack_settings[self.settings_frack_subkey][self.settings_key]\n        )\n\n        project_entity = self.get_project_from_entity(selected_entities[0])\n        selected_ids = [entity[\"id\"] for entity in selected_entities]\n\n        self.log.debug(\"Querying project's entities \\\"{}\\\".\".format(\n            project_entity[\"full_name\"]\n        ))\n        interest_entity_types = tuple(\n            ent_type.lower()\n            for ent_type in action_settings[\"interest_entity_types\"]\n        )\n        all_object_types = session.query(\"ObjectType\").all()\n        object_types_by_low_name = {\n            object_type[\"name\"].lower(): object_type\n            for object_type in all_object_types\n        }\n\n        task_object_type = object_types_by_low_name[\"task\"]\n        dst_object_type_ids = {task_object_type[\"id\"]}\n        for ent_type in interest_entity_types:\n            obj_type = object_types_by_low_name.get(ent_type)\n            if obj_type:\n                dst_object_type_ids.add(obj_type[\"id\"])\n\n        interest_attributes = action_settings[\"interest_attributes\"]\n        # Find custom attributes definitions\n        attrs_by_obj_id, hier_attrs = self.attrs_configurations(\n            session, dst_object_type_ids, interest_attributes\n        )\n        # Filter destination object types if they have any object specific\n        # custom attribute\n        for obj_id in tuple(dst_object_type_ids):\n            if obj_id not in attrs_by_obj_id:\n                dst_object_type_ids.remove(obj_id)\n\n        if not dst_object_type_ids:\n            # TODO report that there are not matching custom attributes\n            return {\n                \"success\": True,\n                \"message\": \"Nothing has changed.\"\n            }\n\n        (\n            parent_id_by_entity_id,\n            filtered_entities\n        ) = self.all_hierarchy_entities(\n            session,\n            selected_ids,\n            project_entity,\n            dst_object_type_ids\n        )\n\n        self.log.debug(\"Preparing whole project hierarchy by ids.\")\n\n        entities_by_obj_id = {\n            obj_id: []\n            for obj_id in dst_object_type_ids\n        }\n\n        self.log.debug(\"Filtering Task entities.\")\n        focus_entity_ids = []\n        non_task_entity_ids = []\n        task_entity_ids = []\n        for entity in filtered_entities:\n            entity_id = entity[\"id\"]\n            focus_entity_ids.append(entity_id)\n            if entity.entity_type.lower() == \"task\":\n                task_entity_ids.append(entity_id)\n            else:\n                non_task_entity_ids.append(entity_id)\n\n            obj_id = entity[\"object_type_id\"]\n            entities_by_obj_id[obj_id].append(entity_id)\n\n        if not non_task_entity_ids:\n            return {\n                \"success\": True,\n                \"message\": \"Nothing to do in your selection.\"\n            }\n\n        self.log.debug(\"Getting Custom attribute values.\")\n        (\n            real_values_by_entity_id,\n            hier_values_by_entity_id\n        ) = self.query_attr_value(\n            session,\n            hier_attrs,\n            attrs_by_obj_id,\n            dst_object_type_ids,\n            task_entity_ids,\n            non_task_entity_ids,\n            parent_id_by_entity_id\n        )\n\n        self.log.debug(\"Setting parents' values to task.\")\n        self.set_task_attr_values(\n            session,\n            hier_attrs,\n            task_entity_ids,\n            hier_values_by_entity_id,\n            parent_id_by_entity_id,\n            real_values_by_entity_id\n        )\n\n        self.log.debug(\"Setting values to entities themselves.\")\n        self.push_values_to_entities(\n            session,\n            entities_by_obj_id,\n            attrs_by_obj_id,\n            hier_values_by_entity_id,\n            real_values_by_entity_id\n        )\n\n        return True\n\n    def all_hierarchy_entities(\n        self,\n        session,\n        selected_ids,\n        project_entity,\n        destination_object_type_ids\n    ):\n        selected_ids = set(selected_ids)\n\n        filtered_entities = []\n        parent_id_by_entity_id = {}\n        # Query is simple if project is in selection\n        if project_entity[\"id\"] in selected_ids:\n            entities = session.query(\n                self.entities_query_by_project.format(project_entity[\"id\"])\n            ).all()\n\n            for entity in entities:\n                if entity[\"object_type_id\"] in destination_object_type_ids:\n                    filtered_entities.append(entity)\n                entity_id = entity[\"id\"]\n                parent_id_by_entity_id[entity_id] = entity[\"parent_id\"]\n            return parent_id_by_entity_id, filtered_entities\n\n        # Query selection and get it's link to be able calculate parentings\n        entities_with_link = session.query((\n            \"select id, parent_id, link, object_type_id\"\n            \" from TypedContext where id in ({})\"\n        ).format(self.join_query_keys(selected_ids))).all()\n\n        # Process and store queried entities and store all lower entities to\n        #   `bottom_ids`\n        # - bottom_ids should not contain 2 ids where one is parent of second\n        bottom_ids = set(selected_ids)\n        for entity in entities_with_link:\n            if entity[\"object_type_id\"] in destination_object_type_ids:\n                filtered_entities.append(entity)\n            children_id = None\n            for idx, item in enumerate(reversed(entity[\"link\"])):\n                item_id = item[\"id\"]\n                if idx &gt; 0 and item_id in bottom_ids:\n                    bottom_ids.remove(item_id)\n\n                if children_id is not None:\n                    parent_id_by_entity_id[children_id] = item_id\n\n                children_id = item_id\n\n        # Query all children of selection per one hierarchy level and process\n        #   their data the same way as selection but parents are already known\n        chunk_size = 100\n        while bottom_ids:\n            child_entities = []\n            # Query entities in chunks\n            entity_ids = list(bottom_ids)\n            for idx in range(0, len(entity_ids), chunk_size):\n                _entity_ids = entity_ids[idx:idx + chunk_size]\n                child_entities.extend(session.query((\n                    \"select id, parent_id, object_type_id from\"\n                    \" TypedContext where parent_id in ({})\"\n                ).format(self.join_query_keys(_entity_ids))).all())\n\n            bottom_ids = set()\n            for entity in child_entities:\n                entity_id = entity[\"id\"]\n                parent_id_by_entity_id[entity_id] = entity[\"parent_id\"]\n                bottom_ids.add(entity_id)\n                if entity[\"object_type_id\"] in destination_object_type_ids:\n                    filtered_entities.append(entity)\n\n        return parent_id_by_entity_id, filtered_entities\n\n    def set_task_attr_values(\n        self,\n        session,\n        hier_attrs,\n        task_entity_ids,\n        hier_values_by_entity_id,\n        parent_id_by_entity_id,\n        real_values_by_entity_id\n    ):\n        hier_attr_id_by_key = {\n            attr[\"key\"]: attr[\"id\"]\n            for attr in hier_attrs\n        }\n        filtered_task_ids = set()\n        for task_id in task_entity_ids:\n            parent_id = parent_id_by_entity_id.get(task_id)\n            parent_values = hier_values_by_entity_id.get(parent_id)\n            if parent_values:\n                filtered_task_ids.add(task_id)\n\n        if not filtered_task_ids:\n            return\n\n        for task_id in filtered_task_ids:\n            parent_id = parent_id_by_entity_id[task_id]\n            parent_values = hier_values_by_entity_id[parent_id]\n            hier_values_by_entity_id[task_id] = {}\n            real_task_attr_values = real_values_by_entity_id[task_id]\n            for key, value in parent_values.items():\n                hier_values_by_entity_id[task_id][key] = value\n                if value is None:\n                    continue\n\n                configuration_id = hier_attr_id_by_key[key]\n                _entity_key = collections.OrderedDict([\n                    (\"configuration_id\", configuration_id),\n                    (\"entity_id\", task_id)\n                ])\n                op = None\n                if configuration_id not in real_task_attr_values:\n                    op = ftrack_api.operation.CreateEntityOperation(\n                        \"CustomAttributeValue\",\n                        _entity_key,\n                        {\"value\": value}\n                    )\n                elif real_task_attr_values[configuration_id] != value:\n                    op = ftrack_api.operation.UpdateEntityOperation(\n                        \"CustomAttributeValue\",\n                        _entity_key,\n                        \"value\",\n                        real_task_attr_values[configuration_id],\n                        value\n                    )\n\n                if op is not None:\n                    session.recorded_operations.push(op)\n                    if len(session.recorded_operations) &gt; 100:\n                        session.commit()\n\n        session.commit()\n\n    def push_values_to_entities(\n        self,\n        session,\n        entities_by_obj_id,\n        attrs_by_obj_id,\n        hier_values_by_entity_id,\n        real_values_by_entity_id\n    ):\n        \"\"\"Push values from hierarchical custom attributes to non-hierarchical.\n\n        Args:\n            session (ftrack_api.Sessison): Session which queried entities,\n                values and which is used for change propagation.\n            entities_by_obj_id (dict[str, list[str]]): TypedContext\n                ftrack entity ids where the attributes are propagated by their\n                object ids.\n            attrs_by_obj_id (dict[str, ftrack_api.Entity]): Objects of\n                'CustomAttributeConfiguration' by their ids.\n            hier_values_by_entity_id (doc[str, dict[str, Any]]): Attribute\n                values by entity id and by their keys.\n            real_values_by_entity_id (doc[str, dict[str, Any]]): Real attribute\n                values of entities.\n        \"\"\"\n\n        for object_id, entity_ids in entities_by_obj_id.items():\n            attrs = attrs_by_obj_id.get(object_id)\n            if not attrs or not entity_ids:\n                continue\n\n            for entity_id in entity_ids:\n                real_values = real_values_by_entity_id.get(entity_id)\n                hier_values = hier_values_by_entity_id.get(entity_id)\n                if hier_values is None:\n                    continue\n\n                for attr in attrs:\n                    attr_id = attr[\"id\"]\n                    attr_key = attr[\"key\"]\n                    value = hier_values.get(attr_key)\n                    if value is None:\n                        continue\n\n                    _entity_key = collections.OrderedDict([\n                        (\"configuration_id\", attr_id),\n                        (\"entity_id\", entity_id)\n                    ])\n\n                    op = None\n                    if attr_id not in real_values:\n                        op = ftrack_api.operation.CreateEntityOperation(\n                            \"CustomAttributeValue\",\n                            _entity_key,\n                            {\"value\": value}\n                        )\n                    elif real_values[attr_id] != value:\n                        op = ftrack_api.operation.UpdateEntityOperation(\n                            \"CustomAttributeValue\",\n                            _entity_key,\n                            \"value\",\n                            real_values[attr_id],\n                            value\n                        )\n\n                    if op is not None:\n                        session.recorded_operations.push(op)\n                        if len(session.recorded_operations) &gt; 100:\n                            session.commit()\n\n        session.commit()\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_push_frame_values_to_task.html#services.processor.processor.default_handlers.action_push_frame_values_to_task.PushHierValuesToNonHier.discover","title":"<code>discover(session, entities, event)</code>","text":"<p>Validation</p> Source code in <code>services/processor/processor/default_handlers/action_push_frame_values_to_task.py</code> <pre><code>def discover(self, session, entities, event):\n    \"\"\" Validation \"\"\"\n    # Check if selection is valid\n    is_valid = False\n    for ent in event[\"data\"][\"selection\"]:\n        # Ignore entities that are not tasks or projects\n        if ent[\"entityType\"].lower() in (\"task\", \"show\"):\n            is_valid = True\n            break\n\n    if is_valid:\n        is_valid = self.valid_roles(session, entities, event)\n    return is_valid\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_push_frame_values_to_task.html#services.processor.processor.default_handlers.action_push_frame_values_to_task.PushHierValuesToNonHier.push_values_to_entities","title":"<code>push_values_to_entities(session, entities_by_obj_id, attrs_by_obj_id, hier_values_by_entity_id, real_values_by_entity_id)</code>","text":"<p>Push values from hierarchical custom attributes to non-hierarchical.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Sessison</code> <p>Session which queried entities, values and which is used for change propagation.</p> required <code>entities_by_obj_id</code> <code>dict[str, list[str]]</code> <p>TypedContext ftrack entity ids where the attributes are propagated by their object ids.</p> required <code>attrs_by_obj_id</code> <code>dict[str, Entity]</code> <p>Objects of 'CustomAttributeConfiguration' by their ids.</p> required <code>hier_values_by_entity_id</code> <code>doc[str, dict[str, Any]]</code> <p>Attribute values by entity id and by their keys.</p> required <code>real_values_by_entity_id</code> <code>doc[str, dict[str, Any]]</code> <p>Real attribute values of entities.</p> required Source code in <code>services/processor/processor/default_handlers/action_push_frame_values_to_task.py</code> <pre><code>def push_values_to_entities(\n    self,\n    session,\n    entities_by_obj_id,\n    attrs_by_obj_id,\n    hier_values_by_entity_id,\n    real_values_by_entity_id\n):\n    \"\"\"Push values from hierarchical custom attributes to non-hierarchical.\n\n    Args:\n        session (ftrack_api.Sessison): Session which queried entities,\n            values and which is used for change propagation.\n        entities_by_obj_id (dict[str, list[str]]): TypedContext\n            ftrack entity ids where the attributes are propagated by their\n            object ids.\n        attrs_by_obj_id (dict[str, ftrack_api.Entity]): Objects of\n            'CustomAttributeConfiguration' by their ids.\n        hier_values_by_entity_id (doc[str, dict[str, Any]]): Attribute\n            values by entity id and by their keys.\n        real_values_by_entity_id (doc[str, dict[str, Any]]): Real attribute\n            values of entities.\n    \"\"\"\n\n    for object_id, entity_ids in entities_by_obj_id.items():\n        attrs = attrs_by_obj_id.get(object_id)\n        if not attrs or not entity_ids:\n            continue\n\n        for entity_id in entity_ids:\n            real_values = real_values_by_entity_id.get(entity_id)\n            hier_values = hier_values_by_entity_id.get(entity_id)\n            if hier_values is None:\n                continue\n\n            for attr in attrs:\n                attr_id = attr[\"id\"]\n                attr_key = attr[\"key\"]\n                value = hier_values.get(attr_key)\n                if value is None:\n                    continue\n\n                _entity_key = collections.OrderedDict([\n                    (\"configuration_id\", attr_id),\n                    (\"entity_id\", entity_id)\n                ])\n\n                op = None\n                if attr_id not in real_values:\n                    op = ftrack_api.operation.CreateEntityOperation(\n                        \"CustomAttributeValue\",\n                        _entity_key,\n                        {\"value\": value}\n                    )\n                elif real_values[attr_id] != value:\n                    op = ftrack_api.operation.UpdateEntityOperation(\n                        \"CustomAttributeValue\",\n                        _entity_key,\n                        \"value\",\n                        real_values[attr_id],\n                        value\n                    )\n\n                if op is not None:\n                    session.recorded_operations.push(op)\n                    if len(session.recorded_operations) &gt; 100:\n                        session.commit()\n\n    session.commit()\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_sync_from_ftrack.html","title":"action_sync_from_ftrack","text":""},{"location":"autoapi/services/processor/processor/default_handlers/action_sync_from_ftrack.html#services.processor.processor.default_handlers.action_sync_from_ftrack.SyncFromFtrackAction","title":"<code>SyncFromFtrackAction</code>","text":"<p>               Bases: <code>ServerAction</code></p> <p>Prepare project attributes in Anatomy.</p> Source code in <code>services/processor/processor/default_handlers/action_sync_from_ftrack.py</code> <pre><code>class SyncFromFtrackAction(ServerAction):\n    \"\"\"Prepare project attributes in Anatomy.\"\"\"\n\n    identifier = \"sync.from.ftrack.to.ayon\"\n    label = \"AYON Admin\"\n    variant = \"- Sync to AYON\"\n    description = \"Synchronize project hierarchy based on ftrack\"\n    icon = get_service_ftrack_icon_url(\"AYONAdmin.svg\")\n\n    role_list = [\"Administrator\", \"Project Manager\"]\n\n    settings_key = \"sync_from_ftrack\"\n\n    def discover(self, session, entities, event):\n        \"\"\"Show only on project.\"\"\"\n        if (\n            len(entities) != 1\n            or entities[0].entity_type.lower() != \"project\"\n        ):\n            return False\n        return self.valid_roles(session, entities, event)\n\n    def launch(self, session, entities, event):\n        self.log.info(\"Synchronization begins\")\n        project = self.get_project_from_entity(entities[0])\n        project_name = project[\"full_name\"]\n        syncer = SyncFromFtrack(session, project_name, self.log)\n        syncer.sync_to_server()\n        report_items = syncer.report_items\n        if report_items:\n            self.show_interface(\n                report_items,\n                title=\"Sync to AYON report\",\n                event=event\n            )\n        self.log.info(\"Synchronization finished\")\n        return True\n\n    def register(self):\n        super().register()\n\n        # Listen to leecher start event\n        self.session.event_hub.subscribe(\n            \"topic=ayon.ftrack.leecher.started\",\n            self._on_leecher_start,\n            priority=self.priority\n        )\n\n    def _on_leecher_start(self, event):\n        \"\"\"Trigger Sync to AYON action when leecher starts.\n\n        The action is triggered for all project that have enabled auto-sync.\n        \"\"\"\n\n        session = self.session\n        if session is None:\n            self.log.warning(\n                \"Session is not set. Can't trigger Sync to AYON action.\")\n            return True\n\n        projects = session.query(\"Project\").all()\n        if not projects:\n            return True\n\n        selections = []\n        for project in projects:\n            if project[\"status\"] != \"active\":\n                continue\n\n            auto_sync = project[\"custom_attributes\"].get(CUST_ATTR_AUTO_SYNC)\n            if not auto_sync:\n                continue\n\n            selections.append({\n                \"entityId\": project[\"id\"],\n                \"entityType\": \"show\"\n            })\n\n        if not selections:\n            return\n\n        user = session.query(\n            \"User where username is \\\"{}\\\"\".format(session.api_user)\n        ).one()\n        user_data = {\n            \"username\": user[\"username\"],\n            \"id\": user[\"id\"]\n        }\n\n        for selection in selections:\n            event_data = {\n                \"actionIdentifier\": self.launch_identifier,\n                \"selection\": [selection]\n            }\n            session.event_hub.publish(\n                ftrack_api.event.base.Event(\n                    topic=\"ftrack.action.launch\",\n                    data=event_data,\n                    source=dict(user=user_data)\n                ),\n                on_error=\"ignore\"\n            )\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_sync_from_ftrack.html#services.processor.processor.default_handlers.action_sync_from_ftrack.SyncFromFtrackAction.discover","title":"<code>discover(session, entities, event)</code>","text":"<p>Show only on project.</p> Source code in <code>services/processor/processor/default_handlers/action_sync_from_ftrack.py</code> <pre><code>def discover(self, session, entities, event):\n    \"\"\"Show only on project.\"\"\"\n    if (\n        len(entities) != 1\n        or entities[0].entity_type.lower() != \"project\"\n    ):\n        return False\n    return self.valid_roles(session, entities, event)\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_sync_users.html","title":"action_sync_users","text":""},{"location":"autoapi/services/processor/processor/default_handlers/action_sync_users.html#services.processor.processor.default_handlers.action_sync_users.SyncUsersFromFtrackAction","title":"<code>SyncUsersFromFtrackAction</code>","text":"<p>               Bases: <code>ServerAction</code></p> <p>Sync user entities to AYON.</p> <p>This action is used to synchronize users from ftrack to AYON.</p> <p>When a user is created it also synchronizes the user's roles. Roles are NOT synchronized on user update, because user roles might be already modified in AYON.</p> <p>Note: We might add interface to the action to be able to sync only specific users, or to sync roles even on user update.</p> <p>This action is available on project entities, but syncs all users.</p> <p>Does not sync user thumbnails, might be added in the future if needed, but probably only for new users or .</p> Source code in <code>services/processor/processor/default_handlers/action_sync_users.py</code> <pre><code>class SyncUsersFromFtrackAction(ServerAction):\n    \"\"\"Sync user entities to AYON.\n\n    This action is used to synchronize users from ftrack to AYON.\n\n    When a user is created it also synchronizes the user's roles.\n    Roles are NOT synchronized on user update, because user roles might be\n    already modified in AYON.\n\n    Note: We might add interface to the action to be able to sync only specific\n    users, or to sync roles even on user update.\n\n    This action is available on project entities, but syncs all users.\n\n    Does not sync user thumbnails, might be added in the future if needed,\n    but probably only for new users or .\n    \"\"\"\n\n    identifier = \"sync.users.from.ftrack.to.ayon\"\n    label = \"AYON Admin\"\n    variant = \"- Sync users to AYON\"\n    description = \"Synchronize users based on ftrack\"\n    icon = get_service_ftrack_icon_url(\"AYONAdmin.svg\")\n\n    role_list = [\"Administrator\", \"Project Manager\"]\n    settings_key = \"sync_users_from_ftrack\"\n\n    def discover(self, session, entities, event):\n        \"\"\"Show only on project.\"\"\"\n        if (\n            len(entities) != 1\n            or entities[0].entity_type.lower() != \"project\"\n        ):\n            return False\n        return self.valid_roles(session, entities, event)\n\n    def interface(self, session, entities, event):\n        if event[\"data\"].get(\"values\"):\n            return\n\n        response = ayon_api.get(\"accessGroups/_\")\n        access_groups = [\n            item[\"name\"]\n            for item in response.data\n        ]\n\n        title = \"Default artist access groups\"\n\n        items = [\n            {\n                \"type\": \"label\",\n                \"value\": \"Select default access groups for artists\",\n            },\n            {\n                \"type\": \"enumerator\",\n                \"name\": \"access_groups\",\n                \"data\": [\n                    {\n                        \"value\": access_group,\n                        \"label\": access_group,\n                    }\n                    for access_group in access_groups\n                ],\n                \"value\": access_groups,\n                \"multi_select\": True,\n            },\n        ]\n\n        return {\n            \"items\": items,\n            \"title\": title\n        }\n\n    def launch(self, session, entities, event):\n        values = event[\"data\"].get(\"values\")\n        access_groups = None\n        if values:\n            access_groups = values.get(\"access_groups\")\n\n        if access_groups is None:\n            response = ayon_api.get(\"accessGroups/_\")\n            access_groups = [\n                item[\"name\"]\n                for item in response.json()\n            ]\n\n        self.log.info(\"Synchronization begins\")\n        fields = {\n            \"id\",\n            \"username\",\n            \"is_active\",\n            \"email\",\n            \"first_name\",\n            \"last_name\",\n            \"user_type_id\",\n            # \"resource_type\",\n            # \"thumbnail_id\",\n            # \"thumbnail_url\",\n        }\n        joined_fields = \", \".join(fields)\n\n        valid_ftrack_user_type_ids = {\n            user_type[\"id\"]\n            for user_type in session.query(\n                \"select id, name from UserType\"\n            ).all()\n            # Ignore services and demo users\n            if user_type[\"name\"] not in (\"service\", \"demo\")\n        }\n        ftrack_users = [\n            user\n            for user in session.query(f\"select {joined_fields} from User\")\n            if user[\"user_type_id\"] in valid_ftrack_user_type_ids\n        ]\n        ftrack_users_by_id = {\n            ftrack_user[\"id\"]: ftrack_user\n            for ftrack_user in ftrack_users\n        }\n        security_roles_by_id: Dict[str, \"FtrackEntity\"] = {\n            role[\"id\"]: role\n            for role in session.query(\n                \"select id, name, type from SecurityRole\"\n            ).all()\n        }\n        ayon_role_by_user_id: Dict[str, str] = {\n            ftrack_id: \"artist\"\n            for ftrack_id in ftrack_users_by_id\n        }\n        user_roles_by_user_id: Dict[str, List[\"FtrackEntity\"]] = {\n            ftrack_id: []\n            for ftrack_id in ftrack_users_by_id\n        }\n        project_role_ids: Set[str] = set()\n        for user_security_role in session.query(\n            \"select is_all_projects, is_all_open_projects\"\n            \", security_role_id, user_id\"\n            \" from UserSecurityRole\"\n        ).all():\n            role: FtrackEntity = (\n                security_roles_by_id[user_security_role[\"security_role_id\"]]\n            )\n            user_id: str = user_security_role[\"user_id\"]\n            # Ignore users that are not 'ftrack' users\n            if user_id not in ftrack_users_by_id:\n                continue\n\n            user_roles_by_user_id.setdefault(user_id, []).append(\n                user_security_role\n            )\n            if not user_security_role[\"is_all_projects\"]:\n                project_role_ids.add(user_security_role[\"id\"])\n                continue\n\n            # Mark user as admin\n            if role[\"name\"] == \"Administrator\":\n                ayon_role_by_user_id[user_id] = \"admin\"\n                continue\n\n            # Make sure that user which was already marked with previous role\n            #   as admin is not downgraded\n            current_role = ayon_role_by_user_id[user_id]\n            if role[\"name\"] == \"Project Manager\" and current_role != \"admin\":\n                ayon_role_by_user_id[user_id] = \"manager\"\n\n        project_roles_by_id = {}\n        for chunk in create_chunks(project_role_ids):\n            project_role_ids = self.join_filter_values(chunk)\n            for project_role in session.query(\n                \"select id, project_id, user_security_role_id\"\n                \" from UserSecurityRoleProject\"\n                f\" where user_security_role_id in ({project_role_ids})\"\n            ).all():\n                role_id = project_role[\"user_security_role_id\"]\n                project_roles_by_id.setdefault(role_id, []).append(\n                    project_role\n                )\n\n        ftrack_projects: List[FtrackEntity] = session.query(\n            \"select id, full_name, is_private from Project\"\n        )\n        users_mapping: Dict[str, Union[str, None]] = (\n            map_ftrack_users_to_ayon_users(ftrack_users)\n        )\n        for ftrack_id, ayon_user_name in users_mapping.items():\n            ftrack_user = ftrack_users_by_id[ftrack_id]\n            ftrack_username = ftrack_user[\"username\"].split(\"@\", 1)[0]\n            self.log.debug(f\"Processing ftrack user {ftrack_username}\")\n\n            ayon_user_data = {\n                \"ftrack\": {\n                    \"id\": ftrack_id,\n                    \"username\": ftrack_user[\"username\"],\n                }\n            }\n\n            ayon_role = ayon_role_by_user_id[ftrack_id]\n\n            attrib = {}\n            if ftrack_user[\"email\"]:\n                attrib[\"email\"] = ftrack_user[\"email\"]\n\n            full_name_items = []\n            for key in \"first_name\", \"last_name\":\n                value = ftrack_user[key]\n                if value:\n                    full_name_items.append(value)\n\n            if full_name_items:\n                attrib[\"fullName\"] = \" \".join(full_name_items)\n\n            is_admin = ayon_role == \"admin\"\n            is_manager = ayon_role == \"manager\"\n            if not ayon_user_name:\n                self.log.debug(\"User does not exist in AYON yet, creating...\")\n                ayon_user_data[\"isAdmin\"] = is_admin\n                ayon_user_data[\"isManger\"] = is_manager\n                # Create new user\n                if not is_admin and not is_manager:\n                    # TODO use predefined endpoints (are not available\n                    #   at the moment of this PR)\n                    ayon_user_data[\"defaultAccessGroups\"] = list(\n                        access_groups\n                    )\n                    ayon_user_data[\"accessGroups\"] = (\n                        self._calculate_default_access_groups(\n                            ftrack_projects,\n                            user_roles_by_user_id[ftrack_id],\n                            project_roles_by_id,\n                            access_groups,\n                        )\n                    )\n\n                new_ayon_user = {\n                    \"active\": ftrack_user[\"is_active\"],\n                    \"data\": ayon_user_data,\n                }\n                if attrib:\n                    new_ayon_user[\"attrib\"] = attrib\n                response = ayon_api.put(\n                    f\"users/{ftrack_username}\",\n                    **new_ayon_user,\n                )\n                if response.status_code != 204:\n                    self.log.error(\n                        f\"Failed to create user {ftrack_username}:\"\n                        f\" {response.data}\"\n                    )\n                self.log.debug(f\"AYON user {ftrack_username} created.\")\n                continue\n\n            self.log.debug(\n                f\"Mapped ftrack user {ftrack_username}\"\n                f\" to AYON user {ayon_user_name}, updating...\"\n            )\n            # Fetch user with REST to get 'data'\n            ayon_user = ayon_api.get_user(ayon_user_name)\n            user_diffs = {}\n            if ftrack_user[\"is_active\"] != ayon_user[\"active\"]:\n                user_diffs[\"active\"] = ftrack_user[\"is_active\"]\n\n            # Comapre 'data' field\n            current_user_data = ayon_user[\"data\"]\n            data_diffs = {}\n            if \"ftrack\" in current_user_data:\n                ayon_user_ftrack_data = current_user_data[\"ftrack\"]\n                for key, value in ayon_user_data[\"ftrack\"].items():\n                    if (\n                        key not in ayon_user_ftrack_data\n                        or ayon_user_ftrack_data[key] != value\n                    ):\n                        ayon_user_ftrack_data.update(ayon_user_data[\"ftrack\"])\n                        data_diffs[\"ftrack\"] = ayon_user_ftrack_data\n                        break\n\n            if ayon_role == \"admin\":\n                if not current_user_data.get(\"isAdmin\"):\n                    data_diffs[\"isAdmin\"] = True\n                    if current_user_data.get(\"isManger\"):\n                        data_diffs[\"isManger\"] = False\n\n            elif ayon_role == \"manager\":\n                if not current_user_data.get(\"isManger\"):\n                    data_diffs[\"isManger\"] = True\n                    if current_user_data.get(\"isAdmin\"):\n                        data_diffs[\"isAdmin\"] = False\n\n            elif ayon_role == \"artist\":\n                became_artist = False\n                if current_user_data.get(\"isAdmin\"):\n                    became_artist = True\n                    data_diffs[\"isAdmin\"] = False\n\n                if current_user_data.get(\"isManger\"):\n                    became_artist = True\n                    data_diffs[\"isManger\"] = False\n\n                # User will become artist and we need to update access groups\n                if became_artist:\n                    data_diffs[\"defaultAccessGroups\"] = list(\n                        access_groups\n                    )\n                    data_diffs[\"accessGroups\"] = (\n                        self._calculate_default_access_groups(\n                            ftrack_projects,\n                            user_roles_by_user_id[ftrack_id],\n                            project_roles_by_id,\n                            access_groups,\n                        )\n                    )\n\n            if data_diffs:\n                user_diffs[\"data\"] = data_diffs\n\n            # Compare 'attrib' fields\n            for key, value in attrib.items():\n                if ayon_user[\"attrib\"].get(key) != value:\n                    attrib_diffs = user_diffs.setdefault(\"attrib\", {})\n                    attrib_diffs[key] = value\n\n            if user_diffs:\n                ayon_api.patch(\n                    f\"users/{ayon_user_name}\",\n                    **user_diffs,\n                )\n            self.log.debug(f\"AYON user {ftrack_username} updated.\")\n\n        self.log.info(\"Synchronization finished\")\n        return True\n\n    def _calculate_default_access_groups(\n        self,\n        ftrack_projects,\n        user_security_roles,\n        project_roles_by_id,\n        access_groups,\n    ):\n        available_project_names = []\n        project_names = set(ayon_api.get_project_names(active=None))\n\n        allow_public_projects = any(\n            user_security_role[\"is_all_projects\"]\n            for user_security_role in user_security_roles\n        )\n        project_ids = set()\n        for user_security_role in user_security_roles:\n            # QUESTION: Maybe we should check what role it is?\n            role_id = user_security_role[\"id\"]\n            project_roles = project_roles_by_id.get(role_id, [])\n            for project_role in project_roles:\n                project_ids.add(project_role[\"project_id\"])\n\n        for ftrack_project in ftrack_projects:\n            project_name = ftrack_project[\"full_name\"]\n            # Skip projects that are not in AYON\n            if project_name not in project_names:\n                continue\n\n            # Public project\n            if not ftrack_project[\"is_private\"]:\n                # Add access if user has access to all public projects\n                if allow_public_projects:\n                    available_project_names.append(project_name)\n                continue\n\n            if ftrack_project[\"id\"] in project_ids:\n                available_project_names.append(project_name)\n\n        return {\n            project_name: list(access_groups)\n            for project_name in available_project_names\n        }\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_sync_users.html#services.processor.processor.default_handlers.action_sync_users.SyncUsersFromFtrackAction.discover","title":"<code>discover(session, entities, event)</code>","text":"<p>Show only on project.</p> Source code in <code>services/processor/processor/default_handlers/action_sync_users.py</code> <pre><code>def discover(self, session, entities, event):\n    \"\"\"Show only on project.\"\"\"\n    if (\n        len(entities) != 1\n        or entities[0].entity_type.lower() != \"project\"\n    ):\n        return False\n    return self.valid_roles(session, entities, event)\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_tranfer_hierarchical_values.html","title":"action_tranfer_hierarchical_values","text":""},{"location":"autoapi/services/processor/processor/default_handlers/action_tranfer_hierarchical_values.html#services.processor.processor.default_handlers.action_tranfer_hierarchical_values.TransferHierarchicalValues","title":"<code>TransferHierarchicalValues</code>","text":"<p>               Bases: <code>ServerAction</code></p> <p>Transfer values across hierarhcical attributes.</p> <p>Aalso gives ability to convert types meanwhile. That is limited to conversions between numbers and strings - int &lt;-&gt; float - in, float -&gt; string</p> Source code in <code>services/processor/processor/default_handlers/action_tranfer_hierarchical_values.py</code> <pre><code>class TransferHierarchicalValues(ServerAction):\n    \"\"\"Transfer values across hierarhcical attributes.\n\n    Aalso gives ability to convert types meanwhile. That is limited to\n    conversions between numbers and strings\n    - int &lt;-&gt; float\n    - in, float -&gt; string\n    \"\"\"\n\n    identifier = \"ayon.transfer.hierarchical.values\"\n    label = \"AYON Admin\"\n    variant = \"- Transfer values between 2 custom attributes\"\n    description = (\n        \"Move values from a hierarchical attribute to\"\n        \" second hierarchical attribute.\"\n    )\n    icon = get_service_ftrack_icon_url(\"AYONAdmin.svg\")\n\n    all_project_entities_query = (\n        \"select id, name, parent_id, link\"\n        \" from TypedContext where project_id is \\\"{}\\\"\"\n    )\n    cust_attr_query = (\n        \"select value, entity_id from CustomAttributeValue\"\n        \" where entity_id in ({}) and configuration_id is \\\"{}\\\"\"\n    )\n    settings_key = \"transfer_values_of_hierarchical_attributes\"\n\n    def discover(self, session, entities, event):\n        \"\"\"Show anywhere.\"\"\"\n\n        return self.valid_roles(session, entities, event)\n\n    def _selection_interface(self, session, event_values=None):\n        title = \"Transfer hierarchical values\"\n\n        attr_confs = session.query(\n            (\n                \"select id, key from CustomAttributeConfiguration\"\n                \" where is_hierarchical is true\"\n            )\n        ).all()\n        attr_items = []\n        for attr_conf in attr_confs:\n            attr_items.append({\n                \"value\": attr_conf[\"id\"],\n                \"label\": attr_conf[\"key\"]\n            })\n\n        if len(attr_items) &lt; 2:\n            return {\n                \"title\": title,\n                \"items\": [{\n                    \"type\": \"label\",\n                    \"value\": (\n                        \"Didn't found custom attributes\"\n                        \" that can be transfered.\"\n                    )\n                }]\n            }\n\n        attr_items = sorted(attr_items, key=lambda item: item[\"label\"])\n        items = []\n        item_splitter = {\"type\": \"label\", \"value\": \"---\"}\n        items.append({\n            \"type\": \"label\",\n            \"value\": (\n                \"&lt;h2&gt;Please select source and destination\"\n                \" Custom attribute&lt;/h2&gt;\"\n            )\n        })\n        items.append({\n            \"type\": \"label\",\n            \"value\": (\n                \"&lt;b&gt;WARNING:&lt;/b&gt; This will take affect for all projects!\"\n            )\n        })\n        if event_values:\n            items.append({\n                \"type\": \"label\",\n                \"value\": (\n                    \"&lt;b&gt;Note:&lt;/b&gt; Please select 2 different custom attributes.\"\n                )\n            })\n\n        items.append(item_splitter)\n\n        src_item = {\n            \"type\": \"enumerator\",\n            \"label\": \"Source\",\n            \"name\": \"src_attr_id\",\n            \"data\": copy.deepcopy(attr_items)\n        }\n        dst_item = {\n            \"type\": \"enumerator\",\n            \"label\": \"Destination\",\n            \"name\": \"dst_attr_id\",\n            \"data\": copy.deepcopy(attr_items)\n        }\n        delete_item = {\n            \"type\": \"boolean\",\n            \"name\": \"delete_dst_attr_first\",\n            \"label\": \"Delete first\",\n            \"value\": False\n        }\n        if event_values:\n            src_item[\"value\"] = event_values[\"src_attr_id\"]\n            dst_item[\"value\"] = event_values[\"dst_attr_id\"]\n            delete_item[\"value\"] = event_values[\"delete_dst_attr_first\"]\n\n        items.append(src_item)\n        items.append(dst_item)\n        items.append(item_splitter)\n        items.append({\n            \"type\": \"label\",\n            \"value\": (\n                \"&lt;b&gt;WARNING:&lt;/b&gt; All values from destination\"\n                \" Custom Attribute will be removed if this is enabled.\"\n            )\n        })\n        items.append(delete_item)\n\n        return {\n            \"title\": title,\n            \"items\": items\n        }\n\n    def interface(self, session, entities, event):\n        if event[\"data\"].get(\"values\", {}):\n            return None\n\n        return self._selection_interface(session)\n\n    def launch(self, session, entities, event):\n        values = event[\"data\"].get(\"values\", {})\n        if not values:\n            return None\n        src_attr_id = values[\"src_attr_id\"]\n        dst_attr_id = values[\"dst_attr_id\"]\n        delete_dst_values = values[\"delete_dst_attr_first\"]\n\n        if not src_attr_id or not dst_attr_id:\n            self.log.info(\"Attributes were not filled. Nothing to do.\")\n            return {\n                \"success\": True,\n                \"message\": \"Nothing to do\"\n            }\n\n        if src_attr_id == dst_attr_id:\n            self.log.info((\n                \"Same attributes were selected {}, {}.\"\n                \" Showing interface again.\"\n            ).format(src_attr_id, dst_attr_id))\n            return self._selection_interface(session, values)\n\n        # Query custom attrbutes\n        src_conf = session.query((\n            \"select id from CustomAttributeConfiguration where id is {}\"\n        ).format(src_attr_id)).one()\n        dst_conf = session.query((\n            \"select id from CustomAttributeConfiguration where id is {}\"\n        ).format(dst_attr_id)).one()\n        src_type_name = src_conf[\"type\"][\"name\"]\n        dst_type_name = dst_conf[\"type\"][\"name\"]\n        # Limit conversion to\n        # - same type -&gt; same type (there is no need to do conversion)\n        # - number &lt;Any&gt; -&gt; number &lt;Any&gt; (int to float and back)\n        # - number &lt;Any&gt; -&gt; str (any number can be converted to str)\n        src_type = None\n        dst_type = None\n        if src_type_name == \"number\" or src_type_name != dst_type_name:\n            src_type = self._get_attr_type(dst_conf)\n            dst_type = self._get_attr_type(dst_conf)\n            valid = False\n            # Can convert numbers\n            if src_type in (int, float) and dst_type in (int, float):\n                valid = True\n            # Can convert numbers to string\n            elif dst_type is str:\n                valid = True\n\n            if not valid:\n                self.log.info((\n                    \"Don't know how to properly convert\"\n                    \" custom attribute types {} &gt; {}\"\n                ).format(src_type_name, dst_type_name))\n                return {\n                    \"message\": (\n                        \"Don't know how to properly convert\"\n                        \" custom attribute types {} &gt; {}\"\n                    ).format(src_type_name, dst_type_name),\n                    \"success\": False\n                }\n\n        # Query source values\n        src_attr_values = session.query(\n            (\n                \"select value, entity_id\"\n                \" from CustomAttributeValue\"\n                \" where configuration_id is {}\"\n            ).format(src_attr_id)\n        ).all()\n\n        self.log.debug(\"Queried source values.\")\n        failed_entity_ids = []\n        if dst_type is not None:\n            self.log.debug(\"Converting source values to desctination type\")\n            value_by_id = {}\n            for attr_value in src_attr_values:\n                entity_id = attr_value[\"entity_id\"]\n                value = attr_value[\"value\"]\n                if value is not None:\n                    try:\n                        if dst_type is not None:\n                            value = dst_type(value)\n                        value_by_id[entity_id] = value\n                    except Exception:\n                        failed_entity_ids.append(entity_id)\n\n        if failed_entity_ids:\n            self.log.info(\n                \"Couldn't convert some values to destination attribute\"\n            )\n            return {\n                \"success\": False,\n                \"message\": (\n                    \"Couldn't convert some values to destination attribute\"\n                )\n            }\n\n        # Delete destination custom attributes first\n        if delete_dst_values:\n            self.log.info(\"Deleting destination custom attribute values first\")\n            self._delete_custom_attribute_values(session, dst_attr_id)\n\n        self.log.info(\"Applying source values on destination custom attribute\")\n        self._apply_values(session, value_by_id, dst_attr_id)\n        return True\n\n    def _delete_custom_attribute_values(self, session, dst_attr_id):\n        dst_attr_values = session.query(\n            (\n                \"select configuration_id, entity_id\"\n                \" from CustomAttributeValue\"\n                \" where configuration_id is {}\"\n            ).format(dst_attr_id)\n        ).all()\n        delete_operations = []\n        for attr_value in dst_attr_values:\n            entity_id = attr_value[\"entity_id\"]\n            configuration_id = attr_value[\"configuration_id\"]\n            entity_key = collections.OrderedDict((\n                (\"configuration_id\", configuration_id),\n                (\"entity_id\", entity_id)\n            ))\n            delete_operations.append(\n                ftrack_api.operation.DeleteEntityOperation(\n                    \"CustomAttributeValue\",\n                    entity_key\n                )\n            )\n\n        if not delete_operations:\n            return\n\n        for chunk in create_chunks(delete_operations, 500):\n            for operation in chunk:\n                session.recorded_operations.push(operation)\n            session.commit()\n\n    def _apply_values(self, session, value_by_id, dst_attr_id):\n        dst_attr_values = session.query(\n            (\n                \"select configuration_id, entity_id\"\n                \" from CustomAttributeValue\"\n                \" where configuration_id is {}\"\n            ).format(dst_attr_id)\n        ).all()\n\n        dst_entity_ids_with_value = {\n            item[\"entity_id\"]\n            for item in dst_attr_values\n        }\n        operations = []\n        for entity_id, value in value_by_id.items():\n            entity_key = collections.OrderedDict((\n                (\"configuration_id\", dst_attr_id),\n                (\"entity_id\", entity_id)\n            ))\n            if entity_id in dst_entity_ids_with_value:\n                operations.append(\n                    ftrack_api.operation.UpdateEntityOperation(\n                        \"CustomAttributeValue\",\n                        entity_key,\n                        \"value\",\n                        ftrack_api.symbol.NOT_SET,\n                        value\n                    )\n                )\n            else:\n                operations.append(\n                    ftrack_api.operation.CreateEntityOperation(\n                        \"CustomAttributeValue\",\n                        entity_key,\n                        {\"value\": value}\n                    )\n                )\n\n        if not operations:\n            return\n\n        for chunk in create_chunks(operations, 500):\n            for operation in chunk:\n                session.recorded_operations.push(operation)\n            session.commit()\n\n    def _get_attr_type(self, conf_def):\n        type_name = conf_def[\"type\"][\"name\"]\n        if type_name == \"text\":\n            return str\n\n        if type_name == \"number\":\n            config = json.loads(conf_def[\"config\"])\n            if config[\"isdecimal\"]:\n                return float\n            return int\n        return None\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/action_tranfer_hierarchical_values.html#services.processor.processor.default_handlers.action_tranfer_hierarchical_values.TransferHierarchicalValues.discover","title":"<code>discover(session, entities, event)</code>","text":"<p>Show anywhere.</p> Source code in <code>services/processor/processor/default_handlers/action_tranfer_hierarchical_values.py</code> <pre><code>def discover(self, session, entities, event):\n    \"\"\"Show anywhere.\"\"\"\n\n    return self.valid_roles(session, entities, event)\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_first_version_status.html","title":"event_first_version_status","text":""},{"location":"autoapi/services/processor/processor/default_handlers/event_first_version_status.html#services.processor.processor.default_handlers.event_first_version_status.FirstVersionStatus","title":"<code>FirstVersionStatus</code>","text":"<p>               Bases: <code>BaseEventHandler</code></p> Source code in <code>services/processor/processor/default_handlers/event_first_version_status.py</code> <pre><code>class FirstVersionStatus(BaseEventHandler):\n\n    # WARNING Priority MUST be higher\n    # than handler in `event_version_to_task_statuses.py`\n    priority = 200\n\n    keys_enum = [\"task\", \"task_type\"]\n    # This should be set with presets\n    task_status_map = []\n\n    # EXAMPLE of `task_status_map`\n    __example_status_map__ = [{\n        # `key` specify where to look for name (is enumerator of `keys_enum`)\n        # By default is set to \"task\"\n        \"key\": \"task\",\n        # speicification of name\n        \"name\": \"compositing\",\n        # Status to set to the asset version\n        \"status\": \"Blocking\"\n    }]\n\n    def register(self, *args, **kwargs):\n        result = super(FirstVersionStatus, self).register(*args, **kwargs)\n\n        valid_task_status_map = []\n        for item in self.task_status_map:\n            key = (item.get(\"key\") or \"task\").lower()\n            name = (item.get(\"name\") or \"\").lower()\n            status = (item.get(\"status\") or \"\").lower()\n            if not (key and name and status):\n                self.log.warning((\n                    \"Invalid item in Task -&gt; Status mapping. {}\"\n                ).format(str(item)))\n                continue\n\n            if key not in self.keys_enum:\n                expected_msg = \"\"\n                last_key_idx = len(self.keys_enum) - 1\n                for idx, key in enumerate(self.keys_enum):\n                    if idx == 0:\n                        joining_part = \"`{}`\"\n                    elif idx == last_key_idx:\n                        joining_part = \"or `{}`\"\n                    else:\n                        joining_part = \", `{}`\"\n                    expected_msg += joining_part.format(key)\n\n                self.log.warning((\n                    \"Invalid key `{}`. Expected: {}.\"\n                ).format(key, expected_msg))\n                continue\n\n            valid_task_status_map.append({\n                \"key\": key,\n                \"name\": name,\n                \"status\": status\n            })\n\n        self.task_status_map = valid_task_status_map\n        if not self.task_status_map:\n            self.log.warning((\n                \"Event handler `{}` don't have set presets.\"\n            ).format(self.__class__.__name__))\n\n        return result\n\n    def launch(self, session, event):\n        \"\"\"Set task's status for first created Asset Version.\"\"\"\n\n        if not self.task_status_map:\n            return\n\n        filtered_entities_info = self.filter_entities_info(event)\n        if not filtered_entities_info:\n            return\n\n        for project_id, entities_info in filtered_entities_info.items():\n            self.process_by_project(session, event, project_id, entities_info)\n\n    def process_by_project(self, session, event, project_id, entities_info):\n        project_name = self.get_project_name_from_event(\n            session, event, project_id\n        )\n\n        if not self.get_ayon_project_from_event(event, project_name):\n            self.log.debug(\n                f\"Project '{project_name}' not found in AYON. Skipping\"\n            )\n            return\n\n        entity_ids = []\n        for entity_info in entities_info:\n            entity_ids.append(entity_info[\"entityId\"])\n\n        joined_entity_ids = \",\".join(\n            [\"\\\"{}\\\"\".format(entity_id) for entity_id in entity_ids]\n        )\n        asset_versions = session.query(\n            \"AssetVersion where id in ({})\".format(joined_entity_ids)\n        ).all()\n\n        asset_version_statuses = None\n\n        project_schema = None\n        for asset_version in asset_versions:\n            task_entity = asset_version[\"task\"]\n            found_item = None\n            for item in self.task_status_map:\n                if (\n                    item[\"key\"] == \"task\" and\n                    task_entity[\"name\"].lower() != item[\"name\"]\n                ):\n                    continue\n\n                elif (\n                    item[\"key\"] == \"task_type\" and\n                    task_entity[\"type\"][\"name\"].lower() != item[\"name\"]\n                ):\n                    continue\n\n                found_item = item\n                break\n\n            if not found_item:\n                continue\n\n            if project_schema is None:\n                project_schema = task_entity[\"project\"][\"project_schema\"]\n\n            # Get all available statuses for Task\n            if asset_version_statuses is None:\n                statuses = project_schema.get_statuses(\"AssetVersion\")\n\n                # map lowered status name with it's object\n                asset_version_statuses = {\n                    status[\"name\"].lower(): status for status in statuses\n                }\n\n            ent_path = \"/\".join(\n                [ent[\"name\"] for ent in task_entity[\"link\"]] +\n                [\n                    str(asset_version[\"asset\"][\"name\"]),\n                    str(asset_version[\"version\"])\n                ]\n            )\n\n            new_status = asset_version_statuses.get(found_item[\"status\"])\n            if not new_status:\n                self.log.warning(\n                    \"AssetVersion doesn't have status `{}`.\"\n                ).format(found_item[\"status\"])\n                continue\n\n            try:\n                asset_version[\"status\"] = new_status\n                session.commit()\n                self.log.debug(\"[ {} ] Status updated to [ {} ]\".format(\n                    ent_path, new_status['name']\n                ))\n\n            except Exception:\n                session.rollback()\n                self.log.warning(\n                    \"[ {} ] Status couldn't be set.\".format(ent_path),\n                    exc_info=True\n                )\n\n    def filter_entities_info(self, event):\n        filtered_entities_info = collections.defaultdict(list)\n        for entity_info in event[\"data\"].get(\"entities\", []):\n            # Care only about add actions\n            if entity_info.get(\"action\") != \"add\":\n                continue\n\n            # Filter AssetVersions\n            if entity_info[\"entityType\"] != \"assetversion\":\n                continue\n\n            entity_changes = entity_info.get(\"changes\") or {}\n\n            # Check if version of Asset Version is `1`\n            version_num = entity_changes.get(\"version\", {}).get(\"new\")\n            if version_num != 1:\n                continue\n\n            # Skip in Asset Version don't have task\n            task_id = entity_changes.get(\"taskid\", {}).get(\"new\")\n            if not task_id:\n                continue\n\n            project_id = None\n            for parent_item in reversed(entity_info[\"parents\"]):\n                if parent_item[\"entityType\"] == \"show\":\n                    project_id = parent_item[\"entityId\"]\n                    break\n\n            if project_id is None:\n                continue\n\n            filtered_entities_info[project_id].append(entity_info)\n\n        return filtered_entities_info\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_first_version_status.html#services.processor.processor.default_handlers.event_first_version_status.FirstVersionStatus.launch","title":"<code>launch(session, event)</code>","text":"<p>Set task's status for first created Asset Version.</p> Source code in <code>services/processor/processor/default_handlers/event_first_version_status.py</code> <pre><code>def launch(self, session, event):\n    \"\"\"Set task's status for first created Asset Version.\"\"\"\n\n    if not self.task_status_map:\n        return\n\n    filtered_entities_info = self.filter_entities_info(event)\n    if not filtered_entities_info:\n        return\n\n    for project_id, entities_info in filtered_entities_info.items():\n        self.process_by_project(session, event, project_id, entities_info)\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_next_task_update.html","title":"event_next_task_update","text":""},{"location":"autoapi/services/processor/processor/default_handlers/event_next_task_update.html#services.processor.processor.default_handlers.event_next_task_update.NextTaskUpdate","title":"<code>NextTaskUpdate</code>","text":"<p>               Bases: <code>BaseEventHandler</code></p> <p>Change status on following Task.</p> <p>Handler cares about changes of status id on Task entities. When new status has state \"Done\" it will try to find following task and change it's status. It is expected following task should be marked as \"Ready to work on\".</p> <p>By default all tasks with same task type must have state \"Done\" to do any changes. And when all tasks with same task type are \"done\" it will change statuses on all tasks with next task type.</p>"},{"location":"autoapi/services/processor/processor/default_handlers/event_next_task_update.html#services.processor.processor.default_handlers.event_next_task_update.NextTaskUpdate--enable","title":"Enable","text":"<p>Handler is based on settings, handler can be turned on/off with \"enabled\" key.</p> <pre><code>\"enabled\": True\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_next_task_update.html#services.processor.processor.default_handlers.event_next_task_update.NextTaskUpdate--status-mappings","title":"Status mappings","text":"<p>Must have set mappings of new statuses:</p> <pre><code>\"mapping\": {\n    # From -&gt; To\n    \"Not Ready\": \"Ready\",\n    ...\n}\n</code></pre> <p>If current status name is not found then status change is skipped.</p>"},{"location":"autoapi/services/processor/processor/default_handlers/event_next_task_update.html#services.processor.processor.default_handlers.event_next_task_update.NextTaskUpdate--ignored-statuses","title":"Ignored statuses","text":"<p>These status names are skipping as they would be in \"Done\" state. Best example is status \"Omitted\" which in most of cases is \"Blocked\" state but it will never change.</p> <pre><code>\"ignored_statuses\": [\n    \"Omitted\",\n    ...\n]\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_next_task_update.html#services.processor.processor.default_handlers.event_next_task_update.NextTaskUpdate--change-statuses-sorted-by-task-type-and-by-name","title":"Change statuses sorted by task type and by name","text":"<p>Change behaviour of task type batching. Statuses are not checked and set by batches of tasks by Task type but one by one. Tasks are sorted by Task type and then by name if all previous tasks are \"Done\" the following will change status.</p> <pre><code>\"name_sorting\": True\n</code></pre> Source code in <code>services/processor/processor/default_handlers/event_next_task_update.py</code> <pre><code>class NextTaskUpdate(BaseEventHandler):\n    \"\"\"Change status on following Task.\n\n    Handler cares about changes of status id on Task entities. When new status\n    has state \"Done\" it will try to find following task and change it's status.\n    It is expected following task should be marked as \"Ready to work on\".\n\n    By default all tasks with same task type must have state \"Done\" to do any\n    changes. And when all tasks with same task type are \"done\" it will change\n    statuses on all tasks with next task type.\n\n    # Enable\n    Handler is based on settings, handler can be turned on/off with \"enabled\"\n    key.\n    ```\n    \"enabled\": True\n    ```\n\n    # Status mappings\n    Must have set mappings of new statuses:\n    ```\n    \"mapping\": {\n        # From -&gt; To\n        \"Not Ready\": \"Ready\",\n        ...\n    }\n    ```\n\n    If current status name is not found then status change is skipped.\n\n    # Ignored statuses\n    These status names are skipping as they would be in \"Done\" state. Best\n    example is status \"Omitted\" which in most of cases is \"Blocked\" state but\n    it will never change.\n    ```\n    \"ignored_statuses\": [\n        \"Omitted\",\n        ...\n    ]\n    ```\n\n    # Change statuses sorted by task type and by name\n    Change behaviour of task type batching. Statuses are not checked and set\n    by batches of tasks by Task type but one by one. Tasks are sorted by\n    Task type and then by name if all previous tasks are \"Done\" the following\n    will change status.\n    ```\n    \"name_sorting\": True\n    ```\n    \"\"\"\n    settings_key = \"next_task_update\"\n\n    def launch(self, session, event):\n        '''Propagates status from version to task when changed'''\n\n        filtered_entities_info = self.filter_entities_info(event)\n        if not filtered_entities_info:\n            return\n\n        for project_id, entities_info in filtered_entities_info.items():\n            self.process_by_project(session, event, project_id, entities_info)\n\n    def filter_entities_info(self, event):\n        # Filter if event contain relevant data\n        entities_info = event[\"data\"].get(\"entities\")\n        if not entities_info:\n            return\n\n        filtered_entities_info = collections.defaultdict(list)\n        for entity_info in entities_info:\n            # Care only about Task `entity_type`\n            if entity_info.get(\"entity_type\") != \"Task\":\n                continue\n\n            # Care only about changes of status\n            changes = entity_info.get(\"changes\") or {}\n            statusid_changes = changes.get(\"statusid\") or {}\n            if (\n                statusid_changes.get(\"new\") is None\n                or statusid_changes.get(\"old\") is None\n            ):\n                continue\n\n            project_id = None\n            for parent_info in reversed(entity_info[\"parents\"]):\n                if parent_info[\"entityType\"] == \"show\":\n                    project_id = parent_info[\"entityId\"]\n                    break\n\n            if project_id:\n                filtered_entities_info[project_id].append(entity_info)\n        return filtered_entities_info\n\n    def process_by_project(self, session, event, project_id, _entities_info):\n        project_name = self.get_project_name_from_event(\n            session, event, project_id\n        )\n        if not self.get_ayon_project_from_event(event, project_name):\n            self.log.debug(\n                f\"Project '{project_name}' not found in AYON. Skipping\"\n            )\n            return\n\n        # Load settings\n        project_settings = self.get_project_settings_from_event(\n            event, project_name\n        )\n        ftrack_settings = project_settings[\"ftrack\"]\n        if not is_ftrack_enabled_in_settings(ftrack_settings):\n            self.log.debug(\"ftrack is disabled for project \\\"{}\\\"\".format(\n                project_name\n            ))\n            return\n\n        # Load status mapping from presets\n        event_settings = (\n            ftrack_settings\n            [\"service_event_handlers\"]\n            [self.settings_key]\n        )\n        if not event_settings[\"enabled\"]:\n            self.log.debug(\"Project \\\"{}\\\" has disabled {}.\".format(\n                project_name, self.__class__.__name__\n            ))\n            return\n\n        mod_mapping = {\n            item[\"name\"]: item[\"value\"]\n            for item in event_settings[\"mapping\"]\n        }\n        event_settings[\"mapping\"] = mod_mapping\n\n        statuses = session.query(\"Status\").all()\n\n        entities_info = self.filter_by_status_state(_entities_info, statuses)\n        if not entities_info:\n            return\n\n        parent_ids = set()\n        event_task_ids_by_parent_id = collections.defaultdict(list)\n        for entity_info in entities_info:\n            parent_id = entity_info[\"parentId\"]\n            entity_id = entity_info[\"entityId\"]\n            parent_ids.add(parent_id)\n            event_task_ids_by_parent_id[parent_id].append(entity_id)\n\n        # From now it doesn't matter what was in event data\n        task_entities = session.query(\n            (\n                \"select id, type_id, status_id, parent_id, link from Task\"\n                \" where parent_id in ({})\"\n            ).format(self.join_query_keys(parent_ids))\n        ).all()\n\n        tasks_by_parent_id = collections.defaultdict(list)\n        for task_entity in task_entities:\n            tasks_by_parent_id[task_entity[\"parent_id\"]].append(task_entity)\n\n        project_entity = session.get(\"Project\", project_id)\n        self.set_next_task_statuses(\n            session,\n            tasks_by_parent_id,\n            event_task_ids_by_parent_id,\n            statuses,\n            project_entity,\n            event_settings\n        )\n\n    def filter_by_status_state(self, entities_info, statuses):\n        statuses_by_id = {\n            status[\"id\"]: status\n            for status in statuses\n        }\n\n        # Care only about tasks having status with state `Done`\n        filtered_entities_info = []\n        for entity_info in entities_info:\n            status_id = entity_info[\"changes\"][\"statusid\"][\"new\"]\n            status_entity = statuses_by_id[status_id]\n            if status_entity[\"state\"][\"name\"].lower() == \"done\":\n                filtered_entities_info.append(entity_info)\n        return filtered_entities_info\n\n    def set_next_task_statuses(\n        self,\n        session,\n        tasks_by_parent_id,\n        event_task_ids_by_parent_id,\n        statuses,\n        project_entity,\n        event_settings\n    ):\n        statuses_by_id = {\n            status[\"id\"]: status\n            for status in statuses\n        }\n\n        # Lower ignored statuses\n        ignored_statuses = set(\n            status_name.lower()\n            for status_name in event_settings[\"ignored_statuses\"]\n        )\n        # Lower both key and value of mapped statuses\n        mapping = {\n            status_from.lower(): status_to.lower()\n            for status_from, status_to in event_settings[\"mapping\"].items()\n        }\n        # Should use name sorting or not\n        name_sorting = event_settings[\"name_sorting\"]\n\n        # Collect task type ids from changed entities\n        task_type_ids = set()\n        for task_entities in tasks_by_parent_id.values():\n            for task_entity in task_entities:\n                task_type_ids.add(task_entity[\"type_id\"])\n\n        statusese_by_obj_id = self.statuses_for_tasks(\n            task_type_ids, project_entity\n        )\n\n        sorted_task_type_ids = self.get_sorted_task_type_ids(session)\n\n        for parent_id, _task_entities in tasks_by_parent_id.items():\n            task_entities_by_type_id = collections.defaultdict(list)\n            for _task_entity in _task_entities:\n                type_id = _task_entity[\"type_id\"]\n                task_entities_by_type_id[type_id].append(_task_entity)\n\n            event_ids = set(event_task_ids_by_parent_id[parent_id])\n            if name_sorting:\n                # Sort entities by name\n                self.sort_by_name_task_entities_by_type(\n                    task_entities_by_type_id\n                )\n                # Sort entities by type id\n                sorted_task_entities = []\n                for type_id in sorted_task_type_ids:\n                    task_entities = task_entities_by_type_id.get(type_id)\n                    if task_entities:\n                        sorted_task_entities.extend(task_entities)\n\n                next_tasks = self.next_tasks_with_name_sorting(\n                    sorted_task_entities,\n                    event_ids,\n                    statuses_by_id,\n                    ignored_statuses\n                )\n\n            else:\n                next_tasks = self.next_tasks_with_type_sorting(\n                    task_entities_by_type_id,\n                    sorted_task_type_ids,\n                    event_ids,\n                    statuses_by_id,\n                    ignored_statuses\n                )\n\n        for task_entity in next_tasks:\n            if task_entity[\"status\"][\"state\"][\"name\"].lower() == \"done\":\n                continue\n\n            task_status = statuses_by_id[task_entity[\"status_id\"]]\n            old_status_name = task_status[\"name\"].lower()\n            if old_status_name in ignored_statuses:\n                continue\n\n            new_task_name = mapping.get(old_status_name)\n            if not new_task_name:\n                self.log.debug(\n                    \"Didn't found mapping for status \\\"{}\\\".\".format(\n                        task_status[\"name\"]\n                    )\n                )\n                continue\n\n            ent_path = \"/\".join(\n                [ent[\"name\"] for ent in task_entity[\"link\"]]\n            )\n            type_id = task_entity[\"type_id\"]\n            new_status = statusese_by_obj_id[type_id].get(new_task_name)\n            if new_status is None:\n                self.log.warning((\n                    \"\\\"{}\\\" does not have available status name \\\"{}\\\"\"\n                ).format(ent_path, new_task_name))\n                continue\n\n            try:\n                task_entity[\"status_id\"] = new_status[\"id\"]\n                session.commit()\n                self.log.info(\n                    \"\\\"{}\\\" updated status to \\\"{}\\\"\".format(\n                        ent_path, new_status[\"name\"]\n                    )\n                )\n            except Exception:\n                session.rollback()\n                self.log.warning(\n                    \"\\\"{}\\\" status couldnt be set to \\\"{}\\\"\".format(\n                        ent_path, new_status[\"name\"]\n                    ),\n                    exc_info=True\n                )\n\n    def next_tasks_with_name_sorting(\n        self,\n        sorted_task_entities,\n        event_ids,\n        statuses_by_id,\n        ignored_statuses,\n    ):\n        # Pre sort task entities by name\n        use_next_task = False\n        next_tasks = []\n        for task_entity in sorted_task_entities:\n            if task_entity[\"id\"] in event_ids:\n                event_ids.remove(task_entity[\"id\"])\n                use_next_task = True\n                continue\n\n            if not use_next_task:\n                continue\n\n            task_status = statuses_by_id[task_entity[\"status_id\"]]\n            low_status_name = task_status[\"name\"].lower()\n            if low_status_name in ignored_statuses:\n                continue\n\n            next_tasks.append(task_entity)\n            use_next_task = False\n            if not event_ids:\n                break\n\n        return next_tasks\n\n    def check_statuses_done(\n        self, task_entities, ignored_statuses, statuses_by_id\n    ):\n        all_are_done = True\n        for task_entity in task_entities:\n            task_status = statuses_by_id[task_entity[\"status_id\"]]\n            low_status_name = task_status[\"name\"].lower()\n            if low_status_name in ignored_statuses:\n                continue\n\n            low_state_name = task_status[\"state\"][\"name\"].lower()\n            if low_state_name != \"done\":\n                all_are_done = False\n                break\n        return all_are_done\n\n    def next_tasks_with_type_sorting(\n        self,\n        task_entities_by_type_id,\n        sorted_task_type_ids,\n        event_ids,\n        statuses_by_id,\n        ignored_statuses\n    ):\n        # `use_next_task` is used only if `name_sorting` is enabled!\n        next_tasks = []\n        use_next_tasks = False\n        for type_id in sorted_task_type_ids:\n            if type_id not in task_entities_by_type_id:\n                continue\n\n            task_entities = task_entities_by_type_id[type_id]\n\n            # Check if any task was in event\n            event_id_in_tasks = False\n            for task_entity in task_entities:\n                task_id = task_entity[\"id\"]\n                if task_id in event_ids:\n                    event_ids.remove(task_id)\n                    event_id_in_tasks = True\n\n            if use_next_tasks:\n                # Check if next tasks are not done already\n                all_in_type_done = self.check_statuses_done(\n                    task_entities, ignored_statuses, statuses_by_id\n                )\n                if all_in_type_done:\n                    continue\n\n                next_tasks.extend(task_entities)\n                use_next_tasks = False\n                if not event_ids:\n                    break\n\n            if not event_id_in_tasks:\n                continue\n\n            all_in_type_done = self.check_statuses_done(\n                task_entities, ignored_statuses, statuses_by_id\n            )\n            use_next_tasks = all_in_type_done\n            if all_in_type_done:\n                continue\n\n            if not event_ids:\n                break\n\n            use_next_tasks = False\n\n        return next_tasks\n\n    def statuses_for_tasks(self, task_type_ids, project_entity):\n        project_schema = project_entity[\"project_schema\"]\n        output = {}\n        for task_type_id in task_type_ids:\n            statuses = project_schema.get_statuses(\"Task\", task_type_id)\n            output[task_type_id] = {\n                status[\"name\"].lower(): status\n                for status in statuses\n            }\n\n        return output\n\n    def get_sorted_task_type_ids(self, session):\n        types_by_order = collections.defaultdict(list)\n        for _type in session.query(\"Type\").all():\n            sort_oder = _type.get(\"sort\")\n            if sort_oder is not None:\n                types_by_order[sort_oder].append(_type[\"id\"])\n\n        types = []\n        for sort_oder in sorted(types_by_order.keys()):\n            types.extend(types_by_order[sort_oder])\n        return types\n\n    @staticmethod\n    def sort_by_name_task_entities_by_type(task_entities_by_type_id):\n        _task_entities_by_type_id = {}\n        for type_id, task_entities in task_entities_by_type_id.items():\n            # Store tasks by name\n            task_entities_by_name = {}\n            for task_entity in task_entities:\n                task_name = task_entity[\"name\"]\n                task_entities_by_name[task_name] = task_entity\n\n            # Store task entities by sorted names\n            sorted_task_entities = []\n            for task_name in sorted(task_entities_by_name.keys()):\n                task_entity = task_entities_by_name[task_name]\n                sorted_task_entities.append(task_entity)\n            # Store result to temp dictionary\n            _task_entities_by_type_id[type_id] = sorted_task_entities\n\n        # Override values in source object\n        for type_id, value in _task_entities_by_type_id.items():\n            task_entities_by_type_id[type_id] = value\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_next_task_update.html#services.processor.processor.default_handlers.event_next_task_update.NextTaskUpdate.launch","title":"<code>launch(session, event)</code>","text":"<p>Propagates status from version to task when changed</p> Source code in <code>services/processor/processor/default_handlers/event_next_task_update.py</code> <pre><code>def launch(self, session, event):\n    '''Propagates status from version to task when changed'''\n\n    filtered_entities_info = self.filter_entities_info(event)\n    if not filtered_entities_info:\n        return\n\n    for project_id, entities_info in filtered_entities_info.items():\n        self.process_by_project(session, event, project_id, entities_info)\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_push_frame_values_to_task.html","title":"event_push_frame_values_to_task","text":""},{"location":"autoapi/services/processor/processor/default_handlers/event_push_frame_values_to_task.html#services.processor.processor.default_handlers.event_push_frame_values_to_task.PushHierValuesToNonHierEvent","title":"<code>PushHierValuesToNonHierEvent</code>","text":"<p>               Bases: <code>BaseEventHandler</code></p> <p>Push value changes between hierarchical and non-hierarchical attributes.</p> <p>Changes of non-hierarchical attributes are pushed to hierarchical and back. The attributes must have same definition of custom attribute.</p> <p>Handler does not handle changes of hierarchical parents. So if entity does not have explicitly set value of hierarchical attribute and any parent would change it the change would not be propagated.</p> <p>The handler also push the value to task entity on task creation     and movement. To push values between hierarchical &amp; non-hierarchical     add 'Task' to entity types in settings.</p> Todos <p>Task attribute values push on create/move should be possible to     enabled by settings.</p> Source code in <code>services/processor/processor/default_handlers/event_push_frame_values_to_task.py</code> <pre><code>class PushHierValuesToNonHierEvent(BaseEventHandler):\n    \"\"\"Push value changes between hierarchical and non-hierarchical attributes.\n\n    Changes of non-hierarchical attributes are pushed to hierarchical and back.\n    The attributes must have same definition of custom attribute.\n\n    Handler does not handle changes of hierarchical parents. So if entity does\n    not have explicitly set value of hierarchical attribute and any parent\n    would change it the change would not be propagated.\n\n    The handler also push the value to task entity on task creation\n        and movement. To push values between hierarchical &amp; non-hierarchical\n        add 'Task' to entity types in settings.\n\n    Todos:\n        Task attribute values push on create/move should be possible to\n            enabled by settings.\n    \"\"\"\n\n    # Ignore event handler by default\n    cust_attrs_query = (\n        \"select id, key, object_type_id, is_hierarchical, default\"\n        \" from CustomAttributeConfiguration\"\n        \" where key in ({})\"\n    )\n\n    _cached_task_object_id = None\n    _cached_interest_object_ids = None\n    _cached_user_id = None\n    _cached_changes = []\n    _max_delta = 30\n\n    settings_key = \"sync_hier_entity_attributes\"\n\n    def filter_entities_info(\n        self, event: ftrack_api.event.base.Event\n    ) -&gt; dict[str, list[dict[str, Any]]]:\n        \"\"\"Basic entities filter info we care about.\n\n        This filtering is first of many filters. This does not query anything\n        from ftrack nor use settings.\n\n        Args:\n            event (ftrack_api.event.base.Event): ftrack event with update\n                information.\n\n        Returns:\n            dict[str, list[dict[str, Any]]]: Filtered entity changes by\n                project id.\n        \"\"\"\n\n        # Filter if event contain relevant data\n        entities_info = event[\"data\"].get(\"entities\")\n        if not entities_info:\n            return\n\n        entities_info_by_project_id = collections.defaultdict(list)\n        for entity_info in entities_info:\n            # Ignore removed entities\n            if entity_info.get(\"action\") == \"remove\":\n                continue\n\n            # Care only about information with changes of entities\n            changes = entity_info.get(\"changes\")\n            if not changes:\n                continue\n\n            # Get project id from entity info\n            project_id = None\n            for parent_item in reversed(entity_info[\"parents\"]):\n                if parent_item[\"entityType\"] == \"show\":\n                    project_id = parent_item[\"entityId\"]\n                    break\n\n            if project_id is None:\n                continue\n\n            entities_info_by_project_id[project_id].append(entity_info)\n\n        return entities_info_by_project_id\n\n    def _get_attrs_configurations(self, session, interest_attributes):\n        \"\"\"Get custom attribute configurations by name.\n\n        Args:\n            session (ftrack_api.Session): ftrack sesson.\n            interest_attributes (list[str]): Names of custom attributes\n                that should be synchronized.\n\n        Returns:\n            tuple[dict[str, list], list]: Attributes by object id and\n                hierarchical attributes.\n        \"\"\"\n\n        attrs = session.query(self.cust_attrs_query.format(\n            self.join_query_keys(interest_attributes)\n        )).all()\n\n        attrs_by_obj_id = collections.defaultdict(list)\n        hier_attrs = []\n        for attr in attrs:\n            if attr[\"is_hierarchical\"]:\n                hier_attrs.append(attr)\n                continue\n            obj_id = attr[\"object_type_id\"]\n            attrs_by_obj_id[obj_id].append(attr)\n        return attrs_by_obj_id, hier_attrs\n\n    def _get_handler_project_settings(\n        self,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event,\n        project_id: str\n    ) -&gt; tuple[set[str], set[str]]:\n        \"\"\"Get handler settings based on the project.\n\n        Args:\n            session (ftrack_api.Session): ftrack session.\n            event (ftrack_api.event.base.Event): ftrack event which triggered\n                the changes.\n            project_id (str): Project id where the current changes are handled.\n\n        Returns:\n            tuple[set[str], set[str]]: Attribute names we care about and\n                entity types we care about.\n        \"\"\"\n\n        project_name: str = self.get_project_name_from_event(\n            session, event, project_id\n        )\n        if not self.get_ayon_project_from_event(event, project_name):\n            self.log.debug(\n                f\"Project '{project_name}' not found in AYON. Skipping\"\n            )\n            return set(), set()\n\n        # Load settings\n        project_settings: dict[str, Any] = (\n            self.get_project_settings_from_event(event, project_name)\n        )\n        # Load status mapping from presets\n        event_settings: dict[str, Any] = (\n            project_settings\n            [\"ftrack\"]\n            [\"service_event_handlers\"]\n            [self.settings_key]\n        )\n        # Skip if event is not enabled\n        if not event_settings[\"enabled\"]:\n            self.log.debug(\"Project \\\"{}\\\" has disabled {}\".format(\n                project_name, self.__class__.__name__\n            ))\n            return set(), set()\n\n        interest_attributes: list[str] = event_settings[\"interest_attributes\"]\n        if not interest_attributes:\n            self.log.info((\n                \"Project \\\"{}\\\" does not have filled 'interest_attributes',\"\n                \" skipping.\"\n            ))\n\n        interest_entity_types: list[str] = (\n            event_settings[\"interest_entity_types\"])\n        if not interest_entity_types:\n            self.log.info((\n                \"Project \\\"{}\\\" does not have filled 'interest_entity_types',\"\n                \" skipping.\"\n            ))\n\n        # Unify possible issues from settings ('Asset Build' -&gt; 'assetbuild')\n        interest_entity_types: set[str] = {\n            entity_type.replace(\" \", \"\").lower()\n            for entity_type in interest_entity_types\n        }\n        return set(interest_attributes), interest_entity_types\n\n    def _entities_filter_by_settings(\n        self,\n        entities_info: list[dict[str, Any]],\n        interest_attributes: set[str],\n        interest_entity_types: set[str]\n    ):\n        new_entities_info = []\n        for entity_info in entities_info:\n            entity_type_low = entity_info[\"entity_type\"].lower()\n\n            changes = entity_info[\"changes\"]\n            # SPECIAL CASE: Capture changes of task created/moved under\n            #   interested entity type\n            if (\n                entity_type_low == \"task\"\n                and \"parent_id\" in changes\n            ):\n                # Direct parent is always second item in 'parents' and 'Task'\n                #   must have at least one parent\n                parent_info = entity_info[\"parents\"][1]\n                parent_entity_type = (\n                    parent_info[\"entity_type\"]\n                    .replace(\" \", \"\")\n                    .lower()\n                )\n                if parent_entity_type in interest_entity_types:\n                    new_entities_info.append(entity_info)\n                    continue\n\n            # Skip if entity type is not enabled for attr value sync\n            if entity_type_low not in interest_entity_types:\n                continue\n\n            valid_attr_change = entity_info.get(\"action\") == \"add\"\n            for attr_key in interest_attributes:\n                if valid_attr_change:\n                    break\n\n                if attr_key not in changes:\n                    continue\n\n                if changes[attr_key][\"new\"] is not None:\n                    valid_attr_change = True\n\n            if not valid_attr_change:\n                continue\n\n            new_entities_info.append(entity_info)\n\n        return new_entities_info\n\n    def propagate_attribute_changes(\n        self,\n        session,\n        interest_attributes,\n        entities_info,\n        attrs_by_obj_id,\n        hier_attrs,\n        real_values_by_entity_id,\n        hier_values_by_entity_id,\n    ):\n        hier_attr_ids_by_key = {\n            attr[\"key\"]: attr[\"id\"]\n            for attr in hier_attrs\n        }\n        filtered_interest_attributes = {\n            attr_name\n            for attr_name in interest_attributes\n            if attr_name in hier_attr_ids_by_key\n        }\n        attrs_keys_by_obj_id = {}\n        for obj_id, attrs in attrs_by_obj_id.items():\n            attrs_keys_by_obj_id[obj_id] = {\n                attr[\"key\"]: attr[\"id\"]\n                for attr in attrs\n            }\n\n        op_changes = []\n        for entity_info in entities_info:\n            entity_id = entity_info[\"entityId\"]\n            obj_id = entity_info[\"objectTypeId\"]\n            # Skip attributes sync if does not have object specific custom\n            #   attribute\n            if obj_id not in attrs_keys_by_obj_id:\n                continue\n            attr_keys = attrs_keys_by_obj_id[obj_id]\n            real_values = real_values_by_entity_id[entity_id]\n            hier_values = hier_values_by_entity_id[entity_id]\n\n            changes = copy.deepcopy(entity_info[\"changes\"])\n            obj_id_attr_keys = {\n                attr_key\n                for attr_key in filtered_interest_attributes\n                if attr_key in attr_keys\n            }\n            if not obj_id_attr_keys:\n                continue\n\n            value_by_key = {}\n            is_new_entity = entity_info.get(\"action\") == \"add\"\n            for attr_key in obj_id_attr_keys:\n                if (\n                    attr_key in changes\n                    and changes[attr_key][\"new\"] is not None\n                ):\n                    value_by_key[attr_key] = changes[attr_key][\"new\"]\n\n                if not is_new_entity:\n                    continue\n\n                hier_attr_id = hier_attr_ids_by_key[attr_key]\n                attr_id = attr_keys[attr_key]\n                if hier_attr_id in real_values or attr_id in real_values:\n                    continue\n\n                value_by_key[attr_key] = hier_values[hier_attr_id]\n\n            for key, new_value in value_by_key.items():\n                if new_value is None:\n                    continue\n\n                hier_id = hier_attr_ids_by_key[key]\n                std_id = attr_keys[key]\n                real_hier_value = real_values.get(hier_id)\n                real_std_value = real_values.get(std_id)\n                hier_value = hier_values[hier_id]\n                # Get right type of value for conversion\n                #   - values in event are strings\n                type_value = real_hier_value\n                if type_value is None:\n                    type_value = real_std_value\n                    if type_value is None:\n                        type_value = hier_value\n                        # Skip if current values are not set\n                        if type_value is None:\n                            continue\n\n                try:\n                    new_value = type(type_value)(new_value)\n                except Exception:\n                    self.log.warning((\n                        \"Couldn't convert from {} to {}.\"\n                        \" Skipping update values.\"\n                    ).format(type(new_value), type(type_value)))\n                    continue\n\n                real_std_value_is_same = new_value == real_std_value\n                real_hier_value_is_same = new_value == real_hier_value\n                # New value does not match anything in current entity values\n                if (\n                    not is_new_entity\n                    and not real_std_value_is_same\n                    and not real_hier_value_is_same\n                ):\n                    continue\n\n                if not real_std_value_is_same:\n                    op_changes.append((\n                        std_id,\n                        entity_id,\n                        new_value,\n                        real_values.get(std_id),\n                        std_id in real_values\n                    ))\n\n                if not real_hier_value_is_same:\n                    op_changes.append((\n                        hier_id,\n                        entity_id,\n                        new_value,\n                        real_values.get(hier_id),\n                        hier_id in real_values\n                    ))\n\n        for change in op_changes:\n            (\n                attr_id,\n                entity_id,\n                new_value,\n                old_value,\n                do_update\n            ) = change\n\n            entity_key = collections.OrderedDict([\n                (\"configuration_id\", attr_id),\n                (\"entity_id\", entity_id)\n            ])\n            if do_update:\n                op = ftrack_api.operation.UpdateEntityOperation(\n                    \"CustomAttributeValue\",\n                    entity_key,\n                    \"value\",\n                    old_value,\n                    new_value\n                )\n\n            else:\n                op = ftrack_api.operation.CreateEntityOperation(\n                    \"CustomAttributeValue\",\n                    entity_key,\n                    {\"value\": new_value}\n                )\n\n            session.recorded_operations.push(op)\n            if len(session.recorded_operations) &gt; 100:\n                session.commit()\n        session.commit()\n\n    def process_by_project(\n        self,\n        session: ftrack_api.Session,\n        event: ftrack_api.event.base.Event,\n        project_id: str,\n        entities_info: list[dict[str, Any]]\n    ):\n        \"\"\"Proces changes in single project.\n\n        Args:\n            session (ftrack_api.Session): ftrack session.\n            event (ftrack_api.event.base.Event): Event which has all changes\n                information.\n            project_id (str): Project id related to changes.\n            entities_info (list[dict[str, Any]]): Changes of entities.\n        \"\"\"\n\n        (\n            interest_attributes,\n            interest_entity_types\n        ) = self._get_handler_project_settings(session, event, project_id)\n        if not interest_attributes or not interest_entity_types:\n            return\n\n        entities_info: list[dict[str, Any]] = (\n            self._entities_filter_by_settings(\n                entities_info,\n                interest_attributes,\n                interest_entity_types\n            )\n        )\n        if not entities_info:\n            return\n\n        attrs_by_obj_id, hier_attrs = self._get_attrs_configurations(\n            session, interest_attributes\n        )\n        # Skip if attributes are not available\n        #   - there is nothing to sync\n        if not attrs_by_obj_id or not hier_attrs:\n            return\n\n        entity_ids_by_parent_id = collections.defaultdict(set)\n        all_entity_ids = set()\n        for entity_info in entities_info:\n            entity_id = None\n            for item in entity_info[\"parents\"]:\n                item_id = item[\"entityId\"]\n                all_entity_ids.add(item_id)\n                if entity_id is not None:\n                    entity_ids_by_parent_id[item_id].add(entity_id)\n                entity_id = item_id\n\n        attr_ids = {attr[\"id\"] for attr in hier_attrs}\n        for attrs in attrs_by_obj_id.values():\n            attr_ids |= {attr[\"id\"] for attr in attrs}\n\n        # Query real custom attribute values\n        #   - we have to know what are the real values, if are set and to what\n        #       value\n        value_items = query_custom_attribute_values(\n            session, attr_ids, all_entity_ids\n        )\n        real_values_by_entity_id = collections.defaultdict(dict)\n        for item in value_items:\n            entity_id = item[\"entity_id\"]\n            attr_id = item[\"configuration_id\"]\n            real_values_by_entity_id[entity_id][attr_id] = item[\"value\"]\n\n        hier_values_by_entity_id = {}\n        default_values = {\n            attr[\"id\"]: attr[\"default\"]\n            for attr in hier_attrs\n        }\n        hier_queue = collections.deque()\n        hier_queue.append((default_values, [project_id]))\n        while hier_queue:\n            parent_values, entity_ids = hier_queue.popleft()\n            for entity_id in entity_ids:\n                entity_values = copy.deepcopy(parent_values)\n                real_values = real_values_by_entity_id[entity_id]\n                for attr_id, value in real_values.items():\n                    entity_values[attr_id] = value\n                hier_values_by_entity_id[entity_id] = entity_values\n                hier_queue.append(\n                    (entity_values, entity_ids_by_parent_id[entity_id])\n                )\n\n        self.propagate_attribute_changes(\n            session,\n            interest_attributes,\n            entities_info,\n            attrs_by_obj_id,\n            hier_attrs,\n            real_values_by_entity_id,\n            hier_values_by_entity_id,\n        )\n\n    def launch(self, session, event):\n        filtered_entities_info = self.filter_entities_info(event)\n        if not filtered_entities_info:\n            return\n\n        for project_id, entities_info in filtered_entities_info.items():\n            self.process_by_project(session, event, project_id, entities_info)\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_push_frame_values_to_task.html#services.processor.processor.default_handlers.event_push_frame_values_to_task.PushHierValuesToNonHierEvent.filter_entities_info","title":"<code>filter_entities_info(event)</code>","text":"<p>Basic entities filter info we care about.</p> <p>This filtering is first of many filters. This does not query anything from ftrack nor use settings.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>ftrack event with update information.</p> required <p>Returns:</p> Type Description <code>dict[str, list[dict[str, Any]]]</code> <p>dict[str, list[dict[str, Any]]]: Filtered entity changes by project id.</p> Source code in <code>services/processor/processor/default_handlers/event_push_frame_values_to_task.py</code> <pre><code>def filter_entities_info(\n    self, event: ftrack_api.event.base.Event\n) -&gt; dict[str, list[dict[str, Any]]]:\n    \"\"\"Basic entities filter info we care about.\n\n    This filtering is first of many filters. This does not query anything\n    from ftrack nor use settings.\n\n    Args:\n        event (ftrack_api.event.base.Event): ftrack event with update\n            information.\n\n    Returns:\n        dict[str, list[dict[str, Any]]]: Filtered entity changes by\n            project id.\n    \"\"\"\n\n    # Filter if event contain relevant data\n    entities_info = event[\"data\"].get(\"entities\")\n    if not entities_info:\n        return\n\n    entities_info_by_project_id = collections.defaultdict(list)\n    for entity_info in entities_info:\n        # Ignore removed entities\n        if entity_info.get(\"action\") == \"remove\":\n            continue\n\n        # Care only about information with changes of entities\n        changes = entity_info.get(\"changes\")\n        if not changes:\n            continue\n\n        # Get project id from entity info\n        project_id = None\n        for parent_item in reversed(entity_info[\"parents\"]):\n            if parent_item[\"entityType\"] == \"show\":\n                project_id = parent_item[\"entityId\"]\n                break\n\n        if project_id is None:\n            continue\n\n        entities_info_by_project_id[project_id].append(entity_info)\n\n    return entities_info_by_project_id\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_push_frame_values_to_task.html#services.processor.processor.default_handlers.event_push_frame_values_to_task.PushHierValuesToNonHierEvent.process_by_project","title":"<code>process_by_project(session, event, project_id, entities_info)</code>","text":"<p>Proces changes in single project.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>ftrack session.</p> required <code>event</code> <code>Event</code> <p>Event which has all changes information.</p> required <code>project_id</code> <code>str</code> <p>Project id related to changes.</p> required <code>entities_info</code> <code>list[dict[str, Any]]</code> <p>Changes of entities.</p> required Source code in <code>services/processor/processor/default_handlers/event_push_frame_values_to_task.py</code> <pre><code>def process_by_project(\n    self,\n    session: ftrack_api.Session,\n    event: ftrack_api.event.base.Event,\n    project_id: str,\n    entities_info: list[dict[str, Any]]\n):\n    \"\"\"Proces changes in single project.\n\n    Args:\n        session (ftrack_api.Session): ftrack session.\n        event (ftrack_api.event.base.Event): Event which has all changes\n            information.\n        project_id (str): Project id related to changes.\n        entities_info (list[dict[str, Any]]): Changes of entities.\n    \"\"\"\n\n    (\n        interest_attributes,\n        interest_entity_types\n    ) = self._get_handler_project_settings(session, event, project_id)\n    if not interest_attributes or not interest_entity_types:\n        return\n\n    entities_info: list[dict[str, Any]] = (\n        self._entities_filter_by_settings(\n            entities_info,\n            interest_attributes,\n            interest_entity_types\n        )\n    )\n    if not entities_info:\n        return\n\n    attrs_by_obj_id, hier_attrs = self._get_attrs_configurations(\n        session, interest_attributes\n    )\n    # Skip if attributes are not available\n    #   - there is nothing to sync\n    if not attrs_by_obj_id or not hier_attrs:\n        return\n\n    entity_ids_by_parent_id = collections.defaultdict(set)\n    all_entity_ids = set()\n    for entity_info in entities_info:\n        entity_id = None\n        for item in entity_info[\"parents\"]:\n            item_id = item[\"entityId\"]\n            all_entity_ids.add(item_id)\n            if entity_id is not None:\n                entity_ids_by_parent_id[item_id].add(entity_id)\n            entity_id = item_id\n\n    attr_ids = {attr[\"id\"] for attr in hier_attrs}\n    for attrs in attrs_by_obj_id.values():\n        attr_ids |= {attr[\"id\"] for attr in attrs}\n\n    # Query real custom attribute values\n    #   - we have to know what are the real values, if are set and to what\n    #       value\n    value_items = query_custom_attribute_values(\n        session, attr_ids, all_entity_ids\n    )\n    real_values_by_entity_id = collections.defaultdict(dict)\n    for item in value_items:\n        entity_id = item[\"entity_id\"]\n        attr_id = item[\"configuration_id\"]\n        real_values_by_entity_id[entity_id][attr_id] = item[\"value\"]\n\n    hier_values_by_entity_id = {}\n    default_values = {\n        attr[\"id\"]: attr[\"default\"]\n        for attr in hier_attrs\n    }\n    hier_queue = collections.deque()\n    hier_queue.append((default_values, [project_id]))\n    while hier_queue:\n        parent_values, entity_ids = hier_queue.popleft()\n        for entity_id in entity_ids:\n            entity_values = copy.deepcopy(parent_values)\n            real_values = real_values_by_entity_id[entity_id]\n            for attr_id, value in real_values.items():\n                entity_values[attr_id] = value\n            hier_values_by_entity_id[entity_id] = entity_values\n            hier_queue.append(\n                (entity_values, entity_ids_by_parent_id[entity_id])\n            )\n\n    self.propagate_attribute_changes(\n        session,\n        interest_attributes,\n        entities_info,\n        attrs_by_obj_id,\n        hier_attrs,\n        real_values_by_entity_id,\n        hier_values_by_entity_id,\n    )\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_sync_comments.html","title":"event_sync_comments","text":""},{"location":"autoapi/services/processor/processor/default_handlers/event_sync_comments.html#services.processor.processor.default_handlers.event_sync_comments.SyncCommentsHandler","title":"<code>SyncCommentsHandler</code>","text":"<p>               Bases: <code>BaseEventHandler</code></p> <p>Sync comments from ftrack to AYON.</p> Source code in <code>services/processor/processor/default_handlers/event_sync_comments.py</code> <pre><code>class SyncCommentsHandler(BaseEventHandler):\n    \"\"\"Sync comments from ftrack to AYON.\"\"\"\n\n    subscription_topic: str = \"ftrack.update\"\n\n    def launch(self, session, event):\n        filtered_info = collections.defaultdict(list)\n        for ent_info in event[\"data\"][\"entities\"]:\n            if ent_info.get(\"entityType\") != \"note\":\n                continue\n\n            if (\n                ent_info[\"action\"] == \"update\"\n                and \"text\" not in ent_info[\"changes\"]\n            ):\n                continue\n\n            parents = ent_info[\"parents\"]\n            if parents[1][\"entityType\"] not in (\"assetversion\", \"task\"):\n                continue\n\n            project_id = ent_info[\"parents\"][-1][\"entityId\"]\n            filtered_info[project_id].append(ent_info)\n\n        for project_id, ents_info in filtered_info.items():\n            self._process_notes(session, event, project_id, ents_info)\n\n    def _process_notes(self, session, event, project_id, ents_info):\n        project_name = self.get_project_name_from_event(\n            session, event, project_id\n        )\n        ayon_project = self.get_ayon_project_from_event(event, project_name)\n        if not ayon_project:\n            self.log.debug(\n                f\"Project \\\"{project_name}\\\" not found in AYON\"\n            )\n            return\n        project_settings = self.get_project_settings_from_event(\n            event, project_name\n        )\n        ftrack_settings = project_settings[\"ftrack\"]\n        if not is_ftrack_enabled_in_settings(ftrack_settings):\n            self.log.debug(\n                f\"ftrack is disabled for project \\\"{project_name}\\\"\"\n            )\n            return\n\n        ayon_id_attr = session.query(\n            \"select id, key from CustomAttributeConfiguration\"\n            f\" where key is '{CUST_ATTR_KEY_SERVER_ID}'\"\n        ).first()\n        ayon_id_attr_id = None\n        if ayon_id_attr:\n            ayon_id_attr_id = ayon_id_attr[\"id\"]\n\n        user_id = event[\"data\"][\"user\"][\"userid\"]\n        ftrack_user = session.query(\n            f\"select username, email from User where id is '{user_id}'\"\n        ).first()\n        ayon_username = None\n        if ftrack_user:\n            mapping = map_ftrack_users_to_ayon_users([ftrack_user])\n            ayon_username = mapping[user_id]\n\n        con = ayon_api.get_server_api_connection()\n        with con.as_username(ayon_username):\n            for ent_info in ents_info:\n                parent_info = ent_info[\"parents\"][1]\n                parent_entity = self._get_parent_ftrack_entity(\n                    session, parent_info\n                )\n                if parent_entity is None:\n                    continue\n\n                ayon_entity, ayon_entity_type = self._get_ayon_entity(\n                    session,\n                    project_name,\n                    parent_entity,\n                    ayon_id_attr_id\n                )\n                if not ayon_entity:\n                    continue\n\n                activities = list(ayon_api.get_activities(\n                    project_name,\n                    activity_types={\"comment\"},\n                    entity_ids={ayon_entity[\"id\"]},\n                ))\n\n                if ent_info[\"action\"] == \"add\":\n                    self._handle_added_note(\n                        project_name,\n                        session,\n                        ent_info,\n                        ayon_entity,\n                        ayon_entity_type,\n                        activities,\n                    )\n                elif ent_info[\"action\"] == \"remove\":\n                    self._handle_removed_note(\n                        project_name,\n                        ent_info,\n                        activities,\n                    )\n                elif ent_info[\"action\"] == \"update\":\n                    self._handle_updated_note(\n                        project_name,\n                        ent_info,\n                        activities,\n                    )\n\n    def _get_parent_ftrack_entity(self, session, parent_info):\n        parent_type = parent_info[\"entityType\"]\n        parent_id = parent_info[\"entityId\"]\n        if parent_type == \"assetversion\":\n            return session.query(\n                \"select id, asset_id, version from AssetVersion\"\n                f\" where id is '{parent_id}'\"\n            ).first()\n        return session.query(\n            \"select id, name from TypedContext\"\n            f\" where id is '{parent_id}'\"\n        ).first()\n\n    def _get_ayon_entity(\n        self, session, project_name, ft_entity, ayon_id_attr_id\n    ) -&gt; tuple[Optional[dict], str]:\n        parent_id = ft_entity[\"id\"]\n        value_items = session.query((\n            \"select value, entity_id, configuration_id\"\n            \" from CustomAttributeValue\"\n            f\" where entity_id is '{parent_id}'\"\n            f\" and configuration_id is '{ayon_id_attr_id}'\"\n        )).all()\n        entity_id = None\n        for item in value_items:\n            if item[\"value\"]:\n                entity_id = item[\"value\"]\n\n        entity_type = ft_entity.entity_type.lower()\n\n        if entity_type == \"assetversion\":\n            ayon_entity_type = \"version\"\n        elif entity_type == \"task\":\n            ayon_entity_type = \"task\"\n        else:\n            ayon_entity_type = \"folder\"\n\n        if entity_id:\n            if entity_type == \"assetversion\":\n                return ayon_api.get_version_by_id(\n                    project_name, entity_id\n                ), ayon_entity_type\n            elif entity_type == \"task\":\n                return ayon_api.get_task_by_id(\n                    project_name, entity_id\n                ), ayon_entity_type\n            return ayon_api.get_folder_by_id(\n                project_name, entity_id\n            ), ayon_entity_type\n\n        if entity_type != \"assetversion\":\n            return None, ayon_entity_type\n\n        asset_id = ft_entity[\"asset_id\"]\n        asset = session.query(\n            f\"select name, context_id from Asset where id is '{asset_id}'\"\n        ).first()\n        if not asset:\n            return None, ayon_entity_type\n        parent_id = asset[\"context_id\"]\n        parent_entity = session.query(\n            f\"select id from TypedContext where id is '{parent_id}'\"\n        ).first()\n        if not parent_entity:\n            return None, ayon_entity_type\n        parent_ayon_entity, _ = self._get_ayon_entity(\n            session, project_name, parent_entity, ayon_id_attr_id\n        )\n        if not parent_ayon_entity:\n            return None, ayon_entity_type\n\n        expected_product_name = asset[\"name\"].lower()\n        matching_product = None\n        for product in ayon_api.get_products(\n            project_name,\n            folder_ids={parent_ayon_entity[\"id\"]},\n        ):\n            if product[\"name\"].lower() == expected_product_name:\n                matching_product = product\n                break\n\n        if not matching_product:\n            return None, ayon_entity_type\n\n        for version in ayon_api.get_version_by_name(\n            project_name,\n            version=ft_entity[\"version\"],\n            product_id=matching_product[\"id\"],\n        ):\n            return version, ayon_entity_type\n        return None, ayon_entity_type\n\n    def _handle_added_note(\n        self,\n        project_name,\n        session,\n        ent_info,\n        ayon_entity,\n        ayon_entity_type,\n        activities,\n    ):\n        note_id = ent_info[\"entityId\"]\n        note = session.query(\n            f\"select id, metadata from Note where id is '{note_id}'\"\n        ).first()\n        if not note:\n            return\n\n        activity_id = note[\"metadata\"].get(\"ayon_activity_id\")\n        changes = ent_info[\"changes\"]\n        text = changes[\"text\"][\"new\"]\n        ftrack_id_filled = False\n        matching_activity = None\n        if activity_id:\n            matching_activity = next(\n                (\n                    activity\n                    for activity in activities\n                    if activity[\"activityId\"] == activity_id\n                ),\n                None\n            )\n            if matching_activity is not None:\n                data = matching_activity[\"activityData\"]\n                data_id = data.get(\"ftrack\", {}).get(\"id\")\n                ftrack_id_filled = data_id == note_id\n\n        if matching_activity is None:\n            for activity in activities:\n                data = activity[\"activityData\"]\n                data_id = data.get(\"ftrack\", {}).get(\"id\")\n                if data_id == note_id or activity[\"body\"] == text:\n                    matching_activity = activity\n                    ftrack_id_filled = data_id == note_id\n                    break\n\n        session.commit()\n        if matching_activity is None:\n            activity_id = ayon_api.create_activity(\n                project_name,\n                ayon_entity[\"id\"],\n                ayon_entity_type,\n                \"comment\",\n                body=text,\n                data={\"ftrack\": {\"id\": note_id}}\n            )\n            note[\"metadata\"][\"ayon_activity_id\"] = activity_id\n            session.commit()\n            return\n\n        if not ftrack_id_filled:\n            ft_data = matching_activity[\"activityData\"].setdefault(\n                \"ftrack\", {}\n            )\n            ft_data[\"id\"] = note_id\n\n            ayon_api.update_activity(\n                project_name,\n                matching_activity[\"activityId\"],\n                data=matching_activity[\"activityData\"]\n            )\n\n    def _handle_updated_note(\n        self,\n        project_name,\n        ent_info,\n        activities,\n    ):\n        note_id = ent_info[\"entityId\"]\n        changes = ent_info[\"changes\"]\n        old_text = changes[\"text\"][\"old\"]\n        text = changes[\"text\"][\"new\"]\n        ftrack_id_filled = False\n        matching_activity = None\n        for activity in activities:\n            data = activity[\"activityData\"]\n            data_id = data.get(\"ftrack\", {}).get(\"id\")\n            if data_id == note_id or activity[\"body\"] == old_text:\n                matching_activity = activity\n                ftrack_id_filled = data_id == note_id\n                break\n\n        if matching_activity is None:\n            return\n\n        kwargs = {}\n        if not ftrack_id_filled:\n            ft_data = matching_activity[\"activityData\"].setdefault(\n                \"ftrack\", {}\n            )\n            ft_data[\"id\"] = note_id\n            kwargs[\"data\"] = matching_activity[\"activityData\"]\n\n        ayon_api.update_activity(\n            project_name,\n            matching_activity[\"activityId\"],\n            body=text,\n            **kwargs\n        )\n\n    def _handle_removed_note(\n        self,\n        project_name,\n        ent_info,\n        activities,\n    ):\n        changes = ent_info[\"changes\"]\n        note_id = ent_info[\"entityId\"]\n        text = changes[\"text\"][\"old\"]\n        matching_activity = None\n        for activity in activities:\n            data = activity[\"activityData\"]\n            data_id = data.get(\"ftrack\", {}).get(\"id\")\n            if data_id == note_id or activity[\"body\"] == text:\n                matching_activity = activity\n                break\n\n        if matching_activity is not None:\n            ayon_api.delete_activity(\n                project_name, matching_activity[\"activityId\"]\n            )\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_sync_from_ftrack.html","title":"event_sync_from_ftrack","text":""},{"location":"autoapi/services/processor/processor/default_handlers/event_sync_from_ftrack.html#services.processor.processor.default_handlers.event_sync_from_ftrack.AutoSyncFromFtrack","title":"<code>AutoSyncFromFtrack</code>","text":"<p>               Bases: <code>BaseEventHandler</code></p> Source code in <code>services/processor/processor/default_handlers/event_sync_from_ftrack.py</code> <pre><code>class AutoSyncFromFtrack(BaseEventHandler):\n    report_splitter = {\"type\": \"label\", \"value\": \"---\"}\n\n    def __init__(self, session):\n        '''Expects a ftrack_api.Session instance'''\n\n        # Set processing session to not use global\n        self.set_process_session(session)\n        super().__init__(session)\n\n    def set_process_session(self, session):\n        try:\n            self.process_session.close()\n        except Exception:\n            pass\n        self.process_session = ftrack_api.Session(\n            server_url=session.server_url,\n            api_key=session.api_key,\n            api_user=session.api_user,\n            auto_connect_event_hub=True\n        )\n        atexit.register(lambda: self.process_session.close())\n\n    def launch(self, session, event):\n        \"\"\"\n            Main entry port for synchronization.\n            Goes through event (can contain multiple changes) and decides if\n            the event is interesting for us (interest_base_types).\n            It separates changes into add|remove|update.\n            All task changes are handled together by refresh from ftrack.\n        Args:\n            session (ftrack_api.Session): session to ftrack\n            event (dictionary): event content\n\n        Returns:\n            (boolean or None)\n        \"\"\"\n        # Try to commit and if any error happen then recreate session\n        try:\n            self.process_session.commit()\n        except Exception:\n            self.set_process_session(session)\n\n        sync_process = SyncProcess(\n            self, self.process_session, event, self.log\n        )\n\n        sync_process.initial_event_processing()\n        if sync_process.project_changed_autosync:\n            username = self._get_username(\n                sync_process.session, sync_process.event)\n            on_state = \"off\"\n            sub_msg = \"\"\n            if sync_process.trigger_project_sync:\n                on_state = \"on\"\n                sub_msg = \" Triggering sync from ftrack action.\"\n\n            self.log.debug((\n                f\"Auto sync was turned {on_state} for project\"\n                f\" \\\"{sync_process.project_name}\\\" by \\\"{username}\\\".{sub_msg}\"\n            ))\n            if sync_process.trigger_project_sync:\n                # Trigger sync to AYON action if auto sync was turned on\n                selection = [{\n                    \"entityId\": sync_process.ft_project_id,\n                    \"entityType\": \"show\"\n                }]\n                # TODO uncomment when out of testing stage\n                self.trigger_action(\n                    action_identifier=\"sync.from.ftrack.to.ayon\",\n                    event=sync_process.event,\n                    selection=selection\n                )\n\n        if not sync_process.has_valid_entity_types:\n            return\n\n        if sync_process.ft_project is None:\n            self.log.warning(\n                \"Project was not found. Skipping.\"\n                f\"\\nEvent data: {event['data']}\\n\"\n            )\n            return\n\n        if not self.get_ayon_project_from_event(\n            event, sync_process.project_name\n        ):\n            self.log.debug(\n                f\"Project '{sync_process.project_name}' was not\"\n                \" found in AYON. Skipping.\"\n            )\n            return\n\n        if not sync_process.is_event_valid:\n            self.log.debug(\n                f\"Project '{sync_process.project_name}' has disabled\"\n                \" autosync. Skipping.\"\n            )\n            return\n\n        sync_process.process_event_data()\n\n    def _get_username(self, session, event):\n        username = \"Unknown\"\n        event_source = event.get(\"source\")\n        if not event_source:\n            return username\n        user_info = event_source.get(\"user\")\n        if not user_info:\n            return username\n        user_id = user_info.get(\"id\")\n        if not user_id:\n            return username\n\n        user_entity = session.query(\n            \"User where id is {}\".format(user_id)\n        ).first()\n        if user_entity:\n            username = user_entity[\"username\"] or username\n        return username\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_sync_from_ftrack.html#services.processor.processor.default_handlers.event_sync_from_ftrack.AutoSyncFromFtrack.__init__","title":"<code>__init__(session)</code>","text":"<p>Expects a ftrack_api.Session instance</p> Source code in <code>services/processor/processor/default_handlers/event_sync_from_ftrack.py</code> <pre><code>def __init__(self, session):\n    '''Expects a ftrack_api.Session instance'''\n\n    # Set processing session to not use global\n    self.set_process_session(session)\n    super().__init__(session)\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_sync_from_ftrack.html#services.processor.processor.default_handlers.event_sync_from_ftrack.AutoSyncFromFtrack.launch","title":"<code>launch(session, event)</code>","text":"<pre><code>Main entry port for synchronization.\nGoes through event (can contain multiple changes) and decides if\nthe event is interesting for us (interest_base_types).\nIt separates changes into add|remove|update.\nAll task changes are handled together by refresh from ftrack.\n</code></pre> <p>Args:     session (ftrack_api.Session): session to ftrack     event (dictionary): event content</p> <p>Returns:</p> Type Description <p>(boolean or None)</p> Source code in <code>services/processor/processor/default_handlers/event_sync_from_ftrack.py</code> <pre><code>def launch(self, session, event):\n    \"\"\"\n        Main entry port for synchronization.\n        Goes through event (can contain multiple changes) and decides if\n        the event is interesting for us (interest_base_types).\n        It separates changes into add|remove|update.\n        All task changes are handled together by refresh from ftrack.\n    Args:\n        session (ftrack_api.Session): session to ftrack\n        event (dictionary): event content\n\n    Returns:\n        (boolean or None)\n    \"\"\"\n    # Try to commit and if any error happen then recreate session\n    try:\n        self.process_session.commit()\n    except Exception:\n        self.set_process_session(session)\n\n    sync_process = SyncProcess(\n        self, self.process_session, event, self.log\n    )\n\n    sync_process.initial_event_processing()\n    if sync_process.project_changed_autosync:\n        username = self._get_username(\n            sync_process.session, sync_process.event)\n        on_state = \"off\"\n        sub_msg = \"\"\n        if sync_process.trigger_project_sync:\n            on_state = \"on\"\n            sub_msg = \" Triggering sync from ftrack action.\"\n\n        self.log.debug((\n            f\"Auto sync was turned {on_state} for project\"\n            f\" \\\"{sync_process.project_name}\\\" by \\\"{username}\\\".{sub_msg}\"\n        ))\n        if sync_process.trigger_project_sync:\n            # Trigger sync to AYON action if auto sync was turned on\n            selection = [{\n                \"entityId\": sync_process.ft_project_id,\n                \"entityType\": \"show\"\n            }]\n            # TODO uncomment when out of testing stage\n            self.trigger_action(\n                action_identifier=\"sync.from.ftrack.to.ayon\",\n                event=sync_process.event,\n                selection=selection\n            )\n\n    if not sync_process.has_valid_entity_types:\n        return\n\n    if sync_process.ft_project is None:\n        self.log.warning(\n            \"Project was not found. Skipping.\"\n            f\"\\nEvent data: {event['data']}\\n\"\n        )\n        return\n\n    if not self.get_ayon_project_from_event(\n        event, sync_process.project_name\n    ):\n        self.log.debug(\n            f\"Project '{sync_process.project_name}' was not\"\n            \" found in AYON. Skipping.\"\n        )\n        return\n\n    if not sync_process.is_event_valid:\n        self.log.debug(\n            f\"Project '{sync_process.project_name}' has disabled\"\n            \" autosync. Skipping.\"\n        )\n        return\n\n    sync_process.process_event_data()\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_sync_from_ftrack.html#services.processor.processor.default_handlers.event_sync_from_ftrack.SyncProcess","title":"<code>SyncProcess</code>","text":"Source code in <code>services/processor/processor/default_handlers/event_sync_from_ftrack.py</code> <pre><code>class SyncProcess:\n    interest_base_types = {\"show\", \"task\", \"assetversion\"}\n    ignore_ent_types = {\"Milestone\"}\n    ignore_change_keys = {\n        \"thumbid\",\n        \"priorityid\",\n    }\n\n    project_query = (\n        \"select id, full_name, name, custom_attributes,\"\n        \" project_schema._task_type_schema.types.name\"\n        \" from Project where id is \\\"{}\\\"\"\n    )\n    entities_columns = (\n        \"id\",\n        \"name\",\n        \"object_type_id\",\n        \"type_id\",\n        \"parent_id\",\n        \"link\",\n        \"description\",\n    )\n    entities_columns_str = \", \".join(entities_columns)\n    entities_query_by_id = (\n        f\"select {entities_columns_str} from TypedContext\"\n        \" where project_id is \\\"{}\\\" and id in ({})\"\n    )\n    cust_attr_query_keys = [\n        \"id\",\n        \"key\",\n        \"entity_type\",\n        \"object_type_id\",\n        \"is_hierarchical\",\n        \"config\",\n        \"default\"\n    ]\n\n    def __init__(self, event_handler, session, event, log):\n        self.event_handler = event_handler\n        self.event = event\n        self.session = session\n        self.log = log\n\n        self._ft_project_id = UNKNOWN_VALUE\n        self._ft_project = UNKNOWN_VALUE\n        self._project_name = UNKNOWN_VALUE\n        self._project_entity = UNKNOWN_VALUE\n        self._project_settings = None\n\n        self._is_event_valid = UNKNOWN_VALUE\n        self._ft_project_removed = UNKNOWN_VALUE\n        self._entities_by_action = UNKNOWN_VALUE\n        self._found_actions = UNKNOWN_VALUE\n        self._project_changed_autosync = UNKNOWN_VALUE\n        self._trigger_project_sync = UNKNOWN_VALUE\n\n        self._ftrack_entities_by_id = {}\n\n        # Server entity cache\n        self._entity_hub = None\n        self._folder_ids_by_ftrack_id = None\n        self._task_ids_by_ftrack_id = None\n        self._has_valid_entity_types = None\n\n        # Caches from ftrack\n        self._cust_attr_mapping = None\n        self._ft_cust_attr_types_by_id = None\n        self._ft_cust_attrs = None\n        self._ft_object_type_name_by_id = None\n        self._ft_task_type_name_by_id = None\n        self._ft_status_names_by_id = None\n\n        self._created_entity_by_ftrack_id = {}\n        self._hierarchy_changed_by_ftrack_id = {}\n        self._remapped_entity_by_ftrack_id = {}\n        self._ft_failed_sync_ids = set()\n\n    def get_ftrack_entity_by_ids(self, entity_ids):\n        \"\"\"Get or query ftrack entity by id.\n\n        Method is caching already queried entities.\n\n        Args:\n            entity_ids (List[str]): Id of ftrack entity.\n\n        Returns:\n            Dict[str, Union[ftrack_api.Entity, None]]: Mapping of ftrack entity\n                by it's id.\n        \"\"\"\n\n        if not entity_ids:\n            return {}\n\n        entity_ids = set(entity_ids)\n        output = {\n            entity_id: None\n            for entity_id in entity_ids\n        }\n        entity_ids.discard(None)\n        if self.ft_project_id in entity_ids:\n            output[self.ft_project_id] = self.ft_project\n            entity_ids.remove(self.ft_project_id)\n\n        for entity_id in tuple(entity_ids):\n            if entity_id not in self._ftrack_entities_by_id:\n                continue\n            output[entity_id] = self._ftrack_entities_by_id[entity_id]\n            entity_ids.remove(entity_id)\n\n        entities = []\n        if entity_ids:\n            entities = self.session.query(\n                self.entities_query_by_id.format(\n                    self.ft_project_id,\n                    join_filter_values(entity_ids)\n                )\n            ).all()\n\n        for entity in entities:\n            entity_id = entity[\"id\"]\n            self._ftrack_entities_by_id[entity_id] = entity\n            output[entity_id] = entity\n\n        return output\n\n    def get_ftrack_entity_by_id(self, entity_id):\n        if not entity_id:\n            return None\n        return self.get_ftrack_entity_by_ids([entity_id])[entity_id]\n\n    def get_ayon_project(self) -&gt; Optional[dict[str, Any]]:\n        if self._project_entity is UNKNOWN_VALUE:\n            self._project_entity = get_project(self.project_name)\n        return self._project_entity\n\n    @property\n    def project_name(self):\n        \"\"\"\n\n        Returns:\n            str: Name of project on which happened changes in processed event.\n        \"\"\"\n\n        if self._project_name is UNKNOWN_VALUE:\n            project_name = None\n            if self.ft_project is not None:\n                project_name = self.ft_project[\"full_name\"]\n            self._project_name = project_name\n        return self._project_name\n\n    @property\n    def project_settings(self):\n        if self._project_settings is None:\n            self._project_settings = (\n                self.event_handler.get_project_settings_from_event(\n                    self.event, self.project_name\n                )\n            )\n        return self._project_settings\n\n    @property\n    def ft_project_id(self):\n        \"\"\"\n\n        Returns:\n            Union[str, None]: Id of ftrack project based on information in\n                processed event.\n        \"\"\"\n\n        if self._ft_project_id is UNKNOWN_VALUE:\n            found_id = None\n            for ent_info in self.event[\"data\"].get(\"entities\", []):\n                if found_id is not None:\n                    break\n                parents = ent_info.get(\"parents\") or []\n                for parent in parents:\n                    if parent.get(\"entityType\") == \"show\":\n                        found_id = parent.get(\"entityId\")\n                        break\n\n            self._ft_project_id = found_id\n        return self._ft_project_id\n\n    @property\n    def ft_project(self):\n        \"\"\"\n\n        Returns:\n            ftrack_api.Entity: ftrack project entity.\n        \"\"\"\n\n        if self._ft_project is UNKNOWN_VALUE:\n            project_id = self.ft_project_id\n            project = None\n            if project_id:\n                project = self.session.query(\n                    self.project_query.format(project_id)\n                ).first()\n\n            self._ft_project = project\n        return self._ft_project\n\n    @property\n    def is_event_valid(self):\n        \"\"\"\n\n        Returns:\n            bool: Data from event are important for synchronization.\n        \"\"\"\n\n        if self._is_event_valid is UNKNOWN_VALUE:\n            self.initial_event_processing()\n        return self._is_event_valid\n\n    @property\n    def ft_project_removed(self):\n        \"\"\"\n\n        Returns:\n            bool: Project was removed from ftrack.\n        \"\"\"\n\n        if self._ft_project_removed is UNKNOWN_VALUE:\n            self.initial_event_processing()\n        return self._ft_project_removed\n\n    @property\n    def entities_by_action(self):\n        \"\"\"\n\n        Returns:\n            Dict[str, Dict[str, Any]]: Entity information from ftrack event\n                byt action happened on them.\n        \"\"\"\n\n        if self._entities_by_action is UNKNOWN_VALUE:\n            self.initial_event_processing()\n        return self._entities_by_action\n\n    @property\n    def found_actions(self):\n        \"\"\"\n\n        Returns:\n            Set[str]: Actions that happened in processed ftrack event.\n        \"\"\"\n\n        if self._found_actions is UNKNOWN_VALUE:\n            self.initial_event_processing()\n        return self._found_actions\n\n    @property\n    def project_changed_autosync(self):\n        \"\"\"\n\n        Returns:\n            bool: Autosync value has changed.\n        \"\"\"\n\n        if self._project_changed_autosync is UNKNOWN_VALUE:\n            self.initial_event_processing()\n        return self._project_changed_autosync\n\n    @property\n    def trigger_project_sync(self):\n        \"\"\"\n\n        Returns:\n            bool: Autosync was turned on so a project sync action should be\n                triggered.\n        \"\"\"\n\n        if self._trigger_project_sync is UNKNOWN_VALUE:\n            self.initial_event_processing()\n        return self._trigger_project_sync\n\n    @property\n    def entity_hub(self):\n        if self._entity_hub is None:\n            self._entity_hub = EntityHub(self.project_name)\n        return self._entity_hub\n\n    @property\n    def task_ids_by_ftrack_id(self):\n        if self._task_ids_by_ftrack_id is None:\n            task_ids_by_ftrack_id = collections.defaultdict(list)\n            tasks = get_tasks(\n                self.project_name,\n                fields=[\"id\", f\"attrib.{FTRACK_ID_ATTRIB}\"]\n            )\n            for task in tasks:\n                ftrack_id = task.get(\"attrib\", {}).get(FTRACK_ID_ATTRIB)\n                task_ids_by_ftrack_id[ftrack_id].append(task[\"id\"])\n\n            self._task_ids_by_ftrack_id = task_ids_by_ftrack_id\n        return self._task_ids_by_ftrack_id\n\n    @property\n    def folder_ids_by_ftrack_id(self):\n        if self._folder_ids_by_ftrack_id is None:\n            folder_ids_by_ftrack_id = collections.defaultdict(list)\n            folders = get_folders(\n                self.project_name,\n                fields=[\"id\", f\"attrib.{FTRACK_ID_ATTRIB}\"]\n            )\n            for folder in folders:\n                ftrack_id = folder.get(\"attrib\", {}).get(FTRACK_ID_ATTRIB)\n                folder_ids_by_ftrack_id[ftrack_id].append(folder[\"id\"])\n\n            self._folder_ids_by_ftrack_id = folder_ids_by_ftrack_id\n        return self._folder_ids_by_ftrack_id\n\n    @property\n    def ft_cust_attr_types_by_id(self):\n        if self._ft_cust_attr_types_by_id is None:\n            cust_attr_types = self.session.query(\n                \"select id, name from CustomAttributeType\"\n            ).all()\n            self._ft_cust_attr_types_by_id = {\n                cust_attr_type[\"id\"]: cust_attr_type\n                for cust_attr_type in cust_attr_types\n            }\n        return self._ft_cust_attr_types_by_id\n\n    @property\n    def cust_attr_mapping(self) -&gt; CustomAttributesMapping:\n        if self._cust_attr_mapping is None:\n            self._cust_attr_mapping = get_custom_attributes_mapping(\n                self.session,\n                self.project_settings[\"ftrack\"],\n                self.ft_cust_attrs,\n            )\n        return self._cust_attr_mapping\n\n    @property\n    def ft_cust_attrs(self):\n        if self._ft_cust_attrs is None:\n            fields = \", \".join(self.cust_attr_query_keys)\n            self._ft_cust_attrs = self.session.query(\n                    f\"select {fields} from CustomAttributeConfiguration\"\n            ).all()\n        return self._ft_cust_attrs\n\n    @property\n    def ft_object_type_name_by_id(self):\n        if self._ft_object_type_name_by_id is None:\n            object_types = self.session.query(\n                \"select id, name from ObjectType\").all()\n            self._ft_object_type_name_by_id = {\n                object_type[\"id\"]: object_type[\"name\"]\n                for object_type in object_types\n            }\n\n        return self._ft_object_type_name_by_id\n\n    @property\n    def ft_task_type_name_by_id(self):\n        if self._ft_task_type_name_by_id is None:\n            task_types = self.session.query(\"select id, name from Type\").all()\n            self._ft_task_type_name_by_id = {\n                task_type[\"id\"]: task_type[\"name\"]\n                for task_type in task_types\n            }\n        return self._ft_task_type_name_by_id\n\n    @property\n    def ft_status_names_by_id(self):\n        if self._ft_status_names_by_id is None:\n            statuses = self.session.query(\"select id, name from Status\").all()\n            self._ft_status_names_by_id = {\n                statuse[\"id\"]: statuse[\"name\"]\n                for statuse in statuses\n            }\n        return self._ft_status_names_by_id\n\n    @property\n    def has_valid_entity_types(self):\n        return self._has_valid_entity_types\n\n    def initial_event_processing(self):\n        \"\"\"First processing of data on event.\n\n        This part decide if event contain data important for synchronization.\n        \"\"\"\n\n        if self._ft_project_removed is not UNKNOWN_VALUE:\n            return\n\n        # Set default values\n        self._is_event_valid = False\n        self._project_changed_autosync = False\n        self._trigger_project_sync = False\n\n        self._has_valid_entity_types = True\n        self._split_event_entity_info()\n\n        # If project was removed then skip rest of event processing\n        if (\n            self._ft_project_removed\n            or not self._found_actions\n        ):\n            self._has_valid_entity_types = False\n            return\n\n        self._check_enabled_auto_sync()\n        if self._project_changed_autosync:\n            if not self._project_enabled_validation():\n                # Make sure that sync is not triggered if project is not\n                #   available or disabled\n                self._trigger_project_sync = False\n            return\n\n        self._filter_update_actions()\n\n        if not self._found_actions:\n            self.log.debug(\"Skipping. Nothing to update.\")\n            self._has_valid_entity_types = False\n            return\n\n        if not self._project_enabled_validation():\n            return\n\n        # Skip if auto-sync is not set\n        auto_sync = self.ft_project[\"custom_attributes\"][CUST_ATTR_AUTO_SYNC]\n        is_event_valid = auto_sync is True\n        if is_event_valid:\n            # TODO probably should be handled\n            # TODO add logs - with detail what is wrong\n            # - project is not available on server\n            if not self.entity_hub.project_entity:\n                is_event_valid = False\n        self._is_event_valid = is_event_valid\n\n    def _split_event_entity_info(self):\n        entities_by_action = {\n            \"remove\": {},\n            \"update\": {},\n            \"add\": {},\n            \"assignee_change\": {},\n            \"link_change\": [],\n            \"list_added\": [],\n            \"list_removed\": [],\n            \"list_changed\": [],\n            \"list_item_change\": {},\n        }\n        found_actions = set()\n        ft_project_removed = False\n        for ent_info in self.event[\"data\"][\"entities\"]:\n            base_type = ent_info[\"entityType\"]\n            if base_type == \"list\":\n                action = ent_info[\"action\"]\n                if action == \"remove\":\n                    action = \"list_removed\"\n                elif action == \"add\":\n                    action = \"list_added\"\n\n                elif action == \"update\":\n                    action = \"list_changed\"\n\n                    valid = \"name\" in ent_info[\"changes\"]\n\n                    entity_type = ent_info[\"entity_type\"]\n                    if (\n                        entity_type == \"TypedContextList\"\n                        and CUST_ATTR_KEY_LIST_TYPE in ent_info[\"changes\"]\n                    ):\n                        valid = True\n\n                    if not valid:\n                        continue\n\n                else:\n                    continue\n\n                found_actions.add(action)\n                entities_by_action[action].append(ent_info)\n                continue\n\n            if base_type == \"listobject\":\n                action = ent_info[\"action\"]\n                if action not in (\"remove\", \"add\"):\n                    continue\n\n                if action == \"add\":\n                    list_id = ent_info[\"changes\"][\"listid\"][\"new\"]\n                else:\n                    list_id = ent_info[\"changes\"][\"listid\"][\"old\"]\n\n                action = \"list_item_change\"\n                found_actions.add(action)\n                list_entities = entities_by_action[action].setdefault(\n                    list_id, []\n                )\n                list_entities.append(ent_info)\n                continue\n\n            if base_type == \"appointment\":\n                if ent_info[\"action\"] not in (\"remove\", \"add\"):\n                    continue\n                type_changes = ent_info[\"changes\"][\"type\"]\n                appointment_type = type_changes[\"new\"] or type_changes[\"old\"]\n                if appointment_type != \"assignment\":\n                    continue\n                action = \"assignee_change\"\n                ftrack_id = ent_info[\"entityId\"]\n                found_actions.add(action)\n                entities_by_action[action][ftrack_id] = ent_info\n                continue\n\n            if base_type == \"dependency\":\n                # NOTE we're not handling 'update'\n                # - hopefully nobody is changing ids in existing links?\n                if ent_info[\"action\"] not in (\"remove\", \"add\"):\n                    continue\n                action = \"link_change\"\n                found_actions.add(action)\n                entities_by_action[action].append(ent_info)\n                continue\n\n            if base_type not in self.interest_base_types:\n                continue\n\n            entity_type = ent_info.get(\"entity_type\")\n            if not entity_type or entity_type in self.ignore_ent_types:\n                continue\n\n            action = ent_info[\"action\"]\n            ftrack_id = ent_info[\"entityId\"]\n\n            if action == \"remove\":\n                # ignore removement of versions\n                if base_type == \"assetversion\":\n                    continue\n\n                # Skip deleted projects\n                elif base_type == \"show\":\n                    ft_project_removed = True\n\n            # Change 'move' events to 'update'\n            # - they may contain more changes than just 'parent_id'\n            if action == \"move\":\n                action = \"update\"\n\n            # regular change process handles all other than Tasks\n            found_actions.add(action)\n            entities_by_action[action][ftrack_id] = ent_info\n\n        self._ft_project_removed = ft_project_removed\n        self._entities_by_action = entities_by_action\n        self._found_actions = found_actions\n\n    def _check_enabled_auto_sync(self):\n        updates = self._entities_by_action[\"update\"]\n        for ftrack_id, ent_info in updates.items():\n            # filter project\n            if ent_info[\"entityType\"] != \"show\":\n                continue\n\n            changes = ent_info[\"changes\"]\n            if CUST_ATTR_AUTO_SYNC not in changes:\n                continue\n\n            auto_sync = changes[CUST_ATTR_AUTO_SYNC][\"new\"]\n            if auto_sync == \"1\":\n                self._trigger_project_sync = True\n\n            self._project_changed_autosync = True\n\n    def _project_enabled_validation(self):\n        # NOTE This is first part of code which should query entity from\n        #   ftrack.\n        # Query project and check if can be actually queried and if has\n        #   available custom attribute that is used to identify if project\n        #   should be autosynced.\n        ft_project = self.ft_project\n        if ft_project is None:\n            self.log.error(\"Failed to query ftrack project. Skipping event\")\n            return False\n\n        if CUST_ATTR_AUTO_SYNC not in ft_project[\"custom_attributes\"]:\n            # TODO should we sent message to someone?\n            self.log.error((\n                f\"Custom attribute \\\"{CUST_ATTR_AUTO_SYNC}\\\" is not created\"\n                f\" or user \\\"{self.session.api_user}\\\" used\"\n                \" for Event server don't have permissions to access it!\"\n            ))\n            return False\n\n        if not is_ftrack_enabled_in_settings(self.project_settings[\"ftrack\"]):\n            self.log.debug(\n                f\"ftrack is disabled for project \\\"{self.project_name}\\\"\"\n            )\n            return False\n        return True\n\n    def _filter_update_actions(self):\n        updates = self.entities_by_action[\"update\"]\n        filtered_updates = {}\n        for ftrack_id, ent_info in updates.items():\n            changed_keys = list(ent_info.get(\"keys\") or [])\n            changes = dict((ent_info.get(\"changes\") or {}).items())\n\n            for _key in self.ignore_change_keys:\n                if _key in changed_keys:\n                    changed_keys.remove(_key)\n                    changes.pop(_key, None)\n\n            if not changed_keys:\n                continue\n\n            ent_info[\"keys\"] = changed_keys\n            ent_info[\"changes\"] = changes\n            filtered_updates[ftrack_id] = ent_info\n\n        self._entities_by_action[\"update\"] = filtered_updates\n        if not filtered_updates:\n            self._found_actions.discard(\"update\")\n\n    def _get_folder_hierachy_changes(self):\n        output = dict(self.entities_by_action[\"remove\"].items())\n        for ftrack_id, info in self.entities_by_action[\"update\"].items():\n            changed_keys = info[\"keys\"]\n            if \"parent_id\" in changed_keys or \"name\" in changed_keys:\n                output[ftrack_id] = info\n        return {\n            ftrack_id: info\n            for ftrack_id, info in output.items()\n            if info[\"entityType\"] != \"show\" and info[\"entity_type\"] != \"Task\"\n        }\n\n    def _try_create_entity(self, ftrack_id):\n        # Skip creation if it was already tried\n        if ftrack_id in self._ft_failed_sync_ids:\n            return None\n\n        # Try to find ftrack entity (as reference for creation)\n        # - without existing ftrack entity can't be created server as are\n        ft_entity = self.get_ftrack_entity_by_id(ftrack_id)\n        if ft_entity is None:\n            self._ft_failed_sync_ids.add(ftrack_id)\n            return None\n\n        # Get entity type to create (folder/task)\n        if ft_entity.entity_type == \"Task\":\n            entity_type = \"task\"\n            entity_ids = self.task_ids_by_ftrack_id[ftrack_id]\n        else:\n            entity_type = \"folder\"\n            entity_ids = self.folder_ids_by_ftrack_id[ftrack_id]\n\n        # Skip if there is more than one server entity id matching\n        #   ftrack id\n        if len(entity_ids) &gt; 1:\n            # TODO find out what to do in that case\n            # TODO handle this case somehow\n            self._ft_failed_sync_ids.add(ftrack_id)\n            self.log.warning((\n                \"Found more then one matching entity on server for\"\n                f\" ftrack id {ftrack_id} ({entity_ids}). Skipping\"\n            ))\n            return None\n\n        # Just return entity if already exists\n        if entity_ids:\n            entity = self.entity_hub.get_or_fetch_entity_by_id(\n                entity_ids[0], [entity_type]\n            )\n            if entity is not None:\n                return entity\n\n        # Find ftrack parent to find server parent under which the entity can\n        #   be created\n        ft_parent_id = ft_entity[\"parent_id\"]\n        # If parent is project then just get project entity\n        parent = None\n        if ft_parent_id == self.ft_project_id:\n            parent = self.entity_hub.project_entity\n            # Skip creation if task was created under project\n            if entity_type == \"task\":\n                self._ft_failed_sync_ids.add(ftrack_id)\n                return None\n\n        if parent is None:\n            # TODO missing check if there are multiple mathching entity ids\n            parent_ids = self.folder_ids_by_ftrack_id[ft_parent_id]\n            if len(parent_ids) == 1:\n                parent = self.entity_hub.get_or_fetch_entity_by_id(\n                    parent_ids[0], [\"folder\"]\n                )\n\n            # Try to create parent if is not available\n            elif not parent_ids:\n                parent = self._try_create_entity(ft_parent_id)\n\n        # Entity can't be created without parent\n        if parent is None:\n            self._ft_failed_sync_ids.add(ftrack_id)\n            return None\n\n        label = ft_entity[\"name\"]\n        name = slugify_string(label)\n        # Try to find matching entity by name in same parent\n        matching_entity = None\n        for child in parent.children:\n            # Find matching entity by entity type and name\n            # - this is to avoid duplication or to find entity without\n            #   ftrack id in attributes (or old ftrack id)\n            # TODO add lower cased comparison for entities which are not\n            #   immutable\n            if (\n                child.entity_type == entity_type\n                and child.name == name\n            ):\n                matching_entity = child\n                break\n\n        # Handle cases when there already is entity with matching name and\n        #   type\n        if matching_entity is not None:\n            # WARNING this won't update entity attributes!!!\n            # TODO if there is entity that can be used \"instead\" also fill\n            #   it's attributes as expected\n            # - all created entities should have filled all attributes\n\n            # Check if entity has set ftrack id\n            # - when does not have set then we can match it to just processed\n            #   ftrack entity\n            matching_entity_id = matching_entity.id\n            matching_ftrack_id = matching_entity.attribs[FTRACK_ID_ATTRIB]\n            # When ftrack id is not empty then make sure the ftrack id leads\n            #   to ftrack existing entity and unset the id if it does not\n            if matching_ftrack_id is not None:\n                matching_ft_entity = self.get_ftrack_entity_by_id(\n                    matching_ftrack_id)\n                entity_ids = self.folder_ids_by_ftrack_id[matching_ftrack_id]\n                if matching_ft_entity is None:\n                    if matching_entity_id in entity_ids:\n                        entity_ids.remove(matching_entity_id)\n                    matching_ftrack_id = None\n\n            # If ftrack id on matching entity does not exist we can \"reuse\" it\n            if matching_ftrack_id is not None:\n                self._ft_failed_sync_ids.add(ftrack_id)\n                return None\n\n        ft_path = \"/\".join([\n            item[\"name\"]\n            for item in ft_entity[\"link\"]\n            if item[\"type\"] != \"Project\"\n        ])\n\n        mapping_items_by_id = {}\n        for mapping_item in self.cust_attr_mapping.values():\n            attr_conf = mapping_item.get_attr_conf_for_entity(ft_entity)\n            if attr_conf is not None:\n                mapping_items_by_id[attr_conf[\"id\"]] = mapping_item\n\n        value_items = query_custom_attribute_values(\n            self.session, mapping_items_by_id.keys(), [ftrack_id]\n        )\n        attr_values_by_key = {}\n        for item in value_items:\n            value = item[\"value\"]\n            if value is None:\n                continue\n            attr_id = item[\"configuration_id\"]\n            mapping_item: MappedAYONAttribute = mapping_items_by_id[attr_id]\n            key = mapping_item.ayon_attribute_name\n            if key not in attr_values_by_key or mapping_item.is_hierarchical:\n                attr_values_by_key[key] = value\n\n        if matching_entity is not None:\n            entity = matching_entity\n            entity.label = label\n\n        elif entity_type == \"folder\":\n            object_type_id = ft_entity[\"object_type_id\"]\n            folder_type = self.ft_object_type_name_by_id[object_type_id]\n            entity = self.entity_hub.add_new_folder(\n                folder_type=folder_type,\n                name=name,\n                label=label,\n                parent_id=parent.id\n            )\n\n        else:\n            task_type_id = ft_entity[\"type_id\"]\n            task_type = self.ft_task_type_name_by_id[task_type_id]\n            entity = self.entity_hub.add_new_task(\n                task_type=task_type,\n                name=name,\n                label=label,\n                parent_id=parent.id\n            )\n\n        if entity_type == \"folder\":\n            entity_id_mapping = self.folder_ids_by_ftrack_id[ftrack_id]\n        else:\n            entity_id_mapping = self.task_ids_by_ftrack_id[ftrack_id]\n\n        if entity.id not in entity_id_mapping:\n            entity_id_mapping.append(entity.id)\n\n        entity.attribs[FTRACK_ID_ATTRIB] = ftrack_id\n        entity.attribs[FTRACK_PATH_ATTRIB] = ft_path\n        for key, value in attr_values_by_key.items():\n            if key in entity.attribs:\n                entity.attribs[key] = value\n        self._created_entity_by_ftrack_id[ftrack_id] = entity\n        return entity\n\n    def _try_find_other_match(self, info, entity):\n        parent_id = info[\"parentId\"]\n        if parent_id == self.ft_project_id:\n            ft_parent = self.ft_project\n        else:\n            ft_parent = self.session.query((\n                \"select id, name from TypedContext\"\n                f\" where id is {parent_id}\"\n            )).first()\n\n        if ft_parent is None:\n            return False\n\n        new_ft_match = None\n        ft_other_children = self.session.query((\n            f\"select {self.entities_columns_str} from TypedContext\"\n            f\" where parent_id is {parent_id}\"\n        )).all()\n        for child in ft_other_children:\n            label = child[\"name\"]\n            name = slugify_string(label)\n            if name == entity.name:\n                new_ft_match = child\n                break\n\n        if new_ft_match is None:\n            return False\n\n        ft_is_task = new_ft_match.entity_type == \"Task\"\n        entity_is_task = entity.entity_type == \"task\"\n        if ft_is_task != entity_is_task:\n            return False\n\n        ftrack_id = new_ft_match[\"id\"]\n        entity_id = self.folder_ids_by_ftrack_id.get(ftrack_id)\n        if entity_id == entity.id:\n            return True\n\n        if entity_id is not None:\n            return False\n\n        entity.attribs[FTRACK_ID_ATTRIB] = ftrack_id\n        # TODO add task path?\n        if not entity_is_task:\n            entity.attribs[FTRACK_PATH_ATTRIB] = \"/\".join([\n                item[\"name\"]\n                for item in new_ft_match[\"link\"]\n                if item[\"type\"] != \"Project\"\n            ])\n        self._remapped_entity_by_ftrack_id[ftrack_id] = entity\n        return True\n\n    def _prepare_folder_allowed_hierarchy_changes(\n        self, folder_hierarchy_changes, ftrack_ids_to_create\n    ):\n        allowed_changes = {}\n        for ftrack_id, info in folder_hierarchy_changes.items():\n            # Do not exist in current folders (nothing to validate)\n            entity_ids = self.folder_ids_by_ftrack_id[ftrack_id]\n            if not entity_ids:\n                ftrack_ids_to_create.add(ftrack_id)\n                continue\n\n            if len(entity_ids) != 1:\n                # TODO handle this cases somehow\n                self.log.warning((\n                    \"Found more then one matching entity on server for\"\n                    f\" ftrack id {ftrack_id} ({entity_ids}). Skipping\"\n                ))\n                continue\n\n            entity = self.entity_hub.get_or_fetch_entity_by_id(\n                entity_ids[0], [\"folder\"])\n\n            allow_change = not entity.immutable_for_hierarchy\n            if not allow_change:\n                changes = info[\"changes\"]\n                # It is valid change if parent did not change and name\n                #   did not change for server (after slugify)\n                if \"parent_id\" not in changes and \"name\" in changes:\n                    new_name = changes[\"name\"][\"new\"]\n                    if slugify_string(new_name) == entity.name:\n                        allow_change = True\n\n            if allow_change:\n                allowed_changes[ftrack_id] = (info, entity)\n                continue\n\n            self._ft_failed_sync_ids.add(ftrack_id)\n            self.log.warning(\n                f\"Hierarchy changes are not allow on entity {entity.path}\"\n            )\n\n        return allowed_changes\n\n    def _clear_ayon_id_in_created_entities(self, ftrack_ids: set[str]):\n        ayon_id_by_ftrack_id = self._get_server_id_by_ftrack_ids(\n            ftrack_ids\n        )\n        filtered_mapping = {\n            ftrack_id: ayon_id\n            for ftrack_id, ayon_id in ayon_id_by_ftrack_id.items()\n            if ayon_id\n        }\n        ayon_ids = set(filtered_mapping.values())\n        if not ayon_ids:\n            return\n\n        ayon_id_attr_conf = next(\n            (\n                attr\n                for attr in self.ft_cust_attrs\n                if attr[\"key\"] == CUST_ATTR_KEY_SERVER_ID\n            ),\n            None\n        )\n        if ayon_id_attr_conf is None:\n            return\n\n        ayon_id_attr_conf_id = ayon_id_attr_conf[\"id\"]\n        current_mapping_ay = collections.defaultdict(set)\n        current_mapping_ft = {}\n        for chunk in create_chunks(ayon_ids, 100):\n            entity_ids_joined = join_filter_values(chunk)\n            for item in self.session.query(\n                \"select value, entity_id\"\n                \" from CustomAttributeValue\"\n                f\" where configuration_id in ({ayon_id_attr_conf_id})\"\n                f\" and value in ({entity_ids_joined})\"\n            ).all():\n                current_mapping_ay[item[\"value\"]].add(item[\"entity_id\"])\n                current_mapping_ft[item[\"entity_id\"]] = item[\"value\"]\n\n        operations = []\n        cleared_ftrack_ids = set()\n        for ayon_id in ayon_ids:\n            ftrack_ids = current_mapping_ay[ayon_id]\n            if len(ftrack_ids) &lt; 2:\n                continue\n            entity = self.entity_hub.get_or_fetch_entity_by_id(\n                ayon_id, [\"folder\", \"task\"]\n            )\n            current_ftrack_id = entity.attrib.get(FTRACK_ID_ATTRIB, None)\n            if current_ftrack_id and current_ftrack_id in ftrack_ids:\n                ftrack_ids.discard(current_ftrack_id)\n            else:\n                ftrack_ids = set()\n                for ftrack_id, _ayon_id in filtered_mapping.items():\n                    if _ayon_id == ayon_id:\n                        ftrack_ids.add(ftrack_id)\n\n            cleared_ftrack_ids |= ftrack_ids\n            for ftrack_id in ftrack_ids:\n                entity_key = collections.OrderedDict((\n                    (\"configuration_id\", ayon_id_attr_conf_id),\n                    (\"entity_id\", ftrack_id)\n                ))\n                operations.append(\n                    ftrack_api.operation.DeleteEntityOperation(\n                        \"CustomAttributeValue\",\n                        entity_key\n                    )\n                )\n\n        ayon_path_attr_conf = next(\n            (\n                attr\n                for attr in self.ft_cust_attrs\n                if attr[\"key\"] == CUST_ATTR_KEY_SERVER_PATH\n            ),\n            None\n        )\n        if ayon_path_attr_conf is not None:\n            ayon_path_attr_conf_id = ayon_path_attr_conf[\"id\"]\n            for value_item in query_custom_attribute_values(\n                self.session,\n                {ayon_path_attr_conf_id},\n                ftrack_ids,\n            ):\n                if value_item[\"value\"] is None:\n                    continue\n                entity_key = collections.OrderedDict((\n                    (\"configuration_id\", ayon_path_attr_conf_id),\n                    (\"entity_id\", value_item[\"entity_id\"])\n                ))\n                operations.append(\n                    ftrack_api.operation.DeleteEntityOperation(\n                        \"CustomAttributeValue\",\n                        entity_key\n                    )\n                )\n\n        if not operations:\n            return\n\n        for op in operations:\n            self.session.recorded_operations.push(op)\n        self.session.commit()\n\n    def _process_folder_hierarchy_changes(\n        self,\n        folder_hierarchy_changes,\n        ftrack_ids_to_create\n    ):\n        if not folder_hierarchy_changes:\n            return\n\n        changes_count = len(folder_hierarchy_changes)\n        self.log.debug(\n            f\"Looking into {changes_count} folder hierarchy changes\"\n        )\n\n        allowed_changes = self._prepare_folder_allowed_hierarchy_changes(\n            folder_hierarchy_changes,\n            ftrack_ids_to_create\n        )\n        if not allowed_changes:\n            self.log.debug(\"All folder hierarchy changes are not possible\")\n            return\n\n        diff_count = changes_count - len(allowed_changes)\n        if diff_count:\n            self.log.debug(f\"Filtered {diff_count} changes.\")\n\n        changes_queue = collections.deque()\n        for item in allowed_changes.items():\n            changes_queue.append(item)\n        changes_queue.append(len(changes_queue))\n\n        self.log.debug(\"Starting folder changes queue\")\n        while changes_queue:\n            item = changes_queue.popleft()\n            if isinstance(item, int):\n                current_len = len(changes_queue)\n                if current_len == item:\n                    # Mark all remaining items as failed\n                    while changes_queue:\n                        item = changes_queue.popleft()\n                        if not isinstance(item, int):\n                            self._ft_failed_sync_ids.add(item[0])\n\n                else:\n                    # Add current len for next iteration\n                    changes_queue.append(current_len)\n                continue\n\n            ftrack_id, (info, entity) = item\n            if ftrack_id in self._ft_failed_sync_ids:\n                continue\n\n            self.log.debug(\n                f\"Trying to apply hierarchy changes of {ftrack_id}\"\n            )\n\n            changes = info[\"changes\"]\n            if \"name\" in changes:\n                label = changes[\"name\"][\"new\"]\n                name = slugify_string(label)\n            else:\n                name = entity.name\n\n            parent = None\n            if \"parent_id\" not in changes:\n                parent = entity.parent\n            else:\n                ft_parent_id = changes[\"parent_id\"][\"new\"]\n                if ft_parent_id == self.ft_project_id:\n                    parent = self.entity_hub.project_entity\n\n                elif ft_parent_id in ftrack_ids_to_create:\n                    if ft_parent_id not in self._ft_failed_sync_ids:\n                        parent = self._try_create_entity(ft_parent_id)\n\n                elif ft_parent_id in folder_hierarchy_changes:\n                    # If parent is also in hierarchy changes then make\n                    #   sure the parent is already processed\n                    # WARNING This may cause infinite loop or skip entities\n                    #   accidentally if process of parent is missing\n                    sources = (\n                        self._ft_failed_sync_ids,\n                        self._hierarchy_changed_by_ftrack_id,\n                        self._created_entity_by_ftrack_id,\n                    )\n                    if all(\n                        ft_parent_id not in source\n                        for source in sources\n                    ):\n                        changes_queue.append(item)\n                        continue\n\n                else:\n                    entity_ids = self.folder_ids_by_ftrack_id[ft_parent_id]\n                    if len(entity_ids) == 1:\n                        parent = self.entity_hub.get_or_fetch_entity_by_id(\n                            entity_ids[0], [\"folder\"])\n\n            if parent is None:\n                self.log.info(f\"Couldn't define parent of entity {entity.id}\")\n                self._ft_failed_sync_ids.add(ftrack_id)\n                continue\n\n            matching_entities = [\n                child\n                for child in parent.children\n                if child.name == name\n            ]\n            if entity in matching_entities:\n                matching_entities.remove(entity)\n\n            if matching_entities:\n                self.log.warning((\n                    \"Found more then one children with same name\"\n                    f\" \\\"{entity.name}\\\" under parent {parent.path}.\"\n                ))\n                self._ft_failed_sync_ids.add(ftrack_id)\n                continue\n\n            self._hierarchy_changed_by_ftrack_id[ftrack_id] = entity\n            if \"name\" in changes:\n                entity.name = name\n                entity.label = label\n\n            if \"parent_id\" in changes:\n                entity.parent_id = parent.id\n\n            ft_entity = self.get_ftrack_entity_by_id(ftrack_id)\n            entity.attribs[FTRACK_ID_ATTRIB] = ftrack_id\n            entity.attribs[FTRACK_PATH_ATTRIB] = \"/\".join([\n                item[\"name\"]\n                for item in ft_entity[\"link\"]\n                if item[\"type\"] != \"Project\"\n            ])\n            self.log.debug(f\"Updated hierarchy of {entity.path}\")\n\n        self.log.debug(\"Folder changes queue finished\")\n\n    def _process_removed_hierarchy_changes(self):\n        # Handle removed entities\n        # TODO it is possible to look for parent's children that can replace\n        #   previously synchronized entity\n        # - if removed entity has equivalent we can not remove it directly but\n        #       look for \"same name\" (slugified) next to it if parent still\n        #       exists (only if was not already synchronized).\n        removed_items = list(self.entities_by_action[\"remove\"].values())\n        removed_items.sort(key=lambda info: len(info[\"parents\"]))\n        for info in reversed(removed_items):\n            ftrack_id = info[\"entityId\"]\n            if info[\"entity_type\"] == \"Task\":\n                entity_ids = self.task_ids_by_ftrack_id[ftrack_id]\n                entity_type = \"task\"\n            else:\n                entity_ids = self.folder_ids_by_ftrack_id[ftrack_id]\n                entity_type = \"folder\"\n\n            # We don't change if entity was not found\n            if not entity_ids:\n                continue\n\n            # This can happen in some weird cases\n            if len(entity_ids) &gt; 1:\n                # TODO handle this case somehow\n                self.log.warning((\n                    \"Found more then one matching entity on server for\"\n                    f\" ftrack id {ftrack_id} ({entity_ids}). Skipping\"\n                ))\n                continue\n\n            entity_id = entity_ids[0]\n            entity = self.entity_hub.get_or_fetch_entity_by_id(\n                entity_id, [entity_type])\n            # Skip if entity was not found\n            if entity is None:\n                continue\n\n            # First try find different ftrack entity that can \"replace\" the\n            #   entity instead of previous\n            #   - e.g. 'sh-01' was removed but 'sh_01' is there\n            if self._try_find_other_match(info, entity):\n                continue\n\n            if (\n                entity.entity_type == \"folder\"\n                and entity.immutable_for_hierarchy\n            ):\n                # Change ftrack id to something else\n                entity.attribs[FTRACK_ID_ATTRIB] = REMOVED_ID_VALUE\n                continue\n\n            # This will remove the entity\n            path = entity.name\n            if entity.entity_type == \"folder\":\n                path = entity.path\n            elif entity.entity_type == \"task\":\n                if entity.parent:\n                    path = f\"{entity.parent.path}/{entity.name}\"\n            self.log.debug(f\"Removing entity {path}\")\n            entity.parent_id = None\n\n    def _process_created_hierarchy_changes(\n        self, ftrack_ids_to_create\n    ):\n        created_ftrack_ids = set(self._created_entity_by_ftrack_id.keys())\n        filtered_ftrack_ids_to_create = {\n            ftrack_id\n            for ftrack_id in ftrack_ids_to_create\n            if (\n                ftrack_id not in created_ftrack_ids\n                and ftrack_id not in self._ft_failed_sync_ids\n            )\n        }\n        if not filtered_ftrack_ids_to_create:\n            return\n\n        # TODO query entity id for entities from custom attributes\n        #   they may be already filled there even if the entity is new\n        for ftrack_id in filtered_ftrack_ids_to_create:\n            self._try_create_entity(ftrack_id)\n\n    def _get_server_id_by_ftrack_ids(\n        self, ftrack_ids: set[str]\n    ) -&gt; dict[str, Optional[str]]:\n        ayon_id_attr = self._get_server_id_attribute()\n        value_items = query_custom_attribute_values(\n            self.session,\n            {ayon_id_attr[\"id\"]},\n            ftrack_ids,\n        )\n        ayon_id_by_ftrack_id = {ftrack_id: None for ftrack_id in ftrack_ids}\n        ayon_id_by_ftrack_id.update({\n            item[\"entity_id\"]: item[\"value\"]\n            for item in value_items\n            if item[\"value\"]\n        })\n        return ayon_id_by_ftrack_id\n\n    def _process_task_hierarchy_changes(self, task_hierarchy_changes):\n        # TODO finish task name and parent changes\n        for ftrack_id, info in task_hierarchy_changes.items():\n            entity_ids = self.task_ids_by_ftrack_id[ftrack_id]\n            if len(entity_ids) != 1:\n                continue\n            entity = self.entity_hub.get_or_fetch_entity_by_id(\n                entity_ids[0], [\"task\"])\n\n            if entity is None:\n                continue\n\n            changes = info[\"changes\"]\n            if \"name\" in changes:\n                label = changes[\"name\"][\"new\"]\n                name = slugify_string(label)\n            else:\n                name = entity.name\n\n            parent = None\n            if \"parent_id\" not in changes:\n                parent = entity.parent\n            else:\n                ft_parent_id = changes[\"parent_id\"][\"new\"]\n                # Cannot add task under project\n                if ft_parent_id == self.ft_project_id:\n                    self._ft_failed_sync_ids.add(ftrack_id)\n                    continue\n\n                entity_ids = self.folder_ids_by_ftrack_id[ft_parent_id]\n                if len(entity_ids) == 1:\n                    parent = self.entity_hub.get_or_fetch_entity_by_id(\n                        entity_ids[0], [\"folder\"])\n\n            if parent is None:\n                self._ft_failed_sync_ids.add(ftrack_id)\n                continue\n\n            matching_entities = [\n                child\n                for child in parent.children\n                if child.name == name\n            ]\n            if entity in matching_entities:\n                matching_entities.remove(entity)\n\n            # TODO if this happens we should maybe check if other matching task\n            #   has set ftrack id?\n            if matching_entities:\n                self._ft_failed_sync_ids.add(ftrack_id)\n                continue\n\n            self._hierarchy_changed_by_ftrack_id[ftrack_id] = entity\n            if \"name\" in changes:\n                entity.name = name\n                entity.label = label\n\n            if \"parent_id\" in changes:\n                entity.parent_id = parent.id\n\n            entity.attribs[FTRACK_ID_ATTRIB] = ftrack_id\n\n    def _process_hierarchy_changes(self):\n        \"\"\"Handle all hierarchy changes.\n\n        Hierarchy change is creation of entity, removement of entity of change\n        of parent id or name. In all these cases the changes may not be\n        propagated.\n\n        - created enity can have duplicated name as any already existing entity\n            All names of entities from ftrack are \"slugified\" because of\n                strict name regex.\n        - changed or removed entities may already contain published content\n            In case there is something published we don't allow to remove\n                the entity. For removement of these entities is required to\n                trigger special actions.\n        \"\"\"\n\n        # Separate folder and task changes\n        folder_hierarchy_changes = {}\n        task_hierarchy_changes = {}\n\n        for ftrack_id, info in self.entities_by_action[\"update\"].items():\n            if info[\"entityType\"] == \"show\":\n                continue\n\n            changed_keys = info[\"keys\"]\n            if \"parent_id\" in changed_keys or \"name\" in changed_keys:\n                if info[\"entity_type\"] == \"Task\":\n                    task_hierarchy_changes[ftrack_id] = info\n                else:\n                    folder_hierarchy_changes[ftrack_id] = info\n\n        ftrack_ids_to_create = set(self.entities_by_action[\"add\"].keys())\n        self._clear_ayon_id_in_created_entities(ftrack_ids_to_create)\n        self._process_folder_hierarchy_changes(\n            folder_hierarchy_changes,\n            ftrack_ids_to_create\n        )\n        self._process_removed_hierarchy_changes()\n        self._process_created_hierarchy_changes(\n            ftrack_ids_to_create\n        )\n        self._process_task_hierarchy_changes(\n            task_hierarchy_changes\n        )\n\n    def _convert_value_by_cust_attr_conf(self, value, cust_attr_conf):\n        type_id = cust_attr_conf[\"type_id\"]\n        cust_attr_type_name = self.ft_cust_attr_types_by_id[type_id][\"name\"]\n        ignored = (\n            \"expression\", \"notificationtype\", \"dynamic enumerator\"\n        )\n        if cust_attr_type_name in ignored:\n            return None\n\n        if cust_attr_type_name == \"text\":\n            return value\n\n        if cust_attr_type_name == \"boolean\":\n            if value == \"1\":\n                return True\n            if value == \"0\":\n                return False\n            return bool(value)\n\n        if cust_attr_type_name == \"date\":\n            return arrow.get(value)\n\n        cust_attr_config = json.loads(cust_attr_conf[\"config\"])\n\n        if cust_attr_type_name == \"number\":\n            # Always convert to float ('1001.0' -&gt; 1001.0) first\n            #   - int('1001.0') -&gt; is crashing\n            value = float(value)\n            if cust_attr_config[\"isdecimal\"]:\n                return value\n            return int(value)\n\n        if cust_attr_type_name == \"enumerator\":\n            if not cust_attr_config[\"multiSelect\"]:\n                return value\n            return value.split(\", \")\n        return value\n\n    def _update_project_task_types(self):\n        project_entity = self.entity_hub.project_entity\n        src_task_types = {\n            task_type[\"name\"]: task_type\n            for task_type in project_entity.task_types\n        }\n\n        new_task_types = []\n        project_schema = self.ft_project[\"project_schema\"]\n        for task_type in project_schema[\"task_type_schema\"][\"types\"]:\n            task_type_name = task_type[\"name\"]\n            if task_type_name in src_task_types:\n                new_task_types.append(src_task_types[task_type_name])\n            else:\n                new_task_types.append({\n                    \"name\": task_type_name,\n                    \"shortName\": re.sub(r\"\\W+\", \"\", task_type_name.lower())\n                })\n\n        project_entity.task_types = new_task_types\n\n    def _update_project_statuses(self):\n        ft_project = self.ft_project\n        ft_session = self.session\n        fields = {\n            \"asset_version_workflow_schema\",\n            \"task_workflow_schema\",\n            \"task_workflow_schema_overrides\",\n            \"object_type_schemas\",\n        }\n        project_schema_id = ft_project[\"project_schema_id\"]\n\n        joined_fields = \", \".join(fields)\n        project_schema = ft_session.query(\n            f\"select {joined_fields} from ProjectSchema\"\n            f\" where id is '{project_schema_id}'\"\n        ).first()\n\n        # Folder statuses\n        schema_ids = {\n            schema[\"id\"]\n            for schema in project_schema[\"object_type_schemas\"]\n        }\n        object_type_schemas = []\n        if schema_ids:\n            joined_schema_ids = join_filter_values(schema_ids)\n            object_type_schemas = ft_session.query(\n                \"select id, object_type_id from Schema\"\n                f\" where id in ({joined_schema_ids})\"\n            ).all()\n\n        object_type_schema_ids = {\n            schema[\"id\"]\n            for schema in object_type_schemas\n        }\n        folder_statuses_ids = set()\n        if object_type_schema_ids:\n            joined_ot_schema_ids = join_filter_values(object_type_schema_ids)\n            schema_statuses = ft_session.query(\n                \"select status_id from SchemaStatus\"\n                f\" where schema_id in ({joined_ot_schema_ids})\"\n            ).all()\n            folder_statuses_ids = {\n                status[\"status_id\"]\n                for status in schema_statuses\n            }\n\n        # Task statues\n        task_workflow_override_ids = {\n            task_override[\"id\"]\n            for task_override in (\n                project_schema[\"task_workflow_schema_overrides\"]\n            )\n        }\n        workflow_ids = set()\n        if task_workflow_override_ids:\n            joined_ids = join_filter_values(task_workflow_override_ids)\n            override_schemas = ft_session.query(\n                \"select workflow_schema_id\"\n                f\" from ProjectSchemaOverride\"\n                f\" where id in ({joined_ids})\"\n            ).all()\n            workflow_ids = {\n                override_schema[\"workflow_schema_id\"]\n                for override_schema in override_schemas\n            }\n\n        workflow_ids.add(project_schema[\"task_workflow_schema\"][\"id\"])\n        joined_workflow_ids = join_filter_values(workflow_ids)\n        workflow_statuses = ft_session.query(\n            \"select status_id\"\n            \" from WorkflowSchemaStatus\"\n            f\" where workflow_schema_id in ({joined_workflow_ids})\"\n        ).all()\n        task_status_ids = {\n            item[\"status_id\"]\n            for item in workflow_statuses\n        }\n\n        # Version statuses\n        av_workflow_schema_id = (\n            project_schema[\"asset_version_workflow_schema\"][\"id\"]\n        )\n        version_statuse_ids = {\n            item[\"status_id\"]\n            for item in ft_session.query(\n                \"select status_id\"\n                \" from WorkflowSchemaStatus\"\n                f\" where workflow_schema_id is '{av_workflow_schema_id}'\"\n            ).all()\n        }\n\n        statuses_by_id = {\n            status[\"id\"]: status\n            for status in ft_session.query(\n                \"select id, name, color, state, sort from Status\"\n            ).all()\n        }\n        all_status_ids = (\n            folder_statuses_ids\n            | task_status_ids\n            | version_statuse_ids\n        )\n        state_mapping = {\n            \"Blocked\": \"blocked\",\n            \"Not Started\": \"not_started\",\n            \"In Progress\": \"in_progress\",\n            \"Done\": \"done\",\n        }\n        statuses_data = []\n        for status_id in all_status_ids:\n            status = statuses_by_id[status_id]\n            scope = [\"representation\", \"workfile\"]\n            if status_id in folder_statuses_ids:\n                scope.append(\"folder\")\n            if status_id in task_status_ids:\n                scope.append(\"task\")\n            if status_id in version_statuse_ids:\n                scope.append(\"product\")\n                scope.append(\"version\")\n\n            ft_state = status[\"state\"][\"name\"]\n            ayon_state = state_mapping[ft_state]\n            statuses_data.append({\n                \"name\": status[\"name\"],\n                \"color\": status[\"color\"],\n                \"state\": ayon_state,\n                \"scope\": scope,\n                \"sort\": status[\"sort\"],\n            })\n        statuses_data.sort(key=lambda i: i[\"sort\"])\n\n        statuses = self._entity_hub.project_entity.statuses\n        for idx, status_data in enumerate(statuses_data):\n            status_item = statuses.get_status_by_slugified_name(\n                status_data[\"name\"]\n            )\n            if status_item is None:\n                statuses.insert(idx, status_data)\n                continue\n            status_item.name = status_data[\"name\"]\n            status_item.color = status_data[\"color\"]\n            status_item.state = status_data[\"state\"]\n            status_item.scope = status_data[\"scope\"]\n            statuses.insert(idx, status_item)\n        self._entity_hub.commit_changes()\n\n    def _propagate_task_type_changes(self, task_type_changes):\n        if not task_type_changes:\n            return\n\n        project_entity = self.entity_hub.project_entity\n        task_types_names = {\n            task_type[\"name\"]\n            for task_type in project_entity.task_types\n        }\n        task_types = self.ft_task_type_name_by_id\n\n        to_change = []\n        project_need_update = False\n        for ftrack_id, (entity, info) in task_type_changes.items():\n            new_type_id = info[\"changes\"][\"typeid\"][\"new\"]\n            new_type_name = task_types[new_type_id]\n            if entity.task_type == new_type_name:\n                continue\n\n            if new_type_name not in task_types_names:\n                project_need_update = True\n\n            to_change.append((entity, new_type_name))\n\n        if project_need_update:\n            self._update_project_task_types()\n\n        for entity, new_type_name in to_change:\n            prev_task_type = entity.task_type\n            entity.task_type = new_type_name\n            self.log.debug(\n                f\"Changed task type {prev_task_type} -&gt; {new_type_name}\")\n\n    def _propagate_status_changes(self, status_changes):\n        if not status_changes:\n            return\n\n        project_entity = self.entity_hub.project_entity\n        ayon_statuses_by_name = {\n            status.name.lower(): status\n            for status in project_entity.statuses\n        }\n        ft_status_names_by_id = self.ft_status_names_by_id\n        to_change = []\n        project_need_update = False\n        for ftrack_id, (entity, info) in status_changes.items():\n            new_status_id = info[\"changes\"][\"statusid\"][\"new\"]\n            new_status_name = ft_status_names_by_id[new_status_id]\n            if entity.status.lower() == new_status_name.lower():\n                continue\n\n            ayon_status = ayon_statuses_by_name.get(new_status_name.lower())\n            if (\n                ayon_status is None\n                or entity.entity_type not in ayon_status.scope\n            ):\n                project_need_update = True\n\n            to_change.append((entity, ayon_status.name))\n\n        if project_need_update:\n            self._update_project_statuses()\n            # Recalculate 'ayon_statuses_by_name' variable with new statuses\n            project_entity = self.entity_hub.project_entity\n            ayon_statuses_by_name = {\n                status.name.lower(): status\n                for status in project_entity.statuses\n            }\n\n        for entity, new_status_name in to_change:\n            ayon_status = ayon_statuses_by_name.get(new_status_name.lower())\n            if (\n                ayon_status is None\n                or entity.entity_type not in ayon_status.scope\n            ):\n                self.log.debug(\n                    f\"Status '{new_status_name}' not found on AYON project\"\n                )\n                continue\n\n            prev_status_name = entity.status\n            entity.status = new_status_name\n            self.log.debug(\n                f\"Changed status {prev_status_name} -&gt; {new_status_name}\")\n\n    def _propagate_attrib_changes(self):\n        # Prepare all created ftrack ids\n        # - in that case it is not needed to update attributes as they have\n        #   set all attributes from ftrack\n        created_ftrack_ids = set(self._created_entity_by_ftrack_id.keys())\n        task_type_changes = {}\n        status_changes = {}\n        for ftrack_id, info in self.entities_by_action[\"update\"].items():\n            if ftrack_id in created_ftrack_ids:\n                continue\n\n            entity = None\n            if info[\"entityType\"] == \"show\":\n                entity = self.entity_hub.project_entity\n\n            elif info[\"entityType\"] == \"task\":\n                if info[\"entity_type\"] == \"Task\":\n                    entity_ids = self.task_ids_by_ftrack_id[ftrack_id]\n                    entity_types = [\"task\"]\n                else:\n                    entity_ids = self.folder_ids_by_ftrack_id[ftrack_id]\n                    entity_types = [\"folder\"]\n\n                if len(entity_ids) == 1:\n                    entity_id = entity_ids[0]\n                    entity = self.entity_hub.get_or_fetch_entity_by_id(\n                        entity_id, entity_types\n                    )\n\n            elif info[\"entityType\"] == \"assetversion\":\n                entity = self._find_ayon_version_from_ent_info(info)\n\n            if entity is None:\n                continue\n\n            attrib_changes = {}\n            for key, change_info in info[\"changes\"].items():\n                value = change_info[\"new\"]\n                if key == \"typeid\":\n                    if entity.entity_type == \"task\":\n                        task_type_changes[ftrack_id] = (entity, info)\n                    continue\n\n                if key == \"statusid\":\n                    status_changes[ftrack_id] = (entity, info)\n                    continue\n\n                if key in DEFAULT_ATTRS_MAPPING:\n                    dst_key = DEFAULT_ATTRS_MAPPING[key]\n                    if dst_key not in entity.attribs:\n                        continue\n\n                    if value is not None and key in (\"startdate\", \"enddate\"):\n                        date = arrow.get(value)\n                        # Shift date to 00:00:00 of the day\n                        # - ftrack is returning e.g. '2024-10-29T22:00:00'\n                        #  for '2024-10-30'\n                        value = str(date.shift(hours=24 - date.hour))\n\n                    entity.attribs[dst_key] = value\n                    continue\n\n                attrib_changes[key] = value\n\n            if not attrib_changes:\n                continue\n\n            attrs_mapping: CustomAttributesMapping = self.cust_attr_mapping\n            ft_entity = self.get_ftrack_entity_by_id(ftrack_id)\n\n            for key, value in attrib_changes.items():\n                mapping_item = attrs_mapping.get_mapping_item_by_key(\n                    ft_entity, key\n                )\n                if mapping_item is None:\n                    continue\n\n                dst_key = mapping_item.ayon_attribute_name\n                if dst_key not in entity.attribs:\n                    continue\n\n                if value is not None:\n                    if dst_key == \"fps\":\n                        value = convert_to_fps(value)\n                    else:\n                        attr = mapping_item.get_attr_conf_for_entity(\n                            ft_entity\n                        )\n                        value = self._convert_value_by_cust_attr_conf(\n                            value, attr\n                        )\n\n                entity.attribs[dst_key] = value\n\n        self._propagate_task_type_changes(task_type_changes)\n        self._propagate_status_changes(status_changes)\n\n    def _find_ayon_version_from_ent_info(\n        self, entity_info: dict[str, Any]\n    ) -&gt; Optional[VersionEntity]:\n        parents = entity_info[\"parents\"]\n        asset_version_id = parents[0][\"entityId\"]\n        mapping = self._find_matching_ayon_versions({asset_version_id})\n        ayon_id = mapping[asset_version_id]\n        if ayon_id:\n            return self.entity_hub.get_version_by_id(ayon_id)\n        return None\n\n    def _propagate_assignee_changes(self):\n        assignee_changes = self.entities_by_action[\"assignee_change\"]\n        if not assignee_changes:\n            return\n\n        # Initial preparation of user entities\n        ftrack_users = self.session.query(\n            \"select id, username, email from User\"\n        ).all()\n        ayon_user_by_ftrack_id = map_ftrack_users_to_ayon_users(ftrack_users)\n\n        ent_info_by_task_id = {}\n        for ent_info in assignee_changes.values():\n            changes = ent_info[\"changes\"]\n            user_id_changes = changes[\"resource_id\"]\n            user_id = user_id_changes[\"new\"] or user_id_changes[\"old\"]\n            ayon_user = ayon_user_by_ftrack_id.get(user_id)\n            if not ayon_user:\n                continue\n            task_id_changes = changes[\"context_id\"]\n            task_id = task_id_changes[\"new\"] or task_id_changes[\"old\"]\n            ent_info_by_task_id.setdefault(task_id, []).append(ent_info)\n\n        for task_id, ent_infos in ent_info_by_task_id.items():\n            entity_ids = self.task_ids_by_ftrack_id[task_id]\n            if len(entity_ids) != 1:\n                continue\n            task_entity = self.entity_hub.get_or_fetch_entity_by_id(\n                entity_ids[0], [\"task\"]\n            )\n            if task_entity is None:\n                continue\n\n            assignees = task_entity.assignees\n            assignees_changed = False\n            for ent_info in ent_infos:\n                changes = ent_info[\"changes\"]\n                user_id_changes = changes[\"resource_id\"]\n                added = True\n                user_id = user_id_changes[\"new\"]\n                if user_id is None:\n                    added = False\n                    user_id = user_id_changes[\"old\"]\n\n                ayon_user = ayon_user_by_ftrack_id.get(user_id)\n                if added:\n                    if ayon_user not in assignees:\n                        assignees.append(ayon_user)\n                        assignees_changed = True\n                elif ayon_user in assignees:\n                    assignees.remove(ayon_user)\n                    assignees_changed = True\n\n            if assignees_changed:\n                task_entity.assignees = assignees\n\n    def _propagate_link_changes(self):\n        link_change = self.entities_by_action[\"link_change\"]\n        if not link_change:\n            return\n\n        links_info = []\n        ftrack_ids = set()\n        for ent_info in link_change:\n            to_id_changes = ent_info[\"changes\"][\"to_id\"]\n            from_id_changes = ent_info[\"changes\"][\"from_id\"]\n            action = ent_info[\"action\"]\n            if action == \"add\":\n                to_id = to_id_changes[\"new\"]\n                from_id = from_id_changes[\"new\"]\n            else:\n                to_id = to_id_changes[\"old\"]\n                from_id = from_id_changes[\"old\"]\n\n            ftrack_ids |= {to_id, from_id}\n            links_info.append(\n                (from_id, to_id, action)\n            )\n\n        ayon_out_ids = set()\n        added_links = []\n        removed_links = []\n        entities_by_id = self.get_ftrack_entity_by_ids(ftrack_ids)\n        for (ft_from_id, ft_to_id, action) in links_info:\n            ft_from_entity = entities_by_id[ft_to_id]\n            ft_to_entity = entities_by_id[ft_to_id]\n            if not ft_to_entity or not ft_from_entity:\n                continue\n\n            if (\n                ft_from_entity.entity_type.lower() == \"task\"\n                or ft_to_entity.entity_type.lower() == \"task\"\n            ):\n                continue\n\n            ay_in_entity_ids = self.folder_ids_by_ftrack_id[ft_from_id]\n            ay_out_entity_ids = self.folder_ids_by_ftrack_id[ft_to_id]\n            if len(ay_in_entity_ids) != 1 or len(ay_out_entity_ids) != 1:\n                continue\n            ay_in_id = ay_in_entity_ids[0]\n            ay_out_id = ay_out_entity_ids[0]\n            ayon_out_ids.add(ay_out_id)\n            if action == \"add\":\n                added_links.append((ay_in_id, ay_out_id))\n            else:\n                removed_links.append((ay_in_id, ay_out_id))\n\n        if not added_links and not removed_links:\n            return\n\n        ay_link_type = (\n            self.project_settings\n            [\"ftrack\"]\n            [\"service_event_handlers\"]\n            [\"sync_from_ftrack\"]\n            [\"sync_link_type\"]\n        )\n        if ay_link_type == \"&lt; Skip &gt;\":\n            self.log.info(\"Links sync is not set to be skipped.\")\n            return\n\n        project_entity = self.get_ayon_project()\n        exists = False\n        for link_type in project_entity[\"linkTypes\"]:\n            if (\n                link_type[\"linkType\"] == ay_link_type\n                and link_type[\"inputType\"] == \"folder\"\n                and link_type[\"outputType\"] == \"folder\"\n            ):\n                exists = True\n\n        if not exists:\n            self.log.warning(\n                f\"Skipping links sync because link type '{ay_link_type}'\"\n                f\" does not exist on project '{self.project_name}'.\"\n            )\n            return\n\n        folder_links_by_id = get_folders_links(\n            self.project_name,\n            folder_ids=ayon_out_ids,\n            link_types={ay_link_type},\n            link_direction=\"in\",\n        )\n        folder_link_ids_by_id = {}\n        for ayon_id, links in folder_links_by_id.items():\n            folder_link_ids_by_id[ayon_id] = {\n                link[\"entityId\"]: link\n                for link in links\n            }\n\n        for (ay_in_id, ay_out_id) in removed_links:\n            link = folder_link_ids_by_id[ay_out_id].get(ay_in_id)\n            if link:\n                delete_link(self.project_name, link[\"id\"])\n\n        for (ay_in_id, ay_out_id) in added_links:\n            if ay_in_id not in folder_link_ids_by_id[ay_out_id]:\n                create_link(\n                    self.project_name,\n                    ay_link_type,\n                    ay_in_id,\n                    \"folder\",\n                    ay_out_id,\n                    \"folder\",\n                )\n\n    def _propagate_list_changes(self) -&gt; None:\n        list_added = self.entities_by_action[\"list_added\"]\n        list_removed = self.entities_by_action[\"list_removed\"]\n        list_changed = self.entities_by_action[\"list_changed\"]\n        list_item_change = self.entities_by_action[\"list_item_change\"]\n        if not list_added and not list_removed and not list_changed:\n            self._process_list_item_changes()\n            return\n\n        ayon_lists = list(ayon_api.get_entity_lists(\n            self.project_name,\n            fields={\"id\", \"label\", \"entityType\", \"attrib\"}\n        ))\n        ay_lists_by_ftrack_id = {}\n        ay_lists_by_label_low = {}\n        for ay_list in ayon_lists:\n            ftrack_id = ay_list[\"attrib\"].get(FTRACK_ID_ATTRIB)\n            if ftrack_id:\n                ay_lists_by_ftrack_id[ftrack_id] = ay_list\n            label_low = ay_list[\"label\"].lower()\n            ay_lists_by_label_low[label_low] = ay_list\n\n        for ent_info in list_removed:\n            ftrack_id = ent_info[\"entityId\"]\n            # We don't care about changes of items related to the removed list\n            list_item_change.pop(ftrack_id, None)\n\n            # Try to find AYON list by ftrack id\n            ay_list = ay_lists_by_ftrack_id.get(ftrack_id)\n            if not ay_list:\n                # Try to find AYON list by name\n                name = ent_info[\"changes\"][\"name\"][\"old\"].lower()\n                ay_list = ay_lists_by_label_low.get(name)\n\n            # NOTE we might check if the entity type of AYON list is\n            #   actually the same?\n            # - in case someone wants to \"fix\" wrong type of the ftrack list\n            #   he will loose AYON list with this\n            if not ay_list:\n                continue\n\n            # Remove list only if is meant for the same type\n            if ent_info[\"entity_type\"] == \"AssetVersionList\":\n                if ay_list[\"entityType\"] != \"version\":\n                    continue\n            elif ent_info[\"entity_type\"] == \"TypedContextList\":\n                # - We can't get expected type for 'TypedContextList' because\n                #   the custom attribute value to find out is already deleted.\n                if ay_list[\"entityType\"] not in (\"folder\", \"task\"):\n                    continue\n\n            ayon_api.delete_entity_list(self.project_name, ay_list[\"id\"])\n\n        added_ids = set()\n        for ent_info in list_added:\n            ftrack_id = ent_info[\"entityId\"]\n            added_ids.add(ftrack_id)\n            entity_type = \"version\"\n            if ent_info[\"entity_type\"] != \"AssetVersionList\":\n                attr_def = self._get_list_type_attribute()\n                if attr_def is None:\n                    self.log.warning(\n                        \"Can't sync task List because of missing\"\n                        f\" custom attribute '{CUST_ATTR_KEY_LIST_TYPE}'\"\n                    )\n                    continue\n\n                list_type = None\n                for item in query_custom_attribute_values(\n                    self.session,\n                    {attr_def[\"id\"]},\n                    {ftrack_id},\n                ):\n                    value = item[\"value\"]\n                    if value:\n                        list_type = value\n\n                if list_type is None:\n                    list_type = attr_def[\"default\"]\n\n                if list_type and isinstance(list_type, list):\n                    list_type = list_type[0]\n\n                if list_type in (\"task\", \"folder\"):\n                    entity_type = list_type\n\n            label = ent_info[\"changes\"][\"name\"][\"new\"]\n            ay_list = ay_lists_by_ftrack_id.get(ftrack_id)\n            if not ay_list:\n                # Try to find AYON list by name\n                ay_list = ay_lists_by_label_low.get(label.lower())\n\n            if ay_list:\n                ay_entity_type = ay_list[\"entityType\"]\n                if ay_entity_type == entity_type:\n                    self.log.info(f\"List '{label}' already exists in AYON\")\n                else:\n                    self.log.warning(\n                        f\"List '{label}' already exists but for different\"\n                        f\" entity type (Expected '{entity_type}'\"\n                        f\" Current: '{ay_entity_type})\"\n                    )\n                continue\n\n            self.log.info(f\"Creating list '{label}' in AYON\")\n            ayon_api.create_entity_list(\n                self.project_name,\n                entity_type,\n                label,\n                attrib={FTRACK_ID_ATTRIB: ftrack_id},\n            )\n\n        # Propagate changes of list\n        for ent_info in list_changed:\n            ftrack_id = ent_info[\"entityId\"]\n            # Ignore created lists as all values are fetched anyways\n            if ftrack_id in added_ids:\n                continue\n\n            # Find ayon list\n            ay_list = ay_lists_by_ftrack_id.get(ftrack_id)\n            ay_changes = {}\n            if not ay_list:\n                ft_list = self.session.query(\n                    f\"select name from List where id is '{ftrack_id}'\"\n                ).first()\n                if ft_list is None:\n                    continue\n                name = ft_list[\"name\"].lower()\n                ay_list = ay_lists_by_label_low.get(name)\n                if ay_list:\n                    ay_changes[\"attrib\"] = {FTRACK_ID_ATTRIB: ftrack_id}\n\n            if not ay_list:\n                continue\n\n            if \"name\" in ent_info[\"changes\"]:\n                name = ent_info[\"changes\"][\"name\"][\"new\"]\n                if name != ay_list[\"label\"]:\n                    ay_changes[\"label\"] = name\n\n            if ay_changes:\n                ayon_api.update_entity_list(\n                    self.project_name,\n                    ay_list[\"id\"],\n                    **ay_changes\n                )\n\n            # Handle changes of 'ayon_list_type'. Right now it changes value\n            #   to entity type set on AYON's list if exists.\n            # NOTE it might be possible to change the type, but that would\n            #   to delete AYON list and create new\n            if (\n                CUST_ATTR_KEY_LIST_TYPE not in ent_info[\"changes\"]\n                or ent_info[\"entity_type\"] != \"TypedContextList\"\n            ):\n                continue\n\n            attr_def = self._get_list_type_attribute()\n            new_value = None\n            for item in query_custom_attribute_values(\n                self.session, {attr_def[\"id\"]}, {ftrack_id}\n            ):\n                value = item[\"value\"]\n                if value is not None:\n                    new_value = value\n\n            if new_value == ay_list[\"entityType\"]:\n                continue\n\n            op = self._create_ft_attr_operation(\n                attr_def[\"id\"],\n                ftrack_id,\n                new_value is None,\n                ay_list[\"entityType\"],\n                new_value\n            )\n            self.session.recorded_operations.push(op)\n\n        self._process_list_item_changes(ayon_lists)\n\n    def _process_list_item_changes(\n        self, ayon_lists: Optional[list[dict[str, Any]]] = None\n    ) -&gt; None:\n        list_item_change: dict[str, list[dict[str, Any]]] = (\n            self.entities_by_action[\"list_item_change\"]\n        )\n        if not list_item_change:\n            return\n\n        # TODO implement list item changes propagation\n        ft_version_ids = set()\n        ft_entity_ids = set()\n        ent_info_by_list_id = {}\n        for list_id, ent_infos in list_item_change.items():\n            list_type = None\n            for ent_info in ent_infos:\n                if list_type is None:\n                    for parent in ent_info[\"parents\"]:\n                        if parent[\"entityType\"] == \"list\":\n                            list_type = parent[\"entity_type\"]\n                            break\n\n                action = ent_info[\"action\"]\n                if action == \"add\":\n                    entity_id = ent_info[\"changes\"][\"entityid\"][\"new\"]\n                else:\n                    entity_id = ent_info[\"changes\"][\"entityid\"][\"old\"]\n\n                ent_info_by_list_id.setdefault(list_id, []).append(ent_info)\n                if list_type == \"AssetVersionList\":\n                    ft_version_ids.add(entity_id)\n                else:\n                    ft_entity_ids.add(entity_id)\n\n        if not ent_info_by_list_id:\n            return\n\n        if ayon_lists is None:\n            ayon_lists = list(ayon_api.get_entity_lists(\n                self.project_name,\n                fields={\"id\", \"label\", \"entityType\", \"allAttrib\"},\n            ))\n\n        # No lists, nothing to update...\n        if not ayon_lists:\n            return\n\n        ay_lists_by_ftrack_id = {}\n        ay_lists_by_label_low = {}\n        for ay_list in ayon_lists:\n            all_attrib = json.loads(ay_list[\"allAttrib\"] or \"{}\")\n            ay_list[\"attrib\"] = all_attrib\n            ftrack_id = all_attrib.get(FTRACK_ID_ATTRIB)\n            if ftrack_id:\n                ay_lists_by_ftrack_id[ftrack_id] = ay_list\n            label_low = ay_list[\"label\"].lower()\n            ay_lists_by_label_low[label_low] = ay_list\n\n        ids_mapping = self._get_server_id_by_ftrack_ids(\n            ft_entity_ids | ft_version_ids\n        )\n\n        missing_ft_version_ids = set()\n        for ftrack_id in ft_version_ids:\n            ayon_id = ids_mapping[ftrack_id]\n            if not ayon_id:\n                missing_ft_version_ids.add(ftrack_id)\n\n        ids_mapping.update(self._find_matching_ayon_versions(\n            missing_ft_version_ids\n        ))\n\n        ft_missing_list_ids = set()\n        for ft_list_id in ent_info_by_list_id:\n            ay_list = ay_lists_by_ftrack_id.get(ft_list_id)\n            if not ay_list:\n                ft_missing_list_ids.add(ft_list_id)\n\n        if ft_missing_list_ids:\n            joined_list_ids = join_filter_values(ft_missing_list_ids)\n            ft_lists = self.session.query(\n                f\"select id, name from List where id in ({joined_list_ids})\"\n            ).all()\n            for ft_list in ft_lists:\n                name = ft_list[\"name\"].lower()\n                ay_list = ay_lists_by_label_low.get(name)\n                if ay_list:\n                    ayon_api.update_entity_list(\n                        self.project_name,\n                        ay_list[\"id\"],\n                        attrib={FTRACK_ID_ATTRIB: ft_list[\"id\"]}\n                    )\n                    ay_lists_by_ftrack_id[ft_list[\"id\"]] = ay_list\n\n        ft_task_ids = set()\n        ft_folder_ids = set()\n        if ft_entity_ids:\n            joined_entity_ids = join_filter_values(ft_entity_ids)\n            task_type = self.session.query(\n                \"select id from ObjectType where name is 'Task'\"\n            ).one()\n            for entity in self.session.query(\n                \"select id, object_type_id from TypedContext\"\n                f\" where id in ({joined_entity_ids})\"\n            ):\n                if entity[\"object_type_id\"] == task_type[\"id\"]:\n                    ft_task_ids.add(entity[\"id\"])\n                else:\n                    ft_folder_ids.add(entity[\"id\"])\n\n        ayon_list_ids = set()\n        for ft_list_id, ent_infos in ent_info_by_list_id.items():\n            ayon_list = ay_lists_by_ftrack_id.get(ft_list_id)\n            if ayon_list:\n                ayon_list_ids.add(ayon_list[\"id\"])\n\n        if not ayon_list_ids:\n            return\n\n        for ft_list_id, ent_infos in ent_info_by_list_id.items():\n            ayon_list = ay_lists_by_ftrack_id.get(ft_list_id)\n            if not ayon_list:\n                # QUESTION should we create the list in AYON?\n                continue\n\n            list_type = ayon_list[\"entityType\"]\n            l_w_items = ayon_api.get_entity_list_by_id(\n                self.project_name,\n                ayon_list[\"id\"],\n                fields={\"items.id\", \"items.entityId\"},\n            )\n            items_by_entity_id = {\n                item[\"entityId\"]: item\n                for item in l_w_items[\"items\"]\n            }\n\n            to_add_ids = set()\n            to_remove_ids = set()\n            for ent_info in ent_infos:\n                action = ent_info[\"action\"]\n                if action == \"add\":\n                    entity_id = ent_info[\"changes\"][\"entityid\"][\"new\"]\n                else:\n                    entity_id = ent_info[\"changes\"][\"entityid\"][\"old\"]\n\n                ayon_id = ids_mapping.get(entity_id)\n                if not ayon_id:\n                    continue\n\n                # Filter items that have incompatible type for AYON list\n                if list_type == \"folder\":\n                    if entity_id not in ft_folder_ids:\n                        continue\n                elif list_type == \"task\":\n                    if entity_id not in ft_task_ids:\n                        continue\n                elif list_type == \"version\":\n                    if entity_id not in ft_version_ids:\n                        continue\n\n                if action == \"add\":\n                    if ayon_id not in items_by_entity_id:\n                        to_add_ids.add(ayon_id)\n                else:\n                    item = items_by_entity_id.get(ayon_id)\n                    if item:\n                        to_remove_ids.add(item[\"id\"])\n\n            if to_remove_ids:\n                ayon_api.update_entity_list_items(\n                    self.project_name,\n                    ayon_list[\"id\"],\n                    items=[{\"id\": i} for i in to_remove_ids],\n                    mode=\"delete\",\n                )\n\n            if to_add_ids:\n                ayon_api.update_entity_list_items(\n                    self.project_name,\n                    ayon_list[\"id\"],\n                    items=[{\"entityId\": i} for i in to_add_ids],\n                    mode=\"merge\",\n                )\n\n    def _update_versions_ayon_id(\n        self,\n        ayon_id_attr_id: str,\n        available_values: dict[str, Union[str, None]],\n        mapping: dict[str, Union[str, None]],\n    ) -&gt; None:\n        \"\"\"Update ayon_id custom attribute in ftrack.\"\"\"\n        for ftrack_id, ayon_id in mapping.items():\n            if not ayon_id:\n                continue\n            current_id = available_values.get(ftrack_id)\n            if current_id == ayon_id:\n                continue\n\n            op = self._create_ft_attr_operation(\n                ayon_id_attr_id,\n                ftrack_id,\n                ftrack_id not in available_values,\n                current_id,\n                ayon_id\n            )\n            self.session.recorded_operations.push(op)\n            # Also update available values\n            available_values[ftrack_id] = ayon_id\n        self.session.commit()\n\n    def _find_matching_ayon_versions(\n        self, ftrack_ids: set[str]\n    ) -&gt; dict[str, Optional[str]]:\n        \"\"\"Versions did not have stored ayon_id in attribute for some time.\"\"\"\n        output = {i: None for i in ftrack_ids}\n        if not ftrack_ids:\n            return output\n\n        ayon_id_attr = self._get_server_id_attribute()\n\n        available_values = {}\n        for item in query_custom_attribute_values(\n            self.session,\n            {ayon_id_attr[\"id\"]},\n            ftrack_ids,\n        ):\n            value = item[\"value\"]\n            entity_id = item[\"entity_id\"]\n            available_values[entity_id] = value\n            if value:\n                output[entity_id] = value\n\n        missing_ids = {\n            ft_id\n            for ft_id, ay_id in output.items()\n            if not ay_id\n        }\n\n        if not missing_ids:\n            return output\n\n        filters = {\n            \"conditions\": [{\n                \"key\": f\"attrib.{FTRACK_ID_ATTRIB}\",\n                \"operator\": \"in\",\n                \"value\": list(missing_ids),\n            }]\n        }\n\n        for version in ayon_api.get_versions(\n            self.project_name,\n            filters=filters,\n            fields={\"id\", f\"attrib.{FTRACK_ID_ATTRIB}\"},\n        ):\n            ftack_id = version[\"attrib\"][FTRACK_ID_ATTRIB]\n            missing_ids.discard(ftack_id)\n            output[ftack_id] = version[\"id\"]\n\n        if not missing_ids:\n            self._update_versions_ayon_id(\n                ayon_id_attr[\"id\"], available_values, output\n            )\n            return output\n\n        joined_av_ids = join_filter_values(missing_ids)\n        asset_versions = self.session.query(\n            f\"select id, asset_id, version from AssetVersion\"\n            f\" where id in ({joined_av_ids})\"\n        ).all()\n        ft_version_ints = {av[\"version\"] for av in asset_versions}\n        asset_ids = {av[\"asset_id\"] for av in asset_versions}\n        av_by_asset_id = {a_id: [] for a_id in asset_ids}\n        for av in asset_versions:\n            av_by_asset_id[av[\"asset_id\"]].append(av)\n\n        joined_asset_id = join_filter_values(asset_ids)\n\n        assets = self.session.query(\n            \"select id, name, context_id from Asset\"\n            f\" where id in ({joined_asset_id})\"\n        ).all()\n        assets_by_id = {a[\"id\"]: a for a in assets}\n        context_ids = {a[\"context_id\"] for a in assets}\n        assets_by_parent_id = {i: [] for i in context_ids}\n        for asset in assets:\n            assets_by_parent_id[asset[\"context_id\"]].append(asset)\n\n        parents_mapping = self._get_server_id_by_ftrack_ids(context_ids)\n\n        folder_ids = {\n            folder_id\n            for folder_id in parents_mapping.values()\n            if folder_id\n        }\n        if not folder_ids:\n            self._update_versions_ayon_id(\n                ayon_id_attr[\"id\"], available_values, output\n            )\n            return output\n\n        product_ids = set()\n        products_by_folder_id = {i: [] for i in folder_ids}\n        for product in ayon_api.get_products(\n            self.project_name,\n            folder_ids=folder_ids,\n            fields={\"id\", \"name\", \"folderId\"}\n        ):\n            folder_id = product[\"folderId\"]\n            product_ids.add(product[\"id\"])\n            products_by_folder_id[folder_id].append(product)\n\n        version_ids_by_product_id = {i: {} for i in product_ids}\n        for version_entity in ayon_api.get_versions(\n            self.project_name,\n            versions=ft_version_ints,\n            product_ids=product_ids,\n            fields={\"id\", \"version\", \"productId\"},\n        ):\n            product_id = version_entity[\"productId\"]\n            version = version_entity[\"version\"]\n            version_id = version_entity[\"id\"]\n            version_ids_by_product_id[product_id][version] = version_id\n\n        for asset_version in asset_versions:\n            ft_asset_id = asset_version[\"asset_id\"]\n            ft_asset = assets_by_id[ft_asset_id]\n            ft_context_id = ft_asset[\"context_id\"]\n            folder_id = parents_mapping.get(ft_context_id)\n            if not folder_id:\n                continue\n\n            products = products_by_folder_id.get(folder_id)\n            if not products:\n                continue\n\n            ft_asset_name = ft_asset[\"name\"].lower()\n            matching_product = None\n            alternatives = []\n            for product_entity in products:\n                product_name = product_entity[\"name\"].lower()\n                if product_name == ft_asset_name:\n                    matching_product = product_entity\n                    break\n                if product_name in ft_asset_name:\n                    alternatives.append(product_entity)\n\n            if matching_product is None and alternatives:\n                matching_product = alternatives[0]\n\n            if not matching_product:\n                continue\n\n            product_id = matching_product[\"id\"]\n            ft_version = asset_version[\"version\"]\n            version_id = version_ids_by_product_id[product_id].get(ft_version)\n            if version_id:\n                output[asset_version[\"id\"]] = version_id\n\n        self._update_versions_ayon_id(\n            ayon_id_attr[\"id\"], available_values, output\n        )\n        return output\n\n    def _create_ft_attr_operation(\n        self, conf_id, entity_id, is_new, new_value, old_value=None\n    ):\n        entity_key = collections.OrderedDict((\n            (\"configuration_id\", conf_id),\n            (\"entity_id\", entity_id)\n        ))\n        if is_new:\n            return ftrack_api.operation.CreateEntityOperation(\n                \"CustomAttributeValue\",\n                entity_key,\n                {\"value\": new_value}\n            )\n\n        return ftrack_api.operation.UpdateEntityOperation(\n            \"CustomAttributeValue\",\n            entity_key,\n            \"value\",\n            new_value,\n            old_value\n        )\n\n    def _propagate_ftrack_attributes(self):\n        entities_by_ftrack_id = {}\n        for source in (\n            self._created_entity_by_ftrack_id,\n            self._hierarchy_changed_by_ftrack_id,\n            self._remapped_entity_by_ftrack_id,\n        ):\n            for ftrack_id, entity in source.items():\n                entities_by_ftrack_id[ftrack_id] = entity\n\n        ftrack_ids = set(entities_by_ftrack_id.keys())\n        ftrack_ids |= self._ft_failed_sync_ids\n        if not ftrack_ids:\n            return\n\n        # Query ftrack entities to find out which ftrack entities actually\n        #   exists\n        # - they may be removed meanwhile this event is processed and ftrack\n        #   session would crash if we would try to change custom attributes\n        #   of not existing entities\n        ft_entities = self.session.query((\n            \"select id from TypedContext\"\n            f\" where id in ({join_filter_values(ftrack_ids)})\"\n        )).all()\n        ftrack_ids = {\n            ft_entity[\"id\"]\n            for ft_entity in ft_entities\n        }\n        if not ftrack_ids:\n            return\n\n        server_id_attr = path_attr = fail_attr = None\n        for attr in self.ft_cust_attrs:\n            if not attr[\"is_hierarchical\"]:\n                continue\n            if attr[\"key\"] == CUST_ATTR_KEY_SERVER_ID:\n                server_id_attr = attr\n            elif attr[\"key\"] == CUST_ATTR_KEY_SERVER_PATH:\n                path_attr = attr\n            elif attr[\"key\"] == CUST_ATTR_KEY_SYNC_FAIL:\n                fail_attr = attr\n\n        server_id_attr_id = server_id_attr[\"id\"]\n        path_attr_id = path_attr[\"id\"]\n        fail_attr_id = fail_attr[\"id\"]\n\n        attr_key_by_id = {\n            attr[\"id\"]: attr[\"key\"]\n            for attr in (server_id_attr, path_attr, fail_attr)\n        }\n\n        value_items = query_custom_attribute_values(\n            self.session,\n            set(attr_key_by_id.keys()),\n            ftrack_ids,\n        )\n\n        current_values = {\n            ftrack_id: {}\n            for ftrack_id in ftrack_ids\n        }\n        for item in value_items:\n            attr_id = item[\"configuration_id\"]\n            entity_id = item[\"entity_id\"]\n            current_values[entity_id][attr_id] = item[\"value\"]\n\n        expected_values = {\n            ftrack_id: {}\n            for ftrack_id in ftrack_ids\n        }\n        for ftrack_id in ftrack_ids:\n            entity_values = expected_values[ftrack_id]\n            entity = entities_by_ftrack_id.get(ftrack_id)\n            failed = entity is None\n            entity_values[fail_attr_id] = failed\n            if failed:\n                # Limit attribute updates only to failed boolean if sync failed\n                # - we want to keep path and id to potentially fix the issue by\n                #   knowing the path (without ftrack path user may have issues\n                #   to recreate it)\n                # Set default values to avoid inheritance from parent\n                current_entity_values = current_values[ftrack_id]\n                for key, value in (\n                    (path_attr_id, \"\"),\n                    (server_id_attr_id, \"\")\n                ):\n                    if not current_entity_values.get(key):\n                        entity_values[key] = value\n                continue\n\n            # TODO we should probably add path to tasks too\n            # - what the format should look like?\n            path = \"\"\n            if entity.entity_type == \"folder\":\n                path = entity.path\n            entity_values[path_attr_id] = path\n            entity_values[server_id_attr_id] = entity.id\n\n        operations = []\n        for ftrack_id, entity_values in expected_values.items():\n            current_entity_values = current_values[ftrack_id]\n            for attr_id, value in entity_values.items():\n                cur_value = current_entity_values.get(attr_id)\n                if value != cur_value:\n                    operations.append(\n                        self._create_ft_attr_operation(\n                            attr_id,\n                            ftrack_id,\n                            attr_id not in current_entity_values,\n                            value,\n                            old_value=cur_value\n                        )\n                    )\n\n        if operations:\n            for chunk in create_chunks(operations, 500):\n                for operation in chunk:\n                    self.session.recorded_operations.push(operation)\n                self.session.commit()\n\n    def _get_server_id_attribute(self):\n        for attr in self.ft_cust_attrs:\n            if attr[\"key\"] == CUST_ATTR_KEY_SERVER_ID:\n                return attr\n        return None\n\n    def _get_list_type_attribute(self):\n        for attr in self.ft_cust_attrs:\n            if attr[\"key\"] == CUST_ATTR_KEY_LIST_TYPE:\n                return attr\n        return None\n\n    def process_event_data(self):\n        # Check if auto-sync custom attribute exists\n        entities_by_action = self.entities_by_action\n        debug_action_map = {\n            \"add\": \"Created\",\n            \"remove\": \"Removed\",\n            \"update\": \"Updated\",\n            \"assignee_change\": \"Assignee changed\",\n            \"link_change\": \"Link changed\",\n            \"list_added\": \"List added\",\n            \"list_removed\": \"List removed\",\n            \"list_changed\": \"List changed\",\n            \"list_item_change\": \"List item added/removed\",\n        }\n        debug_msg = \"\\n\".join([\n            f\"- {debug_action_map[action]}: {len(entities_info)}\"\n            for action, entities_info in entities_by_action.items()\n        ])\n\n        self.log.debug(\n            f\"Project \\\"{self.project_name}\\\" changes\\n{debug_msg}\")\n\n        # Get ftrack entities - find all ftrack ids first\n        ftrack_ids = set()\n        for action in {\"add\", \"update\"}:\n            ftrack_ids |= set(entities_by_action[action].keys())\n\n        # Add task ids from assignees changes\n        for ent_info in entities_by_action[\"assignee_change\"].values():\n            context_id_changes = ent_info[\"changes\"][\"context_id\"]\n            ftrack_id = context_id_changes[\"new\"] or context_id_changes[\"old\"]\n            ftrack_ids.add(ftrack_id)\n\n        for ent_info in entities_by_action[\"link_change\"]:\n            to_id_changes = ent_info[\"changes\"][\"to_id\"]\n            from_id_changes = ent_info[\"changes\"][\"from_id\"]\n            action = ent_info[\"action\"]\n            if action == \"add\":\n                to_id = to_id_changes[\"new\"]\n                from_id = from_id_changes[\"new\"]\n            else:\n                to_id = to_id_changes[\"old\"]\n                from_id = from_id_changes[\"old\"]\n            # NOTE this works until 'update' is handled\n            ftrack_ids.add(to_id)\n            ftrack_ids.add(from_id)\n\n        # Precache entities that will be needed in single call\n        if ftrack_ids:\n            self.get_ftrack_entity_by_ids(ftrack_ids)\n\n        self.log.debug(\"Synchronization begins\")\n        try:\n            time_1 = time.time()\n            # 1. Process hierarchy changes - may affect all other actions\n            # - hierarchy changes =&gt; name or parent_id changes\n            self._process_hierarchy_changes()\n            time_2 = time.time()\n            # 2. Propagate custom attribute changes\n            self._propagate_attrib_changes()\n            time_3 = time.time()\n            # 3. Propage assigneess changes\n            self._propagate_assignee_changes()\n            time_4 = time.time()\n            # 4. Propage link changes\n            self._propagate_link_changes()\n            time_5 = time.time()\n            # 5. Propage list changes\n            self._propagate_list_changes()\n            time_6 = time.time()\n            # 6. Commit changes to server\n            self.entity_hub.commit_changes()\n            # 7. Propagate entity changes to ftack\n            time_7 = time.time()\n            self._propagate_ftrack_attributes()\n            # TODO propagate entities to ftrack\n            #  - server id, server path, sync failed\n            time_8 = time.time()\n\n            total_time = f\"{time_8 - time_1:.2f}\"\n            mid_times = \", \".join([\n                f\"{diff:.2f}\"\n                for diff in (\n                    time_2 - time_1,\n                    time_3 - time_2,\n                    time_4 - time_3,\n                    time_5 - time_4,\n                    time_6 - time_5,\n                    time_7 - time_6,\n                    time_8 - time_7,\n                )\n            ])\n            self.log.debug(f\"Process time: {total_time} &lt;{mid_times}&gt;\")\n\n        except Exception:\n            msg = \"An error has happened during synchronization\"\n            self.log.warning(msg, exc_info=True)\n            # self.report_items[\"error\"][msg].append((\n            #     str(traceback.format_exc()).replace(\"\\n\", \"&lt;br&gt;\")\n            # ).replace(\" \", \"&amp;nbsp;\"))\n\n        # self.report()\n        return True\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_sync_from_ftrack.html#services.processor.processor.default_handlers.event_sync_from_ftrack.SyncProcess.entities_by_action","title":"<code>entities_by_action</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <p>Dict[str, Dict[str, Any]]: Entity information from ftrack event byt action happened on them.</p>"},{"location":"autoapi/services/processor/processor/default_handlers/event_sync_from_ftrack.html#services.processor.processor.default_handlers.event_sync_from_ftrack.SyncProcess.found_actions","title":"<code>found_actions</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <p>Set[str]: Actions that happened in processed ftrack event.</p>"},{"location":"autoapi/services/processor/processor/default_handlers/event_sync_from_ftrack.html#services.processor.processor.default_handlers.event_sync_from_ftrack.SyncProcess.ft_project","title":"<code>ft_project</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <p>ftrack_api.Entity: ftrack project entity.</p>"},{"location":"autoapi/services/processor/processor/default_handlers/event_sync_from_ftrack.html#services.processor.processor.default_handlers.event_sync_from_ftrack.SyncProcess.ft_project_id","title":"<code>ft_project_id</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <p>Union[str, None]: Id of ftrack project based on information in processed event.</p>"},{"location":"autoapi/services/processor/processor/default_handlers/event_sync_from_ftrack.html#services.processor.processor.default_handlers.event_sync_from_ftrack.SyncProcess.ft_project_removed","title":"<code>ft_project_removed</code>  <code>property</code>","text":"<p>Returns:</p> Name Type Description <code>bool</code> <p>Project was removed from ftrack.</p>"},{"location":"autoapi/services/processor/processor/default_handlers/event_sync_from_ftrack.html#services.processor.processor.default_handlers.event_sync_from_ftrack.SyncProcess.is_event_valid","title":"<code>is_event_valid</code>  <code>property</code>","text":"<p>Returns:</p> Name Type Description <code>bool</code> <p>Data from event are important for synchronization.</p>"},{"location":"autoapi/services/processor/processor/default_handlers/event_sync_from_ftrack.html#services.processor.processor.default_handlers.event_sync_from_ftrack.SyncProcess.project_changed_autosync","title":"<code>project_changed_autosync</code>  <code>property</code>","text":"<p>Returns:</p> Name Type Description <code>bool</code> <p>Autosync value has changed.</p>"},{"location":"autoapi/services/processor/processor/default_handlers/event_sync_from_ftrack.html#services.processor.processor.default_handlers.event_sync_from_ftrack.SyncProcess.project_name","title":"<code>project_name</code>  <code>property</code>","text":"<p>Returns:</p> Name Type Description <code>str</code> <p>Name of project on which happened changes in processed event.</p>"},{"location":"autoapi/services/processor/processor/default_handlers/event_sync_from_ftrack.html#services.processor.processor.default_handlers.event_sync_from_ftrack.SyncProcess.trigger_project_sync","title":"<code>trigger_project_sync</code>  <code>property</code>","text":"<p>Returns:</p> Name Type Description <code>bool</code> <p>Autosync was turned on so a project sync action should be triggered.</p>"},{"location":"autoapi/services/processor/processor/default_handlers/event_sync_from_ftrack.html#services.processor.processor.default_handlers.event_sync_from_ftrack.SyncProcess.get_ftrack_entity_by_ids","title":"<code>get_ftrack_entity_by_ids(entity_ids)</code>","text":"<p>Get or query ftrack entity by id.</p> <p>Method is caching already queried entities.</p> <p>Parameters:</p> Name Type Description Default <code>entity_ids</code> <code>List[str]</code> <p>Id of ftrack entity.</p> required <p>Returns:</p> Type Description <p>Dict[str, Union[ftrack_api.Entity, None]]: Mapping of ftrack entity by it's id.</p> Source code in <code>services/processor/processor/default_handlers/event_sync_from_ftrack.py</code> <pre><code>def get_ftrack_entity_by_ids(self, entity_ids):\n    \"\"\"Get or query ftrack entity by id.\n\n    Method is caching already queried entities.\n\n    Args:\n        entity_ids (List[str]): Id of ftrack entity.\n\n    Returns:\n        Dict[str, Union[ftrack_api.Entity, None]]: Mapping of ftrack entity\n            by it's id.\n    \"\"\"\n\n    if not entity_ids:\n        return {}\n\n    entity_ids = set(entity_ids)\n    output = {\n        entity_id: None\n        for entity_id in entity_ids\n    }\n    entity_ids.discard(None)\n    if self.ft_project_id in entity_ids:\n        output[self.ft_project_id] = self.ft_project\n        entity_ids.remove(self.ft_project_id)\n\n    for entity_id in tuple(entity_ids):\n        if entity_id not in self._ftrack_entities_by_id:\n            continue\n        output[entity_id] = self._ftrack_entities_by_id[entity_id]\n        entity_ids.remove(entity_id)\n\n    entities = []\n    if entity_ids:\n        entities = self.session.query(\n            self.entities_query_by_id.format(\n                self.ft_project_id,\n                join_filter_values(entity_ids)\n            )\n        ).all()\n\n    for entity in entities:\n        entity_id = entity[\"id\"]\n        self._ftrack_entities_by_id[entity_id] = entity\n        output[entity_id] = entity\n\n    return output\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_sync_from_ftrack.html#services.processor.processor.default_handlers.event_sync_from_ftrack.SyncProcess.initial_event_processing","title":"<code>initial_event_processing()</code>","text":"<p>First processing of data on event.</p> <p>This part decide if event contain data important for synchronization.</p> Source code in <code>services/processor/processor/default_handlers/event_sync_from_ftrack.py</code> <pre><code>def initial_event_processing(self):\n    \"\"\"First processing of data on event.\n\n    This part decide if event contain data important for synchronization.\n    \"\"\"\n\n    if self._ft_project_removed is not UNKNOWN_VALUE:\n        return\n\n    # Set default values\n    self._is_event_valid = False\n    self._project_changed_autosync = False\n    self._trigger_project_sync = False\n\n    self._has_valid_entity_types = True\n    self._split_event_entity_info()\n\n    # If project was removed then skip rest of event processing\n    if (\n        self._ft_project_removed\n        or not self._found_actions\n    ):\n        self._has_valid_entity_types = False\n        return\n\n    self._check_enabled_auto_sync()\n    if self._project_changed_autosync:\n        if not self._project_enabled_validation():\n            # Make sure that sync is not triggered if project is not\n            #   available or disabled\n            self._trigger_project_sync = False\n        return\n\n    self._filter_update_actions()\n\n    if not self._found_actions:\n        self.log.debug(\"Skipping. Nothing to update.\")\n        self._has_valid_entity_types = False\n        return\n\n    if not self._project_enabled_validation():\n        return\n\n    # Skip if auto-sync is not set\n    auto_sync = self.ft_project[\"custom_attributes\"][CUST_ATTR_AUTO_SYNC]\n    is_event_valid = auto_sync is True\n    if is_event_valid:\n        # TODO probably should be handled\n        # TODO add logs - with detail what is wrong\n        # - project is not available on server\n        if not self.entity_hub.project_entity:\n            is_event_valid = False\n    self._is_event_valid = is_event_valid\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_task_to_parent_status.html","title":"event_task_to_parent_status","text":""},{"location":"autoapi/services/processor/processor/default_handlers/event_task_to_parent_status.html#services.processor.processor.default_handlers.event_task_to_parent_status.TaskStatusToParent","title":"<code>TaskStatusToParent</code>","text":"<p>               Bases: <code>BaseEventHandler</code></p> Source code in <code>services/processor/processor/default_handlers/event_task_to_parent_status.py</code> <pre><code>class TaskStatusToParent(BaseEventHandler):\n    settings_key = \"status_task_to_parent\"\n\n    def launch(self, session, event):\n        \"\"\"Propagates status from task to parent when changed.\"\"\"\n\n        filtered_entities_info = self.filter_entities_info(event)\n        if not filtered_entities_info:\n            return\n\n        for project_id, entities_info in filtered_entities_info.items():\n            self.process_by_project(session, event, project_id, entities_info)\n\n    def filter_entities_info(self, event):\n        # Filter if event contain relevant data\n        entities_info = event[\"data\"].get(\"entities\")\n        if not entities_info:\n            return\n\n        filtered_entity_info = collections.defaultdict(list)\n        status_ids = set()\n        for entity_info in entities_info:\n            # Care only about tasks\n            if entity_info.get(\"entityType\") != \"task\":\n                continue\n\n            # Care only about changes of status\n            changes = entity_info.get(\"changes\")\n            if not changes:\n                continue\n            statusid_changes = changes.get(\"statusid\")\n            if not statusid_changes:\n                continue\n\n            new_status_id = entity_info[\"changes\"][\"statusid\"][\"new\"]\n            if (\n                statusid_changes.get(\"old\") is None\n                or new_status_id is None\n            ):\n                continue\n\n            project_id = None\n            for parent_item in reversed(entity_info[\"parents\"]):\n                if parent_item[\"entityType\"] == \"show\":\n                    project_id = parent_item[\"entityId\"]\n                    break\n\n            if project_id:\n                filtered_entity_info[project_id].append(entity_info)\n                status_ids.add(new_status_id)\n\n        return filtered_entity_info\n\n    def process_by_project(self, session, event, project_id, entities_info):\n        # Get project name\n        project_name = self.get_project_name_from_event(\n            session, event, project_id\n        )\n\n        if not self.get_ayon_project_from_event(event, project_name):\n            self.log.debug(\"Project not found in AYON. Skipping\")\n            return\n\n        # Load settings\n        project_settings = self.get_project_settings_from_event(\n            event, project_name\n        )\n        ftrack_settings = project_settings[\"ftrack\"]\n        if not is_ftrack_enabled_in_settings(ftrack_settings):\n            self.log.debug(\"ftrack is disabled for project \\\"{}\\\"\".format(\n                project_name\n            ))\n            return\n\n        # Prepare loaded settings and check if can be processed\n        result = self.prepare_settings(project_settings, project_name)\n        if not result:\n            return\n\n        # Unpack the result\n        parent_object_types, all_match, single_match = result\n\n        # Prepare valid object type ids for object types from settings\n        object_types = session.query(\"select id, name from ObjectType\").all()\n        object_type_id_by_low_name = {\n            object_type[\"name\"].lower(): object_type[\"id\"]\n            for object_type in object_types\n        }\n\n        valid_object_type_ids = set()\n        for object_type_name in parent_object_types:\n            if object_type_name in object_type_id_by_low_name:\n                valid_object_type_ids.add(\n                    object_type_id_by_low_name[object_type_name]\n                )\n            else:\n                self.log.warning(\n                    \"Unknown object type \\\"{}\\\" set on project \\\"{}\\\".\".format(\n                        object_type_name, project_name\n                    )\n                )\n\n        if not valid_object_type_ids:\n            return\n\n        # Prepare parent ids\n        parent_ids = set()\n        for entity_info in entities_info:\n            parent_id = entity_info[\"parentId\"]\n            if parent_id:\n                parent_ids.add(parent_id)\n\n        # Query parent ids by object type ids and parent ids\n        parent_entities = session.query(\n            (\n                \"select id, status_id, object_type_id, link from TypedContext\"\n                \" where id in ({}) and object_type_id in ({})\"\n            ).format(\n                self.join_query_keys(parent_ids),\n                self.join_query_keys(valid_object_type_ids)\n            )\n        ).all()\n        # Skip if none of parents match the filtering\n        if not parent_entities:\n            return\n\n        obj_ids = set()\n        for entity in parent_entities:\n            obj_ids.add(entity[\"object_type_id\"])\n\n        types_mapping = {\n            _type.lower(): _type\n            for _type in session.types\n        }\n        # Map object type id by lowered and modified object type name\n        object_type_name_by_id = {}\n        for object_type in object_types:\n            mapping_name = object_type[\"name\"].lower().replace(\" \", \"\")\n            obj_id = object_type[\"id\"]\n            object_type_name_by_id[obj_id] = types_mapping[mapping_name]\n\n        project_entity = session.get(\"Project\", project_id)\n        project_schema = project_entity[\"project_schema\"]\n        available_statuses_by_obj_id = {}\n        for obj_id in obj_ids:\n            obj_name = object_type_name_by_id[obj_id]\n            statuses = project_schema.get_statuses(obj_name)\n            statuses_by_low_name = {\n                status[\"name\"].lower(): status\n                for status in statuses\n            }\n            valid = False\n            for name in all_match.keys():\n                if name in statuses_by_low_name:\n                    valid = True\n                    break\n\n            if not valid:\n                for item in single_match:\n                    if item[\"new_status\"] in statuses_by_low_name:\n                        valid = True\n                        break\n            if valid:\n                available_statuses_by_obj_id[obj_id] = statuses_by_low_name\n\n        valid_parent_ids = set()\n        status_ids = set()\n        valid_parent_entities = []\n        for entity in parent_entities:\n            if entity[\"object_type_id\"] not in available_statuses_by_obj_id:\n                continue\n\n            valid_parent_entities.append(entity)\n            valid_parent_ids.add(entity[\"id\"])\n            status_ids.add(entity[\"status_id\"])\n\n        if not valid_parent_ids:\n            return\n\n        task_entities = session.query(\n            (\n                \"select id, parent_id, status_id from TypedContext\"\n                \" where parent_id in ({}) and object_type_id is \\\"{}\\\"\"\n            ).format(\n                self.join_query_keys(valid_parent_ids),\n                object_type_id_by_low_name[\"task\"]\n            )\n        ).all()\n\n        # This should not happen but it is safer\n        if not task_entities:\n            return\n\n        task_entities_by_parent_id = collections.defaultdict(list)\n        for task_entity in task_entities:\n            status_ids.add(task_entity[\"status_id\"])\n            parent_id = task_entity[\"parent_id\"]\n            task_entities_by_parent_id[parent_id].append(task_entity)\n\n        status_entities = session.query((\n            \"select id, name from Status where id in ({})\"\n        ).format(self.join_query_keys(status_ids))).all()\n\n        statuses_by_id = {\n            entity[\"id\"]: entity\n            for entity in status_entities\n        }\n\n        # New status determination logic\n        new_statuses_by_parent_id = self.new_status_by_all_task_statuses(\n            task_entities_by_parent_id, statuses_by_id, all_match\n        )\n\n        task_entities_by_id = {\n            task_entity[\"id\"]: task_entity\n            for task_entity in task_entities\n        }\n        # Check if there are remaining any parents that does not have\n        # determined new status yet\n        remainder_tasks_by_parent_id = collections.defaultdict(list)\n        for entity_info in entities_info:\n            entity_id = entity_info[\"entityId\"]\n            if entity_id not in task_entities_by_id:\n                continue\n            parent_id = entity_info[\"parentId\"]\n            if (\n                # Skip if already has determined new status\n                parent_id in new_statuses_by_parent_id\n                # Skip if parent is not in parent mapping\n                # - if was not found or parent type is not interesting\n                or parent_id not in task_entities_by_parent_id\n            ):\n                continue\n\n            remainder_tasks_by_parent_id[parent_id].append(\n                task_entities_by_id[entity_id]\n            )\n\n        # Try to find new status for remained parents\n        new_statuses_by_parent_id.update(\n            self.new_status_by_remainders(\n                remainder_tasks_by_parent_id,\n                statuses_by_id,\n                single_match\n            )\n        )\n\n        # If there are not new statuses then just skip\n        if not new_statuses_by_parent_id:\n            return\n\n        parent_entities_by_id = {\n            parent_entity[\"id\"]: parent_entity\n            for parent_entity in valid_parent_entities\n        }\n        for parent_id, new_status_name in new_statuses_by_parent_id.items():\n            if not new_status_name:\n                continue\n\n            parent_entity = parent_entities_by_id[parent_id]\n            ent_path = \"/\".join(\n                [ent[\"name\"] for ent in parent_entity[\"link\"]]\n            )\n\n            obj_id = parent_entity[\"object_type_id\"]\n            statuses_by_low_name = available_statuses_by_obj_id.get(obj_id)\n            if not statuses_by_low_name:\n                continue\n\n            new_status = statuses_by_low_name.get(new_status_name)\n            if not new_status:\n                self.log.warning((\n                    \"\\\"{}\\\" Couldn't change status to \\\"{}\\\".\"\n                    \" Status is not available for entity type \\\"{}\\\".\"\n                ).format(\n                    ent_path, new_status_name, parent_entity.entity_type\n                ))\n                continue\n\n            current_status = parent_entity[\"status\"]\n            # Do nothing if status is already set\n            if new_status[\"id\"] == current_status[\"id\"]:\n                self.log.debug(\n                    \"\\\"{}\\\" Status \\\"{}\\\" already set.\".format(\n                        ent_path, current_status[\"name\"]\n                    )\n                )\n                continue\n\n            try:\n                parent_entity[\"status_id\"] = new_status[\"id\"]\n                session.commit()\n                self.log.info(\n                    \"\\\"{}\\\" changed status to \\\"{}\\\"\".format(\n                        ent_path, new_status[\"name\"]\n                    )\n                )\n            except Exception:\n                session.rollback()\n                self.log.warning(\n                    \"\\\"{}\\\" status couldnt be set to \\\"{}\\\"\".format(\n                        ent_path, new_status[\"name\"]\n                    ),\n                    exc_info=True\n                )\n\n    def prepare_settings(self, project_settings, project_name):\n        event_settings = (\n            project_settings\n            [\"ftrack\"]\n            [\"service_event_handlers\"]\n            [self.settings_key]\n        )\n\n        if not event_settings[\"enabled\"]:\n            self.log.debug(\"Project \\\"{}\\\" has disabled {}.\".format(\n                project_name, self.__class__.__name__\n            ))\n            return\n\n        _parent_object_types = event_settings[\"parent_object_types\"]\n        if not _parent_object_types:\n            self.log.debug((\n                \"Project \\\"{}\\\" does not have set\"\n                \" parent object types filtering.\"\n            ).format(project_name))\n            return\n\n        _all_match = (\n            event_settings[\"parent_status_match_all_task_statuses\"]\n        )\n        _single_match = (\n            event_settings[\"parent_status_by_task_status\"]\n        )\n\n        if not _all_match and not _single_match:\n            self.log.debug((\n                \"Project \\\"{}\\\" does not have set\"\n                \" parent status mappings.\"\n            ).format(project_name))\n            return\n\n        parent_object_types = [\n            item.lower()\n            for item in _parent_object_types\n        ]\n        all_match = {}\n        for item in _all_match:\n            new_status_name = item[\"name\"]\n            task_statuses = item[\"value\"]\n            all_match[new_status_name.lower()] = [\n                status_name.lower()\n                for status_name in task_statuses\n            ]\n\n        single_match = []\n        for item in _single_match:\n            single_match.append({\n                \"new_status\": item[\"new_status\"].lower(),\n                \"task_statuses\": [\n                    status_name.lower()\n                    for status_name in item[\"task_statuses\"]\n                ]\n            })\n        return parent_object_types, all_match, single_match\n\n    def new_status_by_all_task_statuses(\n        self, tasks_by_parent_id, statuses_by_id, all_match\n    ):\n        \"\"\"All statuses of parent entity must match specific status names.\n\n        Only if all task statuses match the condition parent's status name is\n        determined.\n        \"\"\"\n        output = {}\n        for parent_id, task_entities in tasks_by_parent_id.items():\n            task_statuses_lowered = set()\n            for task_entity in task_entities:\n                task_status = statuses_by_id[task_entity[\"status_id\"]]\n                low_status_name = task_status[\"name\"].lower()\n                task_statuses_lowered.add(low_status_name)\n\n            new_status = None\n            for _new_status, task_statuses in all_match.items():\n                valid_item = True\n                for status_name_low in task_statuses_lowered:\n                    if status_name_low not in task_statuses:\n                        valid_item = False\n                        break\n\n                if valid_item:\n                    new_status = _new_status\n                    break\n\n            if new_status is not None:\n                output[parent_id] = new_status\n\n        return output\n\n    def new_status_by_remainders(\n        self, remainder_tasks_by_parent_id, statuses_by_id, single_match\n    ):\n        \"\"\"By new task status can be determined new status of parent.\"\"\"\n        output = {}\n        if not remainder_tasks_by_parent_id:\n            return output\n\n        for parent_id, task_entities in remainder_tasks_by_parent_id.items():\n            if not task_entities:\n                continue\n\n            # For cases there are multiple tasks in changes\n            # - task status which match any new status item by order in the\n            #   list `single_match` is preffered\n            best_order = len(single_match)\n            best_order_status = None\n            for task_entity in task_entities:\n                task_status = statuses_by_id[task_entity[\"status_id\"]]\n                low_status_name = task_status[\"name\"].lower()\n                for order, item in enumerate(single_match):\n                    if order &gt;= best_order:\n                        break\n\n                    if low_status_name in item[\"task_statuses\"]:\n                        best_order = order\n                        best_order_status = item[\"new_status\"]\n                        break\n\n            if best_order_status:\n                output[parent_id] = best_order_status\n        return output\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_task_to_parent_status.html#services.processor.processor.default_handlers.event_task_to_parent_status.TaskStatusToParent.launch","title":"<code>launch(session, event)</code>","text":"<p>Propagates status from task to parent when changed.</p> Source code in <code>services/processor/processor/default_handlers/event_task_to_parent_status.py</code> <pre><code>def launch(self, session, event):\n    \"\"\"Propagates status from task to parent when changed.\"\"\"\n\n    filtered_entities_info = self.filter_entities_info(event)\n    if not filtered_entities_info:\n        return\n\n    for project_id, entities_info in filtered_entities_info.items():\n        self.process_by_project(session, event, project_id, entities_info)\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_task_to_parent_status.html#services.processor.processor.default_handlers.event_task_to_parent_status.TaskStatusToParent.new_status_by_all_task_statuses","title":"<code>new_status_by_all_task_statuses(tasks_by_parent_id, statuses_by_id, all_match)</code>","text":"<p>All statuses of parent entity must match specific status names.</p> <p>Only if all task statuses match the condition parent's status name is determined.</p> Source code in <code>services/processor/processor/default_handlers/event_task_to_parent_status.py</code> <pre><code>def new_status_by_all_task_statuses(\n    self, tasks_by_parent_id, statuses_by_id, all_match\n):\n    \"\"\"All statuses of parent entity must match specific status names.\n\n    Only if all task statuses match the condition parent's status name is\n    determined.\n    \"\"\"\n    output = {}\n    for parent_id, task_entities in tasks_by_parent_id.items():\n        task_statuses_lowered = set()\n        for task_entity in task_entities:\n            task_status = statuses_by_id[task_entity[\"status_id\"]]\n            low_status_name = task_status[\"name\"].lower()\n            task_statuses_lowered.add(low_status_name)\n\n        new_status = None\n        for _new_status, task_statuses in all_match.items():\n            valid_item = True\n            for status_name_low in task_statuses_lowered:\n                if status_name_low not in task_statuses:\n                    valid_item = False\n                    break\n\n            if valid_item:\n                new_status = _new_status\n                break\n\n        if new_status is not None:\n            output[parent_id] = new_status\n\n    return output\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_task_to_parent_status.html#services.processor.processor.default_handlers.event_task_to_parent_status.TaskStatusToParent.new_status_by_remainders","title":"<code>new_status_by_remainders(remainder_tasks_by_parent_id, statuses_by_id, single_match)</code>","text":"<p>By new task status can be determined new status of parent.</p> Source code in <code>services/processor/processor/default_handlers/event_task_to_parent_status.py</code> <pre><code>def new_status_by_remainders(\n    self, remainder_tasks_by_parent_id, statuses_by_id, single_match\n):\n    \"\"\"By new task status can be determined new status of parent.\"\"\"\n    output = {}\n    if not remainder_tasks_by_parent_id:\n        return output\n\n    for parent_id, task_entities in remainder_tasks_by_parent_id.items():\n        if not task_entities:\n            continue\n\n        # For cases there are multiple tasks in changes\n        # - task status which match any new status item by order in the\n        #   list `single_match` is preffered\n        best_order = len(single_match)\n        best_order_status = None\n        for task_entity in task_entities:\n            task_status = statuses_by_id[task_entity[\"status_id\"]]\n            low_status_name = task_status[\"name\"].lower()\n            for order, item in enumerate(single_match):\n                if order &gt;= best_order:\n                    break\n\n                if low_status_name in item[\"task_statuses\"]:\n                    best_order = order\n                    best_order_status = item[\"new_status\"]\n                    break\n\n        if best_order_status:\n            output[parent_id] = best_order_status\n    return output\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_task_to_version_status.html","title":"event_task_to_version_status","text":""},{"location":"autoapi/services/processor/processor/default_handlers/event_task_to_version_status.html#services.processor.processor.default_handlers.event_task_to_version_status.TaskToVersionStatus","title":"<code>TaskToVersionStatus</code>","text":"<p>               Bases: <code>BaseEventHandler</code></p> <p>Changes status of task's latest AssetVersions on its status change.</p> Source code in <code>services/processor/processor/default_handlers/event_task_to_version_status.py</code> <pre><code>class TaskToVersionStatus(BaseEventHandler):\n    \"\"\"Changes status of task's latest AssetVersions on its status change.\"\"\"\n\n    settings_key = \"status_task_to_version\"\n\n    # Attribute for caching session user id\n    _cached_user_id = None\n\n    def is_event_invalid(self, session, event):\n        \"\"\"Skip task status changes for session user changes.\n\n        It is expected that there may be another event handler that set\n        version status to task in that case skip all events caused by same\n        user as session has to avoid infinite loop of status changes.\n        \"\"\"\n        # Cache user id of currently running session\n        if self._cached_user_id is None:\n            session_user_entity = session.query(\n                \"User where username is \\\"{}\\\"\".format(session.api_user)\n            ).first()\n            if not session_user_entity:\n                self.log.warning(\n                    \"Couldn't query ftrack user with username \\\"{}\\\"\".format(\n                        session.api_user\n                    )\n                )\n                return False\n            self._cached_user_id = session_user_entity[\"id\"]\n\n        # Skip processing if current session user was the user who created\n        # the event\n        user_info = event[\"source\"].get(\"user\") or {}\n        user_id = user_info.get(\"id\")\n\n        # Mark as invalid if user is unknown\n        if user_id is None:\n            return True\n        return user_id == self._cached_user_id\n\n    def filter_event_entities(self, event):\n        \"\"\"Filter if event contain relevant data.\n\n        Event cares only about changes of `statusid` on `entity_type` \"Task\".\n        \"\"\"\n\n        entities_info = event[\"data\"].get(\"entities\")\n        if not entities_info:\n            return\n\n        filtered_entity_info = collections.defaultdict(list)\n        for entity_info in entities_info:\n            # Care only about tasks\n            if entity_info.get(\"entity_type\") != \"Task\":\n                continue\n\n            # Care only about changes of status\n            changes = entity_info.get(\"changes\") or {}\n            statusid_changes = changes.get(\"statusid\") or {}\n            if (\n                statusid_changes.get(\"new\") is None\n                or statusid_changes.get(\"old\") is None\n            ):\n                continue\n\n            # Get project id from entity info\n            project_id = None\n            for parent_item in reversed(entity_info[\"parents\"]):\n                if parent_item[\"entityType\"] == \"show\":\n                    project_id = parent_item[\"entityId\"]\n                    break\n\n            if project_id:\n                filtered_entity_info[project_id].append(entity_info)\n\n        return filtered_entity_info\n\n    def _get_ent_path(self, entity):\n        return \"/\".join(\n            [ent[\"name\"] for ent in entity[\"link\"]]\n        )\n\n    def launch(self, session, event):\n        '''Propagates status from version to task when changed'''\n        if self.is_event_invalid(session, event):\n            return\n\n        filtered_entity_infos = self.filter_event_entities(event)\n        if not filtered_entity_infos:\n            return\n\n        for project_id, entities_info in filtered_entity_infos.items():\n            self.process_by_project(session, event, project_id, entities_info)\n\n    def process_by_project(self, session, event, project_id, entities_info):\n        if not entities_info:\n            return\n\n        project_name = self.get_project_name_from_event(\n            session, event, project_id\n        )\n        if not self.get_ayon_project_from_event(event, project_name):\n            self.log.debug(\"Project not found in AYON. Skipping\")\n            return\n\n        # Load settings\n        project_settings = self.get_project_settings_from_event(\n            event, project_name\n        )\n        ftrack_settings = project_settings[\"ftrack\"]\n        if not is_ftrack_enabled_in_settings(ftrack_settings):\n            self.log.debug(\"ftrack is disabled for project \\\"{}\\\"\".format(\n                project_name\n            ))\n            return\n\n        event_settings = (\n            ftrack_settings\n            [\"service_event_handlers\"]\n            [self.settings_key]\n        )\n        if not event_settings[\"enabled\"]:\n            self.log.debug(\"Project \\\"{}\\\" has disabled {}.\".format(\n                project_name, self.__class__.__name__\n            ))\n            return\n\n        status_mapping = {\n            item[\"name\"].lower(): item[\"value\"]\n            for item in event_settings[\"mapping\"]\n        }\n        if not status_mapping:\n            self.log.debug((\n                \"Project \\\"{}\\\" does not have set status mapping for {}.\"\n            ).format(project_name, self.__class__.__name__))\n            return\n\n        asset_type_filter = event_settings[\"asset_types_filter_type\"]\n        is_allow_list = asset_type_filter == \"allow_list\"\n        asset_type_names = {\n            asset_type_name.lower()\n            for asset_type_name in event_settings[\"asset_types\"]\n            if asset_type_name\n        }\n\n        task_ids = [\n            entity_info[\"entityId\"]\n            for entity_info in entities_info\n        ]\n\n        last_asset_versions_by_task_id = (\n            self.find_last_asset_versions_for_task_ids(\n                session, task_ids, is_allow_list, asset_type_names\n            )\n        )\n\n        # Query Task entities for last asset versions\n        joined_filtered_ids = self.join_query_keys(\n            last_asset_versions_by_task_id.keys()\n        )\n        if not joined_filtered_ids:\n            return\n\n        task_entities = session.query(\n            \"select status_id, link from Task where id in ({})\".format(\n                joined_filtered_ids\n            )\n        ).all()\n        if not task_entities:\n            return\n\n        status_ids = {\n            task_entity[\"status_id\"]\n            for task_entity in task_entities\n        }\n\n        task_status_entities = session.query(\n            \"select id, name from Status where id in ({})\".format(\n                self.join_query_keys(status_ids)\n            )\n        ).all()\n        task_status_name_by_id = {\n            status_entity[\"id\"]: status_entity[\"name\"]\n            for status_entity in task_status_entities\n        }\n\n        # Final process of changing statuses\n        project_entity = session.get(\"Project\", project_id)\n        av_statuses_by_low_name, av_statuses_by_id = (\n            self.get_asset_version_statuses(project_entity)\n        )\n\n        asset_ids = set()\n        for asset_versions in last_asset_versions_by_task_id.values():\n            for asset_version in asset_versions:\n                asset_ids.add(asset_version[\"asset_id\"])\n\n        asset_entities = session.query(\n            \"select name from Asset where id in ({})\".format(\n                self.join_query_keys(asset_ids)\n            )\n        ).all()\n        asset_names_by_id = {\n            asset_entity[\"id\"]: asset_entity[\"name\"]\n            for asset_entity in asset_entities\n        }\n        for task_entity in task_entities:\n            task_id = task_entity[\"id\"]\n            status_id = task_entity[\"status_id\"]\n            task_path = self._get_ent_path(task_entity)\n\n            task_status_name = task_status_name_by_id[status_id]\n            task_status_name_low = task_status_name.lower()\n\n            new_asset_version_status = None\n            mapped_status_names = status_mapping.get(task_status_name_low)\n            if mapped_status_names:\n                for status_name in mapped_status_names:\n                    _status = av_statuses_by_low_name.get(status_name.lower())\n                    if _status:\n                        new_asset_version_status = _status\n                        break\n\n            if not new_asset_version_status:\n                new_asset_version_status = av_statuses_by_low_name.get(\n                    task_status_name_low\n                )\n            # Skip if tasks status is not available to AssetVersion\n            if not new_asset_version_status:\n                self.log.debug((\n                    \"AssetVersion does not have matching status to \\\"{}\\\"\"\n                ).format(task_status_name))\n                continue\n\n            last_asset_versions = last_asset_versions_by_task_id[task_id]\n            for asset_version in last_asset_versions:\n                version = asset_version[\"version\"]\n                self.log.debug((\n                    \"Trying to change status of last AssetVersion {}\"\n                    \" for task \\\"{}\\\"\"\n                ).format(version, task_path))\n\n                asset_id = asset_version[\"asset_id\"]\n                asset_type_name = asset_names_by_id[asset_id]\n                av_ent_path = task_path + \" Asset {} AssetVersion {}\".format(\n                    asset_type_name,\n                    version\n                )\n\n                # Skip if current AssetVersion's status is same\n                status_id = asset_version[\"status_id\"]\n                current_status_name = av_statuses_by_id[status_id][\"name\"]\n                if current_status_name.lower() == task_status_name_low:\n                    self.log.debug((\n                        \"AssetVersion already has set status \\\"{}\\\". \\\"{}\\\"\"\n                    ).format(current_status_name, av_ent_path))\n                    continue\n\n                new_status_id = new_asset_version_status[\"id\"]\n                new_status_name = new_asset_version_status[\"name\"]\n                # Skip if status is already same\n                if asset_version[\"status_id\"] == new_status_id:\n                    continue\n\n                # Change the status\n                try:\n                    asset_version[\"status_id\"] = new_status_id\n                    session.commit()\n                    self.log.info(\"[ {} ] Status updated to [ {} ]\".format(\n                        av_ent_path, new_status_name\n                    ))\n                except Exception:\n                    session.rollback()\n                    self.log.warning(\n                        \"[ {} ]Status couldn't be set to \\\"{}\\\"\".format(\n                            av_ent_path, new_status_name\n                        ),\n                        exc_info=True\n                    )\n\n    def get_asset_version_statuses(self, project_entity):\n        \"\"\"Status entities for AssetVersion from project's schema.\n\n        Load statuses from project's schema and store them by id and name.\n\n        Args:\n            project_entity (ftrack_api.Entity): Entity of ftrack's project.\n\n        Returns:\n            tuple: 2 items are returned first are statuses by name\n                second are statuses by id.\n        \"\"\"\n        project_schema = project_entity[\"project_schema\"]\n        # Get all available statuses for Task\n        statuses = project_schema.get_statuses(\"AssetVersion\")\n        # map lowered status name with it's object\n        av_statuses_by_low_name = {}\n        av_statuses_by_id = {}\n        for status in statuses:\n            av_statuses_by_low_name[status[\"name\"].lower()] = status\n            av_statuses_by_id[status[\"id\"]] = status\n\n        return av_statuses_by_low_name, av_statuses_by_id\n\n    def find_last_asset_versions_for_task_ids(\n        self, session, task_ids, is_allow_list, asset_type_names\n    ):\n        \"\"\"Find latest AssetVersion entities for task.\n\n        Find first latest AssetVersion for task and all AssetVersions with\n        same version for the task.\n\n        Args:\n            session (ftrack_api.Session): ftrack session.\n            task_ids (list[str]): Task ids.\n            is_allow_list (bool): If True then asset_types are used\n                as allow list.\n            asset_type_names (set[str]): Asset types short names that will be\n                used to filter AssetVersions. Filtering is skipped if entered\n                value is empty list.\n\n        Returns:\n            dict[str, list[ftrack_api.Entity]]: Dictionary with task id as key\n                and list of AssetVersion entities as value.\n\n        \"\"\"\n        last_asset_versions_by_task_id = collections.defaultdict(list)\n\n        if not task_ids:\n            return last_asset_versions_by_task_id\n\n        if is_allow_list and not asset_type_names:\n            return last_asset_versions_by_task_id\n\n        # Allow event only on specific asset type names\n        asset_query_part = \"\"\n        if asset_type_names:\n            # Query all AssetTypes\n            asset_types = session.query(\n                \"select id, short from AssetType\"\n            ).all()\n            # Store AssetTypes by id\n            asset_type_short_by_id = {\n                asset_type[\"id\"]: asset_type[\"short\"].lower()\n                for asset_type in asset_types\n            }\n\n            # Lower asset types from settings\n            asset_type_ids = {\n                type_id\n                for type_id, short in asset_type_short_by_id.items()\n                if short.lower() in asset_type_names\n            }\n\n            # Allow list is enabled but asset type names are not available\n            if is_allow_list and not asset_type_ids:\n                self.log.warning((\n                    \"None of asset type names were found in ftrack.\"\n                    \" Skipping filter.\"\n                ))\n                return last_asset_versions_by_task_id\n\n            if is_allow_list:\n                asset_query_part = \" and asset.type_id in ({})\".format(\n                    self.join_query_keys(asset_type_ids)\n                )\n            elif asset_type_ids:\n                asset_query_part = \" and asset.type_id not in ({})\".format(\n                    self.join_query_keys(asset_type_ids)\n                )\n\n        # Query tasks' AssetVersions\n        asset_versions = session.query((\n            \"select status_id, version, task_id, asset_id\"\n            \" from AssetVersion where task_id in ({}){}\"\n            \" order by version descending\"\n        ).format(self.join_query_keys(task_ids), asset_query_part)).all()\n\n        last_version_by_task_id = {}\n        not_finished_task_ids = set(task_ids)\n        for asset_version in asset_versions:\n            task_id = asset_version[\"task_id\"]\n            # Check if task id is still in `not_finished_task_ids`\n            if task_id not in not_finished_task_ids:\n                continue\n\n            version = asset_version[\"version\"]\n\n            # Find last version in `last_version_by_task_id`\n            last_version = last_version_by_task_id.get(task_id)\n            if last_version is None:\n                # If task id does not have version set yet then it's first\n                # AssetVersion for this task\n                last_version_by_task_id[task_id] = version\n\n            elif last_version &gt; version:\n                # Skip processing if version is lower than last version\n                # and pop task id from `not_finished_task_ids`\n                not_finished_task_ids.discard(task_id)\n                continue\n\n            # Add AssetVersion entity to output dictionary\n            last_asset_versions_by_task_id[task_id].append(asset_version)\n\n        return last_asset_versions_by_task_id\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_task_to_version_status.html#services.processor.processor.default_handlers.event_task_to_version_status.TaskToVersionStatus.filter_event_entities","title":"<code>filter_event_entities(event)</code>","text":"<p>Filter if event contain relevant data.</p> <p>Event cares only about changes of <code>statusid</code> on <code>entity_type</code> \"Task\".</p> Source code in <code>services/processor/processor/default_handlers/event_task_to_version_status.py</code> <pre><code>def filter_event_entities(self, event):\n    \"\"\"Filter if event contain relevant data.\n\n    Event cares only about changes of `statusid` on `entity_type` \"Task\".\n    \"\"\"\n\n    entities_info = event[\"data\"].get(\"entities\")\n    if not entities_info:\n        return\n\n    filtered_entity_info = collections.defaultdict(list)\n    for entity_info in entities_info:\n        # Care only about tasks\n        if entity_info.get(\"entity_type\") != \"Task\":\n            continue\n\n        # Care only about changes of status\n        changes = entity_info.get(\"changes\") or {}\n        statusid_changes = changes.get(\"statusid\") or {}\n        if (\n            statusid_changes.get(\"new\") is None\n            or statusid_changes.get(\"old\") is None\n        ):\n            continue\n\n        # Get project id from entity info\n        project_id = None\n        for parent_item in reversed(entity_info[\"parents\"]):\n            if parent_item[\"entityType\"] == \"show\":\n                project_id = parent_item[\"entityId\"]\n                break\n\n        if project_id:\n            filtered_entity_info[project_id].append(entity_info)\n\n    return filtered_entity_info\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_task_to_version_status.html#services.processor.processor.default_handlers.event_task_to_version_status.TaskToVersionStatus.find_last_asset_versions_for_task_ids","title":"<code>find_last_asset_versions_for_task_ids(session, task_ids, is_allow_list, asset_type_names)</code>","text":"<p>Find latest AssetVersion entities for task.</p> <p>Find first latest AssetVersion for task and all AssetVersions with same version for the task.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>ftrack session.</p> required <code>task_ids</code> <code>list[str]</code> <p>Task ids.</p> required <code>is_allow_list</code> <code>bool</code> <p>If True then asset_types are used as allow list.</p> required <code>asset_type_names</code> <code>set[str]</code> <p>Asset types short names that will be used to filter AssetVersions. Filtering is skipped if entered value is empty list.</p> required <p>Returns:</p> Type Description <p>dict[str, list[ftrack_api.Entity]]: Dictionary with task id as key and list of AssetVersion entities as value.</p> Source code in <code>services/processor/processor/default_handlers/event_task_to_version_status.py</code> <pre><code>def find_last_asset_versions_for_task_ids(\n    self, session, task_ids, is_allow_list, asset_type_names\n):\n    \"\"\"Find latest AssetVersion entities for task.\n\n    Find first latest AssetVersion for task and all AssetVersions with\n    same version for the task.\n\n    Args:\n        session (ftrack_api.Session): ftrack session.\n        task_ids (list[str]): Task ids.\n        is_allow_list (bool): If True then asset_types are used\n            as allow list.\n        asset_type_names (set[str]): Asset types short names that will be\n            used to filter AssetVersions. Filtering is skipped if entered\n            value is empty list.\n\n    Returns:\n        dict[str, list[ftrack_api.Entity]]: Dictionary with task id as key\n            and list of AssetVersion entities as value.\n\n    \"\"\"\n    last_asset_versions_by_task_id = collections.defaultdict(list)\n\n    if not task_ids:\n        return last_asset_versions_by_task_id\n\n    if is_allow_list and not asset_type_names:\n        return last_asset_versions_by_task_id\n\n    # Allow event only on specific asset type names\n    asset_query_part = \"\"\n    if asset_type_names:\n        # Query all AssetTypes\n        asset_types = session.query(\n            \"select id, short from AssetType\"\n        ).all()\n        # Store AssetTypes by id\n        asset_type_short_by_id = {\n            asset_type[\"id\"]: asset_type[\"short\"].lower()\n            for asset_type in asset_types\n        }\n\n        # Lower asset types from settings\n        asset_type_ids = {\n            type_id\n            for type_id, short in asset_type_short_by_id.items()\n            if short.lower() in asset_type_names\n        }\n\n        # Allow list is enabled but asset type names are not available\n        if is_allow_list and not asset_type_ids:\n            self.log.warning((\n                \"None of asset type names were found in ftrack.\"\n                \" Skipping filter.\"\n            ))\n            return last_asset_versions_by_task_id\n\n        if is_allow_list:\n            asset_query_part = \" and asset.type_id in ({})\".format(\n                self.join_query_keys(asset_type_ids)\n            )\n        elif asset_type_ids:\n            asset_query_part = \" and asset.type_id not in ({})\".format(\n                self.join_query_keys(asset_type_ids)\n            )\n\n    # Query tasks' AssetVersions\n    asset_versions = session.query((\n        \"select status_id, version, task_id, asset_id\"\n        \" from AssetVersion where task_id in ({}){}\"\n        \" order by version descending\"\n    ).format(self.join_query_keys(task_ids), asset_query_part)).all()\n\n    last_version_by_task_id = {}\n    not_finished_task_ids = set(task_ids)\n    for asset_version in asset_versions:\n        task_id = asset_version[\"task_id\"]\n        # Check if task id is still in `not_finished_task_ids`\n        if task_id not in not_finished_task_ids:\n            continue\n\n        version = asset_version[\"version\"]\n\n        # Find last version in `last_version_by_task_id`\n        last_version = last_version_by_task_id.get(task_id)\n        if last_version is None:\n            # If task id does not have version set yet then it's first\n            # AssetVersion for this task\n            last_version_by_task_id[task_id] = version\n\n        elif last_version &gt; version:\n            # Skip processing if version is lower than last version\n            # and pop task id from `not_finished_task_ids`\n            not_finished_task_ids.discard(task_id)\n            continue\n\n        # Add AssetVersion entity to output dictionary\n        last_asset_versions_by_task_id[task_id].append(asset_version)\n\n    return last_asset_versions_by_task_id\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_task_to_version_status.html#services.processor.processor.default_handlers.event_task_to_version_status.TaskToVersionStatus.get_asset_version_statuses","title":"<code>get_asset_version_statuses(project_entity)</code>","text":"<p>Status entities for AssetVersion from project's schema.</p> <p>Load statuses from project's schema and store them by id and name.</p> <p>Parameters:</p> Name Type Description Default <code>project_entity</code> <code>Entity</code> <p>Entity of ftrack's project.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>2 items are returned first are statuses by name second are statuses by id.</p> Source code in <code>services/processor/processor/default_handlers/event_task_to_version_status.py</code> <pre><code>def get_asset_version_statuses(self, project_entity):\n    \"\"\"Status entities for AssetVersion from project's schema.\n\n    Load statuses from project's schema and store them by id and name.\n\n    Args:\n        project_entity (ftrack_api.Entity): Entity of ftrack's project.\n\n    Returns:\n        tuple: 2 items are returned first are statuses by name\n            second are statuses by id.\n    \"\"\"\n    project_schema = project_entity[\"project_schema\"]\n    # Get all available statuses for Task\n    statuses = project_schema.get_statuses(\"AssetVersion\")\n    # map lowered status name with it's object\n    av_statuses_by_low_name = {}\n    av_statuses_by_id = {}\n    for status in statuses:\n        av_statuses_by_low_name[status[\"name\"].lower()] = status\n        av_statuses_by_id[status[\"id\"]] = status\n\n    return av_statuses_by_low_name, av_statuses_by_id\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_task_to_version_status.html#services.processor.processor.default_handlers.event_task_to_version_status.TaskToVersionStatus.is_event_invalid","title":"<code>is_event_invalid(session, event)</code>","text":"<p>Skip task status changes for session user changes.</p> <p>It is expected that there may be another event handler that set version status to task in that case skip all events caused by same user as session has to avoid infinite loop of status changes.</p> Source code in <code>services/processor/processor/default_handlers/event_task_to_version_status.py</code> <pre><code>def is_event_invalid(self, session, event):\n    \"\"\"Skip task status changes for session user changes.\n\n    It is expected that there may be another event handler that set\n    version status to task in that case skip all events caused by same\n    user as session has to avoid infinite loop of status changes.\n    \"\"\"\n    # Cache user id of currently running session\n    if self._cached_user_id is None:\n        session_user_entity = session.query(\n            \"User where username is \\\"{}\\\"\".format(session.api_user)\n        ).first()\n        if not session_user_entity:\n            self.log.warning(\n                \"Couldn't query ftrack user with username \\\"{}\\\"\".format(\n                    session.api_user\n                )\n            )\n            return False\n        self._cached_user_id = session_user_entity[\"id\"]\n\n    # Skip processing if current session user was the user who created\n    # the event\n    user_info = event[\"source\"].get(\"user\") or {}\n    user_id = user_info.get(\"id\")\n\n    # Mark as invalid if user is unknown\n    if user_id is None:\n        return True\n    return user_id == self._cached_user_id\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_task_to_version_status.html#services.processor.processor.default_handlers.event_task_to_version_status.TaskToVersionStatus.launch","title":"<code>launch(session, event)</code>","text":"<p>Propagates status from version to task when changed</p> Source code in <code>services/processor/processor/default_handlers/event_task_to_version_status.py</code> <pre><code>def launch(self, session, event):\n    '''Propagates status from version to task when changed'''\n    if self.is_event_invalid(session, event):\n        return\n\n    filtered_entity_infos = self.filter_event_entities(event)\n    if not filtered_entity_infos:\n        return\n\n    for project_id, entities_info in filtered_entity_infos.items():\n        self.process_by_project(session, event, project_id, entities_info)\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_thumbnail_updates.html","title":"event_thumbnail_updates","text":""},{"location":"autoapi/services/processor/processor/default_handlers/event_thumbnail_updates.html#services.processor.processor.default_handlers.event_thumbnail_updates.ThumbnailEvents","title":"<code>ThumbnailEvents</code>","text":"<p>               Bases: <code>BaseEventHandler</code></p> Source code in <code>services/processor/processor/default_handlers/event_thumbnail_updates.py</code> <pre><code>class ThumbnailEvents(BaseEventHandler):\n    settings_key = \"thumbnail_updates\"\n\n    def launch(self, session, event):\n        \"\"\"Updates thumbnails of entities from new AssetVersion.\"\"\"\n        filtered_entities = self.filter_entities(event)\n        if not filtered_entities:\n            return\n\n        for project_id, entities_info in filtered_entities.items():\n            self.process_project_entities(\n                session, event, project_id, entities_info\n            )\n\n    def process_project_entities(\n        self, session, event, project_id, entities_info\n    ):\n        project_name = self.get_project_name_from_event(\n            session, event, project_id\n        )\n        project = self.get_ayon_project_from_event(event, project_name)\n        if project is None:\n            self.log.debug(\"Project not found in AYON. Skipping\")\n            return\n\n        # Load settings\n        project_settings = self.get_project_settings_from_event(\n            event, project_name\n        )\n        ftrack_settings = project_settings[\"ftrack\"]\n        if not is_ftrack_enabled_in_settings(ftrack_settings):\n            self.log.debug(\"ftrack is disabled for project \\\"{}\\\"\".format(\n                project_name\n            ))\n            return\n\n        event_settings = (\n            ftrack_settings\n            [\"service_event_handlers\"]\n            [self.settings_key]\n        )\n        if not event_settings[\"enabled\"]:\n            self.log.debug(\"Project \\\"{}\\\" does not have activated {}.\".format(\n                project_name, self.__class__.__name__\n            ))\n            return\n\n        self.log.debug(\"Processing {} on project \\\"{}\\\".\".format(\n            self.__class__.__name__, project_name\n        ))\n\n        parent_levels = event_settings[\"levels\"]\n        if parent_levels &lt; 1:\n            self.log.debug(\n                \"Project \\\"{}\\\" has parent levels set to {}. Skipping\".format(\n                    project_name, parent_levels\n                )\n            )\n            return\n\n        asset_version_ids = set()\n        for entity in entities_info:\n            asset_version_ids.add(entity[\"entityId\"])\n\n        # Do not use attribute `asset_version_entities` will be filtered\n        # to when `asset_versions_by_id` is filled\n        asset_version_entities = session.query((\n            \"select task_id, thumbnail_id from AssetVersion where id in ({})\"\n        ).format(self.join_query_keys(asset_version_ids))).all()\n\n        asset_versions_by_id = {}\n        for asset_version_entity in asset_version_entities:\n            if not asset_version_entity[\"thumbnail_id\"]:\n                continue\n            entity_id = asset_version_entity[\"id\"]\n            asset_versions_by_id[entity_id] = asset_version_entity\n\n        if not asset_versions_by_id:\n            self.log.debug(\"None of asset versions has set thumbnail id.\")\n            return\n\n        entity_ids_by_asset_version_id = collections.defaultdict(list)\n        hierarchy_ids = set()\n        for entity_info in entities_info:\n            entity_id = entity_info[\"entityId\"]\n            if entity_id not in asset_versions_by_id:\n                continue\n\n            parent_ids = []\n            counter = None\n            for parent_info in entity_info[\"parents\"]:\n                if counter is not None:\n                    if counter &gt;= parent_levels:\n                        break\n                    parent_ids.append(parent_info[\"entityId\"])\n                    counter += 1\n\n                elif parent_info[\"entityType\"] == \"asset\":\n                    counter = 0\n\n            for parent_id in parent_ids:\n                hierarchy_ids.add(parent_id)\n                entity_ids_by_asset_version_id[entity_id].append(parent_id)\n\n        for asset_version_entity in asset_versions_by_id.values():\n            task_id = asset_version_entity[\"task_id\"]\n            if task_id:\n                hierarchy_ids.add(task_id)\n                asset_version_id = asset_version_entity[\"id\"]\n                entity_ids_by_asset_version_id[asset_version_id].append(\n                    task_id\n                )\n\n        entities = session.query((\n            \"select thumbnail_id, link from TypedContext where id in ({})\"\n        ).format(self.join_query_keys(hierarchy_ids))).all()\n        entities_by_id = {\n            entity[\"id\"]: entity\n            for entity in entities\n        }\n\n        for version_id, version_entity in asset_versions_by_id.items():\n            for entity_id in entity_ids_by_asset_version_id[version_id]:\n                entity = entities_by_id.get(entity_id)\n                if not entity:\n                    continue\n\n                entity[\"thumbnail_id\"] = version_entity[\"thumbnail_id\"]\n                self.log.info(\"Updating thumbnail for entity [ {} ]\".format(\n                    self.get_entity_path(entity)\n                ))\n\n            try:\n                session.commit()\n            except Exception:\n                session.rollback()\n\n    def filter_entities(self, event):\n        filtered_entities_info = {}\n        for entity_info in event[\"data\"].get(\"entities\", []):\n            action = entity_info.get(\"action\")\n            if not action:\n                continue\n\n            if (\n                action == \"remove\"\n                or entity_info[\"entityType\"].lower() != \"assetversion\"\n                or \"thumbid\" not in (entity_info.get(\"keys\") or [])\n            ):\n                continue\n\n            # Get project id from entity info\n            project_id = entity_info[\"parents\"][-1][\"entityId\"]\n            if project_id not in filtered_entities_info:\n                filtered_entities_info[project_id] = []\n            filtered_entities_info[project_id].append(entity_info)\n        return filtered_entities_info\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_thumbnail_updates.html#services.processor.processor.default_handlers.event_thumbnail_updates.ThumbnailEvents.launch","title":"<code>launch(session, event)</code>","text":"<p>Updates thumbnails of entities from new AssetVersion.</p> Source code in <code>services/processor/processor/default_handlers/event_thumbnail_updates.py</code> <pre><code>def launch(self, session, event):\n    \"\"\"Updates thumbnails of entities from new AssetVersion.\"\"\"\n    filtered_entities = self.filter_entities(event)\n    if not filtered_entities:\n        return\n\n    for project_id, entities_info in filtered_entities.items():\n        self.process_project_entities(\n            session, event, project_id, entities_info\n        )\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_users_sync_from_ftrack.html","title":"event_users_sync_from_ftrack","text":""},{"location":"autoapi/services/processor/processor/default_handlers/event_users_sync_from_ftrack.html#services.processor.processor.default_handlers.event_users_sync_from_ftrack.SyncUsersFromFtrackEvent","title":"<code>SyncUsersFromFtrackEvent</code>","text":"<p>               Bases: <code>BaseEventHandler</code></p> <p>Sync access groups of private projects.</p> <p>Listen to changes of user roles in private projects. When user is added to the project, user is added to the project access group in AYON. When user is removed from the project, user is removed from the project access group in AYON.</p> <p>That works only for artist users. Admin and manager users can access all projects in AYON anyway. Roles from 'defaultAccessGroups' are used as roles on user in AYON.</p> Source code in <code>services/processor/processor/default_handlers/event_users_sync_from_ftrack.py</code> <pre><code>class SyncUsersFromFtrackEvent(BaseEventHandler):\n    \"\"\"Sync access groups of private projects.\n\n    Listen to changes of user roles in private projects. When user is added\n    to the project, user is added to the project access group in AYON.\n    When user is removed from the project, user is removed from the project\n    access group in AYON.\n\n    That works only for artist users. Admin and manager users can access all\n    projects in AYON anyway. Roles from 'defaultAccessGroups'\n    are used as roles on user in AYON.\n    \"\"\"\n    def launch(self, session, event):\n        project_ids_by_user_id = {}\n        project_ids = set()\n\n        for ent_info in event[\"data\"].get(\"entities\", []):\n            if ent_info.get(\"entityType\") != \"userroleproject\":\n                continue\n\n            change_user_ids = [\n                p[\"entityId\"]\n                for p in ent_info[\"parents\"]\n                if p[\"entityType\"] == \"user\"\n            ]\n            if not change_user_ids:\n                continue\n\n            project_id_change = ent_info[\"changes\"].get(\"project_id\")\n            if not project_id_change:\n                continue\n\n            project_id = project_id_change[\"new\"] or project_id_change[\"old\"]\n            if not project_id:\n                continue\n\n            user_id = change_user_ids[0]\n            project_ids.add(project_id)\n            filtered_changes = project_ids_by_user_id.setdefault(\n                user_id, {}\n            )\n            filtered_changes[project_id] = project_id_change[\"new\"] is None\n\n        if not project_ids_by_user_id:\n            return\n\n        joined_project_ids = self.join_query_keys(project_ids)\n        projects = session.query(\n            \"select id, full_name, is_private from Project\"\n            f\" where id in ({joined_project_ids})\"\n        ).all()\n        # Filter only private projects\n        # - maybe it could be done in query?\n        project_ids_by_name = {\n            project[\"full_name\"]: project[\"id\"]\n            for project in projects\n            if project[\"is_private\"]\n        }\n        if not project_ids_by_name:\n            return\n\n        # Filter only projects that are available in AYON\n        ayon_projects_names = {\n            ayon_project[\"name\"]\n            for ayon_project in ayon_api.get_projects(\n                set(project_ids_by_name), fields={\"name\"}\n            )\n        }\n        filtered_project_ids = {\n            project_ids_by_name[project_name]\n            for project_name in ayon_projects_names\n            if project_name in project_ids_by_name\n        }\n        if not filtered_project_ids:\n            return\n\n        # Filter only artist users\n        # - admin and manager users can access all projects in AYON\n        ayon_users = [\n            user\n            for user in ayon_api.get_users()\n            if (\n                not user[\"isAdmin\"]\n                and not user[\"isManager\"]\n                and not user[\"isService\"]\n            )\n        ]\n        if not ayon_users:\n            return\n\n        joined_user_ids = self.join_query_keys(project_ids_by_user_id)\n        ftrack_users = session.query(\n            \"select id, username, email from User\"\n            f\" where id in ({joined_user_ids})\"\n        ).all()\n        users_mapping: Dict[str, Union[str, None]] = (\n            map_ftrack_users_to_ayon_users(ftrack_users, ayon_users)\n        )\n        project_name_by_id = {\n            project_id: project_name\n            for project_name, project_id in project_ids_by_name.items()\n        }\n        for ftrack_id, ayon_username in users_mapping.items():\n            # Mapping was not found - ignore\n            if not ayon_username:\n                continue\n\n            removed_by_project_id = project_ids_by_user_id[ftrack_id]\n            filtered_project_ids = {\n                project_id\n                for project_id in removed_by_project_id\n                if project_id in filtered_project_ids\n            }\n            if not filtered_project_ids:\n                continue\n\n            ayon_user = ayon_api.get_user(ayon_username)\n            user_data = ayon_user[\"data\"]\n            default_user_access_groups = user_data.get(\n                \"defaultAccessGroups\", []\n            )\n            user_access_groups = user_data.setdefault(\"accessGroups\", {})\n\n            changed = False\n            for project_id in filtered_project_ids:\n                if project_id not in removed_by_project_id:\n                    continue\n\n                removed: bool = removed_by_project_id[project_id]\n                project_name = project_name_by_id[project_id]\n                if removed and project_name not in user_access_groups:\n                    continue\n\n                access_groups = user_access_groups.setdefault(\n                    project_name, []\n                )\n                if removed:\n                    if access_groups:\n                        access_groups.clear()\n                        changed = True\n\n                elif not access_groups:\n                    for group in default_user_access_groups:\n                        if group not in access_groups:\n                            access_groups.append(group)\n                            changed = True\n\n            if changed:\n                ayon_api.patch(\n                    f\"users/{ayon_username}\",\n                    data=user_data\n                )\n                self.log.info(f\"Updated access groups of '{ayon_username}'.\")\n</code></pre>"},{"location":"autoapi/services/processor/processor/default_handlers/event_version_to_task_statuses.html","title":"event_version_to_task_statuses","text":""},{"location":"autoapi/services/processor/processor/default_handlers/event_version_to_task_statuses.html#services.processor.processor.default_handlers.event_version_to_task_statuses.VersionToTaskStatus","title":"<code>VersionToTaskStatus</code>","text":"<p>               Bases: <code>BaseEventHandler</code></p> <p>Propagates status from version to task when changed.</p> Source code in <code>services/processor/processor/default_handlers/event_version_to_task_statuses.py</code> <pre><code>class VersionToTaskStatus(BaseEventHandler):\n    \"\"\"Propagates status from version to task when changed.\"\"\"\n    def launch(self, session, event):\n        # Filter event entities\n        # - output is dictionary where key is project id and event info in\n        #   value\n        filtered_entities_info = self.filter_entity_info(event)\n        if not filtered_entities_info:\n            return\n\n        for project_id, entities_info in filtered_entities_info.items():\n            self.process_by_project(session, event, project_id, entities_info)\n\n    def filter_entity_info(self, event):\n        filtered_entity_info = {}\n        for entity_info in event[\"data\"].get(\"entities\", []):\n            # Filter AssetVersions\n            if entity_info[\"entityType\"] != \"assetversion\":\n                continue\n\n            # Skip if statusid not in keys (in changes)\n            keys = entity_info.get(\"keys\")\n            if not keys or \"statusid\" not in keys:\n                continue\n\n            # Get new version task name\n            version_status_id = (\n                entity_info\n                .get(\"changes\", {})\n                .get(\"statusid\", {})\n                .get(\"new\", {})\n            )\n\n            # Just check that `new` is set to any value\n            if not version_status_id:\n                continue\n\n            # Get project id from entity info\n            project_id = entity_info[\"parents\"][-1][\"entityId\"]\n            if project_id not in filtered_entity_info:\n                filtered_entity_info[project_id] = []\n            filtered_entity_info[project_id].append(entity_info)\n        return filtered_entity_info\n\n    def process_by_project(self, session, event, project_id, entities_info):\n        # Check for project data if event is enabled for event handler\n        project_name = self.get_project_name_from_event(\n            session, event, project_id\n        )\n        if not self.get_ayon_project_from_event(event, project_name):\n            self.log.debug(\"Project not found in AYON. Skipping\")\n            return\n\n        # Load settings\n        project_settings = self.get_project_settings_from_event(\n            event, project_name\n        )\n        ftrack_settings = project_settings[\"ftrack\"]\n        if not is_ftrack_enabled_in_settings(ftrack_settings):\n            self.log.debug(\"ftrack is disabled for project \\\"{}\\\"\".format(\n                project_name\n            ))\n            return\n\n        # Load status mapping from presets\n        event_settings = (\n            ftrack_settings\n            [\"service_event_handlers\"]\n            [\"status_version_to_task\"]\n        )\n        # Skip if event is not enabled or status mapping is not set\n        if not event_settings[\"enabled\"]:\n            self.log.debug(\"Project \\\"{}\\\" has disabled {}\".format(\n                project_name, self.__class__.__name__\n            ))\n            return\n\n        status_mapping = {\n            item[\"name\"].lower(): item[\"value\"]\n            for item in event_settings[\"mapping\"]\n        }\n        asset_type_filter = event_settings[\"asset_types_filter_type\"]\n        is_allow_list = asset_type_filter == \"allow_list\"\n\n        asset_types = {\n            short_name.lower()\n            for short_name in event_settings[\"asset_types\"]\n        }\n\n        # Collect entity ids\n        asset_version_ids = set()\n        for entity_info in entities_info:\n            asset_version_ids.add(entity_info[\"entityId\"])\n\n        # Query tasks for AssetVersions\n        _asset_version_entities = session.query(\n            \"AssetVersion where task_id != none and id in ({})\".format(\n                self.join_query_keys(asset_version_ids)\n            )\n        ).all()\n        if not _asset_version_entities:\n            return\n\n        # Filter asset versions by asset type and store their task_ids\n        task_ids = set()\n        asset_version_entities = []\n        for asset_version in _asset_version_entities:\n            short_name = asset_version[\"asset\"][\"type\"][\"short\"].lower()\n            if (\n                (is_allow_list and short_name not in asset_types)\n                or (not is_allow_list and short_name in asset_types)\n            ):\n                continue\n            asset_version_entities.append(asset_version)\n            task_ids.add(asset_version[\"task_id\"])\n\n        # Skipt if `task_ids` are empty\n        if not task_ids:\n            return\n\n        task_entities = session.query(\n            \"select link from Task where id in ({})\".format(\n                self.join_query_keys(task_ids)\n            )\n        ).all()\n        task_entities_by_id = {\n            task_entiy[\"id\"]: task_entiy\n            for task_entiy in task_entities\n        }\n\n        # Prepare asset version by their id\n        asset_versions_by_id = {\n            asset_version[\"id\"]: asset_version\n            for asset_version in asset_version_entities\n        }\n\n        # Query status entities\n        status_ids = set()\n        for entity_info in entities_info:\n            # Skip statuses of asset versions without task\n            if entity_info[\"entityId\"] not in asset_versions_by_id:\n                continue\n            status_ids.add(entity_info[\"changes\"][\"statusid\"][\"new\"])\n\n        version_status_entities = session.query(\n            \"select id, name from Status where id in ({})\".format(\n                self.join_query_keys(status_ids)\n            )\n        ).all()\n\n        # Qeury statuses\n        statusese_by_obj_id = self.statuses_for_tasks(\n            session, task_entities, project_id\n        )\n        # Prepare status names by their ids\n        status_name_by_id = {\n            status_entity[\"id\"]: status_entity[\"name\"]\n            for status_entity in version_status_entities\n        }\n        for entity_info in entities_info:\n            entity_id = entity_info[\"entityId\"]\n            status_id = entity_info[\"changes\"][\"statusid\"][\"new\"]\n            status_name = status_name_by_id.get(status_id)\n            if not status_name:\n                continue\n            status_name_low = status_name.lower()\n\n            # Lower version status name and check if has mapping\n            new_status_names = []\n            mapped = status_mapping.get(status_name_low)\n            if mapped:\n                new_status_names.extend(list(mapped))\n\n            new_status_names.append(status_name_low)\n\n            self.log.debug(\n                \"Processing AssetVersion status change: [ {} ]\".format(\n                    status_name\n                )\n            )\n\n            asset_version = asset_versions_by_id[entity_id]\n            task_entity = task_entities_by_id[asset_version[\"task_id\"]]\n            type_id = task_entity[\"type_id\"]\n\n            # Lower all names from presets\n            new_status_names = [name.lower() for name in new_status_names]\n            task_statuses_by_low_name = statusese_by_obj_id[type_id]\n\n            new_status = None\n            for status_name in new_status_names:\n                if status_name not in task_statuses_by_low_name:\n                    self.log.debug((\n                        \"Task does not have status name \\\"{}\\\" available.\"\n                    ).format(status_name))\n                    continue\n\n                # store object of found status\n                new_status = task_statuses_by_low_name[status_name]\n                self.log.debug(\"Status to set: [ {} ]\".format(\n                    new_status[\"name\"]\n                ))\n                break\n\n            # Skip if status names were not found for paticulat entity\n            if not new_status:\n                self.log.warning(\n                    \"Any of statuses from presets can be set: {}\".format(\n                        str(new_status_names)\n                    )\n                )\n                continue\n            # Get full path to task for logging\n            ent_path = \"/\".join([ent[\"name\"] for ent in task_entity[\"link\"]])\n\n            # Setting task status\n            try:\n                task_entity[\"status\"] = new_status\n                session.commit()\n                self.log.debug(\"[ {} ] Status updated to [ {} ]\".format(\n                    ent_path, new_status[\"name\"]\n                ))\n            except Exception:\n                session.rollback()\n                self.log.warning(\n                    \"[ {} ]Status couldn't be set\".format(ent_path),\n                    exc_info=True\n                )\n\n    def statuses_for_tasks(self, session, task_entities, project_id):\n        task_type_ids = set()\n        for task_entity in task_entities:\n            task_type_ids.add(task_entity[\"type_id\"])\n\n        project_entity = session.get(\"Project\", project_id)\n        project_schema = project_entity[\"project_schema\"]\n        output = {}\n        for task_type_id in task_type_ids:\n            statuses = project_schema.get_statuses(\"Task\", task_type_id)\n            output[task_type_id] = {\n                status[\"name\"].lower(): status\n                for status in statuses\n            }\n\n        return output\n</code></pre>"},{"location":"autoapi/services/processor/processor/handlers_to_convert/index.html","title":"handlers_to_convert","text":""},{"location":"autoapi/services/processor/processor/handlers_to_convert/action_create_review_session.html","title":"action_create_review_session","text":""},{"location":"autoapi/services/processor/processor/handlers_to_convert/action_create_review_session.html#services.processor.processor.handlers_to_convert.action_create_review_session.CreateDailyReviewSessionServerAction","title":"<code>CreateDailyReviewSessionServerAction</code>","text":"<p>               Bases: <code>ServerAction</code></p> <p>Create daily review session object per project.</p> <p>Action creates review sessions based on settings. Settings define if is action enabled and what is a template for review session name. Logic works in a way that if review session with the name already exists then skip process. If review session for current day does not exist but yesterdays review exists and is empty then yesterdays is renamed otherwise creates new review session.</p> <p>Also contains cycle creation of dailies which is triggered each morning. This option must be enabled in project settings. Cycle creation is also checked on registration of action.</p> Source code in <code>services/processor/processor/handlers_to_convert/action_create_review_session.py</code> <pre><code>class CreateDailyReviewSessionServerAction(ServerAction):\n    \"\"\"Create daily review session object per project.\n\n    Action creates review sessions based on settings. Settings define if is\n    action enabled and what is a template for review session name. Logic works\n    in a way that if review session with the name already exists then skip\n    process. If review session for current day does not exist but yesterdays\n    review exists and is empty then yesterdays is renamed otherwise creates\n    new review session.\n\n    Also contains cycle creation of dailies which is triggered each morning.\n    This option must be enabled in project settings. Cycle creation is also\n    checked on registration of action.\n    \"\"\"\n\n    identifier = \"create.daily.review.session\"\n    #: Action label.\n    label = \"AYON Admin\"\n    variant = \"- Create Daily Review Session (Server)\"\n    icon = get_service_ftrack_icon_url(\"AYONAdmin.svg\")\n    #: Action description.\n    description = \"Manually create daily review session\"\n    role_list = {\"Administrator\", \"Project Manager\"}\n\n    settings_key = \"create_daily_review_session\"\n    default_template = \"{yy}{mm}{dd}\"\n\n    def __init__(self, *args, **kwargs):\n        super(CreateDailyReviewSessionServerAction, self).__init__(\n            *args, **kwargs\n        )\n\n        self._cycle_timers_by_id = {}\n        self._day_delta = datetime.timedelta(days=1)\n\n    def discover(self, session, entities, event):\n        \"\"\"Show action only on AssetVersions.\"\"\"\n\n        valid_selection = False\n        for ent in event[\"data\"][\"selection\"]:\n            # Ignore entities that are not tasks or projects\n            if ent[\"entityType\"].lower() in (\n                \"show\", \"task\", \"reviewsession\", \"assetversion\"\n            ):\n                valid_selection = True\n                break\n\n        if not valid_selection:\n            return False\n        return self.valid_roles(session, entities, event)\n\n    def launch(self, session, entities, event):\n        project_entity = self.get_project_from_entity(entities[0], session)\n        project_name = project_entity[\"full_name\"]\n        project_settings = self.get_project_settings_from_event(\n            event, project_name\n        )\n        action_settings = self._extract_action_settings(project_settings)\n        project_name_by_id = {\n            project_entity[\"id\"]: project_name\n        }\n        settings_by_project_id = {\n            project_entity[\"id\"]: action_settings\n        }\n        self._process_review_session(\n            session, settings_by_project_id, project_name_by_id\n        )\n        return True\n\n    def _calculate_next_cycle_delta(self):\n        studio_default_settings = get_default_project_settings()\n        action_settings = (\n            studio_default_settings\n            [\"ftrack\"]\n            [self.settings_frack_subkey]\n            [self.settings_key]\n        )\n        cycle_hour_start = action_settings.get(\"cycle_hour_start\")\n        if not cycle_hour_start:\n            h = m = s = 0\n        else:\n            h, m, s = cycle_hour_start\n\n        # Create threading timer which will trigger creation of report\n        #   at the 00:00:01 of next day\n        # - callback will trigger another timer which will have 1 day offset\n        now = datetime.datetime.now()\n        # Create object of today morning\n        expected_next_trigger = datetime.datetime(\n            now.year, now.month, now.day, h, m, s\n        )\n        if expected_next_trigger &lt;= now:\n            expected_next_trigger += self._day_delta\n\n        return (expected_next_trigger - now).total_seconds()\n\n    def register(self, *args, **kwargs):\n        \"\"\"Override register to be able trigger \"\"\"\n        # Register server action as would be normally\n        super().register(*args, **kwargs)\n\n        self._add_timer_callback()\n\n        self._check_review_session()\n\n    def cleanup(self):\n        for timer_id in list(self._cycle_timers_by_id.keys()):\n            timer = self._cycle_timers_by_id.pop(timer_id, None)\n            if timer is not None:\n                timer.cancel()\n\n    def _add_timer_callback(self):\n        seconds_delta = self._calculate_next_cycle_delta()\n\n        timer_id = uuid.uuid4().hex\n        cycle_timer = threading.Timer(\n            seconds_delta, self._timer_callback, [timer_id]\n        )\n        self._cycle_timers_by_id[timer_id] = cycle_timer\n        cycle_timer.start()\n\n    def _timer_callback(self, timer_id):\n        timer = self._cycle_timers_by_id.pop(timer_id, None)\n        if timer is None:\n            return\n\n        # Stop chrono callbacks if session is closed\n        if self.session.closed:\n            return\n\n        self._add_timer_callback()\n\n        self._check_review_session()\n\n    def _check_review_session(self):\n        session = ftrack_api.Session(\n            server_url=self.session.server_url,\n            api_key=self.session.api_key,\n            api_user=self.session.api_user,\n            auto_connect_event_hub=False\n        )\n        project_entities = session.query(\n            \"select id, full_name from Project\"\n        ).all()\n        project_names_by_id = {\n            project_entity[\"id\"]: project_entity[\"full_name\"]\n            for project_entity in project_entities\n        }\n\n        action_settings_by_project_id = self._get_action_settings(\n            project_names_by_id\n        )\n        enabled_action_settings_by_project_id = {}\n        for item in action_settings_by_project_id.items():\n            project_id, action_settings = item\n            if action_settings.get(\"cycle_enabled\"):\n                enabled_action_settings_by_project_id[project_id] = (\n                    action_settings\n                )\n\n        if not enabled_action_settings_by_project_id:\n            self.log.info((\n                \"There are no projects that have enabled\"\n                \" cycle review sesison creation\"\n            ))\n\n        else:\n            self._process_review_session(\n                session,\n                enabled_action_settings_by_project_id,\n                project_names_by_id\n            )\n\n        session.close()\n\n    def _process_review_session(\n        self, session, settings_by_project_id, project_names_by_id\n    ):\n        review_sessions = session.query((\n            \"select id, name, project_id\"\n            \" from ReviewSession where project_id in ({})\"\n        ).format(self.join_query_keys(settings_by_project_id))).all()\n\n        review_sessions_by_project_id = collections.defaultdict(list)\n        for review_session in review_sessions:\n            project_id = review_session[\"project_id\"]\n            review_sessions_by_project_id[project_id].append(review_session)\n\n        # Prepare fill data for today's review sesison and yesterdays\n        now = datetime.datetime.now()\n        today_obj = datetime.datetime(\n            now.year, now.month, now.day, 0, 0, 0\n        )\n        yesterday_obj = today_obj - self._day_delta\n\n        today_fill_data = get_datetime_data(today_obj)\n        yesterday_fill_data = get_datetime_data(yesterday_obj)\n\n        # Loop through projects and try to create daily reviews\n        for project_id, action_settings in settings_by_project_id.items():\n            review_session_template = (\n                action_settings[\"review_session_template\"]\n            ).strip() or self.default_template\n\n            today_project_fill_data = copy.deepcopy(today_fill_data)\n            yesterday_project_fill_data = copy.deepcopy(yesterday_fill_data)\n            project_name = project_names_by_id[project_id]\n            today_project_fill_data[\"project_name\"] = project_name\n            yesterday_project_fill_data[\"project_name\"] = project_name\n\n            today_session_name = self._fill_review_template(\n                review_session_template, today_project_fill_data\n            )\n            yesterday_session_name = self._fill_review_template(\n                review_session_template, yesterday_project_fill_data\n            )\n            # Skip if today's session name could not be filled\n            if not today_session_name:\n                continue\n\n            # Find matchin review session\n            project_review_sessions = review_sessions_by_project_id[project_id]\n            todays_session = None\n            yesterdays_session = None\n            for review_session in project_review_sessions:\n                session_name = review_session[\"name\"]\n                if session_name == today_session_name:\n                    todays_session = review_session\n                    break\n                elif session_name == yesterday_session_name:\n                    yesterdays_session = review_session\n\n            # Skip if today's session already exist\n            if todays_session is not None:\n                self.log.debug((\n                    \"Todays ReviewSession \\\"{}\\\"\"\n                    \" in project \\\"{}\\\" already exists\"\n                ).format(today_session_name, project_name))\n                continue\n\n            # Check if there is yesterday's session and is empty\n            # - in that case just rename it\n            if (\n                yesterdays_session is not None\n                and len(yesterdays_session[\"review_session_objects\"]) == 0\n            ):\n                self.log.debug((\n                    \"Renaming yesterdays empty review session \\\"{}\\\" to \\\"{}\\\"\"\n                    \" in project \\\"{}\\\"\"\n                ).format(\n                    yesterday_session_name, today_session_name, project_name\n                ))\n                yesterdays_session[\"name\"] = today_session_name\n                session.commit()\n                continue\n\n            # Create new review session with new name\n            self.log.debug((\n                \"Creating new review session \\\"{}\\\" in project \\\"{}\\\"\"\n            ).format(today_session_name, project_name))\n            session.create(\"ReviewSession\", {\n                \"project_id\": project_id,\n                \"name\": today_session_name\n            })\n            session.commit()\n\n    def _get_action_settings(self, project_names_by_id):\n        settings_by_project_id = {}\n        for project_id, project_name in project_names_by_id.items():\n            project_settings = get_project_settings(project_name)\n            action_settings = self._extract_action_settings(project_settings)\n            settings_by_project_id[project_id] = action_settings\n        return settings_by_project_id\n\n    def _extract_action_settings(self, project_settings):\n        return (\n            project_settings\n            .get(\"ftrack\", {})\n            .get(self.settings_frack_subkey, {})\n            .get(self.settings_key)\n        ) or {}\n\n    def _fill_review_template(self, template, data):\n        output = None\n        try:\n            output = template.format(**data)\n        except Exception:\n            self.log.warning(\n                (\n                    \"Failed to fill review session template {} with data {}\"\n                ).format(template, data),\n                exc_info=True\n            )\n        return output\n</code></pre>"},{"location":"autoapi/services/processor/processor/handlers_to_convert/action_create_review_session.html#services.processor.processor.handlers_to_convert.action_create_review_session.CreateDailyReviewSessionServerAction.discover","title":"<code>discover(session, entities, event)</code>","text":"<p>Show action only on AssetVersions.</p> Source code in <code>services/processor/processor/handlers_to_convert/action_create_review_session.py</code> <pre><code>def discover(self, session, entities, event):\n    \"\"\"Show action only on AssetVersions.\"\"\"\n\n    valid_selection = False\n    for ent in event[\"data\"][\"selection\"]:\n        # Ignore entities that are not tasks or projects\n        if ent[\"entityType\"].lower() in (\n            \"show\", \"task\", \"reviewsession\", \"assetversion\"\n        ):\n            valid_selection = True\n            break\n\n    if not valid_selection:\n        return False\n    return self.valid_roles(session, entities, event)\n</code></pre>"},{"location":"autoapi/services/processor/processor/handlers_to_convert/action_create_review_session.html#services.processor.processor.handlers_to_convert.action_create_review_session.CreateDailyReviewSessionServerAction.register","title":"<code>register(*args, **kwargs)</code>","text":"<p>Override register to be able trigger</p> Source code in <code>services/processor/processor/handlers_to_convert/action_create_review_session.py</code> <pre><code>def register(self, *args, **kwargs):\n    \"\"\"Override register to be able trigger \"\"\"\n    # Register server action as would be normally\n    super().register(*args, **kwargs)\n\n    self._add_timer_callback()\n\n    self._check_review_session()\n</code></pre>"},{"location":"autoapi/services/processor/processor/handlers_to_convert/event_del_avalon_id_from_new.html","title":"event_del_avalon_id_from_new","text":""},{"location":"autoapi/services/processor/processor/handlers_to_convert/event_del_avalon_id_from_new.html#services.processor.processor.handlers_to_convert.event_del_avalon_id_from_new.DelAvalonIdFromNew","title":"<code>DelAvalonIdFromNew</code>","text":"<p>               Bases: <code>BaseEventHandler</code></p> <p>This event removes AvalonId from custom attributes of new entities Result: - 'Copy-&gt;Pasted' entities won't have same AvalonID as source entity</p> <p>Priority of this event must be less than SyncToAvalon event</p> Source code in <code>services/processor/processor/handlers_to_convert/event_del_avalon_id_from_new.py</code> <pre><code>class DelAvalonIdFromNew(BaseEventHandler):\n    '''\n    This event removes AvalonId from custom attributes of new entities\n    Result:\n    - 'Copy-&gt;Pasted' entities won't have same AvalonID as source entity\n\n    Priority of this event must be less than SyncToAvalon event\n    '''\n    priority = SyncToAvalonEvent.priority - 1\n    ignore_me = True\n\n    def launch(self, session, event):\n        created = []\n        entities = event['data']['entities']\n        for entity in entities:\n            try:\n                entity_id = entity['entityId']\n\n                if entity.get('action', None) == 'add':\n                    id_dict = entity['changes']['id']\n\n                    if id_dict['new'] is not None and id_dict['old'] is None:\n                        created.append(id_dict['new'])\n\n                elif (\n                    entity.get('action', None) == 'update' and\n                    CUST_ATTR_KEY_SERVER_ID in entity['keys'] and\n                    entity_id in created\n                ):\n                    ftrack_entity = session.get(\n                        self._get_entity_type(entity),\n                        entity_id\n                    )\n\n                    cust_attrs = ftrack_entity[\"custom_attributes\"]\n                    if cust_attrs[CUST_ATTR_KEY_SERVER_ID]:\n                        cust_attrs[CUST_ATTR_KEY_SERVER_ID] = \"\"\n                        session.commit()\n\n            except Exception:\n                session.rollback()\n                continue\n</code></pre>"},{"location":"autoapi/services/processor/processor/handlers_to_convert/event_sync_to_avalon.html","title":"event_sync_to_avalon","text":""},{"location":"autoapi/services/processor/processor/handlers_to_convert/event_sync_to_avalon.html#services.processor.processor.handlers_to_convert.event_sync_to_avalon.SyncToAvalonEvent","title":"<code>SyncToAvalonEvent</code>","text":"<p>               Bases: <code>BaseEventHandler</code></p> Source code in <code>services/processor/processor/handlers_to_convert/event_sync_to_avalon.py</code> <pre><code>class SyncToAvalonEvent(BaseEventHandler):\n    interest_entTypes = [\"show\", \"task\"]\n    ignore_ent_types = [\"Milestone\"]\n    ignore_keys = [\"statusid\", \"thumbid\"]\n\n    cust_attr_query_keys = [\n        \"id\",\n        \"key\",\n        \"entity_type\",\n        \"object_type_id\",\n        \"is_hierarchical\",\n        \"config\",\n        \"default\"\n    ]\n    project_query = (\n        \"select full_name, name, custom_attributes\"\n        \", project_schema._task_type_schema.types.name\"\n        \" from Project where id is \\\"{}\\\"\"\n    )\n\n    entities_query_by_id = (\n        \"select id, name, parent_id, link, custom_attributes, description\"\n        \" from TypedContext where project_id is \\\"{}\\\" and id in ({})\"\n    )\n\n    # useful for getting all tasks for asset\n    task_entities_query_by_parent_id = (\n        \"select id, name, parent_id, type_id from Task\"\n        \" where project_id is \\\"{}\\\" and parent_id in ({})\"\n    )\n    task_types_query = (\n        \"select id, name from Type\"\n    )\n    entities_name_query_by_name = (\n        \"select id, name from TypedContext\"\n        \" where project_id is \\\"{}\\\" and name in ({})\"\n    )\n    created_entities = []\n    report_splitter = {\"type\": \"label\", \"value\": \"---\"}\n\n    def __init__(self, session):\n        '''Expects a ftrack_api.Session instance'''\n        # Debug settings\n        # - time expiration in seconds\n        self.debug_print_time_expiration = 5 * 60\n        # - store current time\n        self.debug_print_time = datetime.datetime.now()\n        # - store synchronize entity types to be able to use\n        #   only entityTypes in interest instead of filtering by ignored\n        self.debug_sync_types = collections.defaultdict(list)\n\n        self.dbcon = AvalonMongoDB()\n        # Set processing session to not use global\n        self.set_process_session(session)\n        super().__init__(session)\n\n    def debug_logs(self):\n        \"\"\"This is debug method for printing small debugs messages. \"\"\"\n        now_datetime = datetime.datetime.now()\n        delta = now_datetime - self.debug_print_time\n        if delta.total_seconds() &lt; self.debug_print_time_expiration:\n            return\n\n        self.debug_print_time = now_datetime\n        known_types_items = []\n        for entityType, entity_type in self.debug_sync_types.items():\n            ent_types_msg = \", \".join(entity_type)\n            known_types_items.append(\n                \"&lt;{}&gt; ({})\".format(entityType, ent_types_msg)\n            )\n\n        known_entityTypes = \", \".join(known_types_items)\n        self.log.debug(\n            \"DEBUG MESSAGE: Known types {}\".format(known_entityTypes)\n        )\n\n    @property\n    def cur_project(self):\n        if self._cur_project is None:\n            found_id = None\n            for ent_info in self._cur_event[\"data\"][\"entities\"]:\n                if found_id is not None:\n                    break\n                parents = ent_info.get(\"parents\") or []\n                for parent in parents:\n                    if parent.get(\"entityType\") == \"show\":\n                        found_id = parent.get(\"entityId\")\n                        break\n            if found_id:\n                self._cur_project = self.process_session.query(\n                    self.project_query.format(found_id)\n                ).one()\n        return self._cur_project\n\n    @property\n    def avalon_cust_attrs(self):\n        if self._avalon_cust_attrs is None:\n            self._avalon_cust_attrs = get_ayon_attr_configs(\n                self.process_session, query_keys=self.cust_attr_query_keys\n            )\n        return self._avalon_cust_attrs\n\n    @property\n    def cust_attr_types_by_id(self):\n        if self._cust_attr_types_by_id is None:\n            cust_attr_types = self.process_session.query(\n                \"select id, name from CustomAttributeType\"\n            ).all()\n            self._cust_attr_types_by_id = {\n                cust_attr_type[\"id\"]: cust_attr_type\n                for cust_attr_type in cust_attr_types\n            }\n        return self._cust_attr_types_by_id\n\n    @property\n    def avalon_entities(self):\n        if self._avalon_ents is None:\n            project_name = self.cur_project[\"full_name\"]\n            self.dbcon.install()\n            self.dbcon.Session[\"AVALON_PROJECT\"] = project_name\n            avalon_project = get_project(project_name)\n            avalon_entities = list(get_assets(project_name))\n            self._avalon_ents = (avalon_project, avalon_entities)\n        return self._avalon_ents\n\n    @property\n    def avalon_ents_by_name(self):\n        if self._avalon_ents_by_name is None:\n            self._avalon_ents_by_name = {}\n            proj, ents = self.avalon_entities\n            for ent in ents:\n                self._avalon_ents_by_name[ent[\"name\"]] = ent\n        return self._avalon_ents_by_name\n\n    @property\n    def avalon_ents_by_id(self):\n        if self._avalon_ents_by_id is None:\n            self._avalon_ents_by_id = {}\n            proj, ents = self.avalon_entities\n            if proj:\n                self._avalon_ents_by_id[proj[\"_id\"]] = proj\n                for ent in ents:\n                    self._avalon_ents_by_id[ent[\"_id\"]] = ent\n        return self._avalon_ents_by_id\n\n    @property\n    def avalon_ents_by_parent_id(self):\n        if self._avalon_ents_by_parent_id is None:\n            self._avalon_ents_by_parent_id = collections.defaultdict(list)\n            proj, ents = self.avalon_entities\n            for ent in ents:\n                vis_par = ent[\"data\"][\"visualParent\"]\n                if vis_par is None:\n                    vis_par = proj[\"_id\"]\n                self._avalon_ents_by_parent_id[vis_par].append(ent)\n        return self._avalon_ents_by_parent_id\n\n    @property\n    def avalon_ents_by_ftrack_id(self):\n        if self._avalon_ents_by_ftrack_id is None:\n            self._avalon_ents_by_ftrack_id = {}\n            proj, ents = self.avalon_entities\n            if proj:\n                ftrack_id = proj[\"data\"].get(\"ftrackId\")\n                if ftrack_id is None:\n                    self.handle_missing_ftrack_id(proj)\n                    ftrack_id = proj[\"data\"][\"ftrackId\"]\n                self._avalon_ents_by_ftrack_id[ftrack_id] = proj\n\n                self._avalon_ents_by_ftrack_id[ftrack_id] = proj\n                for ent in ents:\n                    ftrack_id = ent[\"data\"].get(\"ftrackId\")\n                    if ftrack_id is None:\n                        continue\n                    self._avalon_ents_by_ftrack_id[ftrack_id] = ent\n        return self._avalon_ents_by_ftrack_id\n\n    def handle_missing_ftrack_id(self, doc):\n        # TODO handling of missing ftrack id is primarily issue of editorial\n        #   publishing it would be better to find out what causes that\n        #   ftrack id is removed during the publishing\n        ftrack_id = doc[\"data\"].get(\"ftrackId\")\n        if ftrack_id is not None:\n            return\n\n        if doc[\"type\"] == \"project\":\n            ftrack_id = self.cur_project[\"id\"]\n\n            self.dbcon.update_one(\n                {\"type\": \"project\"},\n                {\"$set\": {\n                    \"data.ftrackId\": ftrack_id,\n                    \"data.entityType\": self.cur_project.entity_type\n                }}\n            )\n\n            doc[\"data\"][\"ftrackId\"] = ftrack_id\n            doc[\"data\"][\"entityType\"] = self.cur_project.entity_type\n            self.log.info(\"Updated ftrack id of project \\\"{}\\\"\".format(\n                self.cur_project[\"full_name\"]\n            ))\n            return\n\n        if doc[\"type\"] != \"asset\":\n            return\n\n        doc_parents = doc.get(\"data\", {}).get(\"parents\")\n        if doc_parents is None:\n            return\n\n        entities = self.process_session.query((\n            \"select id, link from TypedContext\"\n            \" where project_id is \\\"{}\\\" and name is \\\"{}\\\"\"\n        ).format(self.cur_project[\"id\"], doc[\"name\"])).all()\n        self.log.info(\"Entities: {}\".format(str(entities)))\n        matching_entity = None\n        for entity in entities:\n            parents = []\n            for item in entity[\"link\"]:\n                if item[\"id\"] == entity[\"id\"]:\n                    break\n                low_type = item[\"type\"].lower()\n                if low_type == \"typedcontext\":\n                    parents.append(item[\"name\"])\n            if doc_parents == parents:\n                matching_entity = entity\n                break\n\n        if matching_entity is None:\n            return\n\n        ftrack_id = matching_entity[\"id\"]\n        self.dbcon.update_one(\n            {\"_id\": doc[\"_id\"]},\n            {\"$set\": {\n                \"data.ftrackId\": ftrack_id,\n                \"data.entityType\": matching_entity.entity_type\n            }}\n        )\n        doc[\"data\"][\"ftrackId\"] = ftrack_id\n        doc[\"data\"][\"entityType\"] = matching_entity.entity_type\n\n        entity_path_items = []\n        for item in entity[\"link\"]:\n            entity_path_items.append(item[\"name\"])\n        self.log.info(\"Updated ftrack id of entity \\\"{}\\\"\".format(\n            \"/\".join(entity_path_items)\n        ))\n        self._avalon_ents_by_ftrack_id[ftrack_id] = doc\n\n    @property\n    def avalon_asset_ids_with_subsets(self):\n        if self._avalon_asset_ids_with_subsets is None:\n            project_name = self.cur_project[\"full_name\"]\n            self._avalon_asset_ids_with_subsets = get_asset_ids_with_subsets(\n                project_name\n            )\n\n        return self._avalon_asset_ids_with_subsets\n\n    @property\n    def avalon_archived_by_id(self):\n        if self._avalon_archived_by_id is None:\n            self._avalon_archived_by_id = {}\n            project_name = self.cur_project[\"full_name\"]\n            for asset in get_archived_assets(project_name):\n                self._avalon_archived_by_id[asset[\"_id\"]] = asset\n        return self._avalon_archived_by_id\n\n    @property\n    def avalon_archived_by_name(self):\n        if self._avalon_archived_by_name is None:\n            self._avalon_archived_by_name = {}\n            for asset in self.avalon_archived_by_id.values():\n                self._avalon_archived_by_name[asset[\"name\"]] = asset\n        return self._avalon_archived_by_name\n\n    @property\n    def changeability_by_mongo_id(self):\n        \"\"\"Return info about changeability of entity and it's parents.\"\"\"\n        if self._changeability_by_mongo_id is None:\n            self._changeability_by_mongo_id = collections.defaultdict(\n                lambda: True\n            )\n            avalon_project, avalon_entities = self.avalon_entities\n            self._changeability_by_mongo_id[avalon_project[\"_id\"]] = False\n            self._bubble_changeability(\n                list(self.avalon_asset_ids_with_subsets)\n            )\n\n        return self._changeability_by_mongo_id\n\n    def remove_cached_by_key(self, key, values):\n        if self._avalon_ents is None:\n            return\n\n        if not isinstance(values, (list, tuple)):\n            values = [values]\n\n        def get_found_data(entity):\n            if not entity:\n                return None\n            return {\n                \"ftrack_id\": entity[\"data\"][\"ftrackId\"],\n                \"parent_id\": entity[\"data\"][\"visualParent\"],\n                \"_id\": entity[\"_id\"],\n                \"name\": entity[\"name\"],\n                \"entity\": entity\n            }\n\n        if key == \"id\":\n            key = \"_id\"\n        elif key == \"ftrack_id\":\n            key = \"data.ftrackId\"\n\n        found_data = {}\n        project, entities = self._avalon_ents\n        key_items = key.split(\".\")\n        for value in values:\n            ent = None\n            if key == \"_id\":\n                if self._avalon_ents_by_id is not None:\n                    ent = self._avalon_ents_by_id.get(value)\n\n            elif key == \"name\":\n                if self._avalon_ents_by_name is not None:\n                    ent = self._avalon_ents_by_name.get(value)\n\n            elif key == \"data.ftrackId\":\n                if self._avalon_ents_by_ftrack_id is not None:\n                    ent = self._avalon_ents_by_ftrack_id.get(value)\n\n            if ent is None:\n                for _ent in entities:\n                    _temp = _ent\n                    for item in key_items:\n                        _temp = _temp[item]\n\n                    if _temp == value:\n                        ent = _ent\n                        break\n\n            found_data[value] = get_found_data(ent)\n\n        for value in values:\n            data = found_data[value]\n            if not data:\n                # TODO logging\n                self.log.warning(\n                    \"Didn't found entity by key/value \\\"{}\\\" / \\\"{}\\\"\".format(\n                        key, value\n                    )\n                )\n                continue\n\n            ftrack_id = data[\"ftrack_id\"]\n            parent_id = data[\"parent_id\"]\n            mongo_id = data[\"_id\"]\n            name = data[\"name\"]\n            entity = data[\"entity\"]\n\n            project, ents = self._avalon_ents\n            ents.remove(entity)\n            self._avalon_ents = project, ents\n\n            if self._avalon_ents_by_ftrack_id is not None:\n                self._avalon_ents_by_ftrack_id.pop(ftrack_id, None)\n\n            if self._avalon_ents_by_parent_id is not None:\n                self._avalon_ents_by_parent_id[parent_id].remove(entity)\n\n            if self._avalon_ents_by_id is not None:\n                self._avalon_ents_by_id.pop(mongo_id, None)\n\n            if self._avalon_ents_by_name is not None:\n                self._avalon_ents_by_name.pop(name, None)\n\n            if self._avalon_archived_by_id is not None:\n                self._avalon_archived_by_id[mongo_id] = entity\n\n    def _bubble_changeability(self, unchangeable_ids):\n        unchangeable_queue = collections.deque()\n        for entity_id in unchangeable_ids:\n            unchangeable_queue.append((entity_id, False))\n\n        processed_parents_ids = []\n        while unchangeable_queue:\n            entity_id, child_is_archived = unchangeable_queue.popleft()\n            # skip if already processed\n            if entity_id in processed_parents_ids:\n                continue\n\n            entity = self.avalon_ents_by_id.get(entity_id)\n            # if entity is not archived but unchageable child was then skip\n            # - archived entities should not affect not archived?\n            if entity and child_is_archived:\n                continue\n\n            # set changeability of current entity to False\n            self._changeability_by_mongo_id[entity_id] = False\n            processed_parents_ids.append(entity_id)\n            # if not entity then is probably archived\n            if not entity:\n                entity = self.avalon_archived_by_id.get(entity_id)\n                child_is_archived = True\n\n            if not entity:\n                # if entity is not found then it is subset without parent\n                if entity_id in unchangeable_ids:\n                    self.log.warning((\n                        \"Parent &lt;{}&gt; with subsets does not exist\"\n                    ).format(str(entity_id)))\n                else:\n                    self.log.warning((\n                        \"In avalon are entities without valid parents that\"\n                        \" lead to Project (should not cause errors)\"\n                        \" - MongoId &lt;{}&gt;\"\n                    ).format(str(entity_id)))\n                continue\n\n            # skip if parent is project\n            parent_id = entity[\"data\"][\"visualParent\"]\n            if parent_id is None:\n                continue\n            unchangeable_queue.append((parent_id, child_is_archived))\n\n    def reset_variables(self):\n        \"\"\"Reset variables so each event callback has clear env.\"\"\"\n        self._cur_project = None\n\n        self._avalon_cust_attrs = None\n        self._cust_attr_types_by_id = None\n\n        self._avalon_ents = None\n        self._avalon_ents_by_id = None\n        self._avalon_ents_by_parent_id = None\n        self._avalon_ents_by_ftrack_id = None\n        self._avalon_ents_by_name = None\n        self._avalon_asset_ids_with_subsets = None\n        self._changeability_by_mongo_id = None\n        self._avalon_archived_by_id = None\n        self._avalon_archived_by_name = None\n\n        self._ent_types_by_name = None\n\n        self.ftrack_ents_by_id = {}\n        self.obj_id_ent_type_map = {}\n        self.ftrack_recreated_mapping = {}\n\n        self.ftrack_added = {}\n        self.ftrack_moved = {}\n        self.ftrack_renamed = {}\n        self.ftrack_updated = {}\n        self.ftrack_removed = {}\n\n        # set of ftrack ids with modified tasks\n        # handled separately by full wipeout and replace from ftrack\n        self.modified_tasks_ftrackids = set()\n\n        self.moved_in_avalon = []\n        self.renamed_in_avalon = []\n        self.hier_cust_attrs_changes = collections.defaultdict(list)\n\n        self.duplicated = []\n        self.regex_failed = []\n\n        self.regex_schemas = {}\n        self.updates = collections.defaultdict(dict)\n\n        self.report_items = {\n            \"info\": collections.defaultdict(list),\n            \"warning\": collections.defaultdict(list),\n            \"error\": collections.defaultdict(list)\n        }\n\n    def set_process_session(self, session):\n        try:\n            self.process_session.close()\n        except Exception:\n            pass\n        self.process_session = ftrack_api.Session(\n            server_url=session.server_url,\n            api_key=session.api_key,\n            api_user=session.api_user,\n            auto_connect_event_hub=True\n        )\n        atexit.register(lambda: self.process_session.close())\n\n    def filter_updated(self, updates):\n        filtered_updates = {}\n        for ftrack_id, ent_info in updates.items():\n            changed_keys = [k for k in (ent_info.get(\"keys\") or [])]\n            changes = {\n                k: v for k, v in (ent_info.get(\"changes\") or {}).items()\n            }\n\n            entity_type = ent_info[\"entity_type\"]\n            if entity_type == \"Task\":\n                if \"name\" in changed_keys:\n                    ent_info[\"keys\"] = [\"name\"]\n                    ent_info[\"changes\"] = {\"name\": changes.pop(\"name\")}\n                    filtered_updates[ftrack_id] = ent_info\n                continue\n\n            for _key in self.ignore_keys:\n                if _key in changed_keys:\n                    changed_keys.remove(_key)\n                    changes.pop(_key, None)\n\n            if not changed_keys:\n                continue\n\n            # Remove custom attributes starting with `avalon_` from changes\n            # - these custom attributes are not synchronized\n            avalon_keys = []\n            for key in changes:\n                if key.startswith(\"avalon_\"):\n                    avalon_keys.append(key)\n\n            for _key in avalon_keys:\n                changed_keys.remove(_key)\n                changes.pop(_key, None)\n\n            if not changed_keys:\n                continue\n\n            ent_info[\"keys\"] = changed_keys\n            ent_info[\"changes\"] = changes\n            filtered_updates[ftrack_id] = ent_info\n\n        return filtered_updates\n\n    def get_ent_path(self, ftrack_id):\n        \"\"\"\n            Looks for entity in ftrack with 'ftrack_id'. If found returns\n            concatenated paths from its 'link' elemenent's names. Describes\n            location of entity in tree.\n        Args:\n            ftrack_id (string): entityId of ftrack entity\n\n        Returns:\n            (string) - example : \"/test_project/assets/my_asset\"\n        \"\"\"\n        entity = self.ftrack_ents_by_id.get(ftrack_id)\n        if not entity:\n            entity = self.process_session.query(\n                self.entities_query_by_id.format(\n                    self.cur_project[\"id\"], ftrack_id\n                )\n            ).first()\n            if entity:\n                self.ftrack_ents_by_id[ftrack_id] = entity\n            else:\n                return \"unknown hierarchy\"\n        return \"/\".join([ent[\"name\"] for ent in entity[\"link\"]])\n\n    def launch(self, session, event):\n        \"\"\"\n            Main entry port for synchronization.\n            Goes through event (can contain multiple changes) and decides if\n            the event is interesting for us (interest_entTypes).\n            It separates changes into add|remove|update.\n            All task changes are handled together by refresh from ftrack.\n        Args:\n            session (object): session to ftrack\n            event (dictionary): event content\n\n        Returns:\n            (boolean or None)\n        \"\"\"\n        # Try to commit and if any error happen then recreate session\n        try:\n            self.process_session.commit()\n        except Exception:\n            self.set_process_session(session)\n        # Reset object values for each launch\n        self.reset_variables()\n        self._cur_event = event\n\n        entities_by_action = {\n            \"remove\": {},\n            \"update\": {},\n            \"move\": {},\n            \"add\": {}\n        }\n\n        entities_info = event[\"data\"][\"entities\"]\n        found_actions = set()\n        for ent_info in entities_info:\n            entityType = ent_info[\"entityType\"]\n            if entityType not in self.interest_entTypes:\n                continue\n\n            entity_type = ent_info.get(\"entity_type\")\n            if not entity_type or entity_type in self.ignore_ent_types:\n                continue\n\n            if entity_type not in self.debug_sync_types[entityType]:\n                self.debug_sync_types[entityType].append(entity_type)\n\n            action = ent_info[\"action\"]\n            ftrack_id = ent_info[\"entityId\"]\n            if isinstance(ftrack_id, list):\n                self.log.warning((\n                    \"BUG REPORT: Entity info has `entityId` as `list` \\\"{}\\\"\"\n                ).format(ent_info))\n                if len(ftrack_id) == 0:\n                    continue\n                ftrack_id = ftrack_id[0]\n\n            # Skip deleted projects\n            if action == \"remove\" and entityType == \"show\":\n                return True\n\n            # task modified, collect parent id of task, handle separately\n            if entity_type.lower() == \"task\":\n                changes = ent_info.get(\"changes\") or {}\n                if action == \"move\":\n                    parent_changes = changes[\"parent_id\"]\n                    self.modified_tasks_ftrackids.add(parent_changes[\"new\"])\n                    self.modified_tasks_ftrackids.add(parent_changes[\"old\"])\n\n                elif \"typeid\" in changes or \"name\" in changes:\n                    self.modified_tasks_ftrackids.add(ent_info[\"parentId\"])\n                continue\n\n            if action == \"move\":\n                ent_keys = ent_info[\"keys\"]\n                # Separate update info from move action\n                if len(ent_keys) &gt; 1:\n                    _ent_info = ent_info.copy()\n                    for ent_key in ent_keys:\n                        if ent_key == \"parent_id\":\n                            _ent_info[\"changes\"].pop(ent_key, None)\n                            _ent_info[\"keys\"].remove(ent_key)\n                        else:\n                            ent_info[\"changes\"].pop(ent_key, None)\n                            ent_info[\"keys\"].remove(ent_key)\n                    entities_by_action[\"update\"][ftrack_id] = _ent_info\n            # regular change process handles all other than Tasks\n            found_actions.add(action)\n            entities_by_action[action][ftrack_id] = ent_info\n\n        found_actions = list(found_actions)\n        if not found_actions and not self.modified_tasks_ftrackids:\n            return True\n\n        # Check if auto sync was turned on/off\n        updated = entities_by_action[\"update\"]\n        for ftrack_id, ent_info in updated.items():\n            # filter project\n            if ent_info[\"entityType\"] != \"show\":\n                continue\n\n            changes = ent_info[\"changes\"]\n            if CUST_ATTR_AUTO_SYNC not in changes:\n                continue\n\n            auto_sync = changes[CUST_ATTR_AUTO_SYNC][\"new\"]\n            turned_on = auto_sync == \"1\"\n            ft_project = self.cur_project\n            username = self._get_username(session, event)\n            message = (\n                \"Auto sync was turned {} for project \\\"{}\\\" by \\\"{}\\\".\"\n            ).format(\n                \"on\" if turned_on else \"off\",\n                ft_project[\"full_name\"],\n                username\n            )\n            if turned_on:\n                message += \" Triggering syncToAvalon action.\"\n            self.log.debug(message)\n\n            if turned_on:\n                # Trigger sync to avalon action if auto sync was turned on\n                selection = [{\n                    \"entityId\": ft_project[\"id\"],\n                    \"entityType\": \"show\"\n                }]\n                self.trigger_action(\n                    action_name=\"sync.to.avalon.server\",\n                    event=event,\n                    selection=selection\n                )\n            # Exit for both cases\n            return True\n\n        # Filter updated data by changed keys\n        updated = self.filter_updated(updated)\n\n        # skip most of events where nothing has changed for avalon\n        if (\n            len(found_actions) == 1\n            and found_actions[0] == \"update\"\n            and not updated\n            and not self.modified_tasks_ftrackids\n        ):\n            return True\n\n        ft_project = self.cur_project\n        # Check if auto-sync custom attribute exists\n        if CUST_ATTR_AUTO_SYNC not in ft_project[\"custom_attributes\"]:\n            # TODO should we sent message to someone?\n            self.log.error((\n                \"Custom attribute \\\"{}\\\" is not created or user \\\"{}\\\" used\"\n                \" for Event server don't have permissions to access it!\"\n            ).format(CUST_ATTR_AUTO_SYNC, self.session.api_user))\n            return True\n\n        # Skip if auto-sync is not set\n        auto_sync = ft_project[\"custom_attributes\"][CUST_ATTR_AUTO_SYNC]\n        if auto_sync is not True:\n            return True\n\n        debug_msg = \"Updated: {}\".format(len(updated))\n        debug_action_map = {\n            \"add\": \"Created\",\n            \"remove\": \"Removed\",\n            \"move\": \"Moved\"\n        }\n        for action, infos in entities_by_action.items():\n            if action == \"update\":\n                continue\n            _action = debug_action_map[action]\n            debug_msg += \"| {}: {}\".format(_action, len(infos))\n\n        self.log.debug(\"Project changes &lt;{}&gt;: {}\".format(\n            ft_project[\"full_name\"], debug_msg\n        ))\n        # Get ftrack entities - find all ftrack ids first\n        ftrack_ids = set(updated.keys())\n\n        for action, _ftrack_ids in entities_by_action.items():\n            # skip updated (already prepared) and removed (not exist in ftrack)\n            if action not in (\"remove\", \"update\"):\n                ftrack_ids |= set(_ftrack_ids)\n\n        # collect entity records data which might not be in event\n        if ftrack_ids:\n            joined_ids = \", \".join([\"\\\"{}\\\"\".format(id) for id in ftrack_ids])\n            ftrack_entities = self.process_session.query(\n                self.entities_query_by_id.format(ft_project[\"id\"], joined_ids)\n            ).all()\n            for entity in ftrack_entities:\n                self.ftrack_ents_by_id[entity[\"id\"]] = entity\n\n        # Filter updates where name is changing\n        for ftrack_id, ent_info in updated.items():\n            ent_keys = ent_info[\"keys\"]\n            # Seprate update info from rename\n            if \"name\" not in ent_keys:\n                continue\n\n            _ent_info = copy.deepcopy(ent_info)\n            for ent_key in ent_keys:\n                if ent_key == \"name\":\n                    ent_info[\"changes\"].pop(ent_key, None)\n                    ent_info[\"keys\"].remove(ent_key)\n                else:\n                    _ent_info[\"changes\"].pop(ent_key, None)\n                    _ent_info[\"keys\"].remove(ent_key)\n\n            self.ftrack_renamed[ftrack_id] = _ent_info\n\n        self.ftrack_removed = entities_by_action[\"remove\"]\n        self.ftrack_moved = entities_by_action[\"move\"]\n        self.ftrack_added = entities_by_action[\"add\"]\n        self.ftrack_updated = updated\n\n        self.debug_logs()\n\n        self.log.debug(\"Synchronization begins\")\n        try:\n            time_1 = time.time()\n            # 1.) Process removed - may affect all other actions\n            self.process_removed()\n            time_2 = time.time()\n            # 2.) Process renamed - may affect added\n            self.process_renamed()\n            time_3 = time.time()\n            # 3.) Process added - moved entity may be moved to new entity\n            self.process_added()\n            time_4 = time.time()\n            # 4.) Process moved\n            self.process_moved()\n            time_5 = time.time()\n            # 5.) Process updated\n            self.process_updated()\n            time_6 = time.time()\n            # 6.) Process changes in hierarchy or hier custom attribues\n            self.process_hier_cleanup()\n            time_7 = time.time()\n            self.process_task_updates()\n            if self.updates:\n                self.update_entities()\n            time_8 = time.time()\n\n            time_removed = time_2 - time_1\n            time_renamed = time_3 - time_2\n            time_added = time_4 - time_3\n            time_moved = time_5 - time_4\n            time_updated = time_6 - time_5\n            time_cleanup = time_7 - time_6\n            time_task_updates = time_8 - time_7\n            time_total = time_8 - time_1\n            self.log.debug((\n                \"Process time: {:.2f} &lt;{:.2f}, {:.2f}, {:.2f}, \"\n                \"{:.2f}, {:.2f}, {:.2f}, {:.2f}&gt;\"\n            ).format(\n                time_total, time_removed, time_renamed, time_added,\n                time_moved, time_updated, time_cleanup, time_task_updates\n            ))\n\n        except Exception:\n            msg = \"An error has happened during synchronization\"\n            self.report_items[\"error\"][msg].append((\n                str(traceback.format_exc()).replace(\"\\n\", \"&lt;br&gt;\")\n            ).replace(\" \", \"&amp;nbsp;\"))\n\n        self.report()\n        return True\n\n    def _get_username(self, session, event):\n        username = \"Unknown\"\n        event_source = event.get(\"source\")\n        if not event_source:\n            return username\n        user_info = event_source.get(\"user\")\n        if not user_info:\n            return username\n        user_id = user_info.get(\"id\")\n        if not user_id:\n            return username\n\n        user_entity = session.query(\n            \"User where id is {}\".format(user_id)\n        ).first()\n        if user_entity:\n            username = user_entity[\"username\"] or username\n        return username\n\n    def process_removed(self):\n        \"\"\"\n            Handles removed entities (not removed tasks - handle separately).\n        \"\"\"\n        if not self.ftrack_removed:\n            return\n        ent_infos = self.ftrack_removed\n        self.log.debug(\n            \"Processing removed entities: {}\".format(str(ent_infos))\n        )\n        removable_ids = []\n        recreate_ents = []\n        removed_names = []\n        for ftrack_id, removed in ent_infos.items():\n            entity_type = removed[\"entity_type\"]\n            if entity_type.lower() == \"task\":\n                continue\n\n            removed_name = removed[\"changes\"][\"name\"][\"old\"]\n\n            avalon_ent = self.avalon_ents_by_ftrack_id.get(ftrack_id)\n            if not avalon_ent:\n                continue\n            mongo_id = avalon_ent[\"_id\"]\n            if self.changeability_by_mongo_id[mongo_id]:\n                removable_ids.append(mongo_id)\n                removed_names.append(removed_name)\n            else:\n                recreate_ents.append(avalon_ent)\n\n        if removable_ids:\n            # TODO logging\n            self.log.debug(\"Assets marked as archived &lt;{}&gt;\".format(\n                \", \".join(removed_names)\n            ))\n            self.dbcon.update_many(\n                {\"_id\": {\"$in\": removable_ids}, \"type\": \"asset\"},\n                {\"$set\": {\"type\": \"archived_asset\"}}\n            )\n            self.remove_cached_by_key(\"id\", removable_ids)\n\n        if recreate_ents:\n            # sort removed entities by parents len\n            # - length of parents determine hierarchy level\n            recreate_ents = sorted(\n                recreate_ents,\n                key=(lambda item: len(\n                    (item.get(\"data\", {}).get(\"parents\") or [])\n                ))\n            )\n            # TODO logging\n            # TODO report\n            recreate_msg = (\n                \"Deleted entity was recreated||Entity was recreated because\"\n                \" it or its children contain published data\"\n            )\n            proj, ents = self.avalon_entities\n            for avalon_entity in recreate_ents:\n                old_ftrack_id = avalon_entity[\"data\"][\"ftrackId\"]\n                vis_par = avalon_entity[\"data\"][\"visualParent\"]\n                if vis_par is None:\n                    vis_par = proj[\"_id\"]\n                parent_ent = self.avalon_ents_by_id[vis_par]\n\n                parent_ftrack_id = parent_ent[\"data\"].get(\"ftrackId\")\n                if parent_ftrack_id is None:\n                    self.handle_missing_ftrack_id(parent_ent)\n                    parent_ftrack_id = parent_ent[\"data\"].get(\"ftrackId\")\n                    if parent_ftrack_id is None:\n                        continue\n\n                parent_ftrack_ent = self.ftrack_ents_by_id.get(\n                    parent_ftrack_id\n                )\n                if not parent_ftrack_ent:\n                    if parent_ent[\"type\"].lower() == \"project\":\n                        parent_ftrack_ent = self.cur_project\n                    else:\n                        parent_ftrack_ent = self.process_session.query(\n                            self.entities_query_by_id.format(\n                                self.cur_project[\"id\"], parent_ftrack_id\n                            )\n                        ).one()\n                entity_type = avalon_entity[\"data\"][\"entityType\"]\n                new_entity = self.process_session.create(entity_type, {\n                    \"name\": avalon_entity[\"name\"],\n                    \"parent\": parent_ftrack_ent\n                })\n                try:\n                    self.process_session.commit()\n                except Exception:\n                    # TODO logging\n                    # TODO report\n                    self.process_session.rolback()\n                    ent_path_items = [self.cur_project[\"full_name\"]]\n                    ent_path_items.extend([\n                        par for par in avalon_entity[\"data\"][\"parents\"]\n                    ])\n                    ent_path_items.append(avalon_entity[\"name\"])\n                    ent_path = \"/\".join(ent_path_items)\n\n                    error_msg = \"Couldn't recreate entity in ftrack\"\n                    report_msg = (\n                        \"{}||Trying to recreate because it or its children\"\n                        \" contain published data\"\n                    ).format(error_msg)\n                    self.report_items[\"warning\"][report_msg].append(ent_path)\n                    self.log.warning(\n                        \"{}. Process session commit failed! &lt;{}&gt;\".format(\n                            error_msg, ent_path\n                        ),\n                        exc_info=True\n                    )\n                    continue\n\n                new_entity_id = new_entity[\"id\"]\n                avalon_entity[\"data\"][\"ftrackId\"] = new_entity_id\n\n                for key, val in avalon_entity[\"data\"].items():\n                    if not val:\n                        continue\n                    if key not in new_entity[\"custom_attributes\"]:\n                        continue\n\n                    new_entity[\"custom_attributes\"][key] = val\n\n                new_entity[\"custom_attributes\"][CUST_ATTR_KEY_SERVER_ID] = (\n                    str(avalon_entity[\"_id\"])\n                )\n                ent_path = self.get_ent_path(new_entity_id)\n\n                try:\n                    self.process_session.commit()\n                except Exception:\n                    # TODO logging\n                    # TODO report\n                    self.process_session.rolback()\n                    error_msg = (\n                        \"Couldn't update custom attributes after recreation\"\n                        \" of entity in ftrack\"\n                    )\n                    report_msg = (\n                        \"{}||Entity was recreated because it or its children\"\n                        \" contain published data\"\n                    ).format(error_msg)\n                    self.report_items[\"warning\"][report_msg].append(ent_path)\n                    self.log.warning(\n                        \"{}. Process session commit failed! &lt;{}&gt;\".format(\n                            error_msg, ent_path\n                        ),\n                        exc_info=True\n                    )\n                    continue\n\n                self.report_items[\"info\"][recreate_msg].append(ent_path)\n\n                self.ftrack_recreated_mapping[old_ftrack_id] = new_entity_id\n                self.process_session.commit()\n\n                found_idx = None\n                proj_doc, asset_docs = self._avalon_ents\n                for idx, asset_doc in enumerate(asset_docs):\n                    if asset_doc[\"_id\"] == avalon_entity[\"_id\"]:\n                        found_idx = idx\n                        break\n\n                if found_idx is None:\n                    continue\n\n                # Prepare updates dict for mongo update\n                if \"data\" not in self.updates[avalon_entity[\"_id\"]]:\n                    self.updates[avalon_entity[\"_id\"]][\"data\"] = {}\n\n                self.updates[avalon_entity[\"_id\"]][\"data\"][\"ftrackId\"] = (\n                    new_entity_id\n                )\n                # Update cached entities\n                asset_docs[found_idx] = avalon_entity\n                self._avalon_ents = proj_doc, asset_docs\n\n                if self._avalon_ents_by_id is not None:\n                    mongo_id = avalon_entity[\"_id\"]\n                    self._avalon_ents_by_id[mongo_id] = avalon_entity\n\n                if self._avalon_ents_by_parent_id is not None:\n                    vis_par = avalon_entity[\"data\"][\"visualParent\"]\n                    children = self._avalon_ents_by_parent_id[vis_par]\n                    found_idx = None\n                    for idx, _entity in enumerate(children):\n                        if _entity[\"_id\"] == avalon_entity[\"_id\"]:\n                            found_idx = idx\n                            break\n                    children[found_idx] = avalon_entity\n                    self._avalon_ents_by_parent_id[vis_par] = children\n\n                if self._avalon_ents_by_ftrack_id is not None:\n                    self._avalon_ents_by_ftrack_id.pop(old_ftrack_id)\n                    self._avalon_ents_by_ftrack_id[new_entity_id] = (\n                        avalon_entity\n                    )\n\n                if self._avalon_ents_by_name is not None:\n                    name = avalon_entity[\"name\"]\n                    self._avalon_ents_by_name[name] = avalon_entity\n\n        # Check if entities with same name can be synchronized\n        if not removed_names:\n            return\n\n        self.check_names_synchronizable(removed_names)\n\n    def check_names_synchronizable(self, names):\n        \"\"\"Check if entities with specific names are importable.\n\n        This check should happend after removing entity or renaming entity.\n        When entity was removed or renamed then it's name is possible to sync.\n        \"\"\"\n        joined_passed_names = \", \".join(\n            [\"\\\"{}\\\"\".format(name) for name in names]\n        )\n        same_name_entities = self.process_session.query(\n            self.entities_name_query_by_name.format(\n                self.cur_project[\"id\"], joined_passed_names\n            )\n        ).all()\n        if not same_name_entities:\n            return\n\n        entities_by_name = collections.defaultdict(list)\n        for entity in same_name_entities:\n            entities_by_name[entity[\"name\"]].append(entity)\n\n        synchronizable_ents = []\n        self.log.debug((\n            \"Deleting of entities should allow to synchronize another entities\"\n            \" with same name.\"\n        ))\n        for name, ents in entities_by_name.items():\n            if len(ents) != 1:\n                self.log.debug((\n                    \"Name \\\"{}\\\" still have more than one entity &lt;{}&gt;\"\n                ).format(\n                    name, \"| \".join(\n                        [self.get_ent_path(ent[\"id\"]) for ent in ents]\n                    )\n                ))\n                continue\n\n            entity = ents[0]\n            ent_path = self.get_ent_path(entity[\"id\"])\n            # TODO logging\n            self.log.debug(\n                \"Checking if can synchronize entity &lt;{}&gt;\".format(ent_path)\n            )\n            # skip if already synchronized\n            ftrack_id = entity[\"id\"]\n            if ftrack_id in self.avalon_ents_by_ftrack_id:\n                # TODO logging\n                self.log.debug(\n                    \"- Entity is already synchronized (skipping) &lt;{}&gt;\".format(\n                        ent_path\n                    )\n                )\n                continue\n\n            parent_id = entity[\"parent_id\"]\n            if parent_id not in self.avalon_ents_by_ftrack_id:\n                # TODO logging\n                self.log.debug((\n                    \"- Entity's parent entity doesn't seems to\"\n                    \" be synchronized (skipping) &lt;{}&gt;\"\n                ).format(ent_path))\n                continue\n\n            synchronizable_ents.append(entity)\n\n        if not synchronizable_ents:\n            return\n\n        synchronizable_ents = sorted(\n            synchronizable_ents,\n            key=(lambda entity: len(entity[\"link\"]))\n        )\n\n        children_queue = collections.deque()\n        for entity in synchronizable_ents:\n            parent_avalon_ent = self.avalon_ents_by_ftrack_id[\n                entity[\"parent_id\"]\n            ]\n            self.create_entity_in_avalon(entity, parent_avalon_ent)\n\n            for child in entity[\"children\"]:\n                if child.entity_type.lower() != \"task\":\n                    children_queue.append(child)\n\n        while children_queue:\n            entity = children_queue.popleft()\n            ftrack_id = entity[\"id\"]\n            name = entity[\"name\"]\n            ent_by_ftrack_id = self.avalon_ents_by_ftrack_id.get(ftrack_id)\n            if ent_by_ftrack_id:\n                raise Exception((\n                    \"This is bug, parent was just synchronized to avalon\"\n                    \" but entity is already in database {}\"\n                ).format(dict(entity)))\n\n            # Entity has duplicated name with another entity\n            # - may be renamed: in that case renaming method will handle that\n            duplicate_ent = self.avalon_ents_by_name.get(name)\n            if duplicate_ent:\n                continue\n\n            passed_regex = avalon_sync.check_regex(\n                name, \"asset\", schema_patterns=self.regex_schemas\n            )\n            if not passed_regex:\n                continue\n\n            parent_id = entity[\"parent_id\"]\n            parent_avalon_ent = self.avalon_ents_by_ftrack_id[parent_id]\n\n            self.create_entity_in_avalon(entity, parent_avalon_ent)\n\n            for child in entity[\"children\"]:\n                if child.entity_type.lower() == \"task\":\n                    continue\n                children_queue.append(child)\n\n    def create_entity_in_avalon(self, ftrack_ent, parent_avalon):\n        proj, ents = self.avalon_entities\n\n        # Parents, Hierarchy\n        ent_path_items = [ent[\"name\"] for ent in ftrack_ent[\"link\"]]\n        parents = ent_path_items[1:len(ent_path_items) - 1:]\n\n        # TODO logging\n        self.log.debug(\n            \"Trying to synchronize entity &lt;{}&gt;\".format(\n                \"/\".join(ent_path_items)\n            )\n        )\n\n        # Add entity to modified so tasks are added at the end\n        self.modified_tasks_ftrackids.add(ftrack_ent[\"id\"])\n\n        # Visual Parent\n        vis_par = None\n        if parent_avalon[\"type\"].lower() != \"project\":\n            vis_par = parent_avalon[\"_id\"]\n\n        mongo_id = ObjectId()\n        name = ftrack_ent[\"name\"]\n        final_entity = {\n            \"_id\": mongo_id,\n            \"name\": name,\n            \"type\": \"asset\",\n            \"schema\": CURRENT_ASSET_DOC_SCHEMA,\n            \"parent\": proj[\"_id\"],\n            \"data\": {\n                \"ftrackId\": ftrack_ent[\"id\"],\n                \"entityType\": ftrack_ent.entity_type,\n                \"parents\": parents,\n                \"tasks\": {},\n                \"visualParent\": vis_par,\n                \"description\": ftrack_ent[\"description\"]\n            }\n        }\n        invalid_fps_items = []\n        cust_attrs = self.get_cust_attr_values(ftrack_ent)\n        for key, val in cust_attrs.items():\n            if key.startswith(\"avalon_\"):\n                continue\n\n            if key in FPS_KEYS:\n                try:\n                    val = convert_to_fps(val)\n                except InvalidFpsValue:\n                    invalid_fps_items.append((ftrack_ent[\"id\"], val))\n                    continue\n\n            final_entity[\"data\"][key] = val\n\n        if invalid_fps_items:\n            fps_msg = (\n                \"These entities have invalid fps value in custom attributes\"\n            )\n            items = []\n            for entity_id, value in invalid_fps_items:\n                ent_path = self.get_ent_path(entity_id)\n                items.append(\"{} - \\\"{}\\\"\".format(ent_path, value))\n            self.report_items[\"error\"][fps_msg] = items\n\n        _mongo_id_str = cust_attrs.get(CUST_ATTR_KEY_SERVER_ID)\n        if _mongo_id_str:\n            try:\n                _mongo_id = ObjectId(_mongo_id_str)\n                if _mongo_id not in self.avalon_ents_by_id:\n                    mongo_id = _mongo_id\n                    final_entity[\"_id\"] = mongo_id\n\n            except Exception:\n                pass\n\n        ent_path_items = [self.cur_project[\"full_name\"]]\n        ent_path_items.extend([par for par in parents])\n        ent_path_items.append(name)\n        ent_path = \"/\".join(ent_path_items)\n\n        try:\n            schema.validate(final_entity)\n        except Exception:\n            # TODO logging\n            # TODO report\n            error_msg = (\n                \"Schema validation failed for new entity (This is a bug)\"\n            )\n            error_traceback = (\n                str(traceback.format_exc()).replace(\"\\n\", \"&lt;br&gt;\")\n            ).replace(\" \", \"&amp;nbsp;\")\n\n            item_msg = ent_path + \"&lt;br&gt;\" + error_traceback\n            self.report_items[\"error\"][error_msg].append(item_msg)\n            self.log.error(\n                \"{}: \\\"{}\\\"\".format(error_msg, str(final_entity)),\n                exc_info=True\n            )\n            return None\n\n        replaced = False\n        archived = self.avalon_archived_by_name.get(name)\n        if archived:\n            archived_id = archived[\"_id\"]\n            if (\n                archived[\"data\"][\"parents\"] == parents or\n                self.changeability_by_mongo_id[archived_id]\n            ):\n                # TODO logging\n                self.log.debug(\n                    \"Entity was unarchived instead of creation &lt;{}&gt;\".format(\n                        ent_path\n                    )\n                )\n                mongo_id = archived_id\n                final_entity[\"_id\"] = mongo_id\n                self.dbcon.replace_one({\"_id\": mongo_id}, final_entity)\n                replaced = True\n\n        if not replaced:\n            self.dbcon.insert_one(final_entity)\n            # TODO logging\n            self.log.debug(\"Entity was synchronized &lt;{}&gt;\".format(ent_path))\n\n        mongo_id_str = str(mongo_id)\n        if mongo_id_str != (\n            ftrack_ent[\"custom_attributes\"][CUST_ATTR_KEY_SERVER_ID]\n        ):\n            (\n                ftrack_ent[\"custom_attributes\"][CUST_ATTR_KEY_SERVER_ID]\n            ) = mongo_id_str\n            try:\n                self.process_session.commit()\n            except Exception:\n                self.process_session.rolback()\n                # TODO logging\n                # TODO report\n                error_msg = (\n                    \"Failed to store MongoID to entity's custom attribute\"\n                )\n                report_msg = (\n                    \"{}||SyncToAvalon action may solve this issue\"\n                ).format(error_msg)\n\n                self.report_items[\"warning\"][report_msg].append(ent_path)\n                self.log.error(\n                    \"{}: \\\"{}\\\"\".format(error_msg, ent_path),\n                    exc_info=True\n                )\n\n        # modify cached data\n        # Skip if self._avalon_ents is not set(maybe never happen)\n        if self._avalon_ents is None:\n            return final_entity\n\n        if self._avalon_ents is not None:\n            proj, ents = self._avalon_ents\n            ents.append(final_entity)\n            self._avalon_ents = (proj, ents)\n\n        if self._avalon_ents_by_id is not None:\n            self._avalon_ents_by_id[mongo_id] = final_entity\n\n        if self._avalon_ents_by_parent_id is not None:\n            self._avalon_ents_by_parent_id[vis_par].append(final_entity)\n\n        if self._avalon_ents_by_ftrack_id is not None:\n            self._avalon_ents_by_ftrack_id[ftrack_ent[\"id\"]] = final_entity\n\n        if self._avalon_ents_by_name is not None:\n            self._avalon_ents_by_name[ftrack_ent[\"name\"]] = final_entity\n\n        return final_entity\n\n    def get_cust_attr_values(self, entity):\n        output = {}\n        custom_attrs, hier_attrs = self.avalon_cust_attrs\n\n        # Notmal custom attributes\n        for attr in custom_attrs:\n            key = attr[\"key\"]\n            if key in entity[\"custom_attributes\"]:\n                output[key] = entity[\"custom_attributes\"][key]\n\n        hier_values = avalon_sync.get_hierarchical_attributes_values(\n            self.process_session,\n            entity,\n            hier_attrs,\n            self.cust_attr_types_by_id.values()\n        )\n        for key, val in hier_values.items():\n            output[key] = val\n\n        # Make sure mongo id is not set\n        output.pop(CUST_ATTR_KEY_SERVER_ID, None)\n\n        return output\n\n    def process_renamed(self):\n        ent_infos = self.ftrack_renamed\n        if not ent_infos:\n            return\n\n        self.log.debug(\n            \"Processing renamed entities: {}\".format(str(ent_infos))\n        )\n\n        changeable_queue = collections.deque()\n        for ftrack_id, ent_info in ent_infos.items():\n            entity_type = ent_info[\"entity_type\"]\n            if entity_type == \"Task\":\n                continue\n\n            new_name = ent_info[\"changes\"][\"name\"][\"new\"]\n            old_name = ent_info[\"changes\"][\"name\"][\"old\"]\n\n            ent_path = self.get_ent_path(ftrack_id)\n            avalon_ent = self.avalon_ents_by_ftrack_id.get(ftrack_id)\n            if not avalon_ent:\n                # TODO logging\n                self.log.debug((\n                    \"Entity is not is avalon. Moving to \\\"add\\\" process. &lt;{}&gt;\"\n                ).format(ent_path))\n                self.ftrack_added[ftrack_id] = ent_info\n                continue\n\n            if new_name == avalon_ent[\"name\"]:\n                # TODO logging\n                self.log.debug((\n                    \"Avalon entity already has the same name &lt;{}&gt;\"\n                ).format(ent_path))\n                continue\n\n            mongo_id = avalon_ent[\"_id\"]\n            if self.changeability_by_mongo_id[mongo_id]:\n                changeable_queue.append((ftrack_id, avalon_ent, new_name))\n            else:\n                ftrack_ent = self.ftrack_ents_by_id[ftrack_id]\n                ftrack_ent[\"name\"] = avalon_ent[\"name\"]\n                try:\n                    self.process_session.commit()\n                    # TODO logging\n                    # TODO report\n                    error_msg = \"Entity renamed back\"\n                    report_msg = (\n                        \"{}||It is not possible to change\"\n                        \" the name of an entity or it's parents, \"\n                        \" if it already contained published data.\"\n                    ).format(error_msg)\n                    self.report_items[\"info\"][report_msg].append(ent_path)\n                    self.log.warning(\"{} &lt;{}&gt;\".format(error_msg, ent_path))\n\n                except Exception:\n                    self.process_session.rollback()\n                    # TODO report\n                    # TODO logging\n                    error_msg = (\n                        \"Couldn't rename the entity back to its original name\"\n                    )\n                    report_msg = (\n                        \"{}||Renamed because it is not possible to\"\n                        \" change the name of an entity or it's parents, \"\n                        \" if it already contained published data.\"\n                    ).format(error_msg)\n                    error_traceback = (\n                        str(traceback.format_exc()).replace(\"\\n\", \"&lt;br&gt;\")\n                    ).replace(\" \", \"&amp;nbsp;\")\n\n                    item_msg = ent_path + \"&lt;br&gt;\" + error_traceback\n                    self.report_items[\"warning\"][report_msg].append(item_msg)\n                    self.log.warning(\n                        \"{}: \\\"{}\\\"\".format(error_msg, ent_path),\n                        exc_info=True\n                    )\n\n        old_names = []\n        # Process renaming in Avalon DB\n        while changeable_queue:\n            ftrack_id, avalon_ent, new_name = changeable_queue.popleft()\n            mongo_id = avalon_ent[\"_id\"]\n            old_name = avalon_ent[\"name\"]\n\n            _entity_type = \"asset\"\n            if entity_type == \"Project\":\n                _entity_type = \"project\"\n\n            passed_regex = avalon_sync.check_regex(\n                new_name, _entity_type, schema_patterns=self.regex_schemas\n            )\n            if not passed_regex:\n                self.regex_failed.append(ftrack_id)\n                continue\n\n            # if avalon does not have same name then can be changed\n            same_name_avalon_ent = self.avalon_ents_by_name.get(new_name)\n            if not same_name_avalon_ent:\n                old_val = self._avalon_ents_by_name.pop(old_name)\n                old_val[\"name\"] = new_name\n                self._avalon_ents_by_name[new_name] = old_val\n                self.updates[mongo_id] = {\"name\": new_name}\n                self.renamed_in_avalon.append(mongo_id)\n\n                old_names.append(old_name)\n                if new_name in old_names:\n                    old_names.remove(new_name)\n\n                # TODO logging\n                ent_path = self.get_ent_path(ftrack_id)\n                self.log.debug(\n                    \"Name of entity will be changed to \\\"{}\\\" &lt;{}&gt;\".format(\n                        new_name, ent_path\n                    )\n                )\n                continue\n\n            # Check if same name is in changable_queue\n            # - it's name may be changed in next iteration\n            same_name_ftrack_id = same_name_avalon_ent[\"data\"][\"ftrackId\"]\n            same_is_unprocessed = False\n            for item in changeable_queue:\n                if same_name_ftrack_id == item[0]:\n                    same_is_unprocessed = True\n                    break\n\n            if same_is_unprocessed:\n                changeable_queue.append((ftrack_id, avalon_ent, new_name))\n                continue\n\n            self.duplicated.append(ftrack_id)\n\n        if old_names:\n            self.check_names_synchronizable(old_names)\n\n        # not_found are not processed since all not found are\n        # not found because they are not synchronizable\n\n    def process_added(self):\n        ent_infos = self.ftrack_added\n        if not ent_infos:\n            return\n\n        self.log.debug(\n            \"Processing added entities: {}\".format(str(ent_infos))\n        )\n\n        cust_attrs, hier_attrs = self.avalon_cust_attrs\n        entity_type_conf_ids = {}\n        # Skip if already exit in avalon db or tasks entities\n        # - happen when was created by any sync event/action\n        pop_out_ents = []\n        for ftrack_id, ent_info in ent_infos.items():\n            if self.avalon_ents_by_ftrack_id.get(ftrack_id):\n                pop_out_ents.append(ftrack_id)\n                self.log.warning(\n                    \"Added entity is already synchronized &lt;{}&gt;\".format(\n                        self.get_ent_path(ftrack_id)\n                    )\n                )\n                continue\n\n            entity_type = ent_info[\"entity_type\"]\n            if entity_type == \"Task\":\n                continue\n\n            name = (\n                ent_info\n                .get(\"changes\", {})\n                .get(\"name\", {})\n                .get(\"new\")\n            )\n            avalon_ent_by_name = self.avalon_ents_by_name.get(name) or {}\n            avalon_ent_by_name_ftrack_id = (\n                avalon_ent_by_name\n                .get(\"data\", {})\n                .get(\"ftrackId\")\n            )\n            if avalon_ent_by_name and avalon_ent_by_name_ftrack_id is None:\n                ftrack_ent = self.ftrack_ents_by_id.get(ftrack_id)\n                if not ftrack_ent:\n                    ftrack_ent = self.process_session.query(\n                        self.entities_query_by_id.format(\n                            self.cur_project[\"id\"], ftrack_id\n                        )\n                    ).one()\n                    self.ftrack_ents_by_id[ftrack_id] = ftrack_ent\n\n                ent_path_items = [ent[\"name\"] for ent in ftrack_ent[\"link\"]]\n                parents = ent_path_items[1:len(ent_path_items) - 1:]\n\n                avalon_ent_parents = (\n                    avalon_ent_by_name.get(\"data\", {}).get(\"parents\")\n                )\n                if parents == avalon_ent_parents:\n                    self.dbcon.update_one({\n                        \"_id\": avalon_ent_by_name[\"_id\"]\n                    }, {\n                        \"$set\": {\n                            \"data.ftrackId\": ftrack_id,\n                            \"data.entityType\": entity_type\n                        }\n                    })\n\n                    avalon_ent_by_name[\"data\"][\"ftrackId\"] = ftrack_id\n                    avalon_ent_by_name[\"data\"][\"entityType\"] = entity_type\n\n                    self._avalon_ents_by_ftrack_id[ftrack_id] = (\n                        avalon_ent_by_name\n                    )\n                    if self._avalon_ents_by_parent_id:\n                        found = None\n                        for _parent_id_, _entities_ in (\n                            self._avalon_ents_by_parent_id.items()\n                        ):\n                            for _idx_, entity in enumerate(_entities_):\n                                if entity[\"_id\"] == avalon_ent_by_name[\"_id\"]:\n                                    found = (_parent_id_, _idx_)\n                                    break\n\n                            if found:\n                                break\n\n                        if found:\n                            _parent_id_, _idx_ = found\n                            self._avalon_ents_by_parent_id[_parent_id_][\n                                _idx_] = avalon_ent_by_name\n\n                    if self._avalon_ents_by_id:\n                        self._avalon_ents_by_id[avalon_ent_by_name[\"_id\"]] = (\n                            avalon_ent_by_name\n                        )\n\n                    if self._avalon_ents_by_name:\n                        self._avalon_ents_by_name[name] = avalon_ent_by_name\n\n                    if self._avalon_ents:\n                        found = None\n                        project, entities = self._avalon_ents\n                        for _idx_, _ent_ in enumerate(entities):\n                            if _ent_[\"_id\"] != avalon_ent_by_name[\"_id\"]:\n                                continue\n                            found = _idx_\n                            break\n\n                        if found is not None:\n                            entities[found] = avalon_ent_by_name\n                            self._avalon_ents = project, entities\n\n                    pop_out_ents.append(ftrack_id)\n                    continue\n\n            mongo_id_configuration_id = self._mongo_id_configuration(\n                ent_info,\n                cust_attrs,\n                hier_attrs,\n                entity_type_conf_ids\n            )\n            if not mongo_id_configuration_id:\n                self.log.warning((\n                    \"BUG REPORT: Missing MongoID configuration for `{} &lt; {} &gt;`\"\n                ).format(entity_type, ent_info[\"entityType\"]))\n                continue\n\n            _entity_key = collections.OrderedDict()\n            _entity_key[\"configuration_id\"] = mongo_id_configuration_id\n            _entity_key[\"entity_id\"] = ftrack_id\n\n            self.process_session.recorded_operations.push(\n                ftrack_api.operation.UpdateEntityOperation(\n                    \"ContextCustomAttributeValue\",\n                    _entity_key,\n                    \"value\",\n                    ftrack_api.symbol.NOT_SET,\n                    \"\"\n                )\n            )\n\n        try:\n            # Commit changes of mongo_id to empty string\n            self.process_session.commit()\n            self.log.debug(\"Committing unsetting\")\n        except Exception:\n            self.process_session.rollback()\n            # TODO logging\n            msg = (\n                \"Could not set value of Custom attribute, where mongo id\"\n                \" is stored, to empty string. ftrack ids: \\\"{}\\\"\"\n            ).format(\", \".join(ent_infos.keys()))\n            self.log.warning(msg, exc_info=True)\n\n        for ftrack_id in pop_out_ents:\n            ent_infos.pop(ftrack_id)\n\n        # sort by parents length (same as by hierarchy level)\n        _ent_infos = sorted(\n            ent_infos.values(),\n            key=(lambda ent_info: len(ent_info.get(\"parents\", [])))\n        )\n        to_sync_by_id = collections.OrderedDict()\n        for ent_info in _ent_infos:\n            ft_id = ent_info[\"entityId\"]\n            to_sync_by_id[ft_id] = self.ftrack_ents_by_id[ft_id]\n\n        # cache regex success (for tasks)\n        for ftrack_id, entity in to_sync_by_id.items():\n            if entity.entity_type.lower() == \"project\":\n                raise Exception((\n                    \"Project can't be created with event handler!\"\n                    \"This is a bug\"\n                ))\n            parent_id = entity[\"parent_id\"]\n            parent_avalon = self.avalon_ents_by_ftrack_id.get(parent_id)\n            if not parent_avalon:\n                # TODO logging\n                self.log.debug((\n                    \"Skipping synchronization of entity\"\n                    \" because parent was not found in Avalon DB &lt;{}&gt;\"\n                ).format(self.get_ent_path(ftrack_id)))\n                continue\n\n            is_synchonizable = True\n            name = entity[\"name\"]\n            passed_regex = avalon_sync.check_regex(\n                name, \"asset\", schema_patterns=self.regex_schemas\n            )\n            if not passed_regex:\n                self.regex_failed.append(ftrack_id)\n                is_synchonizable = False\n\n            if name in self.avalon_ents_by_name:\n                self.duplicated.append(ftrack_id)\n                is_synchonizable = False\n\n            if not is_synchonizable:\n                continue\n\n            self.create_entity_in_avalon(entity, parent_avalon)\n\n    def process_moved(self):\n        \"\"\"\n            Handles moved entities to different place in hiearchy.\n            (Not tasks - handled separately.)\n        \"\"\"\n        if not self.ftrack_moved:\n            return\n\n        self.log.debug(\n            \"Processing moved entities: {}\".format(str(self.ftrack_moved))\n        )\n\n        ftrack_moved = {k: v for k, v in sorted(\n            self.ftrack_moved.items(),\n            key=(lambda line: len(\n                (line[1].get(\"data\", {}).get(\"parents\") or [])\n            ))\n        )}\n\n        for ftrack_id, ent_info in ftrack_moved.items():\n            avalon_ent = self.avalon_ents_by_ftrack_id.get(ftrack_id)\n            if not avalon_ent:\n                continue\n\n            new_parent_id = ent_info[\"changes\"][\"parent_id\"][\"new\"]\n\n            mongo_id = avalon_ent[\"_id\"]\n            if self.changeability_by_mongo_id[mongo_id]:\n                par_av_ent = self.avalon_ents_by_ftrack_id.get(new_parent_id)\n                if not par_av_ent:\n                    # TODO logging\n                    # TODO report\n                    ent_path_items = [self.cur_project[\"full_name\"]]\n                    ent_path_items.extend(avalon_ent[\"data\"][\"parents\"])\n                    ent_path_items.append(avalon_ent[\"name\"])\n                    ent_path = \"/\".join(ent_path_items)\n\n                    error_msg = (\n                        \"New parent of entity is not synchronized to avalon\"\n                    )\n                    report_msg = (\n                        \"{}||Parent in Avalon can't be changed. That\"\n                        \" may cause issues. Please fix parent or move entity\"\n                        \" under valid entity.\"\n                    ).format(error_msg)\n\n                    self.report_items[\"warning\"][report_msg].append(ent_path)\n                    self.log.warning(\"{} &lt;{}&gt;\".format(error_msg, ent_path))\n                    continue\n\n                # THIS MUST HAPPEND AFTER CREATING NEW ENTITIES !!!!\n                # - because may be moved to new created entity\n                if \"data\" not in self.updates[mongo_id]:\n                    self.updates[mongo_id][\"data\"] = {}\n\n                vis_par_id = None\n                ent_path_items = [self.cur_project[\"full_name\"]]\n                if par_av_ent[\"type\"].lower() != \"project\":\n                    vis_par_id = par_av_ent[\"_id\"]\n                    ent_path_items.extend(par_av_ent[\"data\"][\"parents\"])\n                    ent_path_items.append(par_av_ent[\"name\"])\n\n                self.updates[mongo_id][\"data\"][\"visualParent\"] = vis_par_id\n                self.moved_in_avalon.append(mongo_id)\n\n                ent_path_items.append(avalon_ent[\"name\"])\n                ent_path = \"/\".join(ent_path_items)\n                self.log.debug((\n                    \"Parent of entity ({}) was changed in avalon &lt;{}&gt;\"\n                    ).format(str(mongo_id), ent_path)\n                )\n\n            else:\n                avalon_ent = self.avalon_ents_by_id[mongo_id]\n                avalon_parent_id = avalon_ent[\"data\"][\"visualParent\"]\n                if avalon_parent_id is None:\n                    avalon_parent_id = avalon_ent[\"parent\"]\n\n                avalon_parent = self.avalon_ents_by_id[avalon_parent_id]\n                parent_id = avalon_parent[\"data\"][\"ftrackId\"]\n\n                # For cases when parent was deleted at the same time\n                if parent_id in self.ftrack_recreated_mapping:\n                    parent_id = (\n                        self.ftrack_recreated_mapping[parent_id]\n                    )\n\n                ftrack_ent = self.ftrack_ents_by_id.get(ftrack_id)\n                if not ftrack_ent:\n                    ftrack_ent = self.process_session.query(\n                        self.entities_query_by_id.format(\n                            self.cur_project[\"id\"], ftrack_id\n                        )\n                    ).one()\n                    self.ftrack_ents_by_id[ftrack_id] = ftrack_ent\n\n                if parent_id == ftrack_ent[\"parent_id\"]:\n                    continue\n\n                ftrack_ent[\"parent_id\"] = parent_id\n                try:\n                    self.process_session.commit()\n                    # TODO logging\n                    # TODO report\n                    msg = \"Entity was moved back\"\n                    report_msg = (\n                        \"{}||Entity can't be moved when\"\n                        \" it or its children contain published data\"\n                    ).format(msg)\n                    ent_path = self.get_ent_path(ftrack_id)\n                    self.report_items[\"info\"][report_msg].append(ent_path)\n                    self.log.warning(\"{} &lt;{}&gt;\".format(msg, ent_path))\n\n                except Exception:\n                    self.process_session.rollback()\n                    # TODO logging\n                    # TODO report\n                    error_msg = (\n                        \"Couldn't moved the entity back to its original parent\"\n                    )\n                    report_msg = (\n                        \"{}||Moved back because it is not possible to\"\n                        \" move with an entity or it's parents, \"\n                        \" if it already contained published data.\"\n                    ).format(error_msg)\n                    error_traceback = (\n                        str(traceback.format_exc()).replace(\"\\n\", \"&lt;br&gt;\")\n                    ).replace(\" \", \"&amp;nbsp;\")\n\n                    item_msg = ent_path + \"&lt;br&gt;\" + error_traceback\n                    self.report_items[\"warning\"][report_msg].append(item_msg)\n                    self.log.warning(\n                        \"{}: \\\"{}\\\"\".format(error_msg, ent_path),\n                        exc_info=True\n                    )\n\n    def process_updated(self):\n        \"\"\"\n            Only custom attributes changes should get here\n        \"\"\"\n        if not self.ftrack_updated:\n            return\n\n        self.log.debug(\n            \"Processing updated entities: {}\".format(str(self.ftrack_updated))\n        )\n\n        ent_infos = self.ftrack_updated\n        ftrack_mongo_mapping = {}\n        not_found_ids = []\n        for ftrack_id, ent_info in ent_infos.items():\n            avalon_ent = self.avalon_ents_by_ftrack_id.get(ftrack_id)\n            if not avalon_ent:\n                not_found_ids.append(ftrack_id)\n                continue\n\n            ftrack_mongo_mapping[ftrack_id] = avalon_ent[\"_id\"]\n\n        for ftrack_id in not_found_ids:\n            ent_infos.pop(ftrack_id)\n\n        if not ent_infos:\n            return\n\n        cust_attrs, hier_attrs = self.avalon_cust_attrs\n        hier_attrs_by_key = {\n            attr[\"key\"]: attr\n            for attr in hier_attrs\n        }\n        cust_attrs_by_obj_id = collections.defaultdict(dict)\n        for cust_attr in cust_attrs:\n            key = cust_attr[\"key\"]\n            if key.startswith(\"avalon_\"):\n                continue\n\n            ca_ent_type = cust_attr[\"entity_type\"]\n\n            if ca_ent_type == \"show\":\n                cust_attrs_by_obj_id[ca_ent_type][key] = cust_attr\n\n            elif ca_ent_type == \"task\":\n                obj_id = cust_attr[\"object_type_id\"]\n                cust_attrs_by_obj_id[obj_id][key] = cust_attr\n\n        for ftrack_id, ent_info in ent_infos.items():\n            mongo_id = ftrack_mongo_mapping[ftrack_id]\n            entType = ent_info[\"entityType\"]\n            ent_path = self.get_ent_path(ftrack_id)\n            if entType == \"show\":\n                ent_cust_attrs = cust_attrs_by_obj_id.get(\"show\")\n            else:\n                obj_type_id = ent_info[\"objectTypeId\"]\n                ent_cust_attrs = cust_attrs_by_obj_id.get(obj_type_id)\n\n            # ftrack's entity_type does not have defined custom attributes\n            if ent_cust_attrs is None:\n                ent_cust_attrs = {}\n\n            ent_changes = ent_info[\"changes\"]\n            if \"description\" in ent_changes:\n                if \"data\" not in self.updates[mongo_id]:\n                    self.updates[mongo_id][\"data\"] = {}\n                self.updates[mongo_id][\"data\"][\"description\"] = (\n                    ent_changes[\"description\"][\"new\"] or \"\"\n                )\n\n            for key, values in ent_changes.items():\n                if key in hier_attrs_by_key:\n                    self.hier_cust_attrs_changes[key].append(ftrack_id)\n                    continue\n\n                if key not in ent_cust_attrs:\n                    continue\n\n                value = values[\"new\"]\n                new_value = self.convert_value_by_cust_attr_conf(\n                    value, ent_cust_attrs[key]\n                )\n\n                if \"data\" not in self.updates[mongo_id]:\n                    self.updates[mongo_id][\"data\"] = {}\n                self.updates[mongo_id][\"data\"][key] = new_value\n                self.log.debug(\n                    \"Setting data value of \\\"{}\\\" to \\\"{}\\\" &lt;{}&gt;\".format(\n                        key, new_value, ent_path\n                    )\n                )\n\n    def convert_value_by_cust_attr_conf(self, value, cust_attr_conf):\n        type_id = cust_attr_conf[\"type_id\"]\n        cust_attr_type_name = self.cust_attr_types_by_id[type_id][\"name\"]\n        ignored = (\n            \"expression\", \"notificationtype\", \"dynamic enumerator\"\n        )\n        if cust_attr_type_name in ignored:\n            return None\n\n        if cust_attr_type_name == \"text\":\n            return value\n\n        if cust_attr_type_name == \"boolean\":\n            if value == \"1\":\n                return True\n            if value == \"0\":\n                return False\n            return bool(value)\n\n        if cust_attr_type_name == \"date\":\n            return arrow.get(value)\n\n        cust_attr_config = json.loads(cust_attr_conf[\"config\"])\n\n        if cust_attr_type_name == \"number\":\n            if cust_attr_config[\"isdecimal\"]:\n                return float(value)\n            return int(value)\n\n        if cust_attr_type_name == \"enumerator\":\n            if not cust_attr_config[\"multiSelect\"]:\n                return value\n            return value.split(\", \")\n        return value\n\n    def process_hier_cleanup(self):\n        if (\n            not self.moved_in_avalon and\n            not self.renamed_in_avalon and\n            not self.hier_cust_attrs_changes\n        ):\n            return\n\n        parent_changes = []\n        hier_cust_attrs_ids = []\n        hier_cust_attrs_keys = []\n        all_keys = False\n        for mongo_id in self.moved_in_avalon:\n            parent_changes.append(mongo_id)\n            hier_cust_attrs_ids.append(mongo_id)\n            all_keys = True\n\n        for mongo_id in self.renamed_in_avalon:\n            if mongo_id not in parent_changes:\n                parent_changes.append(mongo_id)\n\n        for key, ftrack_ids in self.hier_cust_attrs_changes.items():\n            if key.startswith(\"avalon_\"):\n                continue\n            for ftrack_id in ftrack_ids:\n                avalon_ent = self.avalon_ents_by_ftrack_id[ftrack_id]\n                mongo_id = avalon_ent[\"_id\"]\n                if mongo_id in hier_cust_attrs_ids:\n                    continue\n                hier_cust_attrs_ids.append(mongo_id)\n                if not all_keys and key not in hier_cust_attrs_keys:\n                    hier_cust_attrs_keys.append(key)\n\n        # Parents preparation ***\n        mongo_to_ftrack_parents = {}\n        missing_ftrack_ents = {}\n        for mongo_id in parent_changes:\n            avalon_ent = self.avalon_ents_by_id[mongo_id]\n            ftrack_id = avalon_ent[\"data\"][\"ftrackId\"]\n            if ftrack_id not in self.ftrack_ents_by_id:\n                missing_ftrack_ents[ftrack_id] = mongo_id\n                continue\n            ftrack_ent = self.ftrack_ents_by_id[ftrack_id]\n            mongo_to_ftrack_parents[mongo_id] = len(ftrack_ent[\"link\"])\n\n        if missing_ftrack_ents:\n            joine_ids = \", \".join(\n                [\"\\\"{}\\\"\".format(id) for id in missing_ftrack_ents.keys()]\n            )\n            entities = self.process_session.query(\n                self.entities_query_by_id.format(\n                    self.cur_project[\"id\"], joine_ids\n                )\n            ).all()\n            for entity in entities:\n                ftrack_id = entity[\"id\"]\n                self.ftrack_ents_by_id[ftrack_id] = entity\n                mongo_id = missing_ftrack_ents[ftrack_id]\n                mongo_to_ftrack_parents[mongo_id] = len(entity[\"link\"])\n\n        stored_parents_by_mongo = {}\n        # sort by hierarchy level\n        mongo_to_ftrack_parents = [k for k, v in sorted(\n            mongo_to_ftrack_parents.items(),\n            key=(lambda item: item[1])\n        )]\n        self.log.debug(\n            \"Updating parents and hieararchy because of name/parenting changes\"\n        )\n        for mongo_id in mongo_to_ftrack_parents:\n            avalon_ent = self.avalon_ents_by_id[mongo_id]\n            vis_par = avalon_ent[\"data\"][\"visualParent\"]\n            if vis_par in stored_parents_by_mongo:\n                parents = [par for par in stored_parents_by_mongo[vis_par]]\n                if vis_par is not None:\n                    parent_ent = self.avalon_ents_by_id[vis_par]\n                    parents.append(parent_ent[\"name\"])\n                stored_parents_by_mongo[mongo_id] = parents\n                continue\n\n            ftrack_id = avalon_ent[\"data\"][\"ftrackId\"]\n            ftrack_ent = self.ftrack_ents_by_id[ftrack_id]\n            ent_path_items = [ent[\"name\"] for ent in ftrack_ent[\"link\"]]\n            parents = ent_path_items[1:len(ent_path_items) - 1:]\n            stored_parents_by_mongo[mongo_id] = parents\n\n        for mongo_id, parents in stored_parents_by_mongo.items():\n            avalon_ent = self.avalon_ents_by_id[mongo_id]\n            cur_par = avalon_ent[\"data\"][\"parents\"]\n            if cur_par == parents:\n                continue\n\n            if \"data\" not in self.updates[mongo_id]:\n                self.updates[mongo_id][\"data\"] = {}\n            self.updates[mongo_id][\"data\"][\"parents\"] = parents\n\n        # Skip custom attributes if didn't change\n        if not hier_cust_attrs_ids:\n            # TODO logging\n            self.log.debug(\n                \"Hierarchical attributes were not changed. Skipping\"\n            )\n            self.update_entities()\n            return\n\n        _, hier_attrs = self.avalon_cust_attrs\n\n        # Hierarchical custom attributes preparation ***\n        hier_attr_key_by_id = {\n            attr[\"id\"]: attr[\"key\"]\n            for attr in hier_attrs\n        }\n        hier_attr_id_by_key = {\n            key: attr_id\n            for attr_id, key in hier_attr_key_by_id.items()\n        }\n\n        if all_keys:\n            hier_cust_attrs_keys = [\n                key\n                for key in hier_attr_id_by_key.keys()\n                if not key.startswith(\"avalon_\")\n            ]\n\n        mongo_ftrack_mapping = {}\n        cust_attrs_ftrack_ids = []\n        # ftrack_parenting = collections.defaultdict(list)\n        entities_dict = collections.defaultdict(dict)\n\n        children_queue = collections.deque()\n        parent_queue = collections.deque()\n\n        for mongo_id in hier_cust_attrs_ids:\n            avalon_ent = self.avalon_ents_by_id[mongo_id]\n            parent_queue.append(avalon_ent)\n            ftrack_id = avalon_ent[\"data\"][\"ftrackId\"]\n            if ftrack_id not in entities_dict:\n                entities_dict[ftrack_id] = {\n                    \"children\": [],\n                    \"parent_id\": None,\n                    \"hier_attrs\": {}\n                }\n\n            mongo_ftrack_mapping[mongo_id] = ftrack_id\n            cust_attrs_ftrack_ids.append(ftrack_id)\n            children_ents = self.avalon_ents_by_parent_id.get(mongo_id) or []\n            for children_ent in children_ents:\n                _ftrack_id = children_ent[\"data\"][\"ftrackId\"]\n                if _ftrack_id in entities_dict:\n                    continue\n\n                entities_dict[_ftrack_id] = {\n                    \"children\": [],\n                    \"parent_id\": None,\n                    \"hier_attrs\": {}\n                }\n                # if _ftrack_id not in ftrack_parenting[ftrack_id]:\n                #     ftrack_parenting[ftrack_id].append(_ftrack_id)\n                entities_dict[_ftrack_id][\"parent_id\"] = ftrack_id\n                if _ftrack_id not in entities_dict[ftrack_id][\"children\"]:\n                    entities_dict[ftrack_id][\"children\"].append(_ftrack_id)\n                children_queue.append(children_ent)\n\n        while children_queue:\n            avalon_ent = children_queue.popleft()\n            mongo_id = avalon_ent[\"_id\"]\n            ftrack_id = avalon_ent[\"data\"][\"ftrackId\"]\n            if ftrack_id in cust_attrs_ftrack_ids:\n                continue\n\n            mongo_ftrack_mapping[mongo_id] = ftrack_id\n            cust_attrs_ftrack_ids.append(ftrack_id)\n\n            children_ents = self.avalon_ents_by_parent_id.get(mongo_id) or []\n            for children_ent in children_ents:\n                _ftrack_id = children_ent[\"data\"][\"ftrackId\"]\n                if _ftrack_id in entities_dict:\n                    continue\n\n                entities_dict[_ftrack_id] = {\n                    \"children\": [],\n                    \"parent_id\": None,\n                    \"hier_attrs\": {}\n                }\n                entities_dict[_ftrack_id][\"parent_id\"] = ftrack_id\n                if _ftrack_id not in entities_dict[ftrack_id][\"children\"]:\n                    entities_dict[ftrack_id][\"children\"].append(_ftrack_id)\n                children_queue.append(children_ent)\n\n        while parent_queue:\n            avalon_ent = parent_queue.popleft()\n            if avalon_ent[\"type\"].lower() == \"project\":\n                continue\n\n            ftrack_id = avalon_ent[\"data\"][\"ftrackId\"]\n\n            vis_par = avalon_ent[\"data\"][\"visualParent\"]\n            if vis_par is None:\n                vis_par = avalon_ent[\"parent\"]\n\n            parent_ent = self.avalon_ents_by_id[vis_par]\n            parent_ftrack_id = parent_ent[\"data\"].get(\"ftrackId\")\n            if parent_ftrack_id is None:\n                self.handle_missing_ftrack_id(parent_ent)\n                parent_ftrack_id = parent_ent[\"data\"].get(\"ftrackId\")\n                if parent_ftrack_id is None:\n                    continue\n\n            if parent_ftrack_id not in entities_dict:\n                entities_dict[parent_ftrack_id] = {\n                    \"children\": [],\n                    \"parent_id\": None,\n                    \"hier_attrs\": {}\n                }\n\n            if ftrack_id not in entities_dict[parent_ftrack_id][\"children\"]:\n                entities_dict[parent_ftrack_id][\"children\"].append(ftrack_id)\n\n            entities_dict[ftrack_id][\"parent_id\"] = parent_ftrack_id\n\n            if parent_ftrack_id in cust_attrs_ftrack_ids:\n                continue\n            mongo_ftrack_mapping[vis_par] = parent_ftrack_id\n            cust_attrs_ftrack_ids.append(parent_ftrack_id)\n            # if ftrack_id not in ftrack_parenting[parent_ftrack_id]:\n            #     ftrack_parenting[parent_ftrack_id].append(ftrack_id)\n\n            parent_queue.append(parent_ent)\n\n        # Prepare values to query\n        configuration_ids = set()\n        for key in hier_cust_attrs_keys:\n            configuration_ids.add(hier_attr_id_by_key[key])\n\n        values = query_custom_attribute_values(\n            self.process_session,\n            configuration_ids,\n            cust_attrs_ftrack_ids\n        )\n\n        ftrack_project_id = self.cur_project[\"id\"]\n\n        attr_types_by_id = self.cust_attr_types_by_id\n        convert_types_by_id = {}\n        for attr in hier_attrs:\n            key = attr[\"key\"]\n            if key not in hier_cust_attrs_keys:\n                continue\n\n            type_id = attr[\"type_id\"]\n            attr_id = attr[\"id\"]\n            cust_attr_type_name = attr_types_by_id[type_id][\"name\"]\n            convert_type = avalon_sync.get_python_type_for_custom_attribute(\n                attr, cust_attr_type_name\n            )\n\n            convert_types_by_id[attr_id] = convert_type\n            default_value = attr[\"default\"]\n            if key in FPS_KEYS:\n                try:\n                    default_value = convert_to_fps(default_value)\n                except InvalidFpsValue:\n                    pass\n\n            entities_dict[ftrack_project_id][\"hier_attrs\"][key] = (\n                attr[\"default\"]\n            )\n\n        # PREPARE DATA BEFORE THIS\n        invalid_fps_items = []\n        avalon_hier = []\n        for item in values:\n            value = item[\"value\"]\n            if value is None:\n                continue\n            entity_id = item[\"entity_id\"]\n            configuration_id = item[\"configuration_id\"]\n\n            convert_type = convert_types_by_id[configuration_id]\n            key = hier_attr_key_by_id[configuration_id]\n\n            if convert_type:\n                value = convert_type(value)\n\n            if key in FPS_KEYS:\n                try:\n                    value = convert_to_fps(value)\n                except InvalidFpsValue:\n                    invalid_fps_items.append((entity_id, value))\n                    continue\n            entities_dict[entity_id][\"hier_attrs\"][key] = value\n\n        if invalid_fps_items:\n            fps_msg = (\n                \"These entities have invalid fps value in custom attributes\"\n            )\n            items = []\n            for entity_id, value in invalid_fps_items:\n                ent_path = self.get_ent_path(entity_id)\n                items.append(\"{} - \\\"{}\\\"\".format(ent_path, value))\n            self.report_items[\"error\"][fps_msg] = items\n\n        # Get dictionary with not None hierarchical values to pull to childs\n        project_values = {}\n        for key, value in (\n            entities_dict[ftrack_project_id][\"hier_attrs\"].items()\n        ):\n            if value is not None:\n                project_values[key] = value\n\n        for key in avalon_hier:\n            value = entities_dict[ftrack_project_id][\"avalon_attrs\"][key]\n            if value is not None:\n                project_values[key] = value\n\n        hier_down_queue = collections.deque()\n        hier_down_queue.append(\n            (project_values, ftrack_project_id)\n        )\n\n        while hier_down_queue:\n            hier_values, parent_id = hier_down_queue.popleft()\n            for child_id in entities_dict[parent_id][\"children\"]:\n                _hier_values = hier_values.copy()\n                for name in hier_cust_attrs_keys:\n                    value = entities_dict[child_id][\"hier_attrs\"].get(name)\n                    if value is not None:\n                        _hier_values[name] = value\n\n                entities_dict[child_id][\"hier_attrs\"].update(_hier_values)\n                hier_down_queue.append((_hier_values, child_id))\n\n        ftrack_mongo_mapping = {}\n        for mongo_id, ftrack_id in mongo_ftrack_mapping.items():\n            ftrack_mongo_mapping[ftrack_id] = mongo_id\n\n        for ftrack_id, data in entities_dict.items():\n            mongo_id = ftrack_mongo_mapping[ftrack_id]\n            avalon_ent = self.avalon_ents_by_id[mongo_id]\n            ent_path = self.get_ent_path(ftrack_id)\n            # TODO logging\n            self.log.debug(\n                \"Updating hierarchical attributes &lt;{}&gt;\".format(ent_path)\n            )\n            for key, value in data[\"hier_attrs\"].items():\n                if (\n                    key in avalon_ent[\"data\"] and\n                    avalon_ent[\"data\"][key] == value\n                ):\n                    continue\n\n                self.log.debug(\"- {}: {}\".format(key, value))\n                if \"data\" not in self.updates[mongo_id]:\n                    self.updates[mongo_id][\"data\"] = {}\n\n                self.updates[mongo_id][\"data\"][key] = value\n\n        self.update_entities()\n\n    def process_task_updates(self):\n        \"\"\"\n            Pull task information for selected ftrack ids to replace stored\n            existing in Avalon.\n            Solves problem of changing type (even Status in the future) of\n            task without storing ftrack id for task in the DB. (Which doesn't\n            bring much advantage currently and it could be troublesome for\n            all hosts or plugins (for example Nuke) to collect and store.\n        Returns:\n            None\n        \"\"\"\n        self.log.debug(\n            \"Processing task changes for parents: {}\".format(\n                self.modified_tasks_ftrackids\n            )\n        )\n        if not self.modified_tasks_ftrackids:\n            return\n\n        joined_ids = \", \".join([\n            \"\\\"{}\\\"\".format(ftrack_id)\n            for ftrack_id in self.modified_tasks_ftrackids\n        ])\n        task_entities = self.process_session.query(\n            self.task_entities_query_by_parent_id.format(\n                self.cur_project[\"id\"], joined_ids\n            )\n        ).all()\n\n        ftrack_mongo_mapping_found = {}\n        not_found_ids = []\n        # Make sure all parents have updated tasks, as they may not have any\n        tasks_per_ftrack_id = {\n            ftrack_id: {}\n            for ftrack_id in self.modified_tasks_ftrackids\n        }\n\n        # Query all task types at once\n        task_types = self.process_session.query(self.task_types_query).all()\n        task_types_by_id = {\n            task_type[\"id\"]: task_type\n            for task_type in task_types\n        }\n\n        # prepare all tasks per parentId, eg. Avalon asset record\n        for task_entity in task_entities:\n            task_type = task_types_by_id[task_entity[\"type_id\"]]\n            ftrack_id = task_entity[\"parent_id\"]\n            if ftrack_id not in tasks_per_ftrack_id:\n                tasks_per_ftrack_id[ftrack_id] = {}\n\n            passed_regex = avalon_sync.check_regex(\n                task_entity[\"name\"], \"task\",\n                schema_patterns=self.regex_schemas\n            )\n            if not passed_regex:\n                self.regex_failed.append(task_entity[\"id\"])\n                continue\n\n            tasks_per_ftrack_id[ftrack_id][task_entity[\"name\"]] = {\n                \"type\": task_type[\"name\"]\n            }\n\n        # find avalon entity by parentId\n        # should be there as create was run first\n        for ftrack_id in tasks_per_ftrack_id.keys():\n            avalon_entity = self.avalon_ents_by_ftrack_id.get(ftrack_id)\n            if not avalon_entity:\n                not_found_ids.append(ftrack_id)\n                continue\n            ftrack_mongo_mapping_found[ftrack_id] = avalon_entity[\"_id\"]\n\n        self._update_avalon_tasks(\n            ftrack_mongo_mapping_found,\n            tasks_per_ftrack_id\n        )\n\n    def update_entities(self):\n        \"\"\"\n            Update Avalon entities by mongo bulk changes.\n            Expects self.updates which are transfered to $set part of update\n            command.\n            Resets self.updates afterwards.\n        \"\"\"\n        mongo_changes_bulk = []\n        for mongo_id, changes in self.updates.items():\n            avalon_ent = self.avalon_ents_by_id[mongo_id]\n            is_project = avalon_ent[\"type\"] == \"project\"\n            change_data = avalon_sync.from_dict_to_set(changes, is_project)\n            mongo_changes_bulk.append(\n                UpdateOne({\"_id\": mongo_id}, change_data)\n            )\n\n        if not mongo_changes_bulk:\n            return\n\n        self.dbcon.bulk_write(mongo_changes_bulk)\n        self.updates = collections.defaultdict(dict)\n\n    @property\n    def duplicated_report(self):\n        if not self.duplicated:\n            return []\n\n        ft_project = self.cur_project\n        duplicated_names = []\n        for ftrack_id in self.duplicated:\n            ftrack_ent = self.ftrack_ents_by_id.get(ftrack_id)\n            if not ftrack_ent:\n                ftrack_ent = self.process_session.query(\n                    self.entities_query_by_id.format(\n                        ft_project[\"id\"], ftrack_id\n                    )\n                ).one()\n                self.ftrack_ents_by_id[ftrack_id] = ftrack_ent\n            name = ftrack_ent[\"name\"]\n            if name not in duplicated_names:\n                duplicated_names.append(name)\n\n        joined_names = \", \".join(\n            [\"\\\"{}\\\"\".format(name) for name in duplicated_names]\n        )\n        ft_ents = self.process_session.query(\n            self.entities_name_query_by_name.format(\n                ft_project[\"id\"], joined_names\n            )\n        ).all()\n\n        ft_ents_by_name = collections.defaultdict(list)\n        for ft_ent in ft_ents:\n            name = ft_ent[\"name\"]\n            ft_ents_by_name[name].append(ft_ent)\n\n        if not ft_ents_by_name:\n            return []\n\n        subtitle = \"Duplicated entity names:\"\n        items = []\n        items.append({\n            \"type\": \"label\",\n            \"value\": \"# {}\".format(subtitle)\n        })\n        items.append({\n            \"type\": \"label\",\n            \"value\": (\n                \"&lt;p&gt;&lt;i&gt;NOTE: It is not allowed to use the same name\"\n                \" for multiple entities in the same project&lt;/i&gt;&lt;/p&gt;\"\n            )\n        })\n\n        for name, ents in ft_ents_by_name.items():\n            items.append({\n                \"type\": \"label\",\n                \"value\": \"## {}\".format(name)\n            })\n            paths = []\n            for ent in ents:\n                ftrack_id = ent[\"id\"]\n                ent_path = \"/\".join([_ent[\"name\"] for _ent in ent[\"link\"]])\n                avalon_ent = self.avalon_ents_by_id.get(ftrack_id)\n\n                if avalon_ent:\n                    additional = \" (synchronized)\"\n                    if avalon_ent[\"name\"] != name:\n                        additional = \" (synchronized as {})\".format(\n                            avalon_ent[\"name\"]\n                        )\n                    ent_path += additional\n                paths.append(ent_path)\n\n            items.append({\n                \"type\": \"label\",\n                \"value\": '&lt;p&gt;{}&lt;/p&gt;'.format(\"&lt;br&gt;\".join(paths))\n            })\n\n        return items\n\n    @property\n    def regex_report(self):\n        if not self.regex_failed:\n            return []\n\n        subtitle = \"Entity names contain prohibited symbols:\"\n        items = []\n        items.append({\n            \"type\": \"label\",\n            \"value\": \"# {}\".format(subtitle)\n        })\n        items.append({\n            \"type\": \"label\",\n            \"value\": (\n                \"&lt;p&gt;&lt;i&gt;NOTE: You can use Letters( a-Z ),\"\n                \" Numbers( 0-9 ) and Underscore( _ )&lt;/i&gt;&lt;/p&gt;\"\n            )\n        })\n\n        ft_project = self.cur_project\n        for ftrack_id in self.regex_failed:\n            ftrack_ent = self.ftrack_ents_by_id.get(ftrack_id)\n            if not ftrack_ent:\n                ftrack_ent = self.process_session.query(\n                    self.entities_query_by_id.format(\n                        ft_project[\"id\"], ftrack_id\n                    )\n                ).one()\n                self.ftrack_ents_by_id[ftrack_id] = ftrack_ent\n\n            name = ftrack_ent[\"name\"]\n            ent_path_items = [\n                _ent[\"name\"] for _ent in ftrack_ent[\"link\"][:-1]\n            ]\n            ent_path_items.append(\"&lt;strong&gt;{}&lt;/strong&gt;\".format(name))\n            ent_path = \"/\".join(ent_path_items)\n            items.append({\n                \"type\": \"label\",\n                \"value\": \"&lt;p&gt;{} - {}&lt;/p&gt;\".format(name, ent_path)\n            })\n\n        return items\n\n    def report(self):\n        msg_len = len(self.duplicated) + len(self.regex_failed)\n        for msgs in self.report_items.values():\n            msg_len += len(msgs)\n\n        if msg_len == 0:\n            return\n\n        items = []\n        project_name = self.cur_project[\"full_name\"]\n        title = \"Synchronization report ({}):\".format(project_name)\n\n        keys = [\"error\", \"warning\", \"info\"]\n        for key in keys:\n            subitems = []\n            if key == \"warning\":\n                subitems.extend(self.duplicated_report)\n                subitems.extend(self.regex_report)\n\n            for _msg, _items in self.report_items[key].items():\n                if not _items:\n                    continue\n\n                msg_items = _msg.split(\"||\")\n                msg = msg_items[0]\n                subitems.append({\n                    \"type\": \"label\",\n                    \"value\": \"# {}\".format(msg)\n                })\n\n                if len(msg_items) &gt; 1:\n                    for note in msg_items[1:]:\n                        subitems.append({\n                            \"type\": \"label\",\n                            \"value\": \"&lt;p&gt;&lt;i&gt;NOTE: {}&lt;/i&gt;&lt;/p&gt;\".format(note)\n                        })\n\n                if isinstance(_items, str):\n                    _items = [_items]\n                subitems.append({\n                    \"type\": \"label\",\n                    \"value\": '&lt;p&gt;{}&lt;/p&gt;'.format(\"&lt;br&gt;\".join(_items))\n                })\n\n            if items and subitems:\n                items.append(self.report_splitter)\n\n            items.extend(subitems)\n\n        self.show_interface(\n            items=items,\n            title=title,\n            event=self._cur_event\n        )\n        return True\n\n    def _update_avalon_tasks(\n        self, ftrack_mongo_mapping_found, tasks_per_ftrack_id\n    ):\n        \"\"\"\n            Prepare new \"tasks\" content for existing records in Avalon.\n        Args:\n            ftrack_mongo_mapping_found (dictionary): ftrack parentId to\n                Avalon _id mapping\n            tasks_per_ftrack_id (dictionary): task dictionaries per ftrack\n                parentId\n\n        Returns:\n            None\n        \"\"\"\n        mongo_changes_bulk = []\n        for ftrack_id, mongo_id in ftrack_mongo_mapping_found.items():\n            filter = {\"_id\": mongo_id}\n            change_data = {\"$set\": {}}\n            change_data[\"$set\"][\"data.tasks\"] = tasks_per_ftrack_id[ftrack_id]\n            mongo_changes_bulk.append(UpdateOne(filter, change_data))\n\n        if mongo_changes_bulk:\n            self.dbcon.bulk_write(mongo_changes_bulk)\n\n    def _mongo_id_configuration(\n        self,\n        ent_info,\n        cust_attrs,\n        hier_attrs,\n        temp_dict\n    ):\n        # Use hierarchical mongo id attribute if possible.\n        if \"_hierarchical\" not in temp_dict:\n            hier_mongo_id_configuration_id = None\n            for attr in hier_attrs:\n                if attr[\"key\"] == CUST_ATTR_KEY_SERVER_ID:\n                    hier_mongo_id_configuration_id = attr[\"id\"]\n                    break\n            temp_dict[\"_hierarchical\"] = hier_mongo_id_configuration_id\n\n        hier_mongo_id_configuration_id = temp_dict.get(\"_hierarchical\")\n        if hier_mongo_id_configuration_id is not None:\n            return hier_mongo_id_configuration_id\n\n        # Legacy part for cases that MongoID attribute is per entity type.\n        entity_type = ent_info[\"entity_type\"]\n        mongo_id_configuration_id = temp_dict.get(entity_type)\n        if mongo_id_configuration_id is not None:\n            return mongo_id_configuration_id\n\n        for attr in cust_attrs:\n            key = attr[\"key\"]\n            if key != CUST_ATTR_KEY_SERVER_ID:\n                continue\n\n            if attr[\"entity_type\"] != ent_info[\"entityType\"]:\n                continue\n\n            if (\n                ent_info[\"entityType\"] == \"task\" and\n                attr[\"object_type_id\"] != ent_info[\"objectTypeId\"]\n            ):\n                continue\n\n            mongo_id_configuration_id = attr[\"id\"]\n            break\n\n        temp_dict[entity_type] = mongo_id_configuration_id\n\n        return mongo_id_configuration_id\n</code></pre>"},{"location":"autoapi/services/processor/processor/handlers_to_convert/event_sync_to_avalon.html#services.processor.processor.handlers_to_convert.event_sync_to_avalon.SyncToAvalonEvent.changeability_by_mongo_id","title":"<code>changeability_by_mongo_id</code>  <code>property</code>","text":"<p>Return info about changeability of entity and it's parents.</p>"},{"location":"autoapi/services/processor/processor/handlers_to_convert/event_sync_to_avalon.html#services.processor.processor.handlers_to_convert.event_sync_to_avalon.SyncToAvalonEvent.__init__","title":"<code>__init__(session)</code>","text":"<p>Expects a ftrack_api.Session instance</p> Source code in <code>services/processor/processor/handlers_to_convert/event_sync_to_avalon.py</code> <pre><code>def __init__(self, session):\n    '''Expects a ftrack_api.Session instance'''\n    # Debug settings\n    # - time expiration in seconds\n    self.debug_print_time_expiration = 5 * 60\n    # - store current time\n    self.debug_print_time = datetime.datetime.now()\n    # - store synchronize entity types to be able to use\n    #   only entityTypes in interest instead of filtering by ignored\n    self.debug_sync_types = collections.defaultdict(list)\n\n    self.dbcon = AvalonMongoDB()\n    # Set processing session to not use global\n    self.set_process_session(session)\n    super().__init__(session)\n</code></pre>"},{"location":"autoapi/services/processor/processor/handlers_to_convert/event_sync_to_avalon.html#services.processor.processor.handlers_to_convert.event_sync_to_avalon.SyncToAvalonEvent.check_names_synchronizable","title":"<code>check_names_synchronizable(names)</code>","text":"<p>Check if entities with specific names are importable.</p> <p>This check should happend after removing entity or renaming entity. When entity was removed or renamed then it's name is possible to sync.</p> Source code in <code>services/processor/processor/handlers_to_convert/event_sync_to_avalon.py</code> <pre><code>def check_names_synchronizable(self, names):\n    \"\"\"Check if entities with specific names are importable.\n\n    This check should happend after removing entity or renaming entity.\n    When entity was removed or renamed then it's name is possible to sync.\n    \"\"\"\n    joined_passed_names = \", \".join(\n        [\"\\\"{}\\\"\".format(name) for name in names]\n    )\n    same_name_entities = self.process_session.query(\n        self.entities_name_query_by_name.format(\n            self.cur_project[\"id\"], joined_passed_names\n        )\n    ).all()\n    if not same_name_entities:\n        return\n\n    entities_by_name = collections.defaultdict(list)\n    for entity in same_name_entities:\n        entities_by_name[entity[\"name\"]].append(entity)\n\n    synchronizable_ents = []\n    self.log.debug((\n        \"Deleting of entities should allow to synchronize another entities\"\n        \" with same name.\"\n    ))\n    for name, ents in entities_by_name.items():\n        if len(ents) != 1:\n            self.log.debug((\n                \"Name \\\"{}\\\" still have more than one entity &lt;{}&gt;\"\n            ).format(\n                name, \"| \".join(\n                    [self.get_ent_path(ent[\"id\"]) for ent in ents]\n                )\n            ))\n            continue\n\n        entity = ents[0]\n        ent_path = self.get_ent_path(entity[\"id\"])\n        # TODO logging\n        self.log.debug(\n            \"Checking if can synchronize entity &lt;{}&gt;\".format(ent_path)\n        )\n        # skip if already synchronized\n        ftrack_id = entity[\"id\"]\n        if ftrack_id in self.avalon_ents_by_ftrack_id:\n            # TODO logging\n            self.log.debug(\n                \"- Entity is already synchronized (skipping) &lt;{}&gt;\".format(\n                    ent_path\n                )\n            )\n            continue\n\n        parent_id = entity[\"parent_id\"]\n        if parent_id not in self.avalon_ents_by_ftrack_id:\n            # TODO logging\n            self.log.debug((\n                \"- Entity's parent entity doesn't seems to\"\n                \" be synchronized (skipping) &lt;{}&gt;\"\n            ).format(ent_path))\n            continue\n\n        synchronizable_ents.append(entity)\n\n    if not synchronizable_ents:\n        return\n\n    synchronizable_ents = sorted(\n        synchronizable_ents,\n        key=(lambda entity: len(entity[\"link\"]))\n    )\n\n    children_queue = collections.deque()\n    for entity in synchronizable_ents:\n        parent_avalon_ent = self.avalon_ents_by_ftrack_id[\n            entity[\"parent_id\"]\n        ]\n        self.create_entity_in_avalon(entity, parent_avalon_ent)\n\n        for child in entity[\"children\"]:\n            if child.entity_type.lower() != \"task\":\n                children_queue.append(child)\n\n    while children_queue:\n        entity = children_queue.popleft()\n        ftrack_id = entity[\"id\"]\n        name = entity[\"name\"]\n        ent_by_ftrack_id = self.avalon_ents_by_ftrack_id.get(ftrack_id)\n        if ent_by_ftrack_id:\n            raise Exception((\n                \"This is bug, parent was just synchronized to avalon\"\n                \" but entity is already in database {}\"\n            ).format(dict(entity)))\n\n        # Entity has duplicated name with another entity\n        # - may be renamed: in that case renaming method will handle that\n        duplicate_ent = self.avalon_ents_by_name.get(name)\n        if duplicate_ent:\n            continue\n\n        passed_regex = avalon_sync.check_regex(\n            name, \"asset\", schema_patterns=self.regex_schemas\n        )\n        if not passed_regex:\n            continue\n\n        parent_id = entity[\"parent_id\"]\n        parent_avalon_ent = self.avalon_ents_by_ftrack_id[parent_id]\n\n        self.create_entity_in_avalon(entity, parent_avalon_ent)\n\n        for child in entity[\"children\"]:\n            if child.entity_type.lower() == \"task\":\n                continue\n            children_queue.append(child)\n</code></pre>"},{"location":"autoapi/services/processor/processor/handlers_to_convert/event_sync_to_avalon.html#services.processor.processor.handlers_to_convert.event_sync_to_avalon.SyncToAvalonEvent.debug_logs","title":"<code>debug_logs()</code>","text":"<p>This is debug method for printing small debugs messages.</p> Source code in <code>services/processor/processor/handlers_to_convert/event_sync_to_avalon.py</code> <pre><code>def debug_logs(self):\n    \"\"\"This is debug method for printing small debugs messages. \"\"\"\n    now_datetime = datetime.datetime.now()\n    delta = now_datetime - self.debug_print_time\n    if delta.total_seconds() &lt; self.debug_print_time_expiration:\n        return\n\n    self.debug_print_time = now_datetime\n    known_types_items = []\n    for entityType, entity_type in self.debug_sync_types.items():\n        ent_types_msg = \", \".join(entity_type)\n        known_types_items.append(\n            \"&lt;{}&gt; ({})\".format(entityType, ent_types_msg)\n        )\n\n    known_entityTypes = \", \".join(known_types_items)\n    self.log.debug(\n        \"DEBUG MESSAGE: Known types {}\".format(known_entityTypes)\n    )\n</code></pre>"},{"location":"autoapi/services/processor/processor/handlers_to_convert/event_sync_to_avalon.html#services.processor.processor.handlers_to_convert.event_sync_to_avalon.SyncToAvalonEvent.get_ent_path","title":"<code>get_ent_path(ftrack_id)</code>","text":"<pre><code>Looks for entity in ftrack with 'ftrack_id'. If found returns\nconcatenated paths from its 'link' elemenent's names. Describes\nlocation of entity in tree.\n</code></pre> <p>Args:     ftrack_id (string): entityId of ftrack entity</p> <p>Returns:</p> Type Description <p>(string) - example : \"/test_project/assets/my_asset\"</p> Source code in <code>services/processor/processor/handlers_to_convert/event_sync_to_avalon.py</code> <pre><code>def get_ent_path(self, ftrack_id):\n    \"\"\"\n        Looks for entity in ftrack with 'ftrack_id'. If found returns\n        concatenated paths from its 'link' elemenent's names. Describes\n        location of entity in tree.\n    Args:\n        ftrack_id (string): entityId of ftrack entity\n\n    Returns:\n        (string) - example : \"/test_project/assets/my_asset\"\n    \"\"\"\n    entity = self.ftrack_ents_by_id.get(ftrack_id)\n    if not entity:\n        entity = self.process_session.query(\n            self.entities_query_by_id.format(\n                self.cur_project[\"id\"], ftrack_id\n            )\n        ).first()\n        if entity:\n            self.ftrack_ents_by_id[ftrack_id] = entity\n        else:\n            return \"unknown hierarchy\"\n    return \"/\".join([ent[\"name\"] for ent in entity[\"link\"]])\n</code></pre>"},{"location":"autoapi/services/processor/processor/handlers_to_convert/event_sync_to_avalon.html#services.processor.processor.handlers_to_convert.event_sync_to_avalon.SyncToAvalonEvent.launch","title":"<code>launch(session, event)</code>","text":"<pre><code>Main entry port for synchronization.\nGoes through event (can contain multiple changes) and decides if\nthe event is interesting for us (interest_entTypes).\nIt separates changes into add|remove|update.\nAll task changes are handled together by refresh from ftrack.\n</code></pre> <p>Args:     session (object): session to ftrack     event (dictionary): event content</p> <p>Returns:</p> Type Description <p>(boolean or None)</p> Source code in <code>services/processor/processor/handlers_to_convert/event_sync_to_avalon.py</code> <pre><code>def launch(self, session, event):\n    \"\"\"\n        Main entry port for synchronization.\n        Goes through event (can contain multiple changes) and decides if\n        the event is interesting for us (interest_entTypes).\n        It separates changes into add|remove|update.\n        All task changes are handled together by refresh from ftrack.\n    Args:\n        session (object): session to ftrack\n        event (dictionary): event content\n\n    Returns:\n        (boolean or None)\n    \"\"\"\n    # Try to commit and if any error happen then recreate session\n    try:\n        self.process_session.commit()\n    except Exception:\n        self.set_process_session(session)\n    # Reset object values for each launch\n    self.reset_variables()\n    self._cur_event = event\n\n    entities_by_action = {\n        \"remove\": {},\n        \"update\": {},\n        \"move\": {},\n        \"add\": {}\n    }\n\n    entities_info = event[\"data\"][\"entities\"]\n    found_actions = set()\n    for ent_info in entities_info:\n        entityType = ent_info[\"entityType\"]\n        if entityType not in self.interest_entTypes:\n            continue\n\n        entity_type = ent_info.get(\"entity_type\")\n        if not entity_type or entity_type in self.ignore_ent_types:\n            continue\n\n        if entity_type not in self.debug_sync_types[entityType]:\n            self.debug_sync_types[entityType].append(entity_type)\n\n        action = ent_info[\"action\"]\n        ftrack_id = ent_info[\"entityId\"]\n        if isinstance(ftrack_id, list):\n            self.log.warning((\n                \"BUG REPORT: Entity info has `entityId` as `list` \\\"{}\\\"\"\n            ).format(ent_info))\n            if len(ftrack_id) == 0:\n                continue\n            ftrack_id = ftrack_id[0]\n\n        # Skip deleted projects\n        if action == \"remove\" and entityType == \"show\":\n            return True\n\n        # task modified, collect parent id of task, handle separately\n        if entity_type.lower() == \"task\":\n            changes = ent_info.get(\"changes\") or {}\n            if action == \"move\":\n                parent_changes = changes[\"parent_id\"]\n                self.modified_tasks_ftrackids.add(parent_changes[\"new\"])\n                self.modified_tasks_ftrackids.add(parent_changes[\"old\"])\n\n            elif \"typeid\" in changes or \"name\" in changes:\n                self.modified_tasks_ftrackids.add(ent_info[\"parentId\"])\n            continue\n\n        if action == \"move\":\n            ent_keys = ent_info[\"keys\"]\n            # Separate update info from move action\n            if len(ent_keys) &gt; 1:\n                _ent_info = ent_info.copy()\n                for ent_key in ent_keys:\n                    if ent_key == \"parent_id\":\n                        _ent_info[\"changes\"].pop(ent_key, None)\n                        _ent_info[\"keys\"].remove(ent_key)\n                    else:\n                        ent_info[\"changes\"].pop(ent_key, None)\n                        ent_info[\"keys\"].remove(ent_key)\n                entities_by_action[\"update\"][ftrack_id] = _ent_info\n        # regular change process handles all other than Tasks\n        found_actions.add(action)\n        entities_by_action[action][ftrack_id] = ent_info\n\n    found_actions = list(found_actions)\n    if not found_actions and not self.modified_tasks_ftrackids:\n        return True\n\n    # Check if auto sync was turned on/off\n    updated = entities_by_action[\"update\"]\n    for ftrack_id, ent_info in updated.items():\n        # filter project\n        if ent_info[\"entityType\"] != \"show\":\n            continue\n\n        changes = ent_info[\"changes\"]\n        if CUST_ATTR_AUTO_SYNC not in changes:\n            continue\n\n        auto_sync = changes[CUST_ATTR_AUTO_SYNC][\"new\"]\n        turned_on = auto_sync == \"1\"\n        ft_project = self.cur_project\n        username = self._get_username(session, event)\n        message = (\n            \"Auto sync was turned {} for project \\\"{}\\\" by \\\"{}\\\".\"\n        ).format(\n            \"on\" if turned_on else \"off\",\n            ft_project[\"full_name\"],\n            username\n        )\n        if turned_on:\n            message += \" Triggering syncToAvalon action.\"\n        self.log.debug(message)\n\n        if turned_on:\n            # Trigger sync to avalon action if auto sync was turned on\n            selection = [{\n                \"entityId\": ft_project[\"id\"],\n                \"entityType\": \"show\"\n            }]\n            self.trigger_action(\n                action_name=\"sync.to.avalon.server\",\n                event=event,\n                selection=selection\n            )\n        # Exit for both cases\n        return True\n\n    # Filter updated data by changed keys\n    updated = self.filter_updated(updated)\n\n    # skip most of events where nothing has changed for avalon\n    if (\n        len(found_actions) == 1\n        and found_actions[0] == \"update\"\n        and not updated\n        and not self.modified_tasks_ftrackids\n    ):\n        return True\n\n    ft_project = self.cur_project\n    # Check if auto-sync custom attribute exists\n    if CUST_ATTR_AUTO_SYNC not in ft_project[\"custom_attributes\"]:\n        # TODO should we sent message to someone?\n        self.log.error((\n            \"Custom attribute \\\"{}\\\" is not created or user \\\"{}\\\" used\"\n            \" for Event server don't have permissions to access it!\"\n        ).format(CUST_ATTR_AUTO_SYNC, self.session.api_user))\n        return True\n\n    # Skip if auto-sync is not set\n    auto_sync = ft_project[\"custom_attributes\"][CUST_ATTR_AUTO_SYNC]\n    if auto_sync is not True:\n        return True\n\n    debug_msg = \"Updated: {}\".format(len(updated))\n    debug_action_map = {\n        \"add\": \"Created\",\n        \"remove\": \"Removed\",\n        \"move\": \"Moved\"\n    }\n    for action, infos in entities_by_action.items():\n        if action == \"update\":\n            continue\n        _action = debug_action_map[action]\n        debug_msg += \"| {}: {}\".format(_action, len(infos))\n\n    self.log.debug(\"Project changes &lt;{}&gt;: {}\".format(\n        ft_project[\"full_name\"], debug_msg\n    ))\n    # Get ftrack entities - find all ftrack ids first\n    ftrack_ids = set(updated.keys())\n\n    for action, _ftrack_ids in entities_by_action.items():\n        # skip updated (already prepared) and removed (not exist in ftrack)\n        if action not in (\"remove\", \"update\"):\n            ftrack_ids |= set(_ftrack_ids)\n\n    # collect entity records data which might not be in event\n    if ftrack_ids:\n        joined_ids = \", \".join([\"\\\"{}\\\"\".format(id) for id in ftrack_ids])\n        ftrack_entities = self.process_session.query(\n            self.entities_query_by_id.format(ft_project[\"id\"], joined_ids)\n        ).all()\n        for entity in ftrack_entities:\n            self.ftrack_ents_by_id[entity[\"id\"]] = entity\n\n    # Filter updates where name is changing\n    for ftrack_id, ent_info in updated.items():\n        ent_keys = ent_info[\"keys\"]\n        # Seprate update info from rename\n        if \"name\" not in ent_keys:\n            continue\n\n        _ent_info = copy.deepcopy(ent_info)\n        for ent_key in ent_keys:\n            if ent_key == \"name\":\n                ent_info[\"changes\"].pop(ent_key, None)\n                ent_info[\"keys\"].remove(ent_key)\n            else:\n                _ent_info[\"changes\"].pop(ent_key, None)\n                _ent_info[\"keys\"].remove(ent_key)\n\n        self.ftrack_renamed[ftrack_id] = _ent_info\n\n    self.ftrack_removed = entities_by_action[\"remove\"]\n    self.ftrack_moved = entities_by_action[\"move\"]\n    self.ftrack_added = entities_by_action[\"add\"]\n    self.ftrack_updated = updated\n\n    self.debug_logs()\n\n    self.log.debug(\"Synchronization begins\")\n    try:\n        time_1 = time.time()\n        # 1.) Process removed - may affect all other actions\n        self.process_removed()\n        time_2 = time.time()\n        # 2.) Process renamed - may affect added\n        self.process_renamed()\n        time_3 = time.time()\n        # 3.) Process added - moved entity may be moved to new entity\n        self.process_added()\n        time_4 = time.time()\n        # 4.) Process moved\n        self.process_moved()\n        time_5 = time.time()\n        # 5.) Process updated\n        self.process_updated()\n        time_6 = time.time()\n        # 6.) Process changes in hierarchy or hier custom attribues\n        self.process_hier_cleanup()\n        time_7 = time.time()\n        self.process_task_updates()\n        if self.updates:\n            self.update_entities()\n        time_8 = time.time()\n\n        time_removed = time_2 - time_1\n        time_renamed = time_3 - time_2\n        time_added = time_4 - time_3\n        time_moved = time_5 - time_4\n        time_updated = time_6 - time_5\n        time_cleanup = time_7 - time_6\n        time_task_updates = time_8 - time_7\n        time_total = time_8 - time_1\n        self.log.debug((\n            \"Process time: {:.2f} &lt;{:.2f}, {:.2f}, {:.2f}, \"\n            \"{:.2f}, {:.2f}, {:.2f}, {:.2f}&gt;\"\n        ).format(\n            time_total, time_removed, time_renamed, time_added,\n            time_moved, time_updated, time_cleanup, time_task_updates\n        ))\n\n    except Exception:\n        msg = \"An error has happened during synchronization\"\n        self.report_items[\"error\"][msg].append((\n            str(traceback.format_exc()).replace(\"\\n\", \"&lt;br&gt;\")\n        ).replace(\" \", \"&amp;nbsp;\"))\n\n    self.report()\n    return True\n</code></pre>"},{"location":"autoapi/services/processor/processor/handlers_to_convert/event_sync_to_avalon.html#services.processor.processor.handlers_to_convert.event_sync_to_avalon.SyncToAvalonEvent.process_moved","title":"<code>process_moved()</code>","text":"<p>Handles moved entities to different place in hiearchy. (Not tasks - handled separately.)</p> Source code in <code>services/processor/processor/handlers_to_convert/event_sync_to_avalon.py</code> <pre><code>def process_moved(self):\n    \"\"\"\n        Handles moved entities to different place in hiearchy.\n        (Not tasks - handled separately.)\n    \"\"\"\n    if not self.ftrack_moved:\n        return\n\n    self.log.debug(\n        \"Processing moved entities: {}\".format(str(self.ftrack_moved))\n    )\n\n    ftrack_moved = {k: v for k, v in sorted(\n        self.ftrack_moved.items(),\n        key=(lambda line: len(\n            (line[1].get(\"data\", {}).get(\"parents\") or [])\n        ))\n    )}\n\n    for ftrack_id, ent_info in ftrack_moved.items():\n        avalon_ent = self.avalon_ents_by_ftrack_id.get(ftrack_id)\n        if not avalon_ent:\n            continue\n\n        new_parent_id = ent_info[\"changes\"][\"parent_id\"][\"new\"]\n\n        mongo_id = avalon_ent[\"_id\"]\n        if self.changeability_by_mongo_id[mongo_id]:\n            par_av_ent = self.avalon_ents_by_ftrack_id.get(new_parent_id)\n            if not par_av_ent:\n                # TODO logging\n                # TODO report\n                ent_path_items = [self.cur_project[\"full_name\"]]\n                ent_path_items.extend(avalon_ent[\"data\"][\"parents\"])\n                ent_path_items.append(avalon_ent[\"name\"])\n                ent_path = \"/\".join(ent_path_items)\n\n                error_msg = (\n                    \"New parent of entity is not synchronized to avalon\"\n                )\n                report_msg = (\n                    \"{}||Parent in Avalon can't be changed. That\"\n                    \" may cause issues. Please fix parent or move entity\"\n                    \" under valid entity.\"\n                ).format(error_msg)\n\n                self.report_items[\"warning\"][report_msg].append(ent_path)\n                self.log.warning(\"{} &lt;{}&gt;\".format(error_msg, ent_path))\n                continue\n\n            # THIS MUST HAPPEND AFTER CREATING NEW ENTITIES !!!!\n            # - because may be moved to new created entity\n            if \"data\" not in self.updates[mongo_id]:\n                self.updates[mongo_id][\"data\"] = {}\n\n            vis_par_id = None\n            ent_path_items = [self.cur_project[\"full_name\"]]\n            if par_av_ent[\"type\"].lower() != \"project\":\n                vis_par_id = par_av_ent[\"_id\"]\n                ent_path_items.extend(par_av_ent[\"data\"][\"parents\"])\n                ent_path_items.append(par_av_ent[\"name\"])\n\n            self.updates[mongo_id][\"data\"][\"visualParent\"] = vis_par_id\n            self.moved_in_avalon.append(mongo_id)\n\n            ent_path_items.append(avalon_ent[\"name\"])\n            ent_path = \"/\".join(ent_path_items)\n            self.log.debug((\n                \"Parent of entity ({}) was changed in avalon &lt;{}&gt;\"\n                ).format(str(mongo_id), ent_path)\n            )\n\n        else:\n            avalon_ent = self.avalon_ents_by_id[mongo_id]\n            avalon_parent_id = avalon_ent[\"data\"][\"visualParent\"]\n            if avalon_parent_id is None:\n                avalon_parent_id = avalon_ent[\"parent\"]\n\n            avalon_parent = self.avalon_ents_by_id[avalon_parent_id]\n            parent_id = avalon_parent[\"data\"][\"ftrackId\"]\n\n            # For cases when parent was deleted at the same time\n            if parent_id in self.ftrack_recreated_mapping:\n                parent_id = (\n                    self.ftrack_recreated_mapping[parent_id]\n                )\n\n            ftrack_ent = self.ftrack_ents_by_id.get(ftrack_id)\n            if not ftrack_ent:\n                ftrack_ent = self.process_session.query(\n                    self.entities_query_by_id.format(\n                        self.cur_project[\"id\"], ftrack_id\n                    )\n                ).one()\n                self.ftrack_ents_by_id[ftrack_id] = ftrack_ent\n\n            if parent_id == ftrack_ent[\"parent_id\"]:\n                continue\n\n            ftrack_ent[\"parent_id\"] = parent_id\n            try:\n                self.process_session.commit()\n                # TODO logging\n                # TODO report\n                msg = \"Entity was moved back\"\n                report_msg = (\n                    \"{}||Entity can't be moved when\"\n                    \" it or its children contain published data\"\n                ).format(msg)\n                ent_path = self.get_ent_path(ftrack_id)\n                self.report_items[\"info\"][report_msg].append(ent_path)\n                self.log.warning(\"{} &lt;{}&gt;\".format(msg, ent_path))\n\n            except Exception:\n                self.process_session.rollback()\n                # TODO logging\n                # TODO report\n                error_msg = (\n                    \"Couldn't moved the entity back to its original parent\"\n                )\n                report_msg = (\n                    \"{}||Moved back because it is not possible to\"\n                    \" move with an entity or it's parents, \"\n                    \" if it already contained published data.\"\n                ).format(error_msg)\n                error_traceback = (\n                    str(traceback.format_exc()).replace(\"\\n\", \"&lt;br&gt;\")\n                ).replace(\" \", \"&amp;nbsp;\")\n\n                item_msg = ent_path + \"&lt;br&gt;\" + error_traceback\n                self.report_items[\"warning\"][report_msg].append(item_msg)\n                self.log.warning(\n                    \"{}: \\\"{}\\\"\".format(error_msg, ent_path),\n                    exc_info=True\n                )\n</code></pre>"},{"location":"autoapi/services/processor/processor/handlers_to_convert/event_sync_to_avalon.html#services.processor.processor.handlers_to_convert.event_sync_to_avalon.SyncToAvalonEvent.process_removed","title":"<code>process_removed()</code>","text":"<p>Handles removed entities (not removed tasks - handle separately).</p> Source code in <code>services/processor/processor/handlers_to_convert/event_sync_to_avalon.py</code> <pre><code>def process_removed(self):\n    \"\"\"\n        Handles removed entities (not removed tasks - handle separately).\n    \"\"\"\n    if not self.ftrack_removed:\n        return\n    ent_infos = self.ftrack_removed\n    self.log.debug(\n        \"Processing removed entities: {}\".format(str(ent_infos))\n    )\n    removable_ids = []\n    recreate_ents = []\n    removed_names = []\n    for ftrack_id, removed in ent_infos.items():\n        entity_type = removed[\"entity_type\"]\n        if entity_type.lower() == \"task\":\n            continue\n\n        removed_name = removed[\"changes\"][\"name\"][\"old\"]\n\n        avalon_ent = self.avalon_ents_by_ftrack_id.get(ftrack_id)\n        if not avalon_ent:\n            continue\n        mongo_id = avalon_ent[\"_id\"]\n        if self.changeability_by_mongo_id[mongo_id]:\n            removable_ids.append(mongo_id)\n            removed_names.append(removed_name)\n        else:\n            recreate_ents.append(avalon_ent)\n\n    if removable_ids:\n        # TODO logging\n        self.log.debug(\"Assets marked as archived &lt;{}&gt;\".format(\n            \", \".join(removed_names)\n        ))\n        self.dbcon.update_many(\n            {\"_id\": {\"$in\": removable_ids}, \"type\": \"asset\"},\n            {\"$set\": {\"type\": \"archived_asset\"}}\n        )\n        self.remove_cached_by_key(\"id\", removable_ids)\n\n    if recreate_ents:\n        # sort removed entities by parents len\n        # - length of parents determine hierarchy level\n        recreate_ents = sorted(\n            recreate_ents,\n            key=(lambda item: len(\n                (item.get(\"data\", {}).get(\"parents\") or [])\n            ))\n        )\n        # TODO logging\n        # TODO report\n        recreate_msg = (\n            \"Deleted entity was recreated||Entity was recreated because\"\n            \" it or its children contain published data\"\n        )\n        proj, ents = self.avalon_entities\n        for avalon_entity in recreate_ents:\n            old_ftrack_id = avalon_entity[\"data\"][\"ftrackId\"]\n            vis_par = avalon_entity[\"data\"][\"visualParent\"]\n            if vis_par is None:\n                vis_par = proj[\"_id\"]\n            parent_ent = self.avalon_ents_by_id[vis_par]\n\n            parent_ftrack_id = parent_ent[\"data\"].get(\"ftrackId\")\n            if parent_ftrack_id is None:\n                self.handle_missing_ftrack_id(parent_ent)\n                parent_ftrack_id = parent_ent[\"data\"].get(\"ftrackId\")\n                if parent_ftrack_id is None:\n                    continue\n\n            parent_ftrack_ent = self.ftrack_ents_by_id.get(\n                parent_ftrack_id\n            )\n            if not parent_ftrack_ent:\n                if parent_ent[\"type\"].lower() == \"project\":\n                    parent_ftrack_ent = self.cur_project\n                else:\n                    parent_ftrack_ent = self.process_session.query(\n                        self.entities_query_by_id.format(\n                            self.cur_project[\"id\"], parent_ftrack_id\n                        )\n                    ).one()\n            entity_type = avalon_entity[\"data\"][\"entityType\"]\n            new_entity = self.process_session.create(entity_type, {\n                \"name\": avalon_entity[\"name\"],\n                \"parent\": parent_ftrack_ent\n            })\n            try:\n                self.process_session.commit()\n            except Exception:\n                # TODO logging\n                # TODO report\n                self.process_session.rolback()\n                ent_path_items = [self.cur_project[\"full_name\"]]\n                ent_path_items.extend([\n                    par for par in avalon_entity[\"data\"][\"parents\"]\n                ])\n                ent_path_items.append(avalon_entity[\"name\"])\n                ent_path = \"/\".join(ent_path_items)\n\n                error_msg = \"Couldn't recreate entity in ftrack\"\n                report_msg = (\n                    \"{}||Trying to recreate because it or its children\"\n                    \" contain published data\"\n                ).format(error_msg)\n                self.report_items[\"warning\"][report_msg].append(ent_path)\n                self.log.warning(\n                    \"{}. Process session commit failed! &lt;{}&gt;\".format(\n                        error_msg, ent_path\n                    ),\n                    exc_info=True\n                )\n                continue\n\n            new_entity_id = new_entity[\"id\"]\n            avalon_entity[\"data\"][\"ftrackId\"] = new_entity_id\n\n            for key, val in avalon_entity[\"data\"].items():\n                if not val:\n                    continue\n                if key not in new_entity[\"custom_attributes\"]:\n                    continue\n\n                new_entity[\"custom_attributes\"][key] = val\n\n            new_entity[\"custom_attributes\"][CUST_ATTR_KEY_SERVER_ID] = (\n                str(avalon_entity[\"_id\"])\n            )\n            ent_path = self.get_ent_path(new_entity_id)\n\n            try:\n                self.process_session.commit()\n            except Exception:\n                # TODO logging\n                # TODO report\n                self.process_session.rolback()\n                error_msg = (\n                    \"Couldn't update custom attributes after recreation\"\n                    \" of entity in ftrack\"\n                )\n                report_msg = (\n                    \"{}||Entity was recreated because it or its children\"\n                    \" contain published data\"\n                ).format(error_msg)\n                self.report_items[\"warning\"][report_msg].append(ent_path)\n                self.log.warning(\n                    \"{}. Process session commit failed! &lt;{}&gt;\".format(\n                        error_msg, ent_path\n                    ),\n                    exc_info=True\n                )\n                continue\n\n            self.report_items[\"info\"][recreate_msg].append(ent_path)\n\n            self.ftrack_recreated_mapping[old_ftrack_id] = new_entity_id\n            self.process_session.commit()\n\n            found_idx = None\n            proj_doc, asset_docs = self._avalon_ents\n            for idx, asset_doc in enumerate(asset_docs):\n                if asset_doc[\"_id\"] == avalon_entity[\"_id\"]:\n                    found_idx = idx\n                    break\n\n            if found_idx is None:\n                continue\n\n            # Prepare updates dict for mongo update\n            if \"data\" not in self.updates[avalon_entity[\"_id\"]]:\n                self.updates[avalon_entity[\"_id\"]][\"data\"] = {}\n\n            self.updates[avalon_entity[\"_id\"]][\"data\"][\"ftrackId\"] = (\n                new_entity_id\n            )\n            # Update cached entities\n            asset_docs[found_idx] = avalon_entity\n            self._avalon_ents = proj_doc, asset_docs\n\n            if self._avalon_ents_by_id is not None:\n                mongo_id = avalon_entity[\"_id\"]\n                self._avalon_ents_by_id[mongo_id] = avalon_entity\n\n            if self._avalon_ents_by_parent_id is not None:\n                vis_par = avalon_entity[\"data\"][\"visualParent\"]\n                children = self._avalon_ents_by_parent_id[vis_par]\n                found_idx = None\n                for idx, _entity in enumerate(children):\n                    if _entity[\"_id\"] == avalon_entity[\"_id\"]:\n                        found_idx = idx\n                        break\n                children[found_idx] = avalon_entity\n                self._avalon_ents_by_parent_id[vis_par] = children\n\n            if self._avalon_ents_by_ftrack_id is not None:\n                self._avalon_ents_by_ftrack_id.pop(old_ftrack_id)\n                self._avalon_ents_by_ftrack_id[new_entity_id] = (\n                    avalon_entity\n                )\n\n            if self._avalon_ents_by_name is not None:\n                name = avalon_entity[\"name\"]\n                self._avalon_ents_by_name[name] = avalon_entity\n\n    # Check if entities with same name can be synchronized\n    if not removed_names:\n        return\n\n    self.check_names_synchronizable(removed_names)\n</code></pre>"},{"location":"autoapi/services/processor/processor/handlers_to_convert/event_sync_to_avalon.html#services.processor.processor.handlers_to_convert.event_sync_to_avalon.SyncToAvalonEvent.process_task_updates","title":"<code>process_task_updates()</code>","text":"<pre><code>Pull task information for selected ftrack ids to replace stored\nexisting in Avalon.\nSolves problem of changing type (even Status in the future) of\ntask without storing ftrack id for task in the DB. (Which doesn't\nbring much advantage currently and it could be troublesome for\nall hosts or plugins (for example Nuke) to collect and store.\n</code></pre> <p>Returns:     None</p> Source code in <code>services/processor/processor/handlers_to_convert/event_sync_to_avalon.py</code> <pre><code>def process_task_updates(self):\n    \"\"\"\n        Pull task information for selected ftrack ids to replace stored\n        existing in Avalon.\n        Solves problem of changing type (even Status in the future) of\n        task without storing ftrack id for task in the DB. (Which doesn't\n        bring much advantage currently and it could be troublesome for\n        all hosts or plugins (for example Nuke) to collect and store.\n    Returns:\n        None\n    \"\"\"\n    self.log.debug(\n        \"Processing task changes for parents: {}\".format(\n            self.modified_tasks_ftrackids\n        )\n    )\n    if not self.modified_tasks_ftrackids:\n        return\n\n    joined_ids = \", \".join([\n        \"\\\"{}\\\"\".format(ftrack_id)\n        for ftrack_id in self.modified_tasks_ftrackids\n    ])\n    task_entities = self.process_session.query(\n        self.task_entities_query_by_parent_id.format(\n            self.cur_project[\"id\"], joined_ids\n        )\n    ).all()\n\n    ftrack_mongo_mapping_found = {}\n    not_found_ids = []\n    # Make sure all parents have updated tasks, as they may not have any\n    tasks_per_ftrack_id = {\n        ftrack_id: {}\n        for ftrack_id in self.modified_tasks_ftrackids\n    }\n\n    # Query all task types at once\n    task_types = self.process_session.query(self.task_types_query).all()\n    task_types_by_id = {\n        task_type[\"id\"]: task_type\n        for task_type in task_types\n    }\n\n    # prepare all tasks per parentId, eg. Avalon asset record\n    for task_entity in task_entities:\n        task_type = task_types_by_id[task_entity[\"type_id\"]]\n        ftrack_id = task_entity[\"parent_id\"]\n        if ftrack_id not in tasks_per_ftrack_id:\n            tasks_per_ftrack_id[ftrack_id] = {}\n\n        passed_regex = avalon_sync.check_regex(\n            task_entity[\"name\"], \"task\",\n            schema_patterns=self.regex_schemas\n        )\n        if not passed_regex:\n            self.regex_failed.append(task_entity[\"id\"])\n            continue\n\n        tasks_per_ftrack_id[ftrack_id][task_entity[\"name\"]] = {\n            \"type\": task_type[\"name\"]\n        }\n\n    # find avalon entity by parentId\n    # should be there as create was run first\n    for ftrack_id in tasks_per_ftrack_id.keys():\n        avalon_entity = self.avalon_ents_by_ftrack_id.get(ftrack_id)\n        if not avalon_entity:\n            not_found_ids.append(ftrack_id)\n            continue\n        ftrack_mongo_mapping_found[ftrack_id] = avalon_entity[\"_id\"]\n\n    self._update_avalon_tasks(\n        ftrack_mongo_mapping_found,\n        tasks_per_ftrack_id\n    )\n</code></pre>"},{"location":"autoapi/services/processor/processor/handlers_to_convert/event_sync_to_avalon.html#services.processor.processor.handlers_to_convert.event_sync_to_avalon.SyncToAvalonEvent.process_updated","title":"<code>process_updated()</code>","text":"<p>Only custom attributes changes should get here</p> Source code in <code>services/processor/processor/handlers_to_convert/event_sync_to_avalon.py</code> <pre><code>def process_updated(self):\n    \"\"\"\n        Only custom attributes changes should get here\n    \"\"\"\n    if not self.ftrack_updated:\n        return\n\n    self.log.debug(\n        \"Processing updated entities: {}\".format(str(self.ftrack_updated))\n    )\n\n    ent_infos = self.ftrack_updated\n    ftrack_mongo_mapping = {}\n    not_found_ids = []\n    for ftrack_id, ent_info in ent_infos.items():\n        avalon_ent = self.avalon_ents_by_ftrack_id.get(ftrack_id)\n        if not avalon_ent:\n            not_found_ids.append(ftrack_id)\n            continue\n\n        ftrack_mongo_mapping[ftrack_id] = avalon_ent[\"_id\"]\n\n    for ftrack_id in not_found_ids:\n        ent_infos.pop(ftrack_id)\n\n    if not ent_infos:\n        return\n\n    cust_attrs, hier_attrs = self.avalon_cust_attrs\n    hier_attrs_by_key = {\n        attr[\"key\"]: attr\n        for attr in hier_attrs\n    }\n    cust_attrs_by_obj_id = collections.defaultdict(dict)\n    for cust_attr in cust_attrs:\n        key = cust_attr[\"key\"]\n        if key.startswith(\"avalon_\"):\n            continue\n\n        ca_ent_type = cust_attr[\"entity_type\"]\n\n        if ca_ent_type == \"show\":\n            cust_attrs_by_obj_id[ca_ent_type][key] = cust_attr\n\n        elif ca_ent_type == \"task\":\n            obj_id = cust_attr[\"object_type_id\"]\n            cust_attrs_by_obj_id[obj_id][key] = cust_attr\n\n    for ftrack_id, ent_info in ent_infos.items():\n        mongo_id = ftrack_mongo_mapping[ftrack_id]\n        entType = ent_info[\"entityType\"]\n        ent_path = self.get_ent_path(ftrack_id)\n        if entType == \"show\":\n            ent_cust_attrs = cust_attrs_by_obj_id.get(\"show\")\n        else:\n            obj_type_id = ent_info[\"objectTypeId\"]\n            ent_cust_attrs = cust_attrs_by_obj_id.get(obj_type_id)\n\n        # ftrack's entity_type does not have defined custom attributes\n        if ent_cust_attrs is None:\n            ent_cust_attrs = {}\n\n        ent_changes = ent_info[\"changes\"]\n        if \"description\" in ent_changes:\n            if \"data\" not in self.updates[mongo_id]:\n                self.updates[mongo_id][\"data\"] = {}\n            self.updates[mongo_id][\"data\"][\"description\"] = (\n                ent_changes[\"description\"][\"new\"] or \"\"\n            )\n\n        for key, values in ent_changes.items():\n            if key in hier_attrs_by_key:\n                self.hier_cust_attrs_changes[key].append(ftrack_id)\n                continue\n\n            if key not in ent_cust_attrs:\n                continue\n\n            value = values[\"new\"]\n            new_value = self.convert_value_by_cust_attr_conf(\n                value, ent_cust_attrs[key]\n            )\n\n            if \"data\" not in self.updates[mongo_id]:\n                self.updates[mongo_id][\"data\"] = {}\n            self.updates[mongo_id][\"data\"][key] = new_value\n            self.log.debug(\n                \"Setting data value of \\\"{}\\\" to \\\"{}\\\" &lt;{}&gt;\".format(\n                    key, new_value, ent_path\n                )\n            )\n</code></pre>"},{"location":"autoapi/services/processor/processor/handlers_to_convert/event_sync_to_avalon.html#services.processor.processor.handlers_to_convert.event_sync_to_avalon.SyncToAvalonEvent.reset_variables","title":"<code>reset_variables()</code>","text":"<p>Reset variables so each event callback has clear env.</p> Source code in <code>services/processor/processor/handlers_to_convert/event_sync_to_avalon.py</code> <pre><code>def reset_variables(self):\n    \"\"\"Reset variables so each event callback has clear env.\"\"\"\n    self._cur_project = None\n\n    self._avalon_cust_attrs = None\n    self._cust_attr_types_by_id = None\n\n    self._avalon_ents = None\n    self._avalon_ents_by_id = None\n    self._avalon_ents_by_parent_id = None\n    self._avalon_ents_by_ftrack_id = None\n    self._avalon_ents_by_name = None\n    self._avalon_asset_ids_with_subsets = None\n    self._changeability_by_mongo_id = None\n    self._avalon_archived_by_id = None\n    self._avalon_archived_by_name = None\n\n    self._ent_types_by_name = None\n\n    self.ftrack_ents_by_id = {}\n    self.obj_id_ent_type_map = {}\n    self.ftrack_recreated_mapping = {}\n\n    self.ftrack_added = {}\n    self.ftrack_moved = {}\n    self.ftrack_renamed = {}\n    self.ftrack_updated = {}\n    self.ftrack_removed = {}\n\n    # set of ftrack ids with modified tasks\n    # handled separately by full wipeout and replace from ftrack\n    self.modified_tasks_ftrackids = set()\n\n    self.moved_in_avalon = []\n    self.renamed_in_avalon = []\n    self.hier_cust_attrs_changes = collections.defaultdict(list)\n\n    self.duplicated = []\n    self.regex_failed = []\n\n    self.regex_schemas = {}\n    self.updates = collections.defaultdict(dict)\n\n    self.report_items = {\n        \"info\": collections.defaultdict(list),\n        \"warning\": collections.defaultdict(list),\n        \"error\": collections.defaultdict(list)\n    }\n</code></pre>"},{"location":"autoapi/services/processor/processor/handlers_to_convert/event_sync_to_avalon.html#services.processor.processor.handlers_to_convert.event_sync_to_avalon.SyncToAvalonEvent.update_entities","title":"<code>update_entities()</code>","text":"<p>Update Avalon entities by mongo bulk changes. Expects self.updates which are transfered to $set part of update command. Resets self.updates afterwards.</p> Source code in <code>services/processor/processor/handlers_to_convert/event_sync_to_avalon.py</code> <pre><code>def update_entities(self):\n    \"\"\"\n        Update Avalon entities by mongo bulk changes.\n        Expects self.updates which are transfered to $set part of update\n        command.\n        Resets self.updates afterwards.\n    \"\"\"\n    mongo_changes_bulk = []\n    for mongo_id, changes in self.updates.items():\n        avalon_ent = self.avalon_ents_by_id[mongo_id]\n        is_project = avalon_ent[\"type\"] == \"project\"\n        change_data = avalon_sync.from_dict_to_set(changes, is_project)\n        mongo_changes_bulk.append(\n            UpdateOne({\"_id\": mongo_id}, change_data)\n        )\n\n    if not mongo_changes_bulk:\n        return\n\n    self.dbcon.bulk_write(mongo_changes_bulk)\n    self.updates = collections.defaultdict(dict)\n</code></pre>"},{"location":"autoapi/services/processor/processor/lib/index.html","title":"lib","text":""},{"location":"autoapi/services/processor/processor/lib/index.html#services.processor.processor.lib.SyncFromFtrack","title":"<code>SyncFromFtrack</code>","text":"<p>Helper for sync project from ftrack.</p> Source code in <code>services/processor/processor/lib/sync_from_ftrack.py</code> <pre><code>class SyncFromFtrack:\n    \"\"\"Helper for sync project from ftrack.\"\"\"\n\n    def __init__(self, session, project_name, log=None):\n        self._log = log\n        self._ft_session = session\n        self._project_name = project_name\n        self._ids_mapping = IdsMapping()\n        self._ayon_project = NOT_SET\n\n        ft_users = session.query(\"select id, username, email from User\").all()\n        users_mapping = map_ftrack_users_to_ayon_users(ft_users)\n        for ftrack_id, ayon_id in users_mapping.items():\n            if ayon_id:\n                self._ids_mapping.set_ftrack_to_server(ftrack_id, ayon_id)\n\n        # Create entity hub which handle entity changes\n        self._entity_hub = EntityHub(project_name)\n        self._ftrack_settings = None\n        self._ftrack_project_settings = None\n\n        self._report_items = []\n\n        # TODO add more and use them\n        self._processed_server_ids = set()\n        self._processed_ftrack_ids = set()\n        self._skipped_ftrack_ids = set()\n        self._duplicated_ftrack_ids = {}\n        # Immutable\n        self._im_invalid_entity_ids = set()\n        self._im_renamed_entity_ids = set()\n        self._im_moved_entity_ids = set()\n        self._im_removed_entity_ids = set()\n\n        self._missing_link_type = None\n\n    @property\n    def project_name(self):\n        \"\"\"Name of project which is synchronized.\n\n        Returns:\n            str: Project name which is synchronized.\n        \"\"\"\n\n        return self._project_name\n\n    @property\n    def log(self):\n        \"\"\"Logger object.\n\n        Returns:\n            logging.Logger: Logger object.\n        \"\"\"\n\n        if self._log is None:\n            self._log = logging.getLogger(self.__class__.__name__)\n        return self._log\n\n    @property\n    def report_items(self):\n        \"\"\"Report items shown once finished.\n\n        Returns:\n            list[dict[str, Any]]: List of interface items for ftrack UI.\n        \"\"\"\n\n        return self._report_items\n\n    def sync_project_types(\n        self,\n        ft_project: \"FtrackEntity\",\n        ft_session: \"FtrackSession\",\n    ) -&gt; tuple[list[\"FtrackEntity\"], list[\"FtrackEntity\"]]:\n        \"\"\"Sync project types from ftrack to AYON.\n\n        Args:\n            ft_project (FtrackEntity): ftrack project entity.\n            ft_session (FtrackSession): ftrack session.\n\n        Returns:\n            tuple[list, list]: Tuple of object types and task types.\n        \"\"\"\n\n        self._entity_hub.fill_project_from_server()\n        # Get Folder types and Task types from ftrack\n        ft_object_types = ft_session.query(\n            \"select id, name, sort from ObjectType\").all()\n        ft_object_types_by_id = {\n            ft_object_type[\"id\"]: ft_object_type\n            for ft_object_type in ft_object_types\n        }\n\n        ft_types = ft_session.query(\"select id, name, sort from Type\").all()\n        ft_types_by_id = {\n            ft_type[\"id\"]: ft_type\n            for ft_type in ft_types\n        }\n\n        # Filter folder and task types for this project based on schema\n        project_schema = ft_project[\"project_schema\"]\n        object_types = {\n            ft_object_types_by_id[object_type[\"id\"]]\n            for object_type in project_schema[\"object_types\"]\n        }\n        task_types = {\n            ft_types_by_id[task_type[\"id\"]]\n            for task_type in project_schema[\"task_type_schema\"][\"types\"]\n        }\n\n        # Update types on project entity from ftrack\n        self.update_project_types(object_types, task_types)\n        return object_types, task_types\n\n    def get_ftrack_settings(self):\n        if self._ftrack_settings is None:\n            settings = get_addons_settings()\n            self._ftrack_settings = settings[\"ftrack\"]\n        return copy.deepcopy(self._ftrack_settings)\n\n    def get_ftrack_project_settings(self):\n        if self._ftrack_project_settings is None:\n            settings = get_addons_settings(project_name=self.project_name)\n            self._ftrack_project_settings = settings[\"ftrack\"]\n        return copy.deepcopy(self._ftrack_project_settings)\n\n    def sync_statuses(\n        self,\n        ft_project: \"FtrackEntity\",\n        ft_session: \"FtrackSession\",\n        ft_status_by_id: Optional[dict[str, \"FtrackEntity\"]] = None,\n    ) -&gt; None:\n        if ft_status_by_id is None:\n            ft_status_by_id = {\n                status[\"id\"]: status\n                for status in ft_session.query(\n                    \"select id, name, color, state, sort from Status\"\n                ).all()\n            }\n\n        fields = {\n            \"asset_version_workflow_schema\",\n            \"task_workflow_schema\",\n            \"task_workflow_schema_overrides\",\n            \"object_type_schemas\",\n        }\n        project_schema_id = ft_project[\"project_schema_id\"]\n\n        joined_fields = \", \".join(fields)\n        project_schema = ft_session.query(\n            f\"select {joined_fields} from ProjectSchema\"\n            f\" where id is '{project_schema_id}'\"\n        ).first()\n\n        # Folder statuses\n        schema_ids = {\n            schema[\"id\"]\n            for schema in project_schema[\"object_type_schemas\"]\n        }\n        object_type_schemas = []\n        if schema_ids:\n            joined_schema_ids = join_filter_values(schema_ids)\n            object_type_schemas = ft_session.query(\n                \"select id, object_type_id from Schema\"\n                f\" where id in ({joined_schema_ids})\"\n            ).all()\n\n        object_type_schema_ids = {\n            schema[\"id\"]\n            for schema in object_type_schemas\n        }\n        folder_statuses_ids = set()\n        if object_type_schema_ids:\n            joined_ot_schema_ids = join_filter_values(object_type_schema_ids)\n            schema_statuses = ft_session.query(\n                \"select status_id from SchemaStatus\"\n                f\" where schema_id in ({joined_ot_schema_ids})\"\n            ).all()\n            folder_statuses_ids = {\n                status[\"status_id\"]\n                for status in schema_statuses\n            }\n\n        # Task statues\n        task_workflow_override_ids = {\n            task_override[\"id\"]\n            for task_override in (\n                project_schema[\"task_workflow_schema_overrides\"]\n            )\n        }\n        workflow_ids = set()\n        if task_workflow_override_ids:\n            joined_ids = join_filter_values(task_workflow_override_ids)\n            override_schemas = ft_session.query(\n                \"select workflow_schema_id\"\n                f\" from ProjectSchemaOverride\"\n                f\" where id in ({joined_ids})\"\n            ).all()\n            workflow_ids = {\n                override_schema[\"workflow_schema_id\"]\n                for override_schema in override_schemas\n            }\n\n        workflow_ids.add(project_schema[\"task_workflow_schema\"][\"id\"])\n        joined_workflow_ids = join_filter_values(workflow_ids)\n        workflow_statuses = ft_session.query(\n            \"select status_id\"\n            \" from WorkflowSchemaStatus\"\n            f\" where workflow_schema_id in ({joined_workflow_ids})\"\n        ).all()\n        task_status_ids = {\n            item[\"status_id\"]\n            for item in workflow_statuses\n        }\n\n        # Version statuses\n        av_workflow_schema_id = (\n            project_schema[\"asset_version_workflow_schema\"][\"id\"]\n        )\n        version_statuse_ids = {\n            item[\"status_id\"]\n            for item in ft_session.query(\n                \"select status_id\"\n                \" from WorkflowSchemaStatus\"\n                f\" where workflow_schema_id is '{av_workflow_schema_id}'\"\n            ).all()\n        }\n\n        all_status_ids = (\n            folder_statuses_ids\n            | task_status_ids\n            | version_statuse_ids\n        )\n        state_mapping = {\n            \"Blocked\": \"blocked\",\n            \"Not Started\": \"not_started\",\n            \"In Progress\": \"in_progress\",\n            \"Done\": \"done\",\n        }\n        statuses_data = []\n        for status_id in all_status_ids:\n            status = ft_status_by_id[status_id]\n            scope = [\"representation\", \"workfile\"]\n            if status_id in folder_statuses_ids:\n                scope.append(\"folder\")\n            if status_id in task_status_ids:\n                scope.append(\"task\")\n            if status_id in version_statuse_ids:\n                scope.append(\"product\")\n                scope.append(\"version\")\n\n            ft_state = status[\"state\"][\"name\"]\n            ayon_state = state_mapping[ft_state]\n            statuses_data.append({\n                \"name\": status[\"name\"],\n                \"color\": status[\"color\"],\n                \"state\": ayon_state,\n                \"scope\": scope,\n                \"sort\": status[\"sort\"],\n            })\n        statuses_data.sort(key=lambda i: i[\"sort\"], reverse=True)\n\n        statuses = self._entity_hub.project_entity.statuses\n        for idx, status_data in enumerate(statuses_data):\n            status_item = statuses.get_status_by_slugified_name(\n                status_data[\"name\"]\n            )\n            if status_item is None:\n                statuses.insert(idx, status_data)\n                continue\n            status_item.name = status_data[\"name\"]\n            status_item.color = status_data[\"color\"]\n            status_item.state = status_data[\"state\"]\n            status_item.scope = status_data[\"scope\"]\n            statuses.insert(idx, status_item)\n\n    def _get_available_ft_statuses(\n        self,\n        ft_entity: \"FtrackEntity\",\n        project_schema_id: str,\n    ) -&gt; set[str]:\n        fields = {\n            \"asset_version_workflow_schema\",\n            \"task_workflow_schema\",\n            \"task_workflow_schema_overrides\",\n            \"object_type_schemas\",\n        }\n\n        joined_fields = \", \".join(fields)\n        project_schema = self._session.query(\n            f\"select {joined_fields} from ProjectSchema\"\n            f\" where id is '{project_schema_id}'\"\n        ).first()\n\n        type_id = ft_entity[\"type_id\"]\n        task_workflow_override_ids = {\n            task_override[\"id\"]\n            for task_override in\n            project_schema[\"task_workflow_schema_overrides\"]\n        }\n        overrides_schema = None\n        if task_workflow_override_ids:\n            joined_ids = join_filter_values(task_workflow_override_ids)\n            overrides_schema = self._session.query(\n                \"select workflow_schema_id\"\n                f\" from ProjectSchemaOverride\"\n                f\" where id in ({joined_ids}) and type_id is '{type_id}'\"\n            ).first()\n\n        workflow_id = project_schema[\"task_workflow_schema\"][\"id\"]\n        if overrides_schema is not None:\n            workflow_id = overrides_schema[\"workflow_schema_id\"]\n        workflow_statuses = self._session.query(\n            \"select status_id\"\n            \" from WorkflowSchemaStatus\"\n            f\" where workflow_schema_id is '{workflow_id}'\"\n        ).all()\n        return {\n            item[\"status_id\"]\n            for item in workflow_statuses\n        }\n\n    def get_ayon_project(self) -&gt; Optional[dict[str, Any]]:\n        if self._ayon_project is NOT_SET:\n            self._ayon_project = get_project(self.project_name)\n        return self._ayon_project\n\n    def project_exists_in_ayon(self) -&gt; bool:\n        \"\"\"Does project exists on AYON server by name.\n\n        Returns:\n            bool: Project exists in AYON.\n        \"\"\"\n\n        # Make sure project exists on server\n        if not self.get_ayon_project():\n            return False\n        return True\n\n    def create_project(\n        self,\n        preset_name: str,\n        attributes: dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Create project on AYON server.\n\n        Args:\n            preset_name (str): Name of anatomy preset that will be used.\n            attributes (dict[str, Any]): Attributes for project creation.\n\n        \"\"\"\n        project_name = self.project_name\n        if self.project_exists_in_ayon():\n            return\n\n        ft_session = self._ft_session\n        ft_project = _get_ftrack_project(ft_session, project_name)\n        self.log.info(f\"Creating project \\\"{project_name}\\\" on server\")\n        project_code = ft_project[\"name\"]\n        create_project(\n            project_name,\n            project_code,\n            preset_name=preset_name\n        )\n        self.log.info(f\"Project \\\"{project_name}\\\" created on server\")\n\n        self.sync_project_types(ft_project, ft_session)\n        self.sync_statuses(ft_project, ft_session)\n        project_entity = self._entity_hub.project_entity\n        for key, value in attributes.items():\n            project_entity.attribs[key] = value\n        self._entity_hub.commit_changes()\n\n    def sync_to_server(self) -&gt; None:\n        \"\"\"Sync project with hierarchy from ftrack to AYON server.\"\"\"\n\n        t_start = time.perf_counter()\n        project_name = self.project_name\n        # Make sure project exists on server\n        if not self.project_exists_in_ayon():\n            self.log.info(\n                f\"Project \\\"{project_name}\\\" does not exist on server.\"\n                \" Skipping project synchronization.\"\n            )\n            self._report_items.extend([\n                {\n                    \"type\": \"label\",\n                    \"value\": (\n                        f\"## Project '{project_name}' does not exist in AYON\"\n                    )\n                },\n                {\n                    \"type\": \"label\",\n                    \"value\": (\n                        \"Synchronization was skipped.\"\n                        \"&lt;br/&gt;Run Prepare Project action or create the\"\n                        \" project manually on server and then run the\"\n                        \" action again.\"\n                    )\n                }\n            ])\n            return\n\n        ft_session = self._ft_session\n\n        if not self.ensure_mandatory_custom_attributes_exists(ft_session):\n            return\n\n        self.log.info(\n            f\"Synchronization of project \\\"{project_name}\\\" started\"\n        )\n\n        # Get ftrack custom attributes to sync\n        attr_confs = ft_session.query(\n            \"select id, key, is_hierarchical, default\"\n            \" from CustomAttributeConfiguration\"\n        ).all()\n\n        # Check if there is custom attribute to store server id\n        server_id_conf_id = None\n        server_path_conf_id = None\n        sync_failed_conf_id = None\n        list_type_conf = None\n        for attr_conf in attr_confs:\n            if attr_conf[\"key\"] == CUST_ATTR_KEY_SERVER_ID:\n                server_id_conf_id = attr_conf[\"id\"]\n            elif attr_conf[\"key\"] == CUST_ATTR_KEY_SERVER_PATH:\n                server_path_conf_id = attr_conf[\"id\"]\n            elif attr_conf[\"key\"] == CUST_ATTR_KEY_SYNC_FAIL:\n                sync_failed_conf_id = attr_conf[\"id\"]\n            elif attr_conf[\"key\"] == CUST_ATTR_KEY_LIST_TYPE:\n                list_type_conf = attr_conf\n\n        missing_attrs = []\n        if not server_id_conf_id:\n            missing_attrs.append(CUST_ATTR_KEY_SERVER_ID)\n\n        if not server_path_conf_id:\n            missing_attrs.append(CUST_ATTR_KEY_SERVER_PATH)\n\n        if not sync_failed_conf_id:\n            missing_attrs.append(CUST_ATTR_KEY_SYNC_FAIL)\n\n        if missing_attrs:\n            attr_end = \"\"\n            was_were = \"was\"\n            if len(missing_attrs) &gt; 1:\n                attr_end = \"s\"\n                was_were = \"were\"\n            joined_attrs = \", \".join([f'\"{attr}\"'for attr in missing_attrs])\n            msg = (\n                f\"Hierarchical attribute{attr_end} {joined_attrs}\"\n                f\" {was_were} not found in ftrack\"\n            )\n\n            self.log.warning(msg)\n            raise ValueError(msg)\n\n        # Query ftrack project\n        ft_project = _get_ftrack_project(ft_session, project_name)\n\n        ft_status_by_id = {\n            status[\"id\"]: status\n            for status in self._ft_session.query(\n                \"select id, name, color, state, sort from Status\"\n            ).all()\n        }\n        self.sync_project_types(ft_project, ft_session)\n        self.sync_statuses(\n            ft_project,\n            ft_session,\n            ft_status_by_id\n        )\n\n        self._entity_hub.commit_changes()\n\n        t_project_existence_1 = time.perf_counter()\n        self.log.debug(\n            \"Initial preparation took\"\n            f\" {t_project_existence_1 - t_start:.2f}s\"\n        )\n        self.log.debug(\"Loading entities from server\")\n        # Query entities from server (project, folders and tasks)\n        self._entity_hub.fetch_hierarchy_entities()\n        self._ids_mapping.set_ftrack_to_server(\n            ft_project[\"id\"], self._entity_hub.project_entity.id\n        )\n        t_server_query_2 = time.perf_counter()\n        self.log.debug((\n            \"Loading of entities from server took\"\n            f\" {t_server_query_2 - t_project_existence_1:.2f}s\"\n        ))\n\n        self.log.info(\"Querying necessary data from ftrack\")\n\n        object_types, task_types = self.sync_project_types(\n            ft_project, ft_session\n        )\n        ft_object_type_name_by_id = {\n            object_type[\"id\"]: object_type[\"name\"]\n            for object_type in object_types\n        }\n        ft_type_names_by_id = {\n            task_type[\"id\"]: task_type[\"name\"]\n            for task_type in task_types\n        }\n\n        t_types_sync_3 = time.perf_counter()\n        self.log.debug((\n            \"Update of types from ftrack took\"\n            f\" {t_types_sync_3 - t_server_query_2:.2f}s\"\n        ))\n\n        self.log.info(\"Querying project hierarchy from ftrack\")\n        ft_entities = ft_session.query((\n            \"select id, name, parent_id, type_id, object_type_id, status_id\"\n            \", start_date, end_date, description, status_id\"\n            \" from TypedContext where project_id is \\\"{}\\\"\"\n        ).format(ft_project[\"id\"])).all()\n        t_ft_entities_4 = time.perf_counter()\n        self.log.debug((\n            \"Query of ftrack entities took\"\n            f\" {t_ft_entities_4 - t_types_sync_3:.2f}s\"\n        ))\n\n        ft_entities_by_id = {ft_project[\"id\"]: ft_project}\n        ft_entities_by_parent_id = collections.defaultdict(list)\n        for entity in ft_entities:\n            entity_id = entity[\"id\"]\n            parent_id = entity[\"parent_id\"]\n            ft_entities_by_id[entity_id] = entity\n            ft_entities_by_parent_id[parent_id].append(entity)\n\n        cust_attr_value_by_entity_id = self._prepare_attribute_values(\n            ft_session,\n            attr_confs,\n            ft_entities_by_id,\n        )\n\n        self.log.info(\"Checking changes of immutable entities\")\n        self.match_immutable_entities(\n            ft_project,\n            ft_entities_by_id,\n            ft_entities_by_parent_id,\n        )\n\n        self.log.info(\"Matching ftrack to server hierarchy\")\n        self.match_existing_entities(\n            ft_project,\n            ft_entities_by_parent_id,\n            ft_object_type_name_by_id,\n            ft_type_names_by_id,\n            cust_attr_value_by_entity_id\n        )\n\n        self.log.info(\"Updating assignees\")\n        self.update_assignees_from_ftrack(\n            ft_entities_by_id\n        )\n\n        self.log.info(\"Updating attributes of entities\")\n\n        ayon_statuses_by_name = {\n            status[\"name\"].lower(): status\n            for status in self._entity_hub.project_entity[\"statuses\"]\n        }\n        self.update_attributes_from_ftrack(\n            cust_attr_value_by_entity_id,\n            ft_entities_by_id,\n            ft_status_by_id,\n            ayon_statuses_by_name,\n        )\n        self._entity_hub.commit_changes()\n\n        self.log.info(\"Updating entity links\")\n        self.update_links_from_ftrack(ft_entities_by_id)\n\n        self.log.info(\"Updating server ids on ftrack entities\")\n        self.update_ftrack_attributes(\n            ft_entities_by_id,\n            cust_attr_value_by_entity_id,\n            server_id_conf_id,\n            server_path_conf_id,\n            sync_failed_conf_id\n        )\n\n        settings = self.get_ftrack_project_settings()\n        sync_versions: bool = (\n            settings\n            [\"service_event_handlers\"]\n            [\"sync_from_ftrack\"]\n            [\"sync_versions\"]\n        )\n        if sync_versions:\n            self.log.info(\"Synchronizing versions\")\n            t_version_start = time.perf_counter()\n            self.update_versions(\n                ft_session,\n                ft_entities_by_id,\n                server_id_conf_id,\n                ayon_statuses_by_name,\n            )\n            t_version_end = time.perf_counter()\n            self.log.info(\n                \"Synchronizing versions took\"\n                f\" {t_version_end - t_version_start:.2f}s\"\n            )\n\n        self.log.info(\"Synchronizing version lists\")\n        self.sync_lists(\n            ft_project,\n            server_id_conf_id,\n            list_type_conf,\n            sync_versions,\n        )\n\n        self.create_report(ft_entities_by_id)\n        t_end = time.perf_counter()\n        self.log.info((\n            f\"Synchronization of project \\\"{project_name}\\\" finished\"\n            f\" in {t_end - t_start:.2f}s\"\n        ))\n\n    def update_project_types(\n        self,\n        object_types: list[\"FtrackEntity\"],\n        task_types: list[\"FtrackEntity\"],\n    ) -&gt; None:\n        project_entity = self._entity_hub.project_entity\n        ignored_folder_types = {\"task\", \"milestone\"}\n        src_folder_types = {\n            folder_type[\"name\"].lower(): folder_type\n            for folder_type in project_entity.folder_types\n            if folder_type[\"name\"].lower() not in ignored_folder_types\n        }\n        src_task_types = {\n            task_type[\"name\"].lower(): task_type\n            for task_type in project_entity.task_types\n        }\n\n        new_folder_types = []\n        for object_type in sorted(object_types, key=lambda o: o[\"sort\"]):\n            name = object_type[\"name\"]\n            src_folder_type = src_folder_types.get(name.lower())\n            if src_folder_type is not None:\n                if src_folder_type[\"name\"] != name:\n                    old_name = src_folder_type[\"name\"]\n                    src_folder_type[\"name\"] = name\n                    src_folder_type[\"original_name\"] = old_name\n\n                new_folder_types.append(src_folder_type)\n            else:\n                new_folder_types.append({\"name\": name})\n\n        new_task_types = []\n        for task_type in task_types:\n            name = task_type[\"name\"]\n            src_task_type = src_task_types.get(name.lower())\n            if src_task_type is not None:\n                if src_task_type[\"name\"] != name:\n                    old_name = src_task_type[\"name\"]\n                    src_task_type[\"name\"] = name\n                    src_task_type[\"original_name\"] = old_name\n                new_task_types.append(src_task_type)\n            else:\n                new_task_types.append({\n                    \"name\": name,\n                    \"shortName\": re.sub(r\"\\W+\", \"\", name.lower())\n                })\n\n        project_entity.folder_types = new_folder_types\n        project_entity.task_types = new_task_types\n\n    def match_immutable_entities(\n        self,\n        ft_project: \"FtrackEntity\",\n        ft_entities_by_id: dict[str, \"FtrackEntity\"],\n        ft_entities_by_parent_id: dict[str, list[\"FtrackEntity\"]],\n    ) -&gt; None:\n        self.log.debug(\"Validation of immutable entities started\")\n\n        # Collect all ftrack ids from immuable entities\n        immutable_queue = collections.deque()\n        for entity in self._entity_hub.project_entity.children:\n            if entity.immutable_for_hierarchy:\n                immutable_queue.append(entity)\n\n        all_immutable_ftrack_ids = set()\n        while immutable_queue:\n            entity = immutable_queue.popleft()\n            all_immutable_ftrack_ids.add(entity.attribs[FTRACK_ID_ATTRIB])\n            for child in entity.children:\n                immutable_queue.append(child)\n\n        # Go through entities and find matching ftrack entity id\n        hierarchy_queue = collections.deque()\n        for entity in self._entity_hub.project_entity.children:\n            if entity.immutable_for_hierarchy:\n                hierarchy_queue.append((entity, ft_project[\"id\"]))\n\n        while hierarchy_queue:\n            (entity, ft_parent_id) = hierarchy_queue.popleft()\n\n            expected_ftrack_id = entity.attribs[FTRACK_ID_ATTRIB]\n            ft_entity = ft_entities_by_id.get(expected_ftrack_id)\n            if ft_entity is None:\n                ft_children = []\n                if ft_parent_id is not None:\n                    ft_children = ft_entities_by_parent_id[ft_parent_id]\n\n                is_folder = entity.entity_type == \"folder\"\n                for ft_child in ft_children:\n                    # Skip all entities that are already reserved for other\n                    #   entities\n                    if ft_child[\"id\"] in all_immutable_ftrack_ids:\n                        continue\n                    name = slugify_string(ft_child[\"name\"])\n                    if name != entity.name:\n                        continue\n                    ft_is_folder = ft_child.entity_type != \"Task\"\n                    if is_folder is ft_is_folder:\n                        ft_entity = ft_child\n                        break\n\n                if ft_entity is None:\n                    # Make sure 'expected_ftrack_id' is None\n                    expected_ftrack_id = None\n                    # Set ftrack id on entity to removed\n                    entity.attribs[FTRACK_ID_ATTRIB] = REMOVED_ID_VALUE\n                else:\n                    # Change ftrack id of entity to matching ftrack entity\n                    expected_ftrack_id = ft_entity[\"id\"]\n                    entity.attribs[FTRACK_ID_ATTRIB] = expected_ftrack_id\n                    # Add the ftrack id to immutable ids\n                    all_immutable_ftrack_ids.add(expected_ftrack_id)\n\n            else:\n                valid = True\n                ft_name = slugify_string(ft_entity[\"name\"])\n                if ft_name != entity.name:\n                    self._im_renamed_entity_ids.add(entity.id)\n                    valid = False\n\n                if ft_entity[\"parent_id\"] != ft_parent_id:\n                    self._im_moved_entity_ids.add(entity.id)\n                    valid = False\n\n                if not valid:\n                    self._im_invalid_entity_ids.add(entity.id)\n\n            if expected_ftrack_id:\n                self._processed_ftrack_ids.add(expected_ftrack_id)\n                self._ids_mapping.set_server_to_ftrack(\n                    entity.id, expected_ftrack_id)\n\n            self._processed_server_ids.add(entity.id)\n            for child in entity.children:\n                if child.immutable_for_hierarchy:\n                    hierarchy_queue.append((child, expected_ftrack_id))\n\n    def ensure_mandatory_custom_attributes_exists(\n        self, session: \"FtrackSession\"\n    ) -&gt; bool:\n        try:\n            ensure_mandatory_custom_attributes_exists(\n                session,\n                self.get_ftrack_settings(),\n            )\n            return True\n        except ServerError:\n            self.log.error(\n                \"Failed to create mandatory custom attributes in ftrack\",\n                exc_info=True\n            )\n            self._report_items.extend([\n                {\n                    \"type\": \"label\",\n                    \"value\": (\n                        \"## Failed to create AYON mandatory custom attributes\"\n                    )\n                },\n                {\n                    \"type\": \"label\",\n                    \"value\": (\n                        \"Sync ftrack &gt; AYON requires some mandatory\"\n                        \" custom attributes. ftrack API key used for services\"\n                        \" does not have enough permissions to create them.\"\n                        \"&lt;br/&gt;&lt;br/&gt;Please add 'Manage settings' permissions\"\n                        \" to used ftrack API key, or use admin ftrack API key\"\n                        \" for services.\"\n                        \"&lt;br/&gt;&lt;br/&gt;NOTE: You can also run ftrack action\"\n                        \" 'AYON Admin - Create/Update custom attributes' to\"\n                        \" create them manually.\"\n                    )\n                }\n            ])\n            return False\n\n    def _create_new_entity(\n        self,\n        parent_entity,\n        ft_entity: \"FtrackEntity\",\n        ft_object_type_name_by_id: dict[str, \"FtrackEntity\"],\n        ft_type_names_by_id: dict[str, str],\n        cust_attr_value_by_entity_id: dict[str, dict[str, Any]],\n    ):\n        ftrack_id = ft_entity[\"id\"]\n        custom_attributes = cust_attr_value_by_entity_id[ftrack_id]\n        entity_id = custom_attributes.get(CUST_ATTR_KEY_SERVER_ID)\n\n        label = ft_entity[\"name\"]\n        name = slugify_string(label)\n        entity_type = ft_entity.entity_type\n        if entity_type.lower() == \"task\":\n            task_type_name = ft_type_names_by_id[ft_entity[\"type_id\"]]\n            new_entity = self._entity_hub.add_new_task(\n                task_type=task_type_name,\n                name=name,\n                label=label,\n                entity_id=entity_id,\n                parent_id=parent_entity.id\n            )\n\n        else:\n            object_type = ft_object_type_name_by_id[\n                ft_entity[\"object_type_id\"]]\n            new_entity = self._entity_hub.add_new_folder(\n                folder_type=object_type,\n                name=name,\n                label=label,\n                entity_id=entity_id,\n                parent_id=parent_entity.id\n            )\n        self._ids_mapping.set_ftrack_to_server(ftrack_id, new_entity.id)\n\n        return new_entity\n\n    def match_existing_entities(\n        self,\n        ft_project: \"FtrackEntity\",\n        ft_entities_by_parent_id: dict[str, list[\"FtrackEntity\"]],\n        ft_object_type_name_by_id: dict[str, \"FtrackEntity\"],\n        ft_type_names_by_id: dict[str, str],\n        cust_attr_value_by_entity_id: dict[str, dict[str, Any]],\n    ) -&gt; None:\n        \"\"\"Match exiting entities on both sides.\n\n        Create new entities that are on ftrack and are not on server and remove\n        those which are not on ftrack.\n\n        Todos:\n            Handle duplicates more clearly. Don't compare children only by name\n                but also by type (right now task == folder).\n\n        Args:\n            ft_project (FtrackEntity): ftrack project entity.\n            ft_entities_by_parent_id (dict[str, list[FtrackEntity]]): Map\n                of ftrack entities by their parent ids.\n            ft_object_type_name_by_id (dict[str, str]): Mapping of ftrack\n                object type ids to their names.\n            ft_type_names_by_id (dict[str, str]): Mapping of ftrack task type\n                ids to their names.\n            cust_attr_value_by_entity_id (dict[str, dict[str, Any]): Custom\n                attribute values by key stored by entity id.\n        \"\"\"\n\n        fill_queue = collections.deque()\n        for ft_child in ft_entities_by_parent_id[ft_project[\"id\"]]:\n            fill_queue.append((self._entity_hub.project_entity, ft_child))\n\n        def _add_children_to_queue(ft_entity_id):\n            children = ft_entities_by_parent_id[ft_entity_id]\n            if not children:\n                return\n\n            entity_id = self._ids_mapping.get_server_mapping(ft_entity_id)\n            entity = None\n            if entity_id:\n                entity = self._entity_hub.get_entity_by_id(entity_id)\n\n            for ft_child in children:\n                fill_queue.append((entity, ft_child))\n\n        while fill_queue:\n            (parent_entity, ft_entity) = fill_queue.popleft()\n            ft_entity_path = \"/\".join([\n                item[\"name\"]\n                for item in ft_entity[\"link\"]\n            ])\n            ft_entity_id = ft_entity[\"id\"]\n            # Go to next children if is already processed\n            if ft_entity_id in self._processed_ftrack_ids:\n                _add_children_to_queue(ft_entity_id)\n                self.log.debug(\n                    f\"{ft_entity_path} - ftrack id already processed\")\n                continue\n\n            if parent_entity is None:\n                self._skipped_ftrack_ids.add(ft_entity_id)\n                _add_children_to_queue(ft_entity_id)\n                self.log.debug(f\"{ft_entity_path} - Skipped\")\n                continue\n\n            if (\n                parent_entity.entity_type == \"project\"\n                and ft_entity.entity_type.lower() == \"task\"\n            ):\n                self._skipped_ftrack_ids.add(ft_entity_id)\n                self.log.debug(\n                    f\"{ft_entity_path} - Skipped task at projectroot\"\n                )\n                continue\n\n            label = ft_entity[\"name\"]\n            name = slugify_string(label)\n            matching_name_entity = None\n            for child in parent_entity.children:\n                if child.name.lower() == name.lower():\n                    matching_name_entity = child\n                    break\n\n            ft_is_folder = ft_entity.entity_type != \"Task\"\n            if matching_name_entity is not None:\n                # If entity was already processed we can skip ftrack entity\n                # --- This is last condition that handle immutable entities ---\n                #   After this condition can be server entities changed,\n                #       removed or created.\n                if matching_name_entity.id in self._processed_server_ids:\n                    self._processed_ftrack_ids.add(ft_entity_id)\n                    self._duplicated_ftrack_ids[ft_entity_id] = (\n                        matching_name_entity\n                    )\n                    _add_children_to_queue(ft_entity_id)\n                    self.log.debug(\n                        f\"{ft_entity_path} - Server id already processed\")\n                    continue\n\n                is_folder = matching_name_entity.entity_type == \"folder\"\n                # It is possible to remove previous server entity at this point\n                #   as we're 100% sure it is not immutable at this point\n                if ft_is_folder is not is_folder:\n                    self.log.debug(\n                        f\"{ft_entity_path} - Deleted previous entity\")\n                    # Remove current entity if type does not match\n                    matching_name_entity.parent_id = None\n                    # Reset variable so new entity is created\n                    matching_name_entity = None\n\n            # No match was found, so we can create new server entity\n            if matching_name_entity is None:\n                self.log.debug(f\"{ft_entity_path} - Creating new entity\")\n                entity = self._create_new_entity(\n                    parent_entity,\n                    ft_entity,\n                    ft_object_type_name_by_id,\n                    ft_type_names_by_id,\n                    cust_attr_value_by_entity_id,\n                )\n                self._processed_server_ids.add(entity.id)\n                self._processed_ftrack_ids.add(ft_entity_id)\n                _add_children_to_queue(ft_entity_id)\n                continue\n\n            self.log.debug(f\"{ft_entity_path} - Updating existing entity\")\n            matching_name_entity.name = name\n            matching_name_entity.label = label\n            matching_name_entity.active = True\n            if matching_name_entity.entity_type == \"task\":\n                task_type_id = ft_entity[\"type_id\"]\n                task_type_name = ft_type_names_by_id[task_type_id]\n                if matching_name_entity.task_type != task_type_name:\n                    matching_name_entity.task_type = task_type_name\n\n            else:\n                object_type_id = ft_entity[\"object_type_id\"]\n                object_type_name = ft_object_type_name_by_id[\n                    object_type_id]\n                if matching_name_entity.folder_type != object_type_name:\n                    matching_name_entity.folder_type = object_type_name\n\n            self._processed_server_ids.add(matching_name_entity.id)\n            self._processed_ftrack_ids.add(ft_entity_id)\n            self._ids_mapping.set_ftrack_to_server(\n                ft_entity_id, matching_name_entity.id\n            )\n            _add_children_to_queue(ft_entity_id)\n\n        deactivate_queue = collections.deque()\n        for child in self._entity_hub.project_entity.children:\n            deactivate_queue.append(child)\n\n        while deactivate_queue:\n            entity = deactivate_queue.popleft()\n            if entity.id not in self._processed_server_ids:\n                entity.active = False\n\n            for child in entity.children:\n                deactivate_queue.append(child)\n\n    def _get_ayon_status(\n        self,\n        ayon_statuses_by_name: dict[str, dict[str, Any]],\n        ayon_entity_type: str,\n        ft_status_name: Union[str, None],\n    ) -&gt; Union[str, None]:\n        if not ft_status_name:\n            return None\n\n        ayon_status = ayon_statuses_by_name.get(ft_status_name.lower())\n        if ayon_status is None:\n            return None\n\n        scope = ayon_status.scope\n        if ayon_entity_type in scope:\n            return ayon_status[\"name\"]\n        return None\n\n    def _set_entity_status(\n        self,\n        ft_entity: \"FtrackEntity\",\n        ft_status_by_id: dict[str, \"FtrackEntity\"],\n        entity: BaseEntity,\n        ayon_statuses_by_name: dict[str, Any],\n    ) -&gt; None:\n        # QUESTION should we log all invalid/missing statuses?\n        # QUESTION should we update AYON project statuses if status\n        #   is not available?\n        if entity.entity_type not in (\"folder\", \"task\"):\n            return\n\n        ft_status = ft_status_by_id.get(ft_entity.get(\"status_id\"))\n        if ft_status is None:\n            return\n\n        ayon_status_name = self._get_ayon_status(\n            ayon_statuses_by_name,\n            entity.entity_type,\n            ft_status[\"name\"]\n        )\n        if ayon_status_name is not None:\n            entity.set_status(ayon_status_name)\n\n    def update_assignees_from_ftrack(\n        self,\n        ft_entities_by_id: dict[str, \"FtrackEntity\"],\n    ) -&gt; None:\n        task_entities_by_id = {}\n        for entity in ft_entities_by_id.values():\n            if entity.entity_type == \"Task\":\n                task_id = entity[\"id\"]\n                ayon_id = self._ids_mapping.get_server_mapping(task_id)\n                if ayon_id is not None:\n                    task_entities_by_id[task_id] = entity\n\n        if not task_entities_by_id:\n            return\n\n        assignment_by_task_id = {\n            task_id: set()\n            for task_id in task_entities_by_id\n        }\n        task_ids = list(task_entities_by_id.keys())\n        for task_ids_chunk in create_chunks(task_ids, 50):\n            joined_ids = \",\".join([\n                f'\"{task_id}\"'\n                for task_id in task_ids_chunk\n            ])\n            appointments = self._ft_session.query(\n                f\"select resource_id, context_id from Appointment\"\n                f\" where context_id in ({joined_ids})\"\n                f\" and type is 'assignment'\"\n            ).all()\n            for appointment in appointments:\n                task_id = appointment[\"context_id\"]\n                user_id = appointment[\"resource_id\"]\n                assignment_by_task_id[task_id].add(user_id)\n\n        for task_id, user_ids in assignment_by_task_id.items():\n            ayon_task = self._entity_hub.get_entity_by_id(\n                self._ids_mapping.get_server_mapping(task_id)\n            )\n            if ayon_task is None:\n                continue\n\n            new_assignees = set()\n            # Keep users that don't have ftrack mapping on task\n            for ayon_user in ayon_task.assignees:\n                user_id = self._ids_mapping.get_ftrack_mapping(ayon_user)\n                if user_id is None:\n                    new_assignees.add(ayon_user)\n\n            for user_id in user_ids:\n                ayon_user = self._ids_mapping.get_server_mapping(user_id)\n                if ayon_user:\n                    new_assignees.add(ayon_user)\n\n            ayon_task.assignees = list(new_assignees)\n\n    def update_attributes_from_ftrack(\n        self,\n        cust_attr_value_by_entity_id: dict[str, dict[str, Any]],\n        ft_entities_by_id: dict[str, \"FtrackEntity\"],\n        ft_status_by_id: dict[str, \"FtrackEntity\"],\n        ayon_statuses_by_name: dict[str, dict[str, Any]],\n    ) -&gt; None:\n        hierarchy_queue = collections.deque()\n        hierarchy_queue.append(self._entity_hub.project_entity)\n        while hierarchy_queue:\n            entity = hierarchy_queue.popleft()\n            # Add children to queue\n            for child_entity in entity.children:\n                hierarchy_queue.append(child_entity)\n\n            ftrack_id = self._ids_mapping.get_ftrack_mapping(entity.id)\n            if ftrack_id is None:\n                continue\n\n            ft_entity = ft_entities_by_id[ftrack_id]\n            path = \"/\".join([\n                item[\"name\"]\n                for item in ft_entity[\"link\"]\n                if item[\"type\"] != \"Project\"\n            ])\n            entity.attribs[FTRACK_ID_ATTRIB] = ftrack_id\n            entity.attribs[FTRACK_PATH_ATTRIB] = path\n\n            self._set_entity_status(\n                ft_entity,\n                ft_status_by_id,\n                entity,\n                ayon_statuses_by_name\n            )\n\n            for attr_name, value in (\n                (\"startDate\", ft_entity[\"start_date\"]),\n                (\"endDate\", ft_entity[\"end_date\"]),\n                (\"description\", ft_entity.get(\"description\")),\n            ):\n                if value is None or attr_name not in entity.attribs:\n                    continue\n\n                if isinstance(value, arrow.Arrow):\n                    # Shift date to 00:00:00 of the day\n                    # - ftrack is returning e.g. '2024-10-29T22:00:00'\n                    #  for '2024-10-30'\n                    value = str(value.shift(hours=24 - value.hour))\n\n                entity.attribs[attr_name] = str(value)\n\n            # ftrack id can not be available if ftrack entity was recreated\n            #   during immutable entity processing\n            attribute_values = cust_attr_value_by_entity_id[ftrack_id]\n            is_project = entity.entity_type == \"project\"\n\n            # TODO handle \"data\" to sync custom attributes not available\n            #   in 'attribs'\n            for key, value in attribute_values.items():\n                # QUESTION Should we skip \"unsetting\" of project attributes?\n                #   - very dangerous for AYON and maybe for project should\n                #       be taken default value of attribute (if there is any)\n                if is_project and value is None:\n                    continue\n\n                if key in entity.attribs:\n                    entity.attribs[key] = value\n\n    def update_links_from_ftrack(\n        self,\n        ft_entities_by_id: dict[str, \"FtrackEntity\"],\n    ) -&gt; None:\n        settings = self.get_ftrack_project_settings()\n        ay_link_type = (\n            settings\n            [\"service_event_handlers\"]\n            [\"sync_from_ftrack\"]\n            [\"sync_link_type\"]\n        )\n        if ay_link_type == \"&lt; Skip &gt;\":\n            self.log.info(\"Links sync is not set to be skipped.\")\n            return\n\n        project_entity = self.get_ayon_project()\n        exists = False\n        for link_type in project_entity[\"linkTypes\"]:\n            if (\n                link_type[\"linkType\"] == ay_link_type\n                and link_type[\"inputType\"] == \"folder\"\n                and link_type[\"outputType\"] == \"folder\"\n            ):\n                exists = True\n\n        if not exists:\n            self._missing_link_type = ay_link_type\n            self.log.warning(\n                f\"Skipping links sync because link type '{ay_link_type}'\"\n                f\" does not exist on project '{self.project_name}'.\"\n            )\n            return\n\n        # Prepare ftrack links\n        ft_folder_ids = set()\n        for ftrack_id, ft_entity in ft_entities_by_id.items():\n            if ft_entity.entity_type.lower() != \"task\":\n                ft_folder_ids.add(ftrack_id)\n\n        ft_links = []\n        for ftrack_ids_chunk in create_chunks(ft_folder_ids, 50):\n            joined_ids = \",\".join([\n                f'\"{ftrack_id}\"'\n                for ftrack_id in ftrack_ids_chunk\n            ])\n            for link in self._ft_session.query(\n                f\"select from_id, to_id from TypedContextLink\"\n                f\" where to_id in ({joined_ids})\"\n            ).all():\n                # Filter only folder links\n                if link[\"from_id\"] in ft_folder_ids:\n                    ft_links.append(link)\n\n        # Skip rest of logic if there are no links\n        if not ft_links:\n            return\n\n        hierarchy_queue = collections.deque()\n        hierarchy_queue.extend(\n            self._entity_hub.project_entity.children\n        )\n        folder_ids = set()\n        while hierarchy_queue:\n            entity = hierarchy_queue.popleft()\n            # Add children to queue\n            for child_entity in entity.children:\n                if child_entity.entity_type == \"folder\":\n                    hierarchy_queue.append(child_entity)\n\n            ftrack_id = self._ids_mapping.get_ftrack_mapping(entity.id)\n            if ftrack_id is not None:\n                folder_ids.add(entity.id)\n\n        _ay_in_links_by_id: dict[str, list[dict[str, Any]]] = (\n            ayon_api.get_folders_links(\n                self.project_name,\n                folder_ids=folder_ids,\n                link_types={ay_link_type},\n                link_direction=\"in\",\n            )\n        )\n        ay_in_links_by_id = {}\n        for ayon_id, entity_links in _ay_in_links_by_id.items():\n            ay_in_links_by_id[ayon_id] = {\n                link[\"entityId\"]\n                for link in entity_links\n            }\n\n        for link in ft_links:\n            ft_in_id = link[\"from_id\"]\n            ft_out_id = link[\"to_id\"]\n            # Not sure how, but can happen...\n            if ft_in_id == ft_out_id:\n                continue\n\n            ay_in_id = self._ids_mapping.get_server_mapping(ft_in_id)\n            ay_out_id = self._ids_mapping.get_server_mapping(ft_out_id)\n            if ay_in_id is None or ay_out_id is None:\n                continue\n\n            if ay_out_id in ay_in_links_by_id[ay_in_id]:\n                continue\n\n            ayon_api.create_link(\n                self.project_name,\n                ay_link_type,\n                ay_in_id,\n                \"folder\",\n                ay_out_id,\n                \"folder\",\n            )\n\n    def _prepare_attribute_values(\n        self,\n        ft_session: \"FtrackSession\",\n        attr_confs: list[\"FtrackEntity\"],\n        ft_entities_by_id: dict[str, \"FtrackEntity\"],\n    ) -&gt; dict[str, dict[str, Any]]:\n        ft_entity_ids = set(ft_entities_by_id.keys())\n        attr_mapping: CustomAttributesMapping = (\n            get_custom_attributes_mapping(\n                ft_session,\n                self.get_ftrack_project_settings(),\n                attr_confs,\n            )\n        )\n        mapped_confs_by_id = {}\n        default_attrs = {}\n        for attr_conf in attr_confs:\n            attr_key = attr_conf[\"key\"]\n            if attr_key in (\n                CUST_ATTR_KEY_SERVER_ID,\n                CUST_ATTR_KEY_SERVER_PATH,\n                CUST_ATTR_KEY_SYNC_FAIL,\n            ):\n                attr_id = attr_conf[\"id\"]\n                default_attrs[attr_id] = attr_key\n                mapped_confs_by_id[attr_id] = attr_conf\n\n        for mapping_item in attr_mapping.values():\n            for mapped_conf in mapping_item.attr_confs:\n                mapped_confs_by_id[mapped_conf[\"id\"]] = mapped_conf\n\n        val_by_entity_id = get_custom_attributes_by_entity_id(\n            ft_session,\n            ft_entity_ids,\n            list(mapped_confs_by_id.values()),\n            store_by_key=False,\n        )\n\n        cust_attr_value_by_entity_id = collections.defaultdict(dict)\n        for entity_id, entity in ft_entities_by_id.items():\n            values_by_attr_id = val_by_entity_id[entity_id]\n            values_by_key = {}\n            for attr_id, default_key in default_attrs.items():\n                value = values_by_attr_id.get(attr_id)\n                if value is not None:\n                    values_by_key[default_key] = value\n\n            for ayon_attr_name, mapping_item in attr_mapping.items():\n                attr_conf = mapping_item.get_attr_conf_for_entity(entity)\n                if attr_conf is None:\n                    continue\n\n                value = values_by_attr_id.get(attr_conf[\"id\"])\n                if value is not None:\n                    values_by_key[ayon_attr_name] = value\n\n            cust_attr_value_by_entity_id[entity_id] = values_by_key\n        return cust_attr_value_by_entity_id\n\n    def _create_ft_operation(\n        self,\n        conf_id: str,\n        entity_id: str,\n        is_new: bool,\n        new_value: Any,\n        old_value: Optional[Any] = None,\n    ) -&gt; \"FtrackOperation\":\n        entity_key = collections.OrderedDict((\n            (\"configuration_id\", conf_id),\n            (\"entity_id\", entity_id)\n        ))\n        if is_new:\n            return ftrack_api.operation.CreateEntityOperation(\n                \"CustomAttributeValue\",\n                entity_key,\n                {\"value\": new_value}\n            )\n\n        return ftrack_api.operation.UpdateEntityOperation(\n            \"CustomAttributeValue\",\n            entity_key,\n            \"value\",\n            old_value,\n            new_value\n        )\n\n    def update_ftrack_attributes(\n        self,\n        ft_entities_by_id: dict[str, \"FtrackEntity\"],\n        cust_attr_value_by_entity_id: dict[str, dict[str, Any]],\n        server_id_conf_id: str,\n        server_path_conf_id: str,\n        sync_failed_conf_id: str,\n    ) -&gt; None:\n        operations = []\n        for ftrack_id, ft_entity in ft_entities_by_id.items():\n            if ft_entity.entity_type == \"Project\":\n                continue\n\n            server_id = self._ids_mapping.get_server_mapping(ftrack_id)\n            entity = None\n            if server_id:\n                entity = self._entity_hub.get_entity_by_id(server_id)\n\n            entity_id = \"\"\n            if entity is not None:\n                entity_id = entity.id\n\n            custom_attributes = cust_attr_value_by_entity_id[ftrack_id]\n\n            oring_sync_failed = custom_attributes.get(CUST_ATTR_KEY_SYNC_FAIL)\n            orig_id = custom_attributes.get(CUST_ATTR_KEY_SERVER_ID)\n            orig_path = custom_attributes.get(CUST_ATTR_KEY_SERVER_PATH)\n            sync_failed = False\n            if entity is None or entity.id in self._im_invalid_entity_ids:\n                sync_failed = True\n\n            if sync_failed != oring_sync_failed:\n                operations.append(\n                    self._create_ft_operation(\n                        sync_failed_conf_id,\n                        ftrack_id,\n                        CUST_ATTR_KEY_SYNC_FAIL not in custom_attributes,\n                        sync_failed,\n                        oring_sync_failed\n                    )\n                )\n\n            if orig_id != entity_id:\n                operations.append(\n                    self._create_ft_operation(\n                        server_id_conf_id,\n                        ftrack_id,\n                        CUST_ATTR_KEY_SERVER_ID not in custom_attributes,\n                        entity_id,\n                        orig_id\n                    )\n                )\n\n            if ft_entity.entity_type == \"Task\" or sync_failed:\n                continue\n\n            path = entity.path\n            if path != orig_path:\n                operations.append(\n                    self._create_ft_operation(\n                        server_path_conf_id,\n                        ftrack_id,\n                        CUST_ATTR_KEY_SERVER_PATH not in custom_attributes,\n                        path,\n                        orig_path\n                    )\n                )\n\n        if not operations:\n            return\n\n        for chunk in create_chunks(operations, 500):\n            for operation in chunk:\n                self._ft_session.recorded_operations.push(operation)\n            self._ft_session.commit()\n\n    def update_versions(\n        self,\n        ft_session: \"FtrackSession\",\n        ft_entities_by_id: dict[str, \"FtrackEntity\"],\n        server_id_conf_id: str,\n        ayon_statuses_by_name: dict[str, dict[str, Any]],\n    ) -&gt; None:\n        \"\"\"Synchronize versions information to AYON.\n\n        Args:\n            ft_session (FtrackSession): Ftrack session.\n            ft_entities_by_id (dict[str, FtrackEntity]): Mapping of ftrack\n                entity ids.\n            server_id_conf_id (str): Id of 'ayon_id' custom attribute.\n            ayon_statuses_by_name (dict[str, dict[str, Any]]): Mapping of AYON\n                statuses by name.\n\n        \"\"\"\n        context_ids = set()\n        for entity in ft_entities_by_id.values():\n            if entity.entity_type != \"Task\":\n                context_ids.add(entity[\"id\"])\n\n        if not context_ids:\n            return\n\n        assets_by_id = {}\n        asset_ids_by_context_id = {\n            context_id: []\n            for context_id in context_ids\n        }\n        for chunk in create_chunks(context_ids, 50):\n            joined_ids = join_filter_values(chunk)\n            for asset in ft_session.query(\n                \"select id, context_id, name from Asset\"\n                f\" where context_id in ({joined_ids})\"\n            ):\n                asset_id = asset[\"id\"]\n                context_id = asset[\"context_id\"]\n                assets_by_id[asset_id] = asset\n                asset_ids_by_context_id[context_id].append(asset_id)\n\n        if not assets_by_id:\n            return\n\n        asset_version_by_id = {}\n        asset_version_ids_by_asset_id = {\n            asset_id: []\n            for asset_id in assets_by_id\n        }\n        for chunk in create_chunks(assets_by_id, 50):\n            joined_ids = join_filter_values(chunk)\n            for asset_version in ft_session.query(\n                \"select id, asset_id, version, status_id from AssetVersion\"\n                f\" where asset_id in ({joined_ids})\"\n            ):\n                av_id = asset_version[\"id\"]\n                asset_id = asset_version[\"asset_id\"]\n                asset_version_by_id[av_id] = asset_version\n                asset_version_ids_by_asset_id[asset_id].append(av_id)\n\n        version_mapping = self._find_versions_ayon_mapping(\n            ft_session,\n            server_id_conf_id,\n            set(asset_version_by_id.keys()),\n        )\n        ayon_ids = set(version_mapping.values())\n        ayon_ids.discard(None)\n        if not ayon_ids:\n            return\n\n        versions_by_id = {\n            version[\"id\"]: version\n            for version in ayon_api.get_versions(\n                self.project_name,\n                version_ids=ayon_ids,\n                fields={\"id\", \"status\"},\n            )\n        }\n        status_name_by_id = {\n            status[\"id\"]: status[\"name\"]\n            for status in self._ft_session.query(\n                \"select id, name from Status\"\n            ).all()\n        }\n\n        op_count = 0\n        operations = OperationsSession()\n        for ftrack_id, ayon_id in version_mapping.items():\n            # Mapping to AYON entity was not found\n            if not ayon_id:\n                continue\n\n            ay_version = versions_by_id.get(ayon_id)\n            ft_av = asset_version_by_id.get(ftrack_id)\n            # Entities are not found\n            if ay_version is None or ft_av is None:\n                continue\n\n            # AYON version was already mapped to a different ftrack version\n            if self._ids_mapping.get_ftrack_mapping(ayon_id):\n                continue\n            self._ids_mapping.set_ftrack_to_server(ftrack_id, ayon_id)\n\n            ft_status_id = ft_av[\"status_id\"]\n            status_name = status_name_by_id[ft_status_id]\n            ayon_status_name = self._get_ayon_status(\n                ayon_statuses_by_name,\n                \"version\",\n                status_name\n            )\n            # AYON status is not available or is same as current status\n            if (\n                not ayon_status_name\n                or ay_version[\"status\"] == ayon_status_name\n            ):\n                continue\n\n            operations.update_version(\n                self.project_name,\n                ayon_id,\n                status=ayon_status_name,\n            )\n            op_count += 1\n            if op_count == 100:\n                operations.commit()\n                op_count = 0\n\n        if op_count &gt; 0:\n            operations.commit()\n\n    def sync_lists(\n        self,\n        ft_project: \"FtrackEntity\",\n        server_id_conf_id: str,\n        list_type_conf: \"FtrackEntity\",\n        sync_versions: bool,\n    ) -&gt; None:\n        # TODO right now it does not remove AYON lists\n        project_id = ft_project[\"id\"]\n        ft_lists_by_id = {\n            le[\"id\"]: le\n            for le in self._ft_session.query(\n                \"select id, category_id, name, system_type from List\"\n                f\" where project_id is '{project_id}'\"\n            ).all()\n        }\n        if not ft_lists_by_id:\n            return\n\n        list_type_by_id = {}\n        if list_type_conf is not None:\n            default = list_type_conf[\"default\"]\n            if isinstance(default, list):\n                default = default[0]\n\n            # Only lists that have different value from 'default' will have\n            #   set the value\n            list_type_by_id = {\n                le[\"id\"]: default\n                for le in ft_lists_by_id.values()\n                if le[\"system_type\"] == \"task\"\n            }\n\n            for item in query_custom_attribute_values(\n                self._ft_session,\n                {list_type_conf[\"id\"]},\n                list_type_by_id\n            ):\n                value = item[\"value\"]\n                entity_id = item[\"entity_id\"]\n                if value:\n                    if isinstance(value, list):\n                        value = value[0]\n                    list_type_by_id[entity_id] = value\n\n        ay_lists = list(ayon_api.get_entity_lists(\n            self.project_name,\n            fields={\"id\", \"label\", \"entityType\", \"attrib\"}\n        ))\n        ay_lists_by_entity_type = {}\n        ay_lists_by_ftrack_id = {}\n        for ay_list in ay_lists:\n            entity_type = ay_list[\"entityType\"]\n            ay_lists_by_entity_type.setdefault(\n                entity_type, []\n            ).append(ay_list)\n            ftrack_id = ay_list[\"attrib\"].get(FTRACK_ID_ATTRIB)\n            if ftrack_id:\n                ay_lists_by_ftrack_id[ftrack_id] = ay_list\n\n        # Fetch items for lists\n        # - it is not possible to be fetched at once if have different\n        #   'entityType'\n        for ls in ay_lists_by_entity_type.values():\n            ls_by_id = {le[\"id\"]: le for le in ls}\n            for list_e in ayon_api.get_entity_lists(\n                self.project_name,\n                list_ids=ls_by_id,\n                fields={\"id\", \"items.id\", \"items.entityId\"},\n            ):\n                ls_by_id[list_e[\"id\"]][\"items\"] = list_e[\"items\"]\n\n        # Try to match lists based on label\n        ay_lists_by_label = {\n            ay_list[\"label\"]: ay_list\n            for ay_list in ay_lists\n        }\n        for ft_list_id, ft_list in ft_lists_by_id.items():\n            if ft_list_id in ay_lists_by_ftrack_id:\n                continue\n\n            name_low = ft_list[\"name\"].lower()\n            for label, ay_list in ay_lists_by_label.items():\n                if name_low == label.lower():\n                    ay_lists_by_ftrack_id[ft_list_id] = ay_list\n                    break\n\n        # Fetch all list items to find AYON equivalents\n        joined_list_ids = join_filter_values(ft_lists_by_id)\n        ft_list_items_by_list_id = {i: [] for i in ft_lists_by_id}\n        ft_version_ids = set()\n        ft_entity_ids = set()\n        ft_list_items = self._ft_session.query(\n            \"select id, entity_id, list_id from ListObject\"\n            f\" where list_id in ({joined_list_ids})\"\n        ).all()\n        for ft_list_item in ft_list_items:\n            list_id = ft_list_item[\"list_id\"]\n            entity_id = ft_list_item[\"entity_id\"]\n            ft_list_items_by_list_id[list_id].append(ft_list_item)\n            ft_list = ft_lists_by_id[list_id]\n            if ft_list[\"system_type\"] == \"assetversion\":\n                ft_version_ids.add(entity_id)\n            else:\n                ft_entity_ids.add(entity_id)\n\n        # Tasks and folders already have mapping prepared from entities sync\n        ay_id_by_ft_id = {}\n\n        # Sync of ftrack versions is enabled so mapping of versions is\n        #   already filled in '_ids_mapping'\n        _mapping_ids = set(ft_entity_ids)\n        if sync_versions:\n            _mapping_ids |= ft_version_ids\n        for entity_id in _mapping_ids:\n            ayon_id = self._ids_mapping.get_server_mapping(entity_id)\n            if ayon_id:\n                ay_id_by_ft_id[entity_id] = ayon_id\n\n        # Sync of versions is disabled\n        if not sync_versions:\n            mapping = self._find_versions_ayon_mapping(\n                self._ft_session,\n                server_id_conf_id,\n                ft_version_ids,\n            )\n            ay_id_by_ft_id.update(mapping)\n\n        for ftrack_id, ft_list in ft_lists_by_id.items():\n            ay_list = ay_lists_by_ftrack_id.get(ftrack_id)\n            list_type = \"version\"\n            if ft_list[\"system_type\"] != \"assetversion\":\n                list_type = list_type_by_id.get(ftrack_id)\n\n            # Check if AYON list type matches ftrack list type\n            if ay_list is not None:\n                # TODO add logs of skipped sync\n                if ft_list[\"system_type\"] == \"assetversion\":\n                    # Both ftrack and AYON lists are for versions\n                    if ay_list[\"entityType\"] != \"version\":\n                        continue\n\n                elif not list_type:\n                    # AYON list type is not set\n                    continue\n\n                elif ft_list[\"system_type\"] != \"task\":\n                    # Unknown list type in ftrack\n                    # - probably could be validated ahead?\n                    continue\n\n                elif ay_list[\"entityType\"] != list_type:\n                    # AYON list type does not match type defined in ftrack\n                    # - maybe could be validated ahead?\n                    continue\n\n            to_add, to_remove = self._prepare_list_items(\n                ft_list_items_by_list_id[ftrack_id],\n                list_type,\n                ay_list,\n                ay_id_by_ft_id,\n            )\n            if ay_list is None:\n                ayon_api.create_entity_list(\n                    self.project_name,\n                    list_type,\n                    ft_list[\"name\"],\n                    items=[{\"entityId\": i} for i in to_add],\n                    attrib={FTRACK_ID_ATTRIB: ftrack_id},\n                )\n                continue\n\n            if ft_list[\"name\"] != ay_list[\"label\"]:\n                ayon_api.update_entity_list(\n                    self.project_name,\n                    ay_list[\"id\"],\n                    label=ft_list[\"name\"],\n                )\n\n            if to_add:\n                ayon_api.update_entity_list_items(\n                    self.project_name,\n                    ay_list[\"id\"],\n                    items=[{\"entityId\": i} for i in to_add],\n                    mode=\"merge\",\n                )\n\n            if to_remove:\n                ayon_api.update_entity_list_items(\n                    self.project_name,\n                    ay_list[\"id\"],\n                    items=[{\"id\": i} for i in to_remove],\n                    mode=\"delete\",\n                )\n\n            attrib = ay_list[\"attrib\"]\n            attr_ftrack_id = attrib.get(FTRACK_ID_ATTRIB)\n            if attr_ftrack_id != ftrack_id:\n                ayon_api.update_entity_list(\n                    self.project_name,\n                    ay_list[\"id\"],\n                    attrib={FTRACK_ID_ATTRIB: ftrack_id},\n                )\n\n    def _prepare_list_items(\n        self,\n        ft_list_items: list[\"FtrackEntity\"],\n        list_type: str,\n        ayon_list: dict[str, Any],\n        ay_id_by_ft_id: dict[str, str],\n    ) -&gt; tuple[set[str], set[str]]:\n        to_add = set()\n        to_remove = set()\n        if not ft_list_items:\n            return to_add, to_remove\n\n        for item in ft_list_items:\n            ftrack_id = item[\"entity_id\"]\n            ay_id = ay_id_by_ft_id.get(ftrack_id)\n            if not ay_id:\n                continue\n\n            if list_type == \"version\":\n                to_add.add(ay_id)\n                continue\n\n            entity = self._entity_hub.get_entity_by_id(ay_id)\n            if entity and entity.entity_type == list_type:\n                to_add.add(ay_id)\n\n        if ayon_list:\n            for item in ayon_list[\"items\"]:\n                entity_id = item[\"entityId\"]\n                if entity_id in to_add:\n                    to_add.discard(entity_id)\n                else:\n                    to_remove.add(item[\"id\"])\n\n        return to_add, to_remove\n\n    def _find_versions_ayon_mapping(\n        self,\n        ft_session: \"FtrackSession\",\n        server_id_conf_id: str,\n        asset_version_ids: set[str],\n    ) -&gt; dict[str, Union[str, None]]:\n        ayon_id_by_av_id = {\n            asset_version_id: None\n            for asset_version_id in asset_version_ids\n        }\n        if not ayon_id_by_av_id:\n            return ayon_id_by_av_id\n\n        real_values = {}\n        for item in query_custom_attribute_values(\n            ft_session,\n            {server_id_conf_id},\n            asset_version_ids,\n        ):\n            value = item[\"value\"]\n            entity_id = item[\"entity_id\"]\n            real_values[entity_id] = value\n            if value:\n                try:\n                    uuid.UUID(value)\n                except ValueError:\n                    continue\n                ayon_id_by_av_id[entity_id] = value\n\n        missing_ids = {\n            ftrack_id\n            for ftrack_id, ayon_id in ayon_id_by_av_id.items()\n            if not ayon_id\n        }\n        if not missing_ids:\n            return ayon_id_by_av_id\n\n        guessed_ids = self._guess_asset_version_ayon_ids(missing_ids)\n        for ftrack_id, ayon_id in guessed_ids.items():\n            if not ayon_id:\n                continue\n\n            ayon_id_by_av_id[ftrack_id] = ayon_id\n\n            entity_key = collections.OrderedDict((\n                (\"configuration_id\", server_id_conf_id),\n                (\"entity_id\", ftrack_id)\n            ))\n            op = ftrack_api.operation.CreateEntityOperation(\n                \"CustomAttributeValue\",\n                entity_key,\n                {\"value\": ayon_id}\n            )\n            self._ft_session.recorded_operations.push(op)\n\n        if self._ft_session.recorded_operations:\n            try:\n                self._ft_session.commit()\n            finally:\n                self._ft_session.recorded_operations.clear()\n        return ayon_id_by_av_id\n\n    def _guess_asset_version_ayon_ids(\n        self, asset_version_ids: set[str]\n    ) -&gt; dict[str, Optional[str]]:\n        output = {\n            av_id: None\n            for av_id in asset_version_ids\n        }\n        if not asset_version_ids:\n            return output\n\n        joined_asset_version_ids = join_filter_values(asset_version_ids)\n        asset_versions_by_asset_id = {}\n        for asset_version in self._ft_session.query(\n            \"select id, asset_id, version from AssetVersion\"\n            f\" where id in ({joined_asset_version_ids})\"\n        ).all():\n            asset_id = asset_version[\"asset_id\"]\n            versions = asset_versions_by_asset_id.setdefault(asset_id, [])\n            versions.append(asset_version)\n\n        if not asset_versions_by_asset_id:\n            return output\n\n        asset_ids = set(asset_versions_by_asset_id)\n        joined_asset_ids = join_filter_values(asset_ids)\n        assets_by_parent_id = collections.defaultdict(list)\n        assets_by_id = {}\n        for asset in self._ft_session.query(\n            \"select id, name, context_id from Asset\"\n            f\" where id in ({joined_asset_ids})\"\n        ).all():\n            assets_by_id[asset[\"id\"]] = asset\n            parent_id = asset[\"context_id\"]\n            assets_by_parent_id[parent_id].append(asset)\n\n        folders_mapping = {}\n        folder_ids = set()\n        for parent_id in assets_by_parent_id.keys():\n            ayon_id = self._ids_mapping.get_server_mapping(parent_id)\n            try:\n                uuid.UUID(ayon_id)\n            except ValueError:\n                continue\n\n            if ayon_id:\n                folders_mapping[ayon_id] = parent_id\n                folder_ids.add(ayon_id)\n\n        if not folder_ids:\n            return output\n\n        products_by_folder_id = {\n            folder_id: []\n            for folder_id in folder_ids\n        }\n        products_mapping = {}\n        version_ints = set()\n        for product_entity in ayon_api.get_products(\n            self.project_name,\n            folder_ids=folder_ids,\n            fields={\"id\", \"folderId\", \"name\"},\n        ):\n            folder_id = product_entity[\"folderId\"]\n            ftrack_id = folders_mapping[folder_id]\n            product_name_low = product_entity[\"name\"].lower()\n            matching_asset = None\n            alternatives = []\n            for asset in assets_by_parent_id[ftrack_id]:\n                low_name = asset[\"name\"].lower()\n                if low_name == product_name_low:\n                    matching_asset = asset\n                    break\n\n                if product_name_low in low_name:\n                    alternatives.append(asset)\n\n            if matching_asset is None and alternatives:\n                matching_asset = alternatives[0]\n\n            if matching_asset is None:\n                continue\n\n            asset_id = matching_asset[\"id\"]\n\n            version_ints |= {\n                asset_version[\"version\"]\n                for asset_version in asset_versions_by_asset_id[asset_id]\n            }\n\n            product_id = product_entity[\"id\"]\n            products_mapping[asset_id] = product_id\n            products_by_folder_id[folder_id].append(product_entity)\n\n        if not products_mapping:\n            return output\n\n        product_ids = set(products_mapping.values())\n        version_entities_by_product_id = {\n            product_id: []\n            for product_id in product_ids\n        }\n        for version_entity in ayon_api.get_versions(\n            self.project_name,\n            product_ids=product_ids,\n            versions=version_ints,\n            fields={\"id\", \"productId\", \"version\"},\n        ):\n            product_id = version_entity[\"productId\"]\n            version_entities_by_product_id[product_id].append(version_entity)\n\n        for asset_id, asset_versions in asset_versions_by_asset_id.items():\n            asset = assets_by_id.get(asset_id)\n            product_id = products_mapping.get(asset_id)\n            if asset is None or not product_id:\n                continue\n\n            version_ids_by_version = {\n                version[\"version\"]: version[\"id\"]\n                for version in version_entities_by_product_id[product_id]\n            }\n            if not version_ids_by_version:\n                continue\n\n            for asset_version in asset_versions:\n                version = asset_version[\"version\"]\n                version_id = version_ids_by_version.get(version)\n                if version_id is None:\n                    continue\n                asset_version_id = asset_version[\"id\"]\n                output[asset_version_id] = version_id\n\n        return output\n\n    def create_report(\n        self, ft_entities_by_id: dict[str, \"FtrackEntity\"]\n    ) -&gt; None:\n        report_items = []\n\n        # --- Immutable entities ---\n        # Removed entities - they don't have ftrack euqivalent anymore\n        deleted_paths = []\n        for entity_id in self._im_removed_entity_ids:\n            entity = self._entity_hub.get_entity_by_id(entity_id)\n            path = entity.attribs[FTRACK_PATH_ATTRIB]\n            if not path:\n                path = entity.path\n            deleted_paths.append(path)\n\n        deleted_paths.sort()\n        if deleted_paths:\n            report_items.append({\n                \"type\": \"label\",\n                \"value\": \"## Not found entities\"\n            })\n            for path in deleted_paths:\n                self.log.info((\n                    f\"Skipped sync of immutable entity {path} (was removed)\"\n                ))\n                report_items.append({\"type\": \"label\", \"value\": f\"- {path}\"})\n\n        # Changed position or name\n        renamed_mapping = {}\n        changed_hierarchy = (\n            self._im_renamed_entity_ids | self._im_moved_entity_ids\n        )\n        for entity_id in changed_hierarchy:\n            entity = self._entity_hub.get_entity_by_id(entity_id)\n            ftrack_id = entity.attribs[FTRACK_ID_ATTRIB]\n            ft_entity = ft_entities_by_id.get(ftrack_id)\n            if ft_entity is None:\n                continue\n            path = \"/\".join([\n                item[\"name\"]\n                for item in ft_entity[\"link\"]\n                if item[\"type\"] != \"Project\"\n            ])\n            expected_path = entity.attribs[FTRACK_PATH_ATTRIB]\n            if not expected_path:\n                expected_path = entity.path\n            renamed_mapping[path] = expected_path\n\n        renamed_paths = []\n        for path in sorted(renamed_mapping.keys()):\n            renamed_paths.append((path, renamed_mapping[path]))\n\n        if renamed_paths:\n            if report_items:\n                report_items.append({\"type\": \"label\", \"value\": \"---\"})\n            report_items.append({\n                \"type\": \"label\",\n                \"value\": \"## Renamed/Moved entities\"\n            })\n            report_items.append({\n                \"type\": \"label\",\n                \"value\": (\n                    \"Entities were renamed or moved to different location\"\n                    \" but it is not allowed to propagate the change.\"\n                )\n            })\n            for (path, expected_path) in renamed_paths:\n                self.log.info((\n                    \"Skipped sync of immutable\"\n                    f\" entity {path} -&gt; {expected_path}\"\n                ))\n                report_items.append({\n                    \"type\": \"label\",\n                    \"value\": f\"- {path} -&gt; {expected_path}\"\n                })\n\n        # --- Other possible issues ---\n        synced_path_mapping = collections.defaultdict(list)\n        for ftrack_id, entity in self._duplicated_ftrack_ids.items():\n            synced_path = entity.attribs[FTRACK_PATH_ATTRIB]\n            ft_entity = ft_entities_by_id.get(ftrack_id)\n            if ft_entity is not None:\n                path = \"/\".join([\n                    item[\"name\"]\n                    for item in ft_entity[\"link\"]\n                    if item[\"type\"] != \"Project\"\n                ])\n                synced_path_mapping[synced_path].append(path)\n\n        if synced_path_mapping:\n            if report_items:\n                report_items.append({\"type\": \"label\", \"value\": \"---\"})\n\n            report_items.append({\n                \"type\": \"label\",\n                \"value\": \"## Duplicated names\"\n            })\n            for synced_path in sorted(synced_path_mapping.keys()):\n                paths = synced_path_mapping[synced_path]\n                self.log.info((\n                    \"Skipped sync because duplicated names.\"\n                    \"\\nSource entity: {}\\n{}\"\n                ).format(\n                    synced_path,\n                    \"\\n\".join([f\"- {path}\" for path in paths])\n                ))\n                report_items.append({\n                    \"type\": \"label\",\n                    \"value\": f\"### {synced_path}\"\n                })\n                for path in paths:\n                    report_items.append({\n                        \"type\": \"label\",\n                        \"value\": f\"- {path}\"\n                    })\n\n        if self._missing_link_type:\n            report_items.append({\n                \"type\": \"label\",\n                \"value\": (\n                    f\"## Link type '{self._missing_link_type}' was\"\n                    f\" not found on project '{self.project_name}'\"\n                ),\n            })\n\n        self._report_items = report_items\n</code></pre>"},{"location":"autoapi/services/processor/processor/lib/index.html#services.processor.processor.lib.SyncFromFtrack.log","title":"<code>log</code>  <code>property</code>","text":"<p>Logger object.</p> <p>Returns:</p> Type Description <p>logging.Logger: Logger object.</p>"},{"location":"autoapi/services/processor/processor/lib/index.html#services.processor.processor.lib.SyncFromFtrack.project_name","title":"<code>project_name</code>  <code>property</code>","text":"<p>Name of project which is synchronized.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Project name which is synchronized.</p>"},{"location":"autoapi/services/processor/processor/lib/index.html#services.processor.processor.lib.SyncFromFtrack.report_items","title":"<code>report_items</code>  <code>property</code>","text":"<p>Report items shown once finished.</p> <p>Returns:</p> Type Description <p>list[dict[str, Any]]: List of interface items for ftrack UI.</p>"},{"location":"autoapi/services/processor/processor/lib/index.html#services.processor.processor.lib.SyncFromFtrack.create_project","title":"<code>create_project(preset_name, attributes)</code>","text":"<p>Create project on AYON server.</p> <p>Parameters:</p> Name Type Description Default <code>preset_name</code> <code>str</code> <p>Name of anatomy preset that will be used.</p> required <code>attributes</code> <code>dict[str, Any]</code> <p>Attributes for project creation.</p> required Source code in <code>services/processor/processor/lib/sync_from_ftrack.py</code> <pre><code>def create_project(\n    self,\n    preset_name: str,\n    attributes: dict[str, Any],\n) -&gt; None:\n    \"\"\"Create project on AYON server.\n\n    Args:\n        preset_name (str): Name of anatomy preset that will be used.\n        attributes (dict[str, Any]): Attributes for project creation.\n\n    \"\"\"\n    project_name = self.project_name\n    if self.project_exists_in_ayon():\n        return\n\n    ft_session = self._ft_session\n    ft_project = _get_ftrack_project(ft_session, project_name)\n    self.log.info(f\"Creating project \\\"{project_name}\\\" on server\")\n    project_code = ft_project[\"name\"]\n    create_project(\n        project_name,\n        project_code,\n        preset_name=preset_name\n    )\n    self.log.info(f\"Project \\\"{project_name}\\\" created on server\")\n\n    self.sync_project_types(ft_project, ft_session)\n    self.sync_statuses(ft_project, ft_session)\n    project_entity = self._entity_hub.project_entity\n    for key, value in attributes.items():\n        project_entity.attribs[key] = value\n    self._entity_hub.commit_changes()\n</code></pre>"},{"location":"autoapi/services/processor/processor/lib/index.html#services.processor.processor.lib.SyncFromFtrack.match_existing_entities","title":"<code>match_existing_entities(ft_project, ft_entities_by_parent_id, ft_object_type_name_by_id, ft_type_names_by_id, cust_attr_value_by_entity_id)</code>","text":"<p>Match exiting entities on both sides.</p> <p>Create new entities that are on ftrack and are not on server and remove those which are not on ftrack.</p> Todos <p>Handle duplicates more clearly. Don't compare children only by name     but also by type (right now task == folder).</p> <p>Parameters:</p> Name Type Description Default <code>ft_project</code> <code>Entity</code> <p>ftrack project entity.</p> required <code>ft_entities_by_parent_id</code> <code>dict[str, list[Entity]]</code> <p>Map of ftrack entities by their parent ids.</p> required <code>ft_object_type_name_by_id</code> <code>dict[str, str]</code> <p>Mapping of ftrack object type ids to their names.</p> required <code>ft_type_names_by_id</code> <code>dict[str, str]</code> <p>Mapping of ftrack task type ids to their names.</p> required <code>cust_attr_value_by_entity_id</code> <code>dict[str, dict[str, Any]</code> <p>Custom attribute values by key stored by entity id.</p> required Source code in <code>services/processor/processor/lib/sync_from_ftrack.py</code> <pre><code>def match_existing_entities(\n    self,\n    ft_project: \"FtrackEntity\",\n    ft_entities_by_parent_id: dict[str, list[\"FtrackEntity\"]],\n    ft_object_type_name_by_id: dict[str, \"FtrackEntity\"],\n    ft_type_names_by_id: dict[str, str],\n    cust_attr_value_by_entity_id: dict[str, dict[str, Any]],\n) -&gt; None:\n    \"\"\"Match exiting entities on both sides.\n\n    Create new entities that are on ftrack and are not on server and remove\n    those which are not on ftrack.\n\n    Todos:\n        Handle duplicates more clearly. Don't compare children only by name\n            but also by type (right now task == folder).\n\n    Args:\n        ft_project (FtrackEntity): ftrack project entity.\n        ft_entities_by_parent_id (dict[str, list[FtrackEntity]]): Map\n            of ftrack entities by their parent ids.\n        ft_object_type_name_by_id (dict[str, str]): Mapping of ftrack\n            object type ids to their names.\n        ft_type_names_by_id (dict[str, str]): Mapping of ftrack task type\n            ids to their names.\n        cust_attr_value_by_entity_id (dict[str, dict[str, Any]): Custom\n            attribute values by key stored by entity id.\n    \"\"\"\n\n    fill_queue = collections.deque()\n    for ft_child in ft_entities_by_parent_id[ft_project[\"id\"]]:\n        fill_queue.append((self._entity_hub.project_entity, ft_child))\n\n    def _add_children_to_queue(ft_entity_id):\n        children = ft_entities_by_parent_id[ft_entity_id]\n        if not children:\n            return\n\n        entity_id = self._ids_mapping.get_server_mapping(ft_entity_id)\n        entity = None\n        if entity_id:\n            entity = self._entity_hub.get_entity_by_id(entity_id)\n\n        for ft_child in children:\n            fill_queue.append((entity, ft_child))\n\n    while fill_queue:\n        (parent_entity, ft_entity) = fill_queue.popleft()\n        ft_entity_path = \"/\".join([\n            item[\"name\"]\n            for item in ft_entity[\"link\"]\n        ])\n        ft_entity_id = ft_entity[\"id\"]\n        # Go to next children if is already processed\n        if ft_entity_id in self._processed_ftrack_ids:\n            _add_children_to_queue(ft_entity_id)\n            self.log.debug(\n                f\"{ft_entity_path} - ftrack id already processed\")\n            continue\n\n        if parent_entity is None:\n            self._skipped_ftrack_ids.add(ft_entity_id)\n            _add_children_to_queue(ft_entity_id)\n            self.log.debug(f\"{ft_entity_path} - Skipped\")\n            continue\n\n        if (\n            parent_entity.entity_type == \"project\"\n            and ft_entity.entity_type.lower() == \"task\"\n        ):\n            self._skipped_ftrack_ids.add(ft_entity_id)\n            self.log.debug(\n                f\"{ft_entity_path} - Skipped task at projectroot\"\n            )\n            continue\n\n        label = ft_entity[\"name\"]\n        name = slugify_string(label)\n        matching_name_entity = None\n        for child in parent_entity.children:\n            if child.name.lower() == name.lower():\n                matching_name_entity = child\n                break\n\n        ft_is_folder = ft_entity.entity_type != \"Task\"\n        if matching_name_entity is not None:\n            # If entity was already processed we can skip ftrack entity\n            # --- This is last condition that handle immutable entities ---\n            #   After this condition can be server entities changed,\n            #       removed or created.\n            if matching_name_entity.id in self._processed_server_ids:\n                self._processed_ftrack_ids.add(ft_entity_id)\n                self._duplicated_ftrack_ids[ft_entity_id] = (\n                    matching_name_entity\n                )\n                _add_children_to_queue(ft_entity_id)\n                self.log.debug(\n                    f\"{ft_entity_path} - Server id already processed\")\n                continue\n\n            is_folder = matching_name_entity.entity_type == \"folder\"\n            # It is possible to remove previous server entity at this point\n            #   as we're 100% sure it is not immutable at this point\n            if ft_is_folder is not is_folder:\n                self.log.debug(\n                    f\"{ft_entity_path} - Deleted previous entity\")\n                # Remove current entity if type does not match\n                matching_name_entity.parent_id = None\n                # Reset variable so new entity is created\n                matching_name_entity = None\n\n        # No match was found, so we can create new server entity\n        if matching_name_entity is None:\n            self.log.debug(f\"{ft_entity_path} - Creating new entity\")\n            entity = self._create_new_entity(\n                parent_entity,\n                ft_entity,\n                ft_object_type_name_by_id,\n                ft_type_names_by_id,\n                cust_attr_value_by_entity_id,\n            )\n            self._processed_server_ids.add(entity.id)\n            self._processed_ftrack_ids.add(ft_entity_id)\n            _add_children_to_queue(ft_entity_id)\n            continue\n\n        self.log.debug(f\"{ft_entity_path} - Updating existing entity\")\n        matching_name_entity.name = name\n        matching_name_entity.label = label\n        matching_name_entity.active = True\n        if matching_name_entity.entity_type == \"task\":\n            task_type_id = ft_entity[\"type_id\"]\n            task_type_name = ft_type_names_by_id[task_type_id]\n            if matching_name_entity.task_type != task_type_name:\n                matching_name_entity.task_type = task_type_name\n\n        else:\n            object_type_id = ft_entity[\"object_type_id\"]\n            object_type_name = ft_object_type_name_by_id[\n                object_type_id]\n            if matching_name_entity.folder_type != object_type_name:\n                matching_name_entity.folder_type = object_type_name\n\n        self._processed_server_ids.add(matching_name_entity.id)\n        self._processed_ftrack_ids.add(ft_entity_id)\n        self._ids_mapping.set_ftrack_to_server(\n            ft_entity_id, matching_name_entity.id\n        )\n        _add_children_to_queue(ft_entity_id)\n\n    deactivate_queue = collections.deque()\n    for child in self._entity_hub.project_entity.children:\n        deactivate_queue.append(child)\n\n    while deactivate_queue:\n        entity = deactivate_queue.popleft()\n        if entity.id not in self._processed_server_ids:\n            entity.active = False\n\n        for child in entity.children:\n            deactivate_queue.append(child)\n</code></pre>"},{"location":"autoapi/services/processor/processor/lib/index.html#services.processor.processor.lib.SyncFromFtrack.project_exists_in_ayon","title":"<code>project_exists_in_ayon()</code>","text":"<p>Does project exists on AYON server by name.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Project exists in AYON.</p> Source code in <code>services/processor/processor/lib/sync_from_ftrack.py</code> <pre><code>def project_exists_in_ayon(self) -&gt; bool:\n    \"\"\"Does project exists on AYON server by name.\n\n    Returns:\n        bool: Project exists in AYON.\n    \"\"\"\n\n    # Make sure project exists on server\n    if not self.get_ayon_project():\n        return False\n    return True\n</code></pre>"},{"location":"autoapi/services/processor/processor/lib/index.html#services.processor.processor.lib.SyncFromFtrack.sync_project_types","title":"<code>sync_project_types(ft_project, ft_session)</code>","text":"<p>Sync project types from ftrack to AYON.</p> <p>Parameters:</p> Name Type Description Default <code>ft_project</code> <code>Entity</code> <p>ftrack project entity.</p> required <code>ft_session</code> <code>Session</code> <p>ftrack session.</p> required <p>Returns:</p> Type Description <code>tuple[list[Entity], list[Entity]]</code> <p>tuple[list, list]: Tuple of object types and task types.</p> Source code in <code>services/processor/processor/lib/sync_from_ftrack.py</code> <pre><code>def sync_project_types(\n    self,\n    ft_project: \"FtrackEntity\",\n    ft_session: \"FtrackSession\",\n) -&gt; tuple[list[\"FtrackEntity\"], list[\"FtrackEntity\"]]:\n    \"\"\"Sync project types from ftrack to AYON.\n\n    Args:\n        ft_project (FtrackEntity): ftrack project entity.\n        ft_session (FtrackSession): ftrack session.\n\n    Returns:\n        tuple[list, list]: Tuple of object types and task types.\n    \"\"\"\n\n    self._entity_hub.fill_project_from_server()\n    # Get Folder types and Task types from ftrack\n    ft_object_types = ft_session.query(\n        \"select id, name, sort from ObjectType\").all()\n    ft_object_types_by_id = {\n        ft_object_type[\"id\"]: ft_object_type\n        for ft_object_type in ft_object_types\n    }\n\n    ft_types = ft_session.query(\"select id, name, sort from Type\").all()\n    ft_types_by_id = {\n        ft_type[\"id\"]: ft_type\n        for ft_type in ft_types\n    }\n\n    # Filter folder and task types for this project based on schema\n    project_schema = ft_project[\"project_schema\"]\n    object_types = {\n        ft_object_types_by_id[object_type[\"id\"]]\n        for object_type in project_schema[\"object_types\"]\n    }\n    task_types = {\n        ft_types_by_id[task_type[\"id\"]]\n        for task_type in project_schema[\"task_type_schema\"][\"types\"]\n    }\n\n    # Update types on project entity from ftrack\n    self.update_project_types(object_types, task_types)\n    return object_types, task_types\n</code></pre>"},{"location":"autoapi/services/processor/processor/lib/index.html#services.processor.processor.lib.SyncFromFtrack.sync_to_server","title":"<code>sync_to_server()</code>","text":"<p>Sync project with hierarchy from ftrack to AYON server.</p> Source code in <code>services/processor/processor/lib/sync_from_ftrack.py</code> <pre><code>def sync_to_server(self) -&gt; None:\n    \"\"\"Sync project with hierarchy from ftrack to AYON server.\"\"\"\n\n    t_start = time.perf_counter()\n    project_name = self.project_name\n    # Make sure project exists on server\n    if not self.project_exists_in_ayon():\n        self.log.info(\n            f\"Project \\\"{project_name}\\\" does not exist on server.\"\n            \" Skipping project synchronization.\"\n        )\n        self._report_items.extend([\n            {\n                \"type\": \"label\",\n                \"value\": (\n                    f\"## Project '{project_name}' does not exist in AYON\"\n                )\n            },\n            {\n                \"type\": \"label\",\n                \"value\": (\n                    \"Synchronization was skipped.\"\n                    \"&lt;br/&gt;Run Prepare Project action or create the\"\n                    \" project manually on server and then run the\"\n                    \" action again.\"\n                )\n            }\n        ])\n        return\n\n    ft_session = self._ft_session\n\n    if not self.ensure_mandatory_custom_attributes_exists(ft_session):\n        return\n\n    self.log.info(\n        f\"Synchronization of project \\\"{project_name}\\\" started\"\n    )\n\n    # Get ftrack custom attributes to sync\n    attr_confs = ft_session.query(\n        \"select id, key, is_hierarchical, default\"\n        \" from CustomAttributeConfiguration\"\n    ).all()\n\n    # Check if there is custom attribute to store server id\n    server_id_conf_id = None\n    server_path_conf_id = None\n    sync_failed_conf_id = None\n    list_type_conf = None\n    for attr_conf in attr_confs:\n        if attr_conf[\"key\"] == CUST_ATTR_KEY_SERVER_ID:\n            server_id_conf_id = attr_conf[\"id\"]\n        elif attr_conf[\"key\"] == CUST_ATTR_KEY_SERVER_PATH:\n            server_path_conf_id = attr_conf[\"id\"]\n        elif attr_conf[\"key\"] == CUST_ATTR_KEY_SYNC_FAIL:\n            sync_failed_conf_id = attr_conf[\"id\"]\n        elif attr_conf[\"key\"] == CUST_ATTR_KEY_LIST_TYPE:\n            list_type_conf = attr_conf\n\n    missing_attrs = []\n    if not server_id_conf_id:\n        missing_attrs.append(CUST_ATTR_KEY_SERVER_ID)\n\n    if not server_path_conf_id:\n        missing_attrs.append(CUST_ATTR_KEY_SERVER_PATH)\n\n    if not sync_failed_conf_id:\n        missing_attrs.append(CUST_ATTR_KEY_SYNC_FAIL)\n\n    if missing_attrs:\n        attr_end = \"\"\n        was_were = \"was\"\n        if len(missing_attrs) &gt; 1:\n            attr_end = \"s\"\n            was_were = \"were\"\n        joined_attrs = \", \".join([f'\"{attr}\"'for attr in missing_attrs])\n        msg = (\n            f\"Hierarchical attribute{attr_end} {joined_attrs}\"\n            f\" {was_were} not found in ftrack\"\n        )\n\n        self.log.warning(msg)\n        raise ValueError(msg)\n\n    # Query ftrack project\n    ft_project = _get_ftrack_project(ft_session, project_name)\n\n    ft_status_by_id = {\n        status[\"id\"]: status\n        for status in self._ft_session.query(\n            \"select id, name, color, state, sort from Status\"\n        ).all()\n    }\n    self.sync_project_types(ft_project, ft_session)\n    self.sync_statuses(\n        ft_project,\n        ft_session,\n        ft_status_by_id\n    )\n\n    self._entity_hub.commit_changes()\n\n    t_project_existence_1 = time.perf_counter()\n    self.log.debug(\n        \"Initial preparation took\"\n        f\" {t_project_existence_1 - t_start:.2f}s\"\n    )\n    self.log.debug(\"Loading entities from server\")\n    # Query entities from server (project, folders and tasks)\n    self._entity_hub.fetch_hierarchy_entities()\n    self._ids_mapping.set_ftrack_to_server(\n        ft_project[\"id\"], self._entity_hub.project_entity.id\n    )\n    t_server_query_2 = time.perf_counter()\n    self.log.debug((\n        \"Loading of entities from server took\"\n        f\" {t_server_query_2 - t_project_existence_1:.2f}s\"\n    ))\n\n    self.log.info(\"Querying necessary data from ftrack\")\n\n    object_types, task_types = self.sync_project_types(\n        ft_project, ft_session\n    )\n    ft_object_type_name_by_id = {\n        object_type[\"id\"]: object_type[\"name\"]\n        for object_type in object_types\n    }\n    ft_type_names_by_id = {\n        task_type[\"id\"]: task_type[\"name\"]\n        for task_type in task_types\n    }\n\n    t_types_sync_3 = time.perf_counter()\n    self.log.debug((\n        \"Update of types from ftrack took\"\n        f\" {t_types_sync_3 - t_server_query_2:.2f}s\"\n    ))\n\n    self.log.info(\"Querying project hierarchy from ftrack\")\n    ft_entities = ft_session.query((\n        \"select id, name, parent_id, type_id, object_type_id, status_id\"\n        \", start_date, end_date, description, status_id\"\n        \" from TypedContext where project_id is \\\"{}\\\"\"\n    ).format(ft_project[\"id\"])).all()\n    t_ft_entities_4 = time.perf_counter()\n    self.log.debug((\n        \"Query of ftrack entities took\"\n        f\" {t_ft_entities_4 - t_types_sync_3:.2f}s\"\n    ))\n\n    ft_entities_by_id = {ft_project[\"id\"]: ft_project}\n    ft_entities_by_parent_id = collections.defaultdict(list)\n    for entity in ft_entities:\n        entity_id = entity[\"id\"]\n        parent_id = entity[\"parent_id\"]\n        ft_entities_by_id[entity_id] = entity\n        ft_entities_by_parent_id[parent_id].append(entity)\n\n    cust_attr_value_by_entity_id = self._prepare_attribute_values(\n        ft_session,\n        attr_confs,\n        ft_entities_by_id,\n    )\n\n    self.log.info(\"Checking changes of immutable entities\")\n    self.match_immutable_entities(\n        ft_project,\n        ft_entities_by_id,\n        ft_entities_by_parent_id,\n    )\n\n    self.log.info(\"Matching ftrack to server hierarchy\")\n    self.match_existing_entities(\n        ft_project,\n        ft_entities_by_parent_id,\n        ft_object_type_name_by_id,\n        ft_type_names_by_id,\n        cust_attr_value_by_entity_id\n    )\n\n    self.log.info(\"Updating assignees\")\n    self.update_assignees_from_ftrack(\n        ft_entities_by_id\n    )\n\n    self.log.info(\"Updating attributes of entities\")\n\n    ayon_statuses_by_name = {\n        status[\"name\"].lower(): status\n        for status in self._entity_hub.project_entity[\"statuses\"]\n    }\n    self.update_attributes_from_ftrack(\n        cust_attr_value_by_entity_id,\n        ft_entities_by_id,\n        ft_status_by_id,\n        ayon_statuses_by_name,\n    )\n    self._entity_hub.commit_changes()\n\n    self.log.info(\"Updating entity links\")\n    self.update_links_from_ftrack(ft_entities_by_id)\n\n    self.log.info(\"Updating server ids on ftrack entities\")\n    self.update_ftrack_attributes(\n        ft_entities_by_id,\n        cust_attr_value_by_entity_id,\n        server_id_conf_id,\n        server_path_conf_id,\n        sync_failed_conf_id\n    )\n\n    settings = self.get_ftrack_project_settings()\n    sync_versions: bool = (\n        settings\n        [\"service_event_handlers\"]\n        [\"sync_from_ftrack\"]\n        [\"sync_versions\"]\n    )\n    if sync_versions:\n        self.log.info(\"Synchronizing versions\")\n        t_version_start = time.perf_counter()\n        self.update_versions(\n            ft_session,\n            ft_entities_by_id,\n            server_id_conf_id,\n            ayon_statuses_by_name,\n        )\n        t_version_end = time.perf_counter()\n        self.log.info(\n            \"Synchronizing versions took\"\n            f\" {t_version_end - t_version_start:.2f}s\"\n        )\n\n    self.log.info(\"Synchronizing version lists\")\n    self.sync_lists(\n        ft_project,\n        server_id_conf_id,\n        list_type_conf,\n        sync_versions,\n    )\n\n    self.create_report(ft_entities_by_id)\n    t_end = time.perf_counter()\n    self.log.info((\n        f\"Synchronization of project \\\"{project_name}\\\" finished\"\n        f\" in {t_end - t_start:.2f}s\"\n    ))\n</code></pre>"},{"location":"autoapi/services/processor/processor/lib/index.html#services.processor.processor.lib.SyncFromFtrack.update_versions","title":"<code>update_versions(ft_session, ft_entities_by_id, server_id_conf_id, ayon_statuses_by_name)</code>","text":"<p>Synchronize versions information to AYON.</p> <p>Parameters:</p> Name Type Description Default <code>ft_session</code> <code>Session</code> <p>Ftrack session.</p> required <code>ft_entities_by_id</code> <code>dict[str, Entity]</code> <p>Mapping of ftrack entity ids.</p> required <code>server_id_conf_id</code> <code>str</code> <p>Id of 'ayon_id' custom attribute.</p> required <code>ayon_statuses_by_name</code> <code>dict[str, dict[str, Any]]</code> <p>Mapping of AYON statuses by name.</p> required Source code in <code>services/processor/processor/lib/sync_from_ftrack.py</code> <pre><code>def update_versions(\n    self,\n    ft_session: \"FtrackSession\",\n    ft_entities_by_id: dict[str, \"FtrackEntity\"],\n    server_id_conf_id: str,\n    ayon_statuses_by_name: dict[str, dict[str, Any]],\n) -&gt; None:\n    \"\"\"Synchronize versions information to AYON.\n\n    Args:\n        ft_session (FtrackSession): Ftrack session.\n        ft_entities_by_id (dict[str, FtrackEntity]): Mapping of ftrack\n            entity ids.\n        server_id_conf_id (str): Id of 'ayon_id' custom attribute.\n        ayon_statuses_by_name (dict[str, dict[str, Any]]): Mapping of AYON\n            statuses by name.\n\n    \"\"\"\n    context_ids = set()\n    for entity in ft_entities_by_id.values():\n        if entity.entity_type != \"Task\":\n            context_ids.add(entity[\"id\"])\n\n    if not context_ids:\n        return\n\n    assets_by_id = {}\n    asset_ids_by_context_id = {\n        context_id: []\n        for context_id in context_ids\n    }\n    for chunk in create_chunks(context_ids, 50):\n        joined_ids = join_filter_values(chunk)\n        for asset in ft_session.query(\n            \"select id, context_id, name from Asset\"\n            f\" where context_id in ({joined_ids})\"\n        ):\n            asset_id = asset[\"id\"]\n            context_id = asset[\"context_id\"]\n            assets_by_id[asset_id] = asset\n            asset_ids_by_context_id[context_id].append(asset_id)\n\n    if not assets_by_id:\n        return\n\n    asset_version_by_id = {}\n    asset_version_ids_by_asset_id = {\n        asset_id: []\n        for asset_id in assets_by_id\n    }\n    for chunk in create_chunks(assets_by_id, 50):\n        joined_ids = join_filter_values(chunk)\n        for asset_version in ft_session.query(\n            \"select id, asset_id, version, status_id from AssetVersion\"\n            f\" where asset_id in ({joined_ids})\"\n        ):\n            av_id = asset_version[\"id\"]\n            asset_id = asset_version[\"asset_id\"]\n            asset_version_by_id[av_id] = asset_version\n            asset_version_ids_by_asset_id[asset_id].append(av_id)\n\n    version_mapping = self._find_versions_ayon_mapping(\n        ft_session,\n        server_id_conf_id,\n        set(asset_version_by_id.keys()),\n    )\n    ayon_ids = set(version_mapping.values())\n    ayon_ids.discard(None)\n    if not ayon_ids:\n        return\n\n    versions_by_id = {\n        version[\"id\"]: version\n        for version in ayon_api.get_versions(\n            self.project_name,\n            version_ids=ayon_ids,\n            fields={\"id\", \"status\"},\n        )\n    }\n    status_name_by_id = {\n        status[\"id\"]: status[\"name\"]\n        for status in self._ft_session.query(\n            \"select id, name from Status\"\n        ).all()\n    }\n\n    op_count = 0\n    operations = OperationsSession()\n    for ftrack_id, ayon_id in version_mapping.items():\n        # Mapping to AYON entity was not found\n        if not ayon_id:\n            continue\n\n        ay_version = versions_by_id.get(ayon_id)\n        ft_av = asset_version_by_id.get(ftrack_id)\n        # Entities are not found\n        if ay_version is None or ft_av is None:\n            continue\n\n        # AYON version was already mapped to a different ftrack version\n        if self._ids_mapping.get_ftrack_mapping(ayon_id):\n            continue\n        self._ids_mapping.set_ftrack_to_server(ftrack_id, ayon_id)\n\n        ft_status_id = ft_av[\"status_id\"]\n        status_name = status_name_by_id[ft_status_id]\n        ayon_status_name = self._get_ayon_status(\n            ayon_statuses_by_name,\n            \"version\",\n            status_name\n        )\n        # AYON status is not available or is same as current status\n        if (\n            not ayon_status_name\n            or ay_version[\"status\"] == ayon_status_name\n        ):\n            continue\n\n        operations.update_version(\n            self.project_name,\n            ayon_id,\n            status=ayon_status_name,\n        )\n        op_count += 1\n        if op_count == 100:\n            operations.commit()\n            op_count = 0\n\n    if op_count &gt; 0:\n        operations.commit()\n</code></pre>"},{"location":"autoapi/services/processor/processor/lib/sync_from_ftrack.html","title":"sync_from_ftrack","text":""},{"location":"autoapi/services/processor/processor/lib/sync_from_ftrack.html#services.processor.processor.lib.sync_from_ftrack.SyncFromFtrack","title":"<code>SyncFromFtrack</code>","text":"<p>Helper for sync project from ftrack.</p> Source code in <code>services/processor/processor/lib/sync_from_ftrack.py</code> <pre><code>class SyncFromFtrack:\n    \"\"\"Helper for sync project from ftrack.\"\"\"\n\n    def __init__(self, session, project_name, log=None):\n        self._log = log\n        self._ft_session = session\n        self._project_name = project_name\n        self._ids_mapping = IdsMapping()\n        self._ayon_project = NOT_SET\n\n        ft_users = session.query(\"select id, username, email from User\").all()\n        users_mapping = map_ftrack_users_to_ayon_users(ft_users)\n        for ftrack_id, ayon_id in users_mapping.items():\n            if ayon_id:\n                self._ids_mapping.set_ftrack_to_server(ftrack_id, ayon_id)\n\n        # Create entity hub which handle entity changes\n        self._entity_hub = EntityHub(project_name)\n        self._ftrack_settings = None\n        self._ftrack_project_settings = None\n\n        self._report_items = []\n\n        # TODO add more and use them\n        self._processed_server_ids = set()\n        self._processed_ftrack_ids = set()\n        self._skipped_ftrack_ids = set()\n        self._duplicated_ftrack_ids = {}\n        # Immutable\n        self._im_invalid_entity_ids = set()\n        self._im_renamed_entity_ids = set()\n        self._im_moved_entity_ids = set()\n        self._im_removed_entity_ids = set()\n\n        self._missing_link_type = None\n\n    @property\n    def project_name(self):\n        \"\"\"Name of project which is synchronized.\n\n        Returns:\n            str: Project name which is synchronized.\n        \"\"\"\n\n        return self._project_name\n\n    @property\n    def log(self):\n        \"\"\"Logger object.\n\n        Returns:\n            logging.Logger: Logger object.\n        \"\"\"\n\n        if self._log is None:\n            self._log = logging.getLogger(self.__class__.__name__)\n        return self._log\n\n    @property\n    def report_items(self):\n        \"\"\"Report items shown once finished.\n\n        Returns:\n            list[dict[str, Any]]: List of interface items for ftrack UI.\n        \"\"\"\n\n        return self._report_items\n\n    def sync_project_types(\n        self,\n        ft_project: \"FtrackEntity\",\n        ft_session: \"FtrackSession\",\n    ) -&gt; tuple[list[\"FtrackEntity\"], list[\"FtrackEntity\"]]:\n        \"\"\"Sync project types from ftrack to AYON.\n\n        Args:\n            ft_project (FtrackEntity): ftrack project entity.\n            ft_session (FtrackSession): ftrack session.\n\n        Returns:\n            tuple[list, list]: Tuple of object types and task types.\n        \"\"\"\n\n        self._entity_hub.fill_project_from_server()\n        # Get Folder types and Task types from ftrack\n        ft_object_types = ft_session.query(\n            \"select id, name, sort from ObjectType\").all()\n        ft_object_types_by_id = {\n            ft_object_type[\"id\"]: ft_object_type\n            for ft_object_type in ft_object_types\n        }\n\n        ft_types = ft_session.query(\"select id, name, sort from Type\").all()\n        ft_types_by_id = {\n            ft_type[\"id\"]: ft_type\n            for ft_type in ft_types\n        }\n\n        # Filter folder and task types for this project based on schema\n        project_schema = ft_project[\"project_schema\"]\n        object_types = {\n            ft_object_types_by_id[object_type[\"id\"]]\n            for object_type in project_schema[\"object_types\"]\n        }\n        task_types = {\n            ft_types_by_id[task_type[\"id\"]]\n            for task_type in project_schema[\"task_type_schema\"][\"types\"]\n        }\n\n        # Update types on project entity from ftrack\n        self.update_project_types(object_types, task_types)\n        return object_types, task_types\n\n    def get_ftrack_settings(self):\n        if self._ftrack_settings is None:\n            settings = get_addons_settings()\n            self._ftrack_settings = settings[\"ftrack\"]\n        return copy.deepcopy(self._ftrack_settings)\n\n    def get_ftrack_project_settings(self):\n        if self._ftrack_project_settings is None:\n            settings = get_addons_settings(project_name=self.project_name)\n            self._ftrack_project_settings = settings[\"ftrack\"]\n        return copy.deepcopy(self._ftrack_project_settings)\n\n    def sync_statuses(\n        self,\n        ft_project: \"FtrackEntity\",\n        ft_session: \"FtrackSession\",\n        ft_status_by_id: Optional[dict[str, \"FtrackEntity\"]] = None,\n    ) -&gt; None:\n        if ft_status_by_id is None:\n            ft_status_by_id = {\n                status[\"id\"]: status\n                for status in ft_session.query(\n                    \"select id, name, color, state, sort from Status\"\n                ).all()\n            }\n\n        fields = {\n            \"asset_version_workflow_schema\",\n            \"task_workflow_schema\",\n            \"task_workflow_schema_overrides\",\n            \"object_type_schemas\",\n        }\n        project_schema_id = ft_project[\"project_schema_id\"]\n\n        joined_fields = \", \".join(fields)\n        project_schema = ft_session.query(\n            f\"select {joined_fields} from ProjectSchema\"\n            f\" where id is '{project_schema_id}'\"\n        ).first()\n\n        # Folder statuses\n        schema_ids = {\n            schema[\"id\"]\n            for schema in project_schema[\"object_type_schemas\"]\n        }\n        object_type_schemas = []\n        if schema_ids:\n            joined_schema_ids = join_filter_values(schema_ids)\n            object_type_schemas = ft_session.query(\n                \"select id, object_type_id from Schema\"\n                f\" where id in ({joined_schema_ids})\"\n            ).all()\n\n        object_type_schema_ids = {\n            schema[\"id\"]\n            for schema in object_type_schemas\n        }\n        folder_statuses_ids = set()\n        if object_type_schema_ids:\n            joined_ot_schema_ids = join_filter_values(object_type_schema_ids)\n            schema_statuses = ft_session.query(\n                \"select status_id from SchemaStatus\"\n                f\" where schema_id in ({joined_ot_schema_ids})\"\n            ).all()\n            folder_statuses_ids = {\n                status[\"status_id\"]\n                for status in schema_statuses\n            }\n\n        # Task statues\n        task_workflow_override_ids = {\n            task_override[\"id\"]\n            for task_override in (\n                project_schema[\"task_workflow_schema_overrides\"]\n            )\n        }\n        workflow_ids = set()\n        if task_workflow_override_ids:\n            joined_ids = join_filter_values(task_workflow_override_ids)\n            override_schemas = ft_session.query(\n                \"select workflow_schema_id\"\n                f\" from ProjectSchemaOverride\"\n                f\" where id in ({joined_ids})\"\n            ).all()\n            workflow_ids = {\n                override_schema[\"workflow_schema_id\"]\n                for override_schema in override_schemas\n            }\n\n        workflow_ids.add(project_schema[\"task_workflow_schema\"][\"id\"])\n        joined_workflow_ids = join_filter_values(workflow_ids)\n        workflow_statuses = ft_session.query(\n            \"select status_id\"\n            \" from WorkflowSchemaStatus\"\n            f\" where workflow_schema_id in ({joined_workflow_ids})\"\n        ).all()\n        task_status_ids = {\n            item[\"status_id\"]\n            for item in workflow_statuses\n        }\n\n        # Version statuses\n        av_workflow_schema_id = (\n            project_schema[\"asset_version_workflow_schema\"][\"id\"]\n        )\n        version_statuse_ids = {\n            item[\"status_id\"]\n            for item in ft_session.query(\n                \"select status_id\"\n                \" from WorkflowSchemaStatus\"\n                f\" where workflow_schema_id is '{av_workflow_schema_id}'\"\n            ).all()\n        }\n\n        all_status_ids = (\n            folder_statuses_ids\n            | task_status_ids\n            | version_statuse_ids\n        )\n        state_mapping = {\n            \"Blocked\": \"blocked\",\n            \"Not Started\": \"not_started\",\n            \"In Progress\": \"in_progress\",\n            \"Done\": \"done\",\n        }\n        statuses_data = []\n        for status_id in all_status_ids:\n            status = ft_status_by_id[status_id]\n            scope = [\"representation\", \"workfile\"]\n            if status_id in folder_statuses_ids:\n                scope.append(\"folder\")\n            if status_id in task_status_ids:\n                scope.append(\"task\")\n            if status_id in version_statuse_ids:\n                scope.append(\"product\")\n                scope.append(\"version\")\n\n            ft_state = status[\"state\"][\"name\"]\n            ayon_state = state_mapping[ft_state]\n            statuses_data.append({\n                \"name\": status[\"name\"],\n                \"color\": status[\"color\"],\n                \"state\": ayon_state,\n                \"scope\": scope,\n                \"sort\": status[\"sort\"],\n            })\n        statuses_data.sort(key=lambda i: i[\"sort\"], reverse=True)\n\n        statuses = self._entity_hub.project_entity.statuses\n        for idx, status_data in enumerate(statuses_data):\n            status_item = statuses.get_status_by_slugified_name(\n                status_data[\"name\"]\n            )\n            if status_item is None:\n                statuses.insert(idx, status_data)\n                continue\n            status_item.name = status_data[\"name\"]\n            status_item.color = status_data[\"color\"]\n            status_item.state = status_data[\"state\"]\n            status_item.scope = status_data[\"scope\"]\n            statuses.insert(idx, status_item)\n\n    def _get_available_ft_statuses(\n        self,\n        ft_entity: \"FtrackEntity\",\n        project_schema_id: str,\n    ) -&gt; set[str]:\n        fields = {\n            \"asset_version_workflow_schema\",\n            \"task_workflow_schema\",\n            \"task_workflow_schema_overrides\",\n            \"object_type_schemas\",\n        }\n\n        joined_fields = \", \".join(fields)\n        project_schema = self._session.query(\n            f\"select {joined_fields} from ProjectSchema\"\n            f\" where id is '{project_schema_id}'\"\n        ).first()\n\n        type_id = ft_entity[\"type_id\"]\n        task_workflow_override_ids = {\n            task_override[\"id\"]\n            for task_override in\n            project_schema[\"task_workflow_schema_overrides\"]\n        }\n        overrides_schema = None\n        if task_workflow_override_ids:\n            joined_ids = join_filter_values(task_workflow_override_ids)\n            overrides_schema = self._session.query(\n                \"select workflow_schema_id\"\n                f\" from ProjectSchemaOverride\"\n                f\" where id in ({joined_ids}) and type_id is '{type_id}'\"\n            ).first()\n\n        workflow_id = project_schema[\"task_workflow_schema\"][\"id\"]\n        if overrides_schema is not None:\n            workflow_id = overrides_schema[\"workflow_schema_id\"]\n        workflow_statuses = self._session.query(\n            \"select status_id\"\n            \" from WorkflowSchemaStatus\"\n            f\" where workflow_schema_id is '{workflow_id}'\"\n        ).all()\n        return {\n            item[\"status_id\"]\n            for item in workflow_statuses\n        }\n\n    def get_ayon_project(self) -&gt; Optional[dict[str, Any]]:\n        if self._ayon_project is NOT_SET:\n            self._ayon_project = get_project(self.project_name)\n        return self._ayon_project\n\n    def project_exists_in_ayon(self) -&gt; bool:\n        \"\"\"Does project exists on AYON server by name.\n\n        Returns:\n            bool: Project exists in AYON.\n        \"\"\"\n\n        # Make sure project exists on server\n        if not self.get_ayon_project():\n            return False\n        return True\n\n    def create_project(\n        self,\n        preset_name: str,\n        attributes: dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Create project on AYON server.\n\n        Args:\n            preset_name (str): Name of anatomy preset that will be used.\n            attributes (dict[str, Any]): Attributes for project creation.\n\n        \"\"\"\n        project_name = self.project_name\n        if self.project_exists_in_ayon():\n            return\n\n        ft_session = self._ft_session\n        ft_project = _get_ftrack_project(ft_session, project_name)\n        self.log.info(f\"Creating project \\\"{project_name}\\\" on server\")\n        project_code = ft_project[\"name\"]\n        create_project(\n            project_name,\n            project_code,\n            preset_name=preset_name\n        )\n        self.log.info(f\"Project \\\"{project_name}\\\" created on server\")\n\n        self.sync_project_types(ft_project, ft_session)\n        self.sync_statuses(ft_project, ft_session)\n        project_entity = self._entity_hub.project_entity\n        for key, value in attributes.items():\n            project_entity.attribs[key] = value\n        self._entity_hub.commit_changes()\n\n    def sync_to_server(self) -&gt; None:\n        \"\"\"Sync project with hierarchy from ftrack to AYON server.\"\"\"\n\n        t_start = time.perf_counter()\n        project_name = self.project_name\n        # Make sure project exists on server\n        if not self.project_exists_in_ayon():\n            self.log.info(\n                f\"Project \\\"{project_name}\\\" does not exist on server.\"\n                \" Skipping project synchronization.\"\n            )\n            self._report_items.extend([\n                {\n                    \"type\": \"label\",\n                    \"value\": (\n                        f\"## Project '{project_name}' does not exist in AYON\"\n                    )\n                },\n                {\n                    \"type\": \"label\",\n                    \"value\": (\n                        \"Synchronization was skipped.\"\n                        \"&lt;br/&gt;Run Prepare Project action or create the\"\n                        \" project manually on server and then run the\"\n                        \" action again.\"\n                    )\n                }\n            ])\n            return\n\n        ft_session = self._ft_session\n\n        if not self.ensure_mandatory_custom_attributes_exists(ft_session):\n            return\n\n        self.log.info(\n            f\"Synchronization of project \\\"{project_name}\\\" started\"\n        )\n\n        # Get ftrack custom attributes to sync\n        attr_confs = ft_session.query(\n            \"select id, key, is_hierarchical, default\"\n            \" from CustomAttributeConfiguration\"\n        ).all()\n\n        # Check if there is custom attribute to store server id\n        server_id_conf_id = None\n        server_path_conf_id = None\n        sync_failed_conf_id = None\n        list_type_conf = None\n        for attr_conf in attr_confs:\n            if attr_conf[\"key\"] == CUST_ATTR_KEY_SERVER_ID:\n                server_id_conf_id = attr_conf[\"id\"]\n            elif attr_conf[\"key\"] == CUST_ATTR_KEY_SERVER_PATH:\n                server_path_conf_id = attr_conf[\"id\"]\n            elif attr_conf[\"key\"] == CUST_ATTR_KEY_SYNC_FAIL:\n                sync_failed_conf_id = attr_conf[\"id\"]\n            elif attr_conf[\"key\"] == CUST_ATTR_KEY_LIST_TYPE:\n                list_type_conf = attr_conf\n\n        missing_attrs = []\n        if not server_id_conf_id:\n            missing_attrs.append(CUST_ATTR_KEY_SERVER_ID)\n\n        if not server_path_conf_id:\n            missing_attrs.append(CUST_ATTR_KEY_SERVER_PATH)\n\n        if not sync_failed_conf_id:\n            missing_attrs.append(CUST_ATTR_KEY_SYNC_FAIL)\n\n        if missing_attrs:\n            attr_end = \"\"\n            was_were = \"was\"\n            if len(missing_attrs) &gt; 1:\n                attr_end = \"s\"\n                was_were = \"were\"\n            joined_attrs = \", \".join([f'\"{attr}\"'for attr in missing_attrs])\n            msg = (\n                f\"Hierarchical attribute{attr_end} {joined_attrs}\"\n                f\" {was_were} not found in ftrack\"\n            )\n\n            self.log.warning(msg)\n            raise ValueError(msg)\n\n        # Query ftrack project\n        ft_project = _get_ftrack_project(ft_session, project_name)\n\n        ft_status_by_id = {\n            status[\"id\"]: status\n            for status in self._ft_session.query(\n                \"select id, name, color, state, sort from Status\"\n            ).all()\n        }\n        self.sync_project_types(ft_project, ft_session)\n        self.sync_statuses(\n            ft_project,\n            ft_session,\n            ft_status_by_id\n        )\n\n        self._entity_hub.commit_changes()\n\n        t_project_existence_1 = time.perf_counter()\n        self.log.debug(\n            \"Initial preparation took\"\n            f\" {t_project_existence_1 - t_start:.2f}s\"\n        )\n        self.log.debug(\"Loading entities from server\")\n        # Query entities from server (project, folders and tasks)\n        self._entity_hub.fetch_hierarchy_entities()\n        self._ids_mapping.set_ftrack_to_server(\n            ft_project[\"id\"], self._entity_hub.project_entity.id\n        )\n        t_server_query_2 = time.perf_counter()\n        self.log.debug((\n            \"Loading of entities from server took\"\n            f\" {t_server_query_2 - t_project_existence_1:.2f}s\"\n        ))\n\n        self.log.info(\"Querying necessary data from ftrack\")\n\n        object_types, task_types = self.sync_project_types(\n            ft_project, ft_session\n        )\n        ft_object_type_name_by_id = {\n            object_type[\"id\"]: object_type[\"name\"]\n            for object_type in object_types\n        }\n        ft_type_names_by_id = {\n            task_type[\"id\"]: task_type[\"name\"]\n            for task_type in task_types\n        }\n\n        t_types_sync_3 = time.perf_counter()\n        self.log.debug((\n            \"Update of types from ftrack took\"\n            f\" {t_types_sync_3 - t_server_query_2:.2f}s\"\n        ))\n\n        self.log.info(\"Querying project hierarchy from ftrack\")\n        ft_entities = ft_session.query((\n            \"select id, name, parent_id, type_id, object_type_id, status_id\"\n            \", start_date, end_date, description, status_id\"\n            \" from TypedContext where project_id is \\\"{}\\\"\"\n        ).format(ft_project[\"id\"])).all()\n        t_ft_entities_4 = time.perf_counter()\n        self.log.debug((\n            \"Query of ftrack entities took\"\n            f\" {t_ft_entities_4 - t_types_sync_3:.2f}s\"\n        ))\n\n        ft_entities_by_id = {ft_project[\"id\"]: ft_project}\n        ft_entities_by_parent_id = collections.defaultdict(list)\n        for entity in ft_entities:\n            entity_id = entity[\"id\"]\n            parent_id = entity[\"parent_id\"]\n            ft_entities_by_id[entity_id] = entity\n            ft_entities_by_parent_id[parent_id].append(entity)\n\n        cust_attr_value_by_entity_id = self._prepare_attribute_values(\n            ft_session,\n            attr_confs,\n            ft_entities_by_id,\n        )\n\n        self.log.info(\"Checking changes of immutable entities\")\n        self.match_immutable_entities(\n            ft_project,\n            ft_entities_by_id,\n            ft_entities_by_parent_id,\n        )\n\n        self.log.info(\"Matching ftrack to server hierarchy\")\n        self.match_existing_entities(\n            ft_project,\n            ft_entities_by_parent_id,\n            ft_object_type_name_by_id,\n            ft_type_names_by_id,\n            cust_attr_value_by_entity_id\n        )\n\n        self.log.info(\"Updating assignees\")\n        self.update_assignees_from_ftrack(\n            ft_entities_by_id\n        )\n\n        self.log.info(\"Updating attributes of entities\")\n\n        ayon_statuses_by_name = {\n            status[\"name\"].lower(): status\n            for status in self._entity_hub.project_entity[\"statuses\"]\n        }\n        self.update_attributes_from_ftrack(\n            cust_attr_value_by_entity_id,\n            ft_entities_by_id,\n            ft_status_by_id,\n            ayon_statuses_by_name,\n        )\n        self._entity_hub.commit_changes()\n\n        self.log.info(\"Updating entity links\")\n        self.update_links_from_ftrack(ft_entities_by_id)\n\n        self.log.info(\"Updating server ids on ftrack entities\")\n        self.update_ftrack_attributes(\n            ft_entities_by_id,\n            cust_attr_value_by_entity_id,\n            server_id_conf_id,\n            server_path_conf_id,\n            sync_failed_conf_id\n        )\n\n        settings = self.get_ftrack_project_settings()\n        sync_versions: bool = (\n            settings\n            [\"service_event_handlers\"]\n            [\"sync_from_ftrack\"]\n            [\"sync_versions\"]\n        )\n        if sync_versions:\n            self.log.info(\"Synchronizing versions\")\n            t_version_start = time.perf_counter()\n            self.update_versions(\n                ft_session,\n                ft_entities_by_id,\n                server_id_conf_id,\n                ayon_statuses_by_name,\n            )\n            t_version_end = time.perf_counter()\n            self.log.info(\n                \"Synchronizing versions took\"\n                f\" {t_version_end - t_version_start:.2f}s\"\n            )\n\n        self.log.info(\"Synchronizing version lists\")\n        self.sync_lists(\n            ft_project,\n            server_id_conf_id,\n            list_type_conf,\n            sync_versions,\n        )\n\n        self.create_report(ft_entities_by_id)\n        t_end = time.perf_counter()\n        self.log.info((\n            f\"Synchronization of project \\\"{project_name}\\\" finished\"\n            f\" in {t_end - t_start:.2f}s\"\n        ))\n\n    def update_project_types(\n        self,\n        object_types: list[\"FtrackEntity\"],\n        task_types: list[\"FtrackEntity\"],\n    ) -&gt; None:\n        project_entity = self._entity_hub.project_entity\n        ignored_folder_types = {\"task\", \"milestone\"}\n        src_folder_types = {\n            folder_type[\"name\"].lower(): folder_type\n            for folder_type in project_entity.folder_types\n            if folder_type[\"name\"].lower() not in ignored_folder_types\n        }\n        src_task_types = {\n            task_type[\"name\"].lower(): task_type\n            for task_type in project_entity.task_types\n        }\n\n        new_folder_types = []\n        for object_type in sorted(object_types, key=lambda o: o[\"sort\"]):\n            name = object_type[\"name\"]\n            src_folder_type = src_folder_types.get(name.lower())\n            if src_folder_type is not None:\n                if src_folder_type[\"name\"] != name:\n                    old_name = src_folder_type[\"name\"]\n                    src_folder_type[\"name\"] = name\n                    src_folder_type[\"original_name\"] = old_name\n\n                new_folder_types.append(src_folder_type)\n            else:\n                new_folder_types.append({\"name\": name})\n\n        new_task_types = []\n        for task_type in task_types:\n            name = task_type[\"name\"]\n            src_task_type = src_task_types.get(name.lower())\n            if src_task_type is not None:\n                if src_task_type[\"name\"] != name:\n                    old_name = src_task_type[\"name\"]\n                    src_task_type[\"name\"] = name\n                    src_task_type[\"original_name\"] = old_name\n                new_task_types.append(src_task_type)\n            else:\n                new_task_types.append({\n                    \"name\": name,\n                    \"shortName\": re.sub(r\"\\W+\", \"\", name.lower())\n                })\n\n        project_entity.folder_types = new_folder_types\n        project_entity.task_types = new_task_types\n\n    def match_immutable_entities(\n        self,\n        ft_project: \"FtrackEntity\",\n        ft_entities_by_id: dict[str, \"FtrackEntity\"],\n        ft_entities_by_parent_id: dict[str, list[\"FtrackEntity\"]],\n    ) -&gt; None:\n        self.log.debug(\"Validation of immutable entities started\")\n\n        # Collect all ftrack ids from immuable entities\n        immutable_queue = collections.deque()\n        for entity in self._entity_hub.project_entity.children:\n            if entity.immutable_for_hierarchy:\n                immutable_queue.append(entity)\n\n        all_immutable_ftrack_ids = set()\n        while immutable_queue:\n            entity = immutable_queue.popleft()\n            all_immutable_ftrack_ids.add(entity.attribs[FTRACK_ID_ATTRIB])\n            for child in entity.children:\n                immutable_queue.append(child)\n\n        # Go through entities and find matching ftrack entity id\n        hierarchy_queue = collections.deque()\n        for entity in self._entity_hub.project_entity.children:\n            if entity.immutable_for_hierarchy:\n                hierarchy_queue.append((entity, ft_project[\"id\"]))\n\n        while hierarchy_queue:\n            (entity, ft_parent_id) = hierarchy_queue.popleft()\n\n            expected_ftrack_id = entity.attribs[FTRACK_ID_ATTRIB]\n            ft_entity = ft_entities_by_id.get(expected_ftrack_id)\n            if ft_entity is None:\n                ft_children = []\n                if ft_parent_id is not None:\n                    ft_children = ft_entities_by_parent_id[ft_parent_id]\n\n                is_folder = entity.entity_type == \"folder\"\n                for ft_child in ft_children:\n                    # Skip all entities that are already reserved for other\n                    #   entities\n                    if ft_child[\"id\"] in all_immutable_ftrack_ids:\n                        continue\n                    name = slugify_string(ft_child[\"name\"])\n                    if name != entity.name:\n                        continue\n                    ft_is_folder = ft_child.entity_type != \"Task\"\n                    if is_folder is ft_is_folder:\n                        ft_entity = ft_child\n                        break\n\n                if ft_entity is None:\n                    # Make sure 'expected_ftrack_id' is None\n                    expected_ftrack_id = None\n                    # Set ftrack id on entity to removed\n                    entity.attribs[FTRACK_ID_ATTRIB] = REMOVED_ID_VALUE\n                else:\n                    # Change ftrack id of entity to matching ftrack entity\n                    expected_ftrack_id = ft_entity[\"id\"]\n                    entity.attribs[FTRACK_ID_ATTRIB] = expected_ftrack_id\n                    # Add the ftrack id to immutable ids\n                    all_immutable_ftrack_ids.add(expected_ftrack_id)\n\n            else:\n                valid = True\n                ft_name = slugify_string(ft_entity[\"name\"])\n                if ft_name != entity.name:\n                    self._im_renamed_entity_ids.add(entity.id)\n                    valid = False\n\n                if ft_entity[\"parent_id\"] != ft_parent_id:\n                    self._im_moved_entity_ids.add(entity.id)\n                    valid = False\n\n                if not valid:\n                    self._im_invalid_entity_ids.add(entity.id)\n\n            if expected_ftrack_id:\n                self._processed_ftrack_ids.add(expected_ftrack_id)\n                self._ids_mapping.set_server_to_ftrack(\n                    entity.id, expected_ftrack_id)\n\n            self._processed_server_ids.add(entity.id)\n            for child in entity.children:\n                if child.immutable_for_hierarchy:\n                    hierarchy_queue.append((child, expected_ftrack_id))\n\n    def ensure_mandatory_custom_attributes_exists(\n        self, session: \"FtrackSession\"\n    ) -&gt; bool:\n        try:\n            ensure_mandatory_custom_attributes_exists(\n                session,\n                self.get_ftrack_settings(),\n            )\n            return True\n        except ServerError:\n            self.log.error(\n                \"Failed to create mandatory custom attributes in ftrack\",\n                exc_info=True\n            )\n            self._report_items.extend([\n                {\n                    \"type\": \"label\",\n                    \"value\": (\n                        \"## Failed to create AYON mandatory custom attributes\"\n                    )\n                },\n                {\n                    \"type\": \"label\",\n                    \"value\": (\n                        \"Sync ftrack &gt; AYON requires some mandatory\"\n                        \" custom attributes. ftrack API key used for services\"\n                        \" does not have enough permissions to create them.\"\n                        \"&lt;br/&gt;&lt;br/&gt;Please add 'Manage settings' permissions\"\n                        \" to used ftrack API key, or use admin ftrack API key\"\n                        \" for services.\"\n                        \"&lt;br/&gt;&lt;br/&gt;NOTE: You can also run ftrack action\"\n                        \" 'AYON Admin - Create/Update custom attributes' to\"\n                        \" create them manually.\"\n                    )\n                }\n            ])\n            return False\n\n    def _create_new_entity(\n        self,\n        parent_entity,\n        ft_entity: \"FtrackEntity\",\n        ft_object_type_name_by_id: dict[str, \"FtrackEntity\"],\n        ft_type_names_by_id: dict[str, str],\n        cust_attr_value_by_entity_id: dict[str, dict[str, Any]],\n    ):\n        ftrack_id = ft_entity[\"id\"]\n        custom_attributes = cust_attr_value_by_entity_id[ftrack_id]\n        entity_id = custom_attributes.get(CUST_ATTR_KEY_SERVER_ID)\n\n        label = ft_entity[\"name\"]\n        name = slugify_string(label)\n        entity_type = ft_entity.entity_type\n        if entity_type.lower() == \"task\":\n            task_type_name = ft_type_names_by_id[ft_entity[\"type_id\"]]\n            new_entity = self._entity_hub.add_new_task(\n                task_type=task_type_name,\n                name=name,\n                label=label,\n                entity_id=entity_id,\n                parent_id=parent_entity.id\n            )\n\n        else:\n            object_type = ft_object_type_name_by_id[\n                ft_entity[\"object_type_id\"]]\n            new_entity = self._entity_hub.add_new_folder(\n                folder_type=object_type,\n                name=name,\n                label=label,\n                entity_id=entity_id,\n                parent_id=parent_entity.id\n            )\n        self._ids_mapping.set_ftrack_to_server(ftrack_id, new_entity.id)\n\n        return new_entity\n\n    def match_existing_entities(\n        self,\n        ft_project: \"FtrackEntity\",\n        ft_entities_by_parent_id: dict[str, list[\"FtrackEntity\"]],\n        ft_object_type_name_by_id: dict[str, \"FtrackEntity\"],\n        ft_type_names_by_id: dict[str, str],\n        cust_attr_value_by_entity_id: dict[str, dict[str, Any]],\n    ) -&gt; None:\n        \"\"\"Match exiting entities on both sides.\n\n        Create new entities that are on ftrack and are not on server and remove\n        those which are not on ftrack.\n\n        Todos:\n            Handle duplicates more clearly. Don't compare children only by name\n                but also by type (right now task == folder).\n\n        Args:\n            ft_project (FtrackEntity): ftrack project entity.\n            ft_entities_by_parent_id (dict[str, list[FtrackEntity]]): Map\n                of ftrack entities by their parent ids.\n            ft_object_type_name_by_id (dict[str, str]): Mapping of ftrack\n                object type ids to their names.\n            ft_type_names_by_id (dict[str, str]): Mapping of ftrack task type\n                ids to their names.\n            cust_attr_value_by_entity_id (dict[str, dict[str, Any]): Custom\n                attribute values by key stored by entity id.\n        \"\"\"\n\n        fill_queue = collections.deque()\n        for ft_child in ft_entities_by_parent_id[ft_project[\"id\"]]:\n            fill_queue.append((self._entity_hub.project_entity, ft_child))\n\n        def _add_children_to_queue(ft_entity_id):\n            children = ft_entities_by_parent_id[ft_entity_id]\n            if not children:\n                return\n\n            entity_id = self._ids_mapping.get_server_mapping(ft_entity_id)\n            entity = None\n            if entity_id:\n                entity = self._entity_hub.get_entity_by_id(entity_id)\n\n            for ft_child in children:\n                fill_queue.append((entity, ft_child))\n\n        while fill_queue:\n            (parent_entity, ft_entity) = fill_queue.popleft()\n            ft_entity_path = \"/\".join([\n                item[\"name\"]\n                for item in ft_entity[\"link\"]\n            ])\n            ft_entity_id = ft_entity[\"id\"]\n            # Go to next children if is already processed\n            if ft_entity_id in self._processed_ftrack_ids:\n                _add_children_to_queue(ft_entity_id)\n                self.log.debug(\n                    f\"{ft_entity_path} - ftrack id already processed\")\n                continue\n\n            if parent_entity is None:\n                self._skipped_ftrack_ids.add(ft_entity_id)\n                _add_children_to_queue(ft_entity_id)\n                self.log.debug(f\"{ft_entity_path} - Skipped\")\n                continue\n\n            if (\n                parent_entity.entity_type == \"project\"\n                and ft_entity.entity_type.lower() == \"task\"\n            ):\n                self._skipped_ftrack_ids.add(ft_entity_id)\n                self.log.debug(\n                    f\"{ft_entity_path} - Skipped task at projectroot\"\n                )\n                continue\n\n            label = ft_entity[\"name\"]\n            name = slugify_string(label)\n            matching_name_entity = None\n            for child in parent_entity.children:\n                if child.name.lower() == name.lower():\n                    matching_name_entity = child\n                    break\n\n            ft_is_folder = ft_entity.entity_type != \"Task\"\n            if matching_name_entity is not None:\n                # If entity was already processed we can skip ftrack entity\n                # --- This is last condition that handle immutable entities ---\n                #   After this condition can be server entities changed,\n                #       removed or created.\n                if matching_name_entity.id in self._processed_server_ids:\n                    self._processed_ftrack_ids.add(ft_entity_id)\n                    self._duplicated_ftrack_ids[ft_entity_id] = (\n                        matching_name_entity\n                    )\n                    _add_children_to_queue(ft_entity_id)\n                    self.log.debug(\n                        f\"{ft_entity_path} - Server id already processed\")\n                    continue\n\n                is_folder = matching_name_entity.entity_type == \"folder\"\n                # It is possible to remove previous server entity at this point\n                #   as we're 100% sure it is not immutable at this point\n                if ft_is_folder is not is_folder:\n                    self.log.debug(\n                        f\"{ft_entity_path} - Deleted previous entity\")\n                    # Remove current entity if type does not match\n                    matching_name_entity.parent_id = None\n                    # Reset variable so new entity is created\n                    matching_name_entity = None\n\n            # No match was found, so we can create new server entity\n            if matching_name_entity is None:\n                self.log.debug(f\"{ft_entity_path} - Creating new entity\")\n                entity = self._create_new_entity(\n                    parent_entity,\n                    ft_entity,\n                    ft_object_type_name_by_id,\n                    ft_type_names_by_id,\n                    cust_attr_value_by_entity_id,\n                )\n                self._processed_server_ids.add(entity.id)\n                self._processed_ftrack_ids.add(ft_entity_id)\n                _add_children_to_queue(ft_entity_id)\n                continue\n\n            self.log.debug(f\"{ft_entity_path} - Updating existing entity\")\n            matching_name_entity.name = name\n            matching_name_entity.label = label\n            matching_name_entity.active = True\n            if matching_name_entity.entity_type == \"task\":\n                task_type_id = ft_entity[\"type_id\"]\n                task_type_name = ft_type_names_by_id[task_type_id]\n                if matching_name_entity.task_type != task_type_name:\n                    matching_name_entity.task_type = task_type_name\n\n            else:\n                object_type_id = ft_entity[\"object_type_id\"]\n                object_type_name = ft_object_type_name_by_id[\n                    object_type_id]\n                if matching_name_entity.folder_type != object_type_name:\n                    matching_name_entity.folder_type = object_type_name\n\n            self._processed_server_ids.add(matching_name_entity.id)\n            self._processed_ftrack_ids.add(ft_entity_id)\n            self._ids_mapping.set_ftrack_to_server(\n                ft_entity_id, matching_name_entity.id\n            )\n            _add_children_to_queue(ft_entity_id)\n\n        deactivate_queue = collections.deque()\n        for child in self._entity_hub.project_entity.children:\n            deactivate_queue.append(child)\n\n        while deactivate_queue:\n            entity = deactivate_queue.popleft()\n            if entity.id not in self._processed_server_ids:\n                entity.active = False\n\n            for child in entity.children:\n                deactivate_queue.append(child)\n\n    def _get_ayon_status(\n        self,\n        ayon_statuses_by_name: dict[str, dict[str, Any]],\n        ayon_entity_type: str,\n        ft_status_name: Union[str, None],\n    ) -&gt; Union[str, None]:\n        if not ft_status_name:\n            return None\n\n        ayon_status = ayon_statuses_by_name.get(ft_status_name.lower())\n        if ayon_status is None:\n            return None\n\n        scope = ayon_status.scope\n        if ayon_entity_type in scope:\n            return ayon_status[\"name\"]\n        return None\n\n    def _set_entity_status(\n        self,\n        ft_entity: \"FtrackEntity\",\n        ft_status_by_id: dict[str, \"FtrackEntity\"],\n        entity: BaseEntity,\n        ayon_statuses_by_name: dict[str, Any],\n    ) -&gt; None:\n        # QUESTION should we log all invalid/missing statuses?\n        # QUESTION should we update AYON project statuses if status\n        #   is not available?\n        if entity.entity_type not in (\"folder\", \"task\"):\n            return\n\n        ft_status = ft_status_by_id.get(ft_entity.get(\"status_id\"))\n        if ft_status is None:\n            return\n\n        ayon_status_name = self._get_ayon_status(\n            ayon_statuses_by_name,\n            entity.entity_type,\n            ft_status[\"name\"]\n        )\n        if ayon_status_name is not None:\n            entity.set_status(ayon_status_name)\n\n    def update_assignees_from_ftrack(\n        self,\n        ft_entities_by_id: dict[str, \"FtrackEntity\"],\n    ) -&gt; None:\n        task_entities_by_id = {}\n        for entity in ft_entities_by_id.values():\n            if entity.entity_type == \"Task\":\n                task_id = entity[\"id\"]\n                ayon_id = self._ids_mapping.get_server_mapping(task_id)\n                if ayon_id is not None:\n                    task_entities_by_id[task_id] = entity\n\n        if not task_entities_by_id:\n            return\n\n        assignment_by_task_id = {\n            task_id: set()\n            for task_id in task_entities_by_id\n        }\n        task_ids = list(task_entities_by_id.keys())\n        for task_ids_chunk in create_chunks(task_ids, 50):\n            joined_ids = \",\".join([\n                f'\"{task_id}\"'\n                for task_id in task_ids_chunk\n            ])\n            appointments = self._ft_session.query(\n                f\"select resource_id, context_id from Appointment\"\n                f\" where context_id in ({joined_ids})\"\n                f\" and type is 'assignment'\"\n            ).all()\n            for appointment in appointments:\n                task_id = appointment[\"context_id\"]\n                user_id = appointment[\"resource_id\"]\n                assignment_by_task_id[task_id].add(user_id)\n\n        for task_id, user_ids in assignment_by_task_id.items():\n            ayon_task = self._entity_hub.get_entity_by_id(\n                self._ids_mapping.get_server_mapping(task_id)\n            )\n            if ayon_task is None:\n                continue\n\n            new_assignees = set()\n            # Keep users that don't have ftrack mapping on task\n            for ayon_user in ayon_task.assignees:\n                user_id = self._ids_mapping.get_ftrack_mapping(ayon_user)\n                if user_id is None:\n                    new_assignees.add(ayon_user)\n\n            for user_id in user_ids:\n                ayon_user = self._ids_mapping.get_server_mapping(user_id)\n                if ayon_user:\n                    new_assignees.add(ayon_user)\n\n            ayon_task.assignees = list(new_assignees)\n\n    def update_attributes_from_ftrack(\n        self,\n        cust_attr_value_by_entity_id: dict[str, dict[str, Any]],\n        ft_entities_by_id: dict[str, \"FtrackEntity\"],\n        ft_status_by_id: dict[str, \"FtrackEntity\"],\n        ayon_statuses_by_name: dict[str, dict[str, Any]],\n    ) -&gt; None:\n        hierarchy_queue = collections.deque()\n        hierarchy_queue.append(self._entity_hub.project_entity)\n        while hierarchy_queue:\n            entity = hierarchy_queue.popleft()\n            # Add children to queue\n            for child_entity in entity.children:\n                hierarchy_queue.append(child_entity)\n\n            ftrack_id = self._ids_mapping.get_ftrack_mapping(entity.id)\n            if ftrack_id is None:\n                continue\n\n            ft_entity = ft_entities_by_id[ftrack_id]\n            path = \"/\".join([\n                item[\"name\"]\n                for item in ft_entity[\"link\"]\n                if item[\"type\"] != \"Project\"\n            ])\n            entity.attribs[FTRACK_ID_ATTRIB] = ftrack_id\n            entity.attribs[FTRACK_PATH_ATTRIB] = path\n\n            self._set_entity_status(\n                ft_entity,\n                ft_status_by_id,\n                entity,\n                ayon_statuses_by_name\n            )\n\n            for attr_name, value in (\n                (\"startDate\", ft_entity[\"start_date\"]),\n                (\"endDate\", ft_entity[\"end_date\"]),\n                (\"description\", ft_entity.get(\"description\")),\n            ):\n                if value is None or attr_name not in entity.attribs:\n                    continue\n\n                if isinstance(value, arrow.Arrow):\n                    # Shift date to 00:00:00 of the day\n                    # - ftrack is returning e.g. '2024-10-29T22:00:00'\n                    #  for '2024-10-30'\n                    value = str(value.shift(hours=24 - value.hour))\n\n                entity.attribs[attr_name] = str(value)\n\n            # ftrack id can not be available if ftrack entity was recreated\n            #   during immutable entity processing\n            attribute_values = cust_attr_value_by_entity_id[ftrack_id]\n            is_project = entity.entity_type == \"project\"\n\n            # TODO handle \"data\" to sync custom attributes not available\n            #   in 'attribs'\n            for key, value in attribute_values.items():\n                # QUESTION Should we skip \"unsetting\" of project attributes?\n                #   - very dangerous for AYON and maybe for project should\n                #       be taken default value of attribute (if there is any)\n                if is_project and value is None:\n                    continue\n\n                if key in entity.attribs:\n                    entity.attribs[key] = value\n\n    def update_links_from_ftrack(\n        self,\n        ft_entities_by_id: dict[str, \"FtrackEntity\"],\n    ) -&gt; None:\n        settings = self.get_ftrack_project_settings()\n        ay_link_type = (\n            settings\n            [\"service_event_handlers\"]\n            [\"sync_from_ftrack\"]\n            [\"sync_link_type\"]\n        )\n        if ay_link_type == \"&lt; Skip &gt;\":\n            self.log.info(\"Links sync is not set to be skipped.\")\n            return\n\n        project_entity = self.get_ayon_project()\n        exists = False\n        for link_type in project_entity[\"linkTypes\"]:\n            if (\n                link_type[\"linkType\"] == ay_link_type\n                and link_type[\"inputType\"] == \"folder\"\n                and link_type[\"outputType\"] == \"folder\"\n            ):\n                exists = True\n\n        if not exists:\n            self._missing_link_type = ay_link_type\n            self.log.warning(\n                f\"Skipping links sync because link type '{ay_link_type}'\"\n                f\" does not exist on project '{self.project_name}'.\"\n            )\n            return\n\n        # Prepare ftrack links\n        ft_folder_ids = set()\n        for ftrack_id, ft_entity in ft_entities_by_id.items():\n            if ft_entity.entity_type.lower() != \"task\":\n                ft_folder_ids.add(ftrack_id)\n\n        ft_links = []\n        for ftrack_ids_chunk in create_chunks(ft_folder_ids, 50):\n            joined_ids = \",\".join([\n                f'\"{ftrack_id}\"'\n                for ftrack_id in ftrack_ids_chunk\n            ])\n            for link in self._ft_session.query(\n                f\"select from_id, to_id from TypedContextLink\"\n                f\" where to_id in ({joined_ids})\"\n            ).all():\n                # Filter only folder links\n                if link[\"from_id\"] in ft_folder_ids:\n                    ft_links.append(link)\n\n        # Skip rest of logic if there are no links\n        if not ft_links:\n            return\n\n        hierarchy_queue = collections.deque()\n        hierarchy_queue.extend(\n            self._entity_hub.project_entity.children\n        )\n        folder_ids = set()\n        while hierarchy_queue:\n            entity = hierarchy_queue.popleft()\n            # Add children to queue\n            for child_entity in entity.children:\n                if child_entity.entity_type == \"folder\":\n                    hierarchy_queue.append(child_entity)\n\n            ftrack_id = self._ids_mapping.get_ftrack_mapping(entity.id)\n            if ftrack_id is not None:\n                folder_ids.add(entity.id)\n\n        _ay_in_links_by_id: dict[str, list[dict[str, Any]]] = (\n            ayon_api.get_folders_links(\n                self.project_name,\n                folder_ids=folder_ids,\n                link_types={ay_link_type},\n                link_direction=\"in\",\n            )\n        )\n        ay_in_links_by_id = {}\n        for ayon_id, entity_links in _ay_in_links_by_id.items():\n            ay_in_links_by_id[ayon_id] = {\n                link[\"entityId\"]\n                for link in entity_links\n            }\n\n        for link in ft_links:\n            ft_in_id = link[\"from_id\"]\n            ft_out_id = link[\"to_id\"]\n            # Not sure how, but can happen...\n            if ft_in_id == ft_out_id:\n                continue\n\n            ay_in_id = self._ids_mapping.get_server_mapping(ft_in_id)\n            ay_out_id = self._ids_mapping.get_server_mapping(ft_out_id)\n            if ay_in_id is None or ay_out_id is None:\n                continue\n\n            if ay_out_id in ay_in_links_by_id[ay_in_id]:\n                continue\n\n            ayon_api.create_link(\n                self.project_name,\n                ay_link_type,\n                ay_in_id,\n                \"folder\",\n                ay_out_id,\n                \"folder\",\n            )\n\n    def _prepare_attribute_values(\n        self,\n        ft_session: \"FtrackSession\",\n        attr_confs: list[\"FtrackEntity\"],\n        ft_entities_by_id: dict[str, \"FtrackEntity\"],\n    ) -&gt; dict[str, dict[str, Any]]:\n        ft_entity_ids = set(ft_entities_by_id.keys())\n        attr_mapping: CustomAttributesMapping = (\n            get_custom_attributes_mapping(\n                ft_session,\n                self.get_ftrack_project_settings(),\n                attr_confs,\n            )\n        )\n        mapped_confs_by_id = {}\n        default_attrs = {}\n        for attr_conf in attr_confs:\n            attr_key = attr_conf[\"key\"]\n            if attr_key in (\n                CUST_ATTR_KEY_SERVER_ID,\n                CUST_ATTR_KEY_SERVER_PATH,\n                CUST_ATTR_KEY_SYNC_FAIL,\n            ):\n                attr_id = attr_conf[\"id\"]\n                default_attrs[attr_id] = attr_key\n                mapped_confs_by_id[attr_id] = attr_conf\n\n        for mapping_item in attr_mapping.values():\n            for mapped_conf in mapping_item.attr_confs:\n                mapped_confs_by_id[mapped_conf[\"id\"]] = mapped_conf\n\n        val_by_entity_id = get_custom_attributes_by_entity_id(\n            ft_session,\n            ft_entity_ids,\n            list(mapped_confs_by_id.values()),\n            store_by_key=False,\n        )\n\n        cust_attr_value_by_entity_id = collections.defaultdict(dict)\n        for entity_id, entity in ft_entities_by_id.items():\n            values_by_attr_id = val_by_entity_id[entity_id]\n            values_by_key = {}\n            for attr_id, default_key in default_attrs.items():\n                value = values_by_attr_id.get(attr_id)\n                if value is not None:\n                    values_by_key[default_key] = value\n\n            for ayon_attr_name, mapping_item in attr_mapping.items():\n                attr_conf = mapping_item.get_attr_conf_for_entity(entity)\n                if attr_conf is None:\n                    continue\n\n                value = values_by_attr_id.get(attr_conf[\"id\"])\n                if value is not None:\n                    values_by_key[ayon_attr_name] = value\n\n            cust_attr_value_by_entity_id[entity_id] = values_by_key\n        return cust_attr_value_by_entity_id\n\n    def _create_ft_operation(\n        self,\n        conf_id: str,\n        entity_id: str,\n        is_new: bool,\n        new_value: Any,\n        old_value: Optional[Any] = None,\n    ) -&gt; \"FtrackOperation\":\n        entity_key = collections.OrderedDict((\n            (\"configuration_id\", conf_id),\n            (\"entity_id\", entity_id)\n        ))\n        if is_new:\n            return ftrack_api.operation.CreateEntityOperation(\n                \"CustomAttributeValue\",\n                entity_key,\n                {\"value\": new_value}\n            )\n\n        return ftrack_api.operation.UpdateEntityOperation(\n            \"CustomAttributeValue\",\n            entity_key,\n            \"value\",\n            old_value,\n            new_value\n        )\n\n    def update_ftrack_attributes(\n        self,\n        ft_entities_by_id: dict[str, \"FtrackEntity\"],\n        cust_attr_value_by_entity_id: dict[str, dict[str, Any]],\n        server_id_conf_id: str,\n        server_path_conf_id: str,\n        sync_failed_conf_id: str,\n    ) -&gt; None:\n        operations = []\n        for ftrack_id, ft_entity in ft_entities_by_id.items():\n            if ft_entity.entity_type == \"Project\":\n                continue\n\n            server_id = self._ids_mapping.get_server_mapping(ftrack_id)\n            entity = None\n            if server_id:\n                entity = self._entity_hub.get_entity_by_id(server_id)\n\n            entity_id = \"\"\n            if entity is not None:\n                entity_id = entity.id\n\n            custom_attributes = cust_attr_value_by_entity_id[ftrack_id]\n\n            oring_sync_failed = custom_attributes.get(CUST_ATTR_KEY_SYNC_FAIL)\n            orig_id = custom_attributes.get(CUST_ATTR_KEY_SERVER_ID)\n            orig_path = custom_attributes.get(CUST_ATTR_KEY_SERVER_PATH)\n            sync_failed = False\n            if entity is None or entity.id in self._im_invalid_entity_ids:\n                sync_failed = True\n\n            if sync_failed != oring_sync_failed:\n                operations.append(\n                    self._create_ft_operation(\n                        sync_failed_conf_id,\n                        ftrack_id,\n                        CUST_ATTR_KEY_SYNC_FAIL not in custom_attributes,\n                        sync_failed,\n                        oring_sync_failed\n                    )\n                )\n\n            if orig_id != entity_id:\n                operations.append(\n                    self._create_ft_operation(\n                        server_id_conf_id,\n                        ftrack_id,\n                        CUST_ATTR_KEY_SERVER_ID not in custom_attributes,\n                        entity_id,\n                        orig_id\n                    )\n                )\n\n            if ft_entity.entity_type == \"Task\" or sync_failed:\n                continue\n\n            path = entity.path\n            if path != orig_path:\n                operations.append(\n                    self._create_ft_operation(\n                        server_path_conf_id,\n                        ftrack_id,\n                        CUST_ATTR_KEY_SERVER_PATH not in custom_attributes,\n                        path,\n                        orig_path\n                    )\n                )\n\n        if not operations:\n            return\n\n        for chunk in create_chunks(operations, 500):\n            for operation in chunk:\n                self._ft_session.recorded_operations.push(operation)\n            self._ft_session.commit()\n\n    def update_versions(\n        self,\n        ft_session: \"FtrackSession\",\n        ft_entities_by_id: dict[str, \"FtrackEntity\"],\n        server_id_conf_id: str,\n        ayon_statuses_by_name: dict[str, dict[str, Any]],\n    ) -&gt; None:\n        \"\"\"Synchronize versions information to AYON.\n\n        Args:\n            ft_session (FtrackSession): Ftrack session.\n            ft_entities_by_id (dict[str, FtrackEntity]): Mapping of ftrack\n                entity ids.\n            server_id_conf_id (str): Id of 'ayon_id' custom attribute.\n            ayon_statuses_by_name (dict[str, dict[str, Any]]): Mapping of AYON\n                statuses by name.\n\n        \"\"\"\n        context_ids = set()\n        for entity in ft_entities_by_id.values():\n            if entity.entity_type != \"Task\":\n                context_ids.add(entity[\"id\"])\n\n        if not context_ids:\n            return\n\n        assets_by_id = {}\n        asset_ids_by_context_id = {\n            context_id: []\n            for context_id in context_ids\n        }\n        for chunk in create_chunks(context_ids, 50):\n            joined_ids = join_filter_values(chunk)\n            for asset in ft_session.query(\n                \"select id, context_id, name from Asset\"\n                f\" where context_id in ({joined_ids})\"\n            ):\n                asset_id = asset[\"id\"]\n                context_id = asset[\"context_id\"]\n                assets_by_id[asset_id] = asset\n                asset_ids_by_context_id[context_id].append(asset_id)\n\n        if not assets_by_id:\n            return\n\n        asset_version_by_id = {}\n        asset_version_ids_by_asset_id = {\n            asset_id: []\n            for asset_id in assets_by_id\n        }\n        for chunk in create_chunks(assets_by_id, 50):\n            joined_ids = join_filter_values(chunk)\n            for asset_version in ft_session.query(\n                \"select id, asset_id, version, status_id from AssetVersion\"\n                f\" where asset_id in ({joined_ids})\"\n            ):\n                av_id = asset_version[\"id\"]\n                asset_id = asset_version[\"asset_id\"]\n                asset_version_by_id[av_id] = asset_version\n                asset_version_ids_by_asset_id[asset_id].append(av_id)\n\n        version_mapping = self._find_versions_ayon_mapping(\n            ft_session,\n            server_id_conf_id,\n            set(asset_version_by_id.keys()),\n        )\n        ayon_ids = set(version_mapping.values())\n        ayon_ids.discard(None)\n        if not ayon_ids:\n            return\n\n        versions_by_id = {\n            version[\"id\"]: version\n            for version in ayon_api.get_versions(\n                self.project_name,\n                version_ids=ayon_ids,\n                fields={\"id\", \"status\"},\n            )\n        }\n        status_name_by_id = {\n            status[\"id\"]: status[\"name\"]\n            for status in self._ft_session.query(\n                \"select id, name from Status\"\n            ).all()\n        }\n\n        op_count = 0\n        operations = OperationsSession()\n        for ftrack_id, ayon_id in version_mapping.items():\n            # Mapping to AYON entity was not found\n            if not ayon_id:\n                continue\n\n            ay_version = versions_by_id.get(ayon_id)\n            ft_av = asset_version_by_id.get(ftrack_id)\n            # Entities are not found\n            if ay_version is None or ft_av is None:\n                continue\n\n            # AYON version was already mapped to a different ftrack version\n            if self._ids_mapping.get_ftrack_mapping(ayon_id):\n                continue\n            self._ids_mapping.set_ftrack_to_server(ftrack_id, ayon_id)\n\n            ft_status_id = ft_av[\"status_id\"]\n            status_name = status_name_by_id[ft_status_id]\n            ayon_status_name = self._get_ayon_status(\n                ayon_statuses_by_name,\n                \"version\",\n                status_name\n            )\n            # AYON status is not available or is same as current status\n            if (\n                not ayon_status_name\n                or ay_version[\"status\"] == ayon_status_name\n            ):\n                continue\n\n            operations.update_version(\n                self.project_name,\n                ayon_id,\n                status=ayon_status_name,\n            )\n            op_count += 1\n            if op_count == 100:\n                operations.commit()\n                op_count = 0\n\n        if op_count &gt; 0:\n            operations.commit()\n\n    def sync_lists(\n        self,\n        ft_project: \"FtrackEntity\",\n        server_id_conf_id: str,\n        list_type_conf: \"FtrackEntity\",\n        sync_versions: bool,\n    ) -&gt; None:\n        # TODO right now it does not remove AYON lists\n        project_id = ft_project[\"id\"]\n        ft_lists_by_id = {\n            le[\"id\"]: le\n            for le in self._ft_session.query(\n                \"select id, category_id, name, system_type from List\"\n                f\" where project_id is '{project_id}'\"\n            ).all()\n        }\n        if not ft_lists_by_id:\n            return\n\n        list_type_by_id = {}\n        if list_type_conf is not None:\n            default = list_type_conf[\"default\"]\n            if isinstance(default, list):\n                default = default[0]\n\n            # Only lists that have different value from 'default' will have\n            #   set the value\n            list_type_by_id = {\n                le[\"id\"]: default\n                for le in ft_lists_by_id.values()\n                if le[\"system_type\"] == \"task\"\n            }\n\n            for item in query_custom_attribute_values(\n                self._ft_session,\n                {list_type_conf[\"id\"]},\n                list_type_by_id\n            ):\n                value = item[\"value\"]\n                entity_id = item[\"entity_id\"]\n                if value:\n                    if isinstance(value, list):\n                        value = value[0]\n                    list_type_by_id[entity_id] = value\n\n        ay_lists = list(ayon_api.get_entity_lists(\n            self.project_name,\n            fields={\"id\", \"label\", \"entityType\", \"attrib\"}\n        ))\n        ay_lists_by_entity_type = {}\n        ay_lists_by_ftrack_id = {}\n        for ay_list in ay_lists:\n            entity_type = ay_list[\"entityType\"]\n            ay_lists_by_entity_type.setdefault(\n                entity_type, []\n            ).append(ay_list)\n            ftrack_id = ay_list[\"attrib\"].get(FTRACK_ID_ATTRIB)\n            if ftrack_id:\n                ay_lists_by_ftrack_id[ftrack_id] = ay_list\n\n        # Fetch items for lists\n        # - it is not possible to be fetched at once if have different\n        #   'entityType'\n        for ls in ay_lists_by_entity_type.values():\n            ls_by_id = {le[\"id\"]: le for le in ls}\n            for list_e in ayon_api.get_entity_lists(\n                self.project_name,\n                list_ids=ls_by_id,\n                fields={\"id\", \"items.id\", \"items.entityId\"},\n            ):\n                ls_by_id[list_e[\"id\"]][\"items\"] = list_e[\"items\"]\n\n        # Try to match lists based on label\n        ay_lists_by_label = {\n            ay_list[\"label\"]: ay_list\n            for ay_list in ay_lists\n        }\n        for ft_list_id, ft_list in ft_lists_by_id.items():\n            if ft_list_id in ay_lists_by_ftrack_id:\n                continue\n\n            name_low = ft_list[\"name\"].lower()\n            for label, ay_list in ay_lists_by_label.items():\n                if name_low == label.lower():\n                    ay_lists_by_ftrack_id[ft_list_id] = ay_list\n                    break\n\n        # Fetch all list items to find AYON equivalents\n        joined_list_ids = join_filter_values(ft_lists_by_id)\n        ft_list_items_by_list_id = {i: [] for i in ft_lists_by_id}\n        ft_version_ids = set()\n        ft_entity_ids = set()\n        ft_list_items = self._ft_session.query(\n            \"select id, entity_id, list_id from ListObject\"\n            f\" where list_id in ({joined_list_ids})\"\n        ).all()\n        for ft_list_item in ft_list_items:\n            list_id = ft_list_item[\"list_id\"]\n            entity_id = ft_list_item[\"entity_id\"]\n            ft_list_items_by_list_id[list_id].append(ft_list_item)\n            ft_list = ft_lists_by_id[list_id]\n            if ft_list[\"system_type\"] == \"assetversion\":\n                ft_version_ids.add(entity_id)\n            else:\n                ft_entity_ids.add(entity_id)\n\n        # Tasks and folders already have mapping prepared from entities sync\n        ay_id_by_ft_id = {}\n\n        # Sync of ftrack versions is enabled so mapping of versions is\n        #   already filled in '_ids_mapping'\n        _mapping_ids = set(ft_entity_ids)\n        if sync_versions:\n            _mapping_ids |= ft_version_ids\n        for entity_id in _mapping_ids:\n            ayon_id = self._ids_mapping.get_server_mapping(entity_id)\n            if ayon_id:\n                ay_id_by_ft_id[entity_id] = ayon_id\n\n        # Sync of versions is disabled\n        if not sync_versions:\n            mapping = self._find_versions_ayon_mapping(\n                self._ft_session,\n                server_id_conf_id,\n                ft_version_ids,\n            )\n            ay_id_by_ft_id.update(mapping)\n\n        for ftrack_id, ft_list in ft_lists_by_id.items():\n            ay_list = ay_lists_by_ftrack_id.get(ftrack_id)\n            list_type = \"version\"\n            if ft_list[\"system_type\"] != \"assetversion\":\n                list_type = list_type_by_id.get(ftrack_id)\n\n            # Check if AYON list type matches ftrack list type\n            if ay_list is not None:\n                # TODO add logs of skipped sync\n                if ft_list[\"system_type\"] == \"assetversion\":\n                    # Both ftrack and AYON lists are for versions\n                    if ay_list[\"entityType\"] != \"version\":\n                        continue\n\n                elif not list_type:\n                    # AYON list type is not set\n                    continue\n\n                elif ft_list[\"system_type\"] != \"task\":\n                    # Unknown list type in ftrack\n                    # - probably could be validated ahead?\n                    continue\n\n                elif ay_list[\"entityType\"] != list_type:\n                    # AYON list type does not match type defined in ftrack\n                    # - maybe could be validated ahead?\n                    continue\n\n            to_add, to_remove = self._prepare_list_items(\n                ft_list_items_by_list_id[ftrack_id],\n                list_type,\n                ay_list,\n                ay_id_by_ft_id,\n            )\n            if ay_list is None:\n                ayon_api.create_entity_list(\n                    self.project_name,\n                    list_type,\n                    ft_list[\"name\"],\n                    items=[{\"entityId\": i} for i in to_add],\n                    attrib={FTRACK_ID_ATTRIB: ftrack_id},\n                )\n                continue\n\n            if ft_list[\"name\"] != ay_list[\"label\"]:\n                ayon_api.update_entity_list(\n                    self.project_name,\n                    ay_list[\"id\"],\n                    label=ft_list[\"name\"],\n                )\n\n            if to_add:\n                ayon_api.update_entity_list_items(\n                    self.project_name,\n                    ay_list[\"id\"],\n                    items=[{\"entityId\": i} for i in to_add],\n                    mode=\"merge\",\n                )\n\n            if to_remove:\n                ayon_api.update_entity_list_items(\n                    self.project_name,\n                    ay_list[\"id\"],\n                    items=[{\"id\": i} for i in to_remove],\n                    mode=\"delete\",\n                )\n\n            attrib = ay_list[\"attrib\"]\n            attr_ftrack_id = attrib.get(FTRACK_ID_ATTRIB)\n            if attr_ftrack_id != ftrack_id:\n                ayon_api.update_entity_list(\n                    self.project_name,\n                    ay_list[\"id\"],\n                    attrib={FTRACK_ID_ATTRIB: ftrack_id},\n                )\n\n    def _prepare_list_items(\n        self,\n        ft_list_items: list[\"FtrackEntity\"],\n        list_type: str,\n        ayon_list: dict[str, Any],\n        ay_id_by_ft_id: dict[str, str],\n    ) -&gt; tuple[set[str], set[str]]:\n        to_add = set()\n        to_remove = set()\n        if not ft_list_items:\n            return to_add, to_remove\n\n        for item in ft_list_items:\n            ftrack_id = item[\"entity_id\"]\n            ay_id = ay_id_by_ft_id.get(ftrack_id)\n            if not ay_id:\n                continue\n\n            if list_type == \"version\":\n                to_add.add(ay_id)\n                continue\n\n            entity = self._entity_hub.get_entity_by_id(ay_id)\n            if entity and entity.entity_type == list_type:\n                to_add.add(ay_id)\n\n        if ayon_list:\n            for item in ayon_list[\"items\"]:\n                entity_id = item[\"entityId\"]\n                if entity_id in to_add:\n                    to_add.discard(entity_id)\n                else:\n                    to_remove.add(item[\"id\"])\n\n        return to_add, to_remove\n\n    def _find_versions_ayon_mapping(\n        self,\n        ft_session: \"FtrackSession\",\n        server_id_conf_id: str,\n        asset_version_ids: set[str],\n    ) -&gt; dict[str, Union[str, None]]:\n        ayon_id_by_av_id = {\n            asset_version_id: None\n            for asset_version_id in asset_version_ids\n        }\n        if not ayon_id_by_av_id:\n            return ayon_id_by_av_id\n\n        real_values = {}\n        for item in query_custom_attribute_values(\n            ft_session,\n            {server_id_conf_id},\n            asset_version_ids,\n        ):\n            value = item[\"value\"]\n            entity_id = item[\"entity_id\"]\n            real_values[entity_id] = value\n            if value:\n                try:\n                    uuid.UUID(value)\n                except ValueError:\n                    continue\n                ayon_id_by_av_id[entity_id] = value\n\n        missing_ids = {\n            ftrack_id\n            for ftrack_id, ayon_id in ayon_id_by_av_id.items()\n            if not ayon_id\n        }\n        if not missing_ids:\n            return ayon_id_by_av_id\n\n        guessed_ids = self._guess_asset_version_ayon_ids(missing_ids)\n        for ftrack_id, ayon_id in guessed_ids.items():\n            if not ayon_id:\n                continue\n\n            ayon_id_by_av_id[ftrack_id] = ayon_id\n\n            entity_key = collections.OrderedDict((\n                (\"configuration_id\", server_id_conf_id),\n                (\"entity_id\", ftrack_id)\n            ))\n            op = ftrack_api.operation.CreateEntityOperation(\n                \"CustomAttributeValue\",\n                entity_key,\n                {\"value\": ayon_id}\n            )\n            self._ft_session.recorded_operations.push(op)\n\n        if self._ft_session.recorded_operations:\n            try:\n                self._ft_session.commit()\n            finally:\n                self._ft_session.recorded_operations.clear()\n        return ayon_id_by_av_id\n\n    def _guess_asset_version_ayon_ids(\n        self, asset_version_ids: set[str]\n    ) -&gt; dict[str, Optional[str]]:\n        output = {\n            av_id: None\n            for av_id in asset_version_ids\n        }\n        if not asset_version_ids:\n            return output\n\n        joined_asset_version_ids = join_filter_values(asset_version_ids)\n        asset_versions_by_asset_id = {}\n        for asset_version in self._ft_session.query(\n            \"select id, asset_id, version from AssetVersion\"\n            f\" where id in ({joined_asset_version_ids})\"\n        ).all():\n            asset_id = asset_version[\"asset_id\"]\n            versions = asset_versions_by_asset_id.setdefault(asset_id, [])\n            versions.append(asset_version)\n\n        if not asset_versions_by_asset_id:\n            return output\n\n        asset_ids = set(asset_versions_by_asset_id)\n        joined_asset_ids = join_filter_values(asset_ids)\n        assets_by_parent_id = collections.defaultdict(list)\n        assets_by_id = {}\n        for asset in self._ft_session.query(\n            \"select id, name, context_id from Asset\"\n            f\" where id in ({joined_asset_ids})\"\n        ).all():\n            assets_by_id[asset[\"id\"]] = asset\n            parent_id = asset[\"context_id\"]\n            assets_by_parent_id[parent_id].append(asset)\n\n        folders_mapping = {}\n        folder_ids = set()\n        for parent_id in assets_by_parent_id.keys():\n            ayon_id = self._ids_mapping.get_server_mapping(parent_id)\n            try:\n                uuid.UUID(ayon_id)\n            except ValueError:\n                continue\n\n            if ayon_id:\n                folders_mapping[ayon_id] = parent_id\n                folder_ids.add(ayon_id)\n\n        if not folder_ids:\n            return output\n\n        products_by_folder_id = {\n            folder_id: []\n            for folder_id in folder_ids\n        }\n        products_mapping = {}\n        version_ints = set()\n        for product_entity in ayon_api.get_products(\n            self.project_name,\n            folder_ids=folder_ids,\n            fields={\"id\", \"folderId\", \"name\"},\n        ):\n            folder_id = product_entity[\"folderId\"]\n            ftrack_id = folders_mapping[folder_id]\n            product_name_low = product_entity[\"name\"].lower()\n            matching_asset = None\n            alternatives = []\n            for asset in assets_by_parent_id[ftrack_id]:\n                low_name = asset[\"name\"].lower()\n                if low_name == product_name_low:\n                    matching_asset = asset\n                    break\n\n                if product_name_low in low_name:\n                    alternatives.append(asset)\n\n            if matching_asset is None and alternatives:\n                matching_asset = alternatives[0]\n\n            if matching_asset is None:\n                continue\n\n            asset_id = matching_asset[\"id\"]\n\n            version_ints |= {\n                asset_version[\"version\"]\n                for asset_version in asset_versions_by_asset_id[asset_id]\n            }\n\n            product_id = product_entity[\"id\"]\n            products_mapping[asset_id] = product_id\n            products_by_folder_id[folder_id].append(product_entity)\n\n        if not products_mapping:\n            return output\n\n        product_ids = set(products_mapping.values())\n        version_entities_by_product_id = {\n            product_id: []\n            for product_id in product_ids\n        }\n        for version_entity in ayon_api.get_versions(\n            self.project_name,\n            product_ids=product_ids,\n            versions=version_ints,\n            fields={\"id\", \"productId\", \"version\"},\n        ):\n            product_id = version_entity[\"productId\"]\n            version_entities_by_product_id[product_id].append(version_entity)\n\n        for asset_id, asset_versions in asset_versions_by_asset_id.items():\n            asset = assets_by_id.get(asset_id)\n            product_id = products_mapping.get(asset_id)\n            if asset is None or not product_id:\n                continue\n\n            version_ids_by_version = {\n                version[\"version\"]: version[\"id\"]\n                for version in version_entities_by_product_id[product_id]\n            }\n            if not version_ids_by_version:\n                continue\n\n            for asset_version in asset_versions:\n                version = asset_version[\"version\"]\n                version_id = version_ids_by_version.get(version)\n                if version_id is None:\n                    continue\n                asset_version_id = asset_version[\"id\"]\n                output[asset_version_id] = version_id\n\n        return output\n\n    def create_report(\n        self, ft_entities_by_id: dict[str, \"FtrackEntity\"]\n    ) -&gt; None:\n        report_items = []\n\n        # --- Immutable entities ---\n        # Removed entities - they don't have ftrack euqivalent anymore\n        deleted_paths = []\n        for entity_id in self._im_removed_entity_ids:\n            entity = self._entity_hub.get_entity_by_id(entity_id)\n            path = entity.attribs[FTRACK_PATH_ATTRIB]\n            if not path:\n                path = entity.path\n            deleted_paths.append(path)\n\n        deleted_paths.sort()\n        if deleted_paths:\n            report_items.append({\n                \"type\": \"label\",\n                \"value\": \"## Not found entities\"\n            })\n            for path in deleted_paths:\n                self.log.info((\n                    f\"Skipped sync of immutable entity {path} (was removed)\"\n                ))\n                report_items.append({\"type\": \"label\", \"value\": f\"- {path}\"})\n\n        # Changed position or name\n        renamed_mapping = {}\n        changed_hierarchy = (\n            self._im_renamed_entity_ids | self._im_moved_entity_ids\n        )\n        for entity_id in changed_hierarchy:\n            entity = self._entity_hub.get_entity_by_id(entity_id)\n            ftrack_id = entity.attribs[FTRACK_ID_ATTRIB]\n            ft_entity = ft_entities_by_id.get(ftrack_id)\n            if ft_entity is None:\n                continue\n            path = \"/\".join([\n                item[\"name\"]\n                for item in ft_entity[\"link\"]\n                if item[\"type\"] != \"Project\"\n            ])\n            expected_path = entity.attribs[FTRACK_PATH_ATTRIB]\n            if not expected_path:\n                expected_path = entity.path\n            renamed_mapping[path] = expected_path\n\n        renamed_paths = []\n        for path in sorted(renamed_mapping.keys()):\n            renamed_paths.append((path, renamed_mapping[path]))\n\n        if renamed_paths:\n            if report_items:\n                report_items.append({\"type\": \"label\", \"value\": \"---\"})\n            report_items.append({\n                \"type\": \"label\",\n                \"value\": \"## Renamed/Moved entities\"\n            })\n            report_items.append({\n                \"type\": \"label\",\n                \"value\": (\n                    \"Entities were renamed or moved to different location\"\n                    \" but it is not allowed to propagate the change.\"\n                )\n            })\n            for (path, expected_path) in renamed_paths:\n                self.log.info((\n                    \"Skipped sync of immutable\"\n                    f\" entity {path} -&gt; {expected_path}\"\n                ))\n                report_items.append({\n                    \"type\": \"label\",\n                    \"value\": f\"- {path} -&gt; {expected_path}\"\n                })\n\n        # --- Other possible issues ---\n        synced_path_mapping = collections.defaultdict(list)\n        for ftrack_id, entity in self._duplicated_ftrack_ids.items():\n            synced_path = entity.attribs[FTRACK_PATH_ATTRIB]\n            ft_entity = ft_entities_by_id.get(ftrack_id)\n            if ft_entity is not None:\n                path = \"/\".join([\n                    item[\"name\"]\n                    for item in ft_entity[\"link\"]\n                    if item[\"type\"] != \"Project\"\n                ])\n                synced_path_mapping[synced_path].append(path)\n\n        if synced_path_mapping:\n            if report_items:\n                report_items.append({\"type\": \"label\", \"value\": \"---\"})\n\n            report_items.append({\n                \"type\": \"label\",\n                \"value\": \"## Duplicated names\"\n            })\n            for synced_path in sorted(synced_path_mapping.keys()):\n                paths = synced_path_mapping[synced_path]\n                self.log.info((\n                    \"Skipped sync because duplicated names.\"\n                    \"\\nSource entity: {}\\n{}\"\n                ).format(\n                    synced_path,\n                    \"\\n\".join([f\"- {path}\" for path in paths])\n                ))\n                report_items.append({\n                    \"type\": \"label\",\n                    \"value\": f\"### {synced_path}\"\n                })\n                for path in paths:\n                    report_items.append({\n                        \"type\": \"label\",\n                        \"value\": f\"- {path}\"\n                    })\n\n        if self._missing_link_type:\n            report_items.append({\n                \"type\": \"label\",\n                \"value\": (\n                    f\"## Link type '{self._missing_link_type}' was\"\n                    f\" not found on project '{self.project_name}'\"\n                ),\n            })\n\n        self._report_items = report_items\n</code></pre>"},{"location":"autoapi/services/processor/processor/lib/sync_from_ftrack.html#services.processor.processor.lib.sync_from_ftrack.SyncFromFtrack.log","title":"<code>log</code>  <code>property</code>","text":"<p>Logger object.</p> <p>Returns:</p> Type Description <p>logging.Logger: Logger object.</p>"},{"location":"autoapi/services/processor/processor/lib/sync_from_ftrack.html#services.processor.processor.lib.sync_from_ftrack.SyncFromFtrack.project_name","title":"<code>project_name</code>  <code>property</code>","text":"<p>Name of project which is synchronized.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Project name which is synchronized.</p>"},{"location":"autoapi/services/processor/processor/lib/sync_from_ftrack.html#services.processor.processor.lib.sync_from_ftrack.SyncFromFtrack.report_items","title":"<code>report_items</code>  <code>property</code>","text":"<p>Report items shown once finished.</p> <p>Returns:</p> Type Description <p>list[dict[str, Any]]: List of interface items for ftrack UI.</p>"},{"location":"autoapi/services/processor/processor/lib/sync_from_ftrack.html#services.processor.processor.lib.sync_from_ftrack.SyncFromFtrack.create_project","title":"<code>create_project(preset_name, attributes)</code>","text":"<p>Create project on AYON server.</p> <p>Parameters:</p> Name Type Description Default <code>preset_name</code> <code>str</code> <p>Name of anatomy preset that will be used.</p> required <code>attributes</code> <code>dict[str, Any]</code> <p>Attributes for project creation.</p> required Source code in <code>services/processor/processor/lib/sync_from_ftrack.py</code> <pre><code>def create_project(\n    self,\n    preset_name: str,\n    attributes: dict[str, Any],\n) -&gt; None:\n    \"\"\"Create project on AYON server.\n\n    Args:\n        preset_name (str): Name of anatomy preset that will be used.\n        attributes (dict[str, Any]): Attributes for project creation.\n\n    \"\"\"\n    project_name = self.project_name\n    if self.project_exists_in_ayon():\n        return\n\n    ft_session = self._ft_session\n    ft_project = _get_ftrack_project(ft_session, project_name)\n    self.log.info(f\"Creating project \\\"{project_name}\\\" on server\")\n    project_code = ft_project[\"name\"]\n    create_project(\n        project_name,\n        project_code,\n        preset_name=preset_name\n    )\n    self.log.info(f\"Project \\\"{project_name}\\\" created on server\")\n\n    self.sync_project_types(ft_project, ft_session)\n    self.sync_statuses(ft_project, ft_session)\n    project_entity = self._entity_hub.project_entity\n    for key, value in attributes.items():\n        project_entity.attribs[key] = value\n    self._entity_hub.commit_changes()\n</code></pre>"},{"location":"autoapi/services/processor/processor/lib/sync_from_ftrack.html#services.processor.processor.lib.sync_from_ftrack.SyncFromFtrack.match_existing_entities","title":"<code>match_existing_entities(ft_project, ft_entities_by_parent_id, ft_object_type_name_by_id, ft_type_names_by_id, cust_attr_value_by_entity_id)</code>","text":"<p>Match exiting entities on both sides.</p> <p>Create new entities that are on ftrack and are not on server and remove those which are not on ftrack.</p> Todos <p>Handle duplicates more clearly. Don't compare children only by name     but also by type (right now task == folder).</p> <p>Parameters:</p> Name Type Description Default <code>ft_project</code> <code>Entity</code> <p>ftrack project entity.</p> required <code>ft_entities_by_parent_id</code> <code>dict[str, list[Entity]]</code> <p>Map of ftrack entities by their parent ids.</p> required <code>ft_object_type_name_by_id</code> <code>dict[str, str]</code> <p>Mapping of ftrack object type ids to their names.</p> required <code>ft_type_names_by_id</code> <code>dict[str, str]</code> <p>Mapping of ftrack task type ids to their names.</p> required <code>cust_attr_value_by_entity_id</code> <code>dict[str, dict[str, Any]</code> <p>Custom attribute values by key stored by entity id.</p> required Source code in <code>services/processor/processor/lib/sync_from_ftrack.py</code> <pre><code>def match_existing_entities(\n    self,\n    ft_project: \"FtrackEntity\",\n    ft_entities_by_parent_id: dict[str, list[\"FtrackEntity\"]],\n    ft_object_type_name_by_id: dict[str, \"FtrackEntity\"],\n    ft_type_names_by_id: dict[str, str],\n    cust_attr_value_by_entity_id: dict[str, dict[str, Any]],\n) -&gt; None:\n    \"\"\"Match exiting entities on both sides.\n\n    Create new entities that are on ftrack and are not on server and remove\n    those which are not on ftrack.\n\n    Todos:\n        Handle duplicates more clearly. Don't compare children only by name\n            but also by type (right now task == folder).\n\n    Args:\n        ft_project (FtrackEntity): ftrack project entity.\n        ft_entities_by_parent_id (dict[str, list[FtrackEntity]]): Map\n            of ftrack entities by their parent ids.\n        ft_object_type_name_by_id (dict[str, str]): Mapping of ftrack\n            object type ids to their names.\n        ft_type_names_by_id (dict[str, str]): Mapping of ftrack task type\n            ids to their names.\n        cust_attr_value_by_entity_id (dict[str, dict[str, Any]): Custom\n            attribute values by key stored by entity id.\n    \"\"\"\n\n    fill_queue = collections.deque()\n    for ft_child in ft_entities_by_parent_id[ft_project[\"id\"]]:\n        fill_queue.append((self._entity_hub.project_entity, ft_child))\n\n    def _add_children_to_queue(ft_entity_id):\n        children = ft_entities_by_parent_id[ft_entity_id]\n        if not children:\n            return\n\n        entity_id = self._ids_mapping.get_server_mapping(ft_entity_id)\n        entity = None\n        if entity_id:\n            entity = self._entity_hub.get_entity_by_id(entity_id)\n\n        for ft_child in children:\n            fill_queue.append((entity, ft_child))\n\n    while fill_queue:\n        (parent_entity, ft_entity) = fill_queue.popleft()\n        ft_entity_path = \"/\".join([\n            item[\"name\"]\n            for item in ft_entity[\"link\"]\n        ])\n        ft_entity_id = ft_entity[\"id\"]\n        # Go to next children if is already processed\n        if ft_entity_id in self._processed_ftrack_ids:\n            _add_children_to_queue(ft_entity_id)\n            self.log.debug(\n                f\"{ft_entity_path} - ftrack id already processed\")\n            continue\n\n        if parent_entity is None:\n            self._skipped_ftrack_ids.add(ft_entity_id)\n            _add_children_to_queue(ft_entity_id)\n            self.log.debug(f\"{ft_entity_path} - Skipped\")\n            continue\n\n        if (\n            parent_entity.entity_type == \"project\"\n            and ft_entity.entity_type.lower() == \"task\"\n        ):\n            self._skipped_ftrack_ids.add(ft_entity_id)\n            self.log.debug(\n                f\"{ft_entity_path} - Skipped task at projectroot\"\n            )\n            continue\n\n        label = ft_entity[\"name\"]\n        name = slugify_string(label)\n        matching_name_entity = None\n        for child in parent_entity.children:\n            if child.name.lower() == name.lower():\n                matching_name_entity = child\n                break\n\n        ft_is_folder = ft_entity.entity_type != \"Task\"\n        if matching_name_entity is not None:\n            # If entity was already processed we can skip ftrack entity\n            # --- This is last condition that handle immutable entities ---\n            #   After this condition can be server entities changed,\n            #       removed or created.\n            if matching_name_entity.id in self._processed_server_ids:\n                self._processed_ftrack_ids.add(ft_entity_id)\n                self._duplicated_ftrack_ids[ft_entity_id] = (\n                    matching_name_entity\n                )\n                _add_children_to_queue(ft_entity_id)\n                self.log.debug(\n                    f\"{ft_entity_path} - Server id already processed\")\n                continue\n\n            is_folder = matching_name_entity.entity_type == \"folder\"\n            # It is possible to remove previous server entity at this point\n            #   as we're 100% sure it is not immutable at this point\n            if ft_is_folder is not is_folder:\n                self.log.debug(\n                    f\"{ft_entity_path} - Deleted previous entity\")\n                # Remove current entity if type does not match\n                matching_name_entity.parent_id = None\n                # Reset variable so new entity is created\n                matching_name_entity = None\n\n        # No match was found, so we can create new server entity\n        if matching_name_entity is None:\n            self.log.debug(f\"{ft_entity_path} - Creating new entity\")\n            entity = self._create_new_entity(\n                parent_entity,\n                ft_entity,\n                ft_object_type_name_by_id,\n                ft_type_names_by_id,\n                cust_attr_value_by_entity_id,\n            )\n            self._processed_server_ids.add(entity.id)\n            self._processed_ftrack_ids.add(ft_entity_id)\n            _add_children_to_queue(ft_entity_id)\n            continue\n\n        self.log.debug(f\"{ft_entity_path} - Updating existing entity\")\n        matching_name_entity.name = name\n        matching_name_entity.label = label\n        matching_name_entity.active = True\n        if matching_name_entity.entity_type == \"task\":\n            task_type_id = ft_entity[\"type_id\"]\n            task_type_name = ft_type_names_by_id[task_type_id]\n            if matching_name_entity.task_type != task_type_name:\n                matching_name_entity.task_type = task_type_name\n\n        else:\n            object_type_id = ft_entity[\"object_type_id\"]\n            object_type_name = ft_object_type_name_by_id[\n                object_type_id]\n            if matching_name_entity.folder_type != object_type_name:\n                matching_name_entity.folder_type = object_type_name\n\n        self._processed_server_ids.add(matching_name_entity.id)\n        self._processed_ftrack_ids.add(ft_entity_id)\n        self._ids_mapping.set_ftrack_to_server(\n            ft_entity_id, matching_name_entity.id\n        )\n        _add_children_to_queue(ft_entity_id)\n\n    deactivate_queue = collections.deque()\n    for child in self._entity_hub.project_entity.children:\n        deactivate_queue.append(child)\n\n    while deactivate_queue:\n        entity = deactivate_queue.popleft()\n        if entity.id not in self._processed_server_ids:\n            entity.active = False\n\n        for child in entity.children:\n            deactivate_queue.append(child)\n</code></pre>"},{"location":"autoapi/services/processor/processor/lib/sync_from_ftrack.html#services.processor.processor.lib.sync_from_ftrack.SyncFromFtrack.project_exists_in_ayon","title":"<code>project_exists_in_ayon()</code>","text":"<p>Does project exists on AYON server by name.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Project exists in AYON.</p> Source code in <code>services/processor/processor/lib/sync_from_ftrack.py</code> <pre><code>def project_exists_in_ayon(self) -&gt; bool:\n    \"\"\"Does project exists on AYON server by name.\n\n    Returns:\n        bool: Project exists in AYON.\n    \"\"\"\n\n    # Make sure project exists on server\n    if not self.get_ayon_project():\n        return False\n    return True\n</code></pre>"},{"location":"autoapi/services/processor/processor/lib/sync_from_ftrack.html#services.processor.processor.lib.sync_from_ftrack.SyncFromFtrack.sync_project_types","title":"<code>sync_project_types(ft_project, ft_session)</code>","text":"<p>Sync project types from ftrack to AYON.</p> <p>Parameters:</p> Name Type Description Default <code>ft_project</code> <code>Entity</code> <p>ftrack project entity.</p> required <code>ft_session</code> <code>Session</code> <p>ftrack session.</p> required <p>Returns:</p> Type Description <code>tuple[list[Entity], list[Entity]]</code> <p>tuple[list, list]: Tuple of object types and task types.</p> Source code in <code>services/processor/processor/lib/sync_from_ftrack.py</code> <pre><code>def sync_project_types(\n    self,\n    ft_project: \"FtrackEntity\",\n    ft_session: \"FtrackSession\",\n) -&gt; tuple[list[\"FtrackEntity\"], list[\"FtrackEntity\"]]:\n    \"\"\"Sync project types from ftrack to AYON.\n\n    Args:\n        ft_project (FtrackEntity): ftrack project entity.\n        ft_session (FtrackSession): ftrack session.\n\n    Returns:\n        tuple[list, list]: Tuple of object types and task types.\n    \"\"\"\n\n    self._entity_hub.fill_project_from_server()\n    # Get Folder types and Task types from ftrack\n    ft_object_types = ft_session.query(\n        \"select id, name, sort from ObjectType\").all()\n    ft_object_types_by_id = {\n        ft_object_type[\"id\"]: ft_object_type\n        for ft_object_type in ft_object_types\n    }\n\n    ft_types = ft_session.query(\"select id, name, sort from Type\").all()\n    ft_types_by_id = {\n        ft_type[\"id\"]: ft_type\n        for ft_type in ft_types\n    }\n\n    # Filter folder and task types for this project based on schema\n    project_schema = ft_project[\"project_schema\"]\n    object_types = {\n        ft_object_types_by_id[object_type[\"id\"]]\n        for object_type in project_schema[\"object_types\"]\n    }\n    task_types = {\n        ft_types_by_id[task_type[\"id\"]]\n        for task_type in project_schema[\"task_type_schema\"][\"types\"]\n    }\n\n    # Update types on project entity from ftrack\n    self.update_project_types(object_types, task_types)\n    return object_types, task_types\n</code></pre>"},{"location":"autoapi/services/processor/processor/lib/sync_from_ftrack.html#services.processor.processor.lib.sync_from_ftrack.SyncFromFtrack.sync_to_server","title":"<code>sync_to_server()</code>","text":"<p>Sync project with hierarchy from ftrack to AYON server.</p> Source code in <code>services/processor/processor/lib/sync_from_ftrack.py</code> <pre><code>def sync_to_server(self) -&gt; None:\n    \"\"\"Sync project with hierarchy from ftrack to AYON server.\"\"\"\n\n    t_start = time.perf_counter()\n    project_name = self.project_name\n    # Make sure project exists on server\n    if not self.project_exists_in_ayon():\n        self.log.info(\n            f\"Project \\\"{project_name}\\\" does not exist on server.\"\n            \" Skipping project synchronization.\"\n        )\n        self._report_items.extend([\n            {\n                \"type\": \"label\",\n                \"value\": (\n                    f\"## Project '{project_name}' does not exist in AYON\"\n                )\n            },\n            {\n                \"type\": \"label\",\n                \"value\": (\n                    \"Synchronization was skipped.\"\n                    \"&lt;br/&gt;Run Prepare Project action or create the\"\n                    \" project manually on server and then run the\"\n                    \" action again.\"\n                )\n            }\n        ])\n        return\n\n    ft_session = self._ft_session\n\n    if not self.ensure_mandatory_custom_attributes_exists(ft_session):\n        return\n\n    self.log.info(\n        f\"Synchronization of project \\\"{project_name}\\\" started\"\n    )\n\n    # Get ftrack custom attributes to sync\n    attr_confs = ft_session.query(\n        \"select id, key, is_hierarchical, default\"\n        \" from CustomAttributeConfiguration\"\n    ).all()\n\n    # Check if there is custom attribute to store server id\n    server_id_conf_id = None\n    server_path_conf_id = None\n    sync_failed_conf_id = None\n    list_type_conf = None\n    for attr_conf in attr_confs:\n        if attr_conf[\"key\"] == CUST_ATTR_KEY_SERVER_ID:\n            server_id_conf_id = attr_conf[\"id\"]\n        elif attr_conf[\"key\"] == CUST_ATTR_KEY_SERVER_PATH:\n            server_path_conf_id = attr_conf[\"id\"]\n        elif attr_conf[\"key\"] == CUST_ATTR_KEY_SYNC_FAIL:\n            sync_failed_conf_id = attr_conf[\"id\"]\n        elif attr_conf[\"key\"] == CUST_ATTR_KEY_LIST_TYPE:\n            list_type_conf = attr_conf\n\n    missing_attrs = []\n    if not server_id_conf_id:\n        missing_attrs.append(CUST_ATTR_KEY_SERVER_ID)\n\n    if not server_path_conf_id:\n        missing_attrs.append(CUST_ATTR_KEY_SERVER_PATH)\n\n    if not sync_failed_conf_id:\n        missing_attrs.append(CUST_ATTR_KEY_SYNC_FAIL)\n\n    if missing_attrs:\n        attr_end = \"\"\n        was_were = \"was\"\n        if len(missing_attrs) &gt; 1:\n            attr_end = \"s\"\n            was_were = \"were\"\n        joined_attrs = \", \".join([f'\"{attr}\"'for attr in missing_attrs])\n        msg = (\n            f\"Hierarchical attribute{attr_end} {joined_attrs}\"\n            f\" {was_were} not found in ftrack\"\n        )\n\n        self.log.warning(msg)\n        raise ValueError(msg)\n\n    # Query ftrack project\n    ft_project = _get_ftrack_project(ft_session, project_name)\n\n    ft_status_by_id = {\n        status[\"id\"]: status\n        for status in self._ft_session.query(\n            \"select id, name, color, state, sort from Status\"\n        ).all()\n    }\n    self.sync_project_types(ft_project, ft_session)\n    self.sync_statuses(\n        ft_project,\n        ft_session,\n        ft_status_by_id\n    )\n\n    self._entity_hub.commit_changes()\n\n    t_project_existence_1 = time.perf_counter()\n    self.log.debug(\n        \"Initial preparation took\"\n        f\" {t_project_existence_1 - t_start:.2f}s\"\n    )\n    self.log.debug(\"Loading entities from server\")\n    # Query entities from server (project, folders and tasks)\n    self._entity_hub.fetch_hierarchy_entities()\n    self._ids_mapping.set_ftrack_to_server(\n        ft_project[\"id\"], self._entity_hub.project_entity.id\n    )\n    t_server_query_2 = time.perf_counter()\n    self.log.debug((\n        \"Loading of entities from server took\"\n        f\" {t_server_query_2 - t_project_existence_1:.2f}s\"\n    ))\n\n    self.log.info(\"Querying necessary data from ftrack\")\n\n    object_types, task_types = self.sync_project_types(\n        ft_project, ft_session\n    )\n    ft_object_type_name_by_id = {\n        object_type[\"id\"]: object_type[\"name\"]\n        for object_type in object_types\n    }\n    ft_type_names_by_id = {\n        task_type[\"id\"]: task_type[\"name\"]\n        for task_type in task_types\n    }\n\n    t_types_sync_3 = time.perf_counter()\n    self.log.debug((\n        \"Update of types from ftrack took\"\n        f\" {t_types_sync_3 - t_server_query_2:.2f}s\"\n    ))\n\n    self.log.info(\"Querying project hierarchy from ftrack\")\n    ft_entities = ft_session.query((\n        \"select id, name, parent_id, type_id, object_type_id, status_id\"\n        \", start_date, end_date, description, status_id\"\n        \" from TypedContext where project_id is \\\"{}\\\"\"\n    ).format(ft_project[\"id\"])).all()\n    t_ft_entities_4 = time.perf_counter()\n    self.log.debug((\n        \"Query of ftrack entities took\"\n        f\" {t_ft_entities_4 - t_types_sync_3:.2f}s\"\n    ))\n\n    ft_entities_by_id = {ft_project[\"id\"]: ft_project}\n    ft_entities_by_parent_id = collections.defaultdict(list)\n    for entity in ft_entities:\n        entity_id = entity[\"id\"]\n        parent_id = entity[\"parent_id\"]\n        ft_entities_by_id[entity_id] = entity\n        ft_entities_by_parent_id[parent_id].append(entity)\n\n    cust_attr_value_by_entity_id = self._prepare_attribute_values(\n        ft_session,\n        attr_confs,\n        ft_entities_by_id,\n    )\n\n    self.log.info(\"Checking changes of immutable entities\")\n    self.match_immutable_entities(\n        ft_project,\n        ft_entities_by_id,\n        ft_entities_by_parent_id,\n    )\n\n    self.log.info(\"Matching ftrack to server hierarchy\")\n    self.match_existing_entities(\n        ft_project,\n        ft_entities_by_parent_id,\n        ft_object_type_name_by_id,\n        ft_type_names_by_id,\n        cust_attr_value_by_entity_id\n    )\n\n    self.log.info(\"Updating assignees\")\n    self.update_assignees_from_ftrack(\n        ft_entities_by_id\n    )\n\n    self.log.info(\"Updating attributes of entities\")\n\n    ayon_statuses_by_name = {\n        status[\"name\"].lower(): status\n        for status in self._entity_hub.project_entity[\"statuses\"]\n    }\n    self.update_attributes_from_ftrack(\n        cust_attr_value_by_entity_id,\n        ft_entities_by_id,\n        ft_status_by_id,\n        ayon_statuses_by_name,\n    )\n    self._entity_hub.commit_changes()\n\n    self.log.info(\"Updating entity links\")\n    self.update_links_from_ftrack(ft_entities_by_id)\n\n    self.log.info(\"Updating server ids on ftrack entities\")\n    self.update_ftrack_attributes(\n        ft_entities_by_id,\n        cust_attr_value_by_entity_id,\n        server_id_conf_id,\n        server_path_conf_id,\n        sync_failed_conf_id\n    )\n\n    settings = self.get_ftrack_project_settings()\n    sync_versions: bool = (\n        settings\n        [\"service_event_handlers\"]\n        [\"sync_from_ftrack\"]\n        [\"sync_versions\"]\n    )\n    if sync_versions:\n        self.log.info(\"Synchronizing versions\")\n        t_version_start = time.perf_counter()\n        self.update_versions(\n            ft_session,\n            ft_entities_by_id,\n            server_id_conf_id,\n            ayon_statuses_by_name,\n        )\n        t_version_end = time.perf_counter()\n        self.log.info(\n            \"Synchronizing versions took\"\n            f\" {t_version_end - t_version_start:.2f}s\"\n        )\n\n    self.log.info(\"Synchronizing version lists\")\n    self.sync_lists(\n        ft_project,\n        server_id_conf_id,\n        list_type_conf,\n        sync_versions,\n    )\n\n    self.create_report(ft_entities_by_id)\n    t_end = time.perf_counter()\n    self.log.info((\n        f\"Synchronization of project \\\"{project_name}\\\" finished\"\n        f\" in {t_end - t_start:.2f}s\"\n    ))\n</code></pre>"},{"location":"autoapi/services/processor/processor/lib/sync_from_ftrack.html#services.processor.processor.lib.sync_from_ftrack.SyncFromFtrack.update_versions","title":"<code>update_versions(ft_session, ft_entities_by_id, server_id_conf_id, ayon_statuses_by_name)</code>","text":"<p>Synchronize versions information to AYON.</p> <p>Parameters:</p> Name Type Description Default <code>ft_session</code> <code>Session</code> <p>Ftrack session.</p> required <code>ft_entities_by_id</code> <code>dict[str, Entity]</code> <p>Mapping of ftrack entity ids.</p> required <code>server_id_conf_id</code> <code>str</code> <p>Id of 'ayon_id' custom attribute.</p> required <code>ayon_statuses_by_name</code> <code>dict[str, dict[str, Any]]</code> <p>Mapping of AYON statuses by name.</p> required Source code in <code>services/processor/processor/lib/sync_from_ftrack.py</code> <pre><code>def update_versions(\n    self,\n    ft_session: \"FtrackSession\",\n    ft_entities_by_id: dict[str, \"FtrackEntity\"],\n    server_id_conf_id: str,\n    ayon_statuses_by_name: dict[str, dict[str, Any]],\n) -&gt; None:\n    \"\"\"Synchronize versions information to AYON.\n\n    Args:\n        ft_session (FtrackSession): Ftrack session.\n        ft_entities_by_id (dict[str, FtrackEntity]): Mapping of ftrack\n            entity ids.\n        server_id_conf_id (str): Id of 'ayon_id' custom attribute.\n        ayon_statuses_by_name (dict[str, dict[str, Any]]): Mapping of AYON\n            statuses by name.\n\n    \"\"\"\n    context_ids = set()\n    for entity in ft_entities_by_id.values():\n        if entity.entity_type != \"Task\":\n            context_ids.add(entity[\"id\"])\n\n    if not context_ids:\n        return\n\n    assets_by_id = {}\n    asset_ids_by_context_id = {\n        context_id: []\n        for context_id in context_ids\n    }\n    for chunk in create_chunks(context_ids, 50):\n        joined_ids = join_filter_values(chunk)\n        for asset in ft_session.query(\n            \"select id, context_id, name from Asset\"\n            f\" where context_id in ({joined_ids})\"\n        ):\n            asset_id = asset[\"id\"]\n            context_id = asset[\"context_id\"]\n            assets_by_id[asset_id] = asset\n            asset_ids_by_context_id[context_id].append(asset_id)\n\n    if not assets_by_id:\n        return\n\n    asset_version_by_id = {}\n    asset_version_ids_by_asset_id = {\n        asset_id: []\n        for asset_id in assets_by_id\n    }\n    for chunk in create_chunks(assets_by_id, 50):\n        joined_ids = join_filter_values(chunk)\n        for asset_version in ft_session.query(\n            \"select id, asset_id, version, status_id from AssetVersion\"\n            f\" where asset_id in ({joined_ids})\"\n        ):\n            av_id = asset_version[\"id\"]\n            asset_id = asset_version[\"asset_id\"]\n            asset_version_by_id[av_id] = asset_version\n            asset_version_ids_by_asset_id[asset_id].append(av_id)\n\n    version_mapping = self._find_versions_ayon_mapping(\n        ft_session,\n        server_id_conf_id,\n        set(asset_version_by_id.keys()),\n    )\n    ayon_ids = set(version_mapping.values())\n    ayon_ids.discard(None)\n    if not ayon_ids:\n        return\n\n    versions_by_id = {\n        version[\"id\"]: version\n        for version in ayon_api.get_versions(\n            self.project_name,\n            version_ids=ayon_ids,\n            fields={\"id\", \"status\"},\n        )\n    }\n    status_name_by_id = {\n        status[\"id\"]: status[\"name\"]\n        for status in self._ft_session.query(\n            \"select id, name from Status\"\n        ).all()\n    }\n\n    op_count = 0\n    operations = OperationsSession()\n    for ftrack_id, ayon_id in version_mapping.items():\n        # Mapping to AYON entity was not found\n        if not ayon_id:\n            continue\n\n        ay_version = versions_by_id.get(ayon_id)\n        ft_av = asset_version_by_id.get(ftrack_id)\n        # Entities are not found\n        if ay_version is None or ft_av is None:\n            continue\n\n        # AYON version was already mapped to a different ftrack version\n        if self._ids_mapping.get_ftrack_mapping(ayon_id):\n            continue\n        self._ids_mapping.set_ftrack_to_server(ftrack_id, ayon_id)\n\n        ft_status_id = ft_av[\"status_id\"]\n        status_name = status_name_by_id[ft_status_id]\n        ayon_status_name = self._get_ayon_status(\n            ayon_statuses_by_name,\n            \"version\",\n            status_name\n        )\n        # AYON status is not available or is same as current status\n        if (\n            not ayon_status_name\n            or ay_version[\"status\"] == ayon_status_name\n        ):\n            continue\n\n        operations.update_version(\n            self.project_name,\n            ayon_id,\n            status=ayon_status_name,\n        )\n        op_count += 1\n        if op_count == 100:\n            operations.commit()\n            op_count = 0\n\n    if op_count &gt; 0:\n        operations.commit()\n</code></pre>"},{"location":"autoapi/services/transmitter/transmitter/index.html","title":"transmitter","text":""},{"location":"autoapi/services/transmitter/transmitter/__main__.html","title":"__main__","text":""},{"location":"autoapi/services/transmitter/transmitter/logic.html","title":"logic","text":""},{"location":"autoapi/services/transmitter/transmitter/logic.html#services.transmitter.transmitter.logic.EventProcessor","title":"<code>EventProcessor</code>","text":"Source code in <code>services/transmitter/transmitter/logic.py</code> <pre><code>class EventProcessor:\n    def __init__(self, session: ftrack_api.Session):\n        self._session = session\n        self._log = logging.getLogger(self.__class__.__name__)\n\n    def process_event(\n        self,\n        source_event: Dict[str, Any],\n        job_event: JobEventType,\n    ):\n        job_status = \"finished\"\n        try:\n            self._log.info(\"Processing event: %s\", job_event[\"id\"])\n            topic: str = source_event[\"topic\"]\n            if topic == \"reviewable.created\":\n                self._process_reviewable_created(source_event)\n            elif topic.startswith(\"entity_list\"):\n                self._process_list_event(source_event)\n            elif topic.startswith(\"entity\"):\n                self._process_entity_event(source_event)\n            else:\n                self._log.error(f\"Unknown topic: '{topic}'\")\n            self._log.info(\"Processing finished\")\n\n        except Exception:\n            self._log.warning(\"Failed to process event.\", exc_info=True)\n            job_status = \"failed\"\n\n        finally:\n            ayon_api.update_event(\n                job_event[\"id\"],\n                status=job_status\n            )\n\n    def sync_comments(self):\n        self._log.info(\"Synchronizing comments from AYON to ftrack.\")\n        project_names = self._get_sync_project_names()\n        if not project_names:\n            return\n\n        any_in_progress = self._cleanup_in_progress_comment_events()\n        if any_in_progress:\n            return\n\n        now = arrow.utcnow()\n        activities_after_date = None\n\n        last_finished_event = self._get_last_finished_event()\n        if last_finished_event is not None:\n            created_at = arrow.get(\n                last_finished_event[\"createdAt\"]\n            ).to(\"local\")\n            delta = now - created_at\n            if delta.seconds &lt; COMMENTS_SYNC_INTERVAL:\n                return\n            activities_after_date = created_at\n\n        if activities_after_date is None:\n            activities_after_date = now - datetime.timedelta(days=5)\n\n        response = ayon_api.dispatch_event(\n            FTRACK_COMMENTS_TOPIC,\n            description=(\n                \"Synchronizing comments from ftrack to AYON.\"\n            ),\n            summary=None,\n            payload={},\n            finished=True,\n            store=True,\n        )\n        if isinstance(response, str):\n            event_id = response\n        else:\n            event_id = response[\"id\"]\n\n        ft_users = self._session.query(\n            \"select id, username, email from User\"\n        ).all()\n        ft_users_by_id = {\n            ft_user[\"id\"]: ft_user\n            for ft_user in ft_users\n        }\n        ayon_username_by_ft_id = map_ftrack_users_to_ayon_users(ft_users)\n        ft_id_by_ay_username = {\n            ayon_username: ft_user_id\n            for ft_user_id, ayon_username in ayon_username_by_ft_id.items()\n            if ayon_username\n        }\n        default_ft_user_id = next(\n            (\n                user[\"id\"]\n                for user in ft_users\n                if user[\"username\"] == self._session.api_user\n            ),\n            None\n        )\n        ft_id_by_ay_username[None] = default_ft_user_id\n        success = True\n        synced_comments = 0\n        try:\n            for project_name in project_names:\n                synced_comments += self._sync_project_comments(\n                    project_name,\n                    ft_id_by_ay_username,\n                    ft_users_by_id,\n                    activities_after_date,\n                )\n\n        except Exception:\n            success = False\n            self._log.warning(\"Failed to sync comments.\", exc_info=True)\n\n        finally:\n            ayon_api.update_event(\n                event_id,\n                description=(\n                    f\"Synchronized {synced_comments} comments\"\n                    \" from AYON to ftrack.\"\n                ),\n                status=\"finished\" if success else \"failed\",\n                payload={\"synced_comments\": synced_comments},\n            )\n\n    def soft_cleanup_sync_comment_events(\n        self, last_comments_soft_cleanup: int\n    ) -&gt; bool:\n        \"\"\"Remove sync comment events that did not sync any comments.\n\n        These comments are not relevant for any reference. The logic makes\n        sure that last finished event, important for comments sync, is not\n        removed.\n\n        \"\"\"\n        self._log.debug(\"Soft cleaning up comment sync events.\")\n        any_in_progress = self._cleanup_in_progress_comment_events()\n        if any_in_progress:\n            return False\n\n        last_finished_event = self._get_last_finished_event()\n        last_event_id = None\n        if last_finished_event:\n            last_event_id = last_finished_event[\"id\"]\n\n        older_than = None\n        if last_comments_soft_cleanup:\n            cleanup_date = arrow.utcnow() - datetime.timedelta(\n                seconds=(last_comments_soft_cleanup + 20)\n            )\n            older_than = cleanup_date.isoformat()\n\n        events_to_cleanup = list(ayon_api.get_events(\n            topics={FTRACK_COMMENTS_TOPIC},\n            statuses={\"finished\"},\n            older_than=older_than,\n            fields={\"id\"}\n        ))\n        removed = 0\n        for event in events_to_cleanup:\n            event_id = event[\"id\"]\n            if event_id == last_event_id:\n                continue\n            full_event = ayon_api.get_event(event_id)\n            if not full_event[\"payload\"].get(\"synced_comments\"):\n                removed += 1\n                ayon_api.delete_event(event_id)\n        self._log.debug(f\"Soft cleaned up {removed} events\")\n        return True\n\n    def cleanup_sync_comment_events(self) -&gt; bool:\n        self._log.debug(\"Cleaning up comment sync events.\")\n        any_in_progress = self._cleanup_in_progress_comment_events()\n        if any_in_progress:\n            return False\n\n        last_finished_event = self._get_last_finished_event()\n        last_event_id = None\n        if last_finished_event:\n            last_event_id = last_finished_event[\"id\"]\n\n        cleanup_date = arrow.utcnow() - datetime.timedelta(\n            days=COMMENT_EVENTS_CLEANUP_TIMEOUT_DAYS\n        )\n        events_to_cleanup = list(ayon_api.get_events(\n            topics={FTRACK_COMMENTS_TOPIC},\n            older_than=cleanup_date.isoformat(),\n            fields={\"id\"}\n        ))\n        removed = 0\n        for event in events_to_cleanup:\n            event_id = event[\"id\"]\n            if last_event_id == event_id:\n                continue\n            try:\n                ayon_api.delete_event(event_id)\n                removed += 1\n            except Exception:\n                self._log.warning(\n                    f\"Failed to delete event {event_id}.\",\n                    exc_info=True\n                )\n        self._log.debug(f\"Cleaned up {removed} events.\")\n        return True\n\n    def _cleanup_in_progress_comment_events(self) -&gt; bool:\n        in_progress_events = list(ayon_api.get_events(\n            topics={FTRACK_COMMENTS_TOPIC},\n            statuses={\"in_progress\"},\n            fields={\"id\", \"createdAt\"}\n        ))\n\n        any_in_progress = False\n        now = arrow.utcnow()\n        for event in in_progress_events:\n            created_at = arrow.get(event[\"createdAt\"]).to(\"local\")\n            delta = now - created_at\n            if delta.seconds &lt; COMMENTS_SYNC_TIMEOUT:\n                any_in_progress = True\n            else:\n                ayon_api.update_event(\n                    event[\"id\"],\n                    status=\"failed\",\n                )\n        return any_in_progress\n\n    def _get_last_finished_event(self):\n        finished_events = list(ayon_api.get_events(\n            topics={FTRACK_COMMENTS_TOPIC},\n            statuses={\"finished\"},\n            limit=1,\n            order=ayon_api.SortOrder.descending,\n        ))\n        for event in finished_events:\n            return event\n        return None\n\n    def _is_project_enabled(\n        self,\n        project_name: str,\n        *,\n        project_settings: Optional[dict[str, Any]] = None,\n    ) -&gt; bool:\n        if project_settings is None:\n            project_settings = ayon_api.get_addons_settings(\n                project_name=project_name\n            )\n\n        if not is_ftrack_enabled_in_settings(project_settings[\"ftrack\"]):\n            self._log.info(\n                f\"Project '{project_name}' is disabled for ftrack.\"\n            )\n            return False\n        return True\n\n    def _process_reviewable_created(self, source_event: dict[str, Any]):\n        # TODO implement\n        pass\n\n    def _process_list_event(self, source_event: dict[str, Any]) -&gt; None:\n        topic = source_event[\"topic\"]\n        action = topic.removeprefix(\"entity_list.\")\n        if action not in (\"created\", \"deleted\", \"changed\"):\n            self._log.warning(f\"Unhandled list event topic: {topic}\")\n            return\n\n        project_name = source_event[\"project\"]\n        if not self._is_project_enabled(project_name):\n            return\n\n        ftrack_project = self._session.query(\n            \"select id from Project\"\n            f\" where full_name is '{project_name}'\"\n        ).first()\n        if not ftrack_project:\n            self._log.info(f\"Project '{project_name}' not found in ftrack.\")\n            return\n\n        if action == \"created\":\n            self._create_ftrack_list(source_event, ftrack_project)\n\n        elif action == \"deleted\":\n            self._delete_ftrack_list(source_event, ftrack_project)\n\n        elif action == \"changed\":\n            self._update_ftrack_list(source_event, ftrack_project)\n\n    def _find_matching_ftrack_list(\n        self,\n        project_id: str,\n        source_event: dict[str, Any],\n        entity_list: Optional[dict[str, Any]] = None,\n    ):\n        ft_lists = self._session.query(\n            \"select id, name, category_id from List\"\n            f\" where project_id is '{project_id}'\"\n        ).all()\n\n        # It won't be possible to find an entity list in AYON if was removed\n        ftrack_id = None\n        if entity_list:\n            ftrack_id = entity_list[\"attrib\"].get(FTRACK_ID_ATTRIB)\n        if ftrack_id:\n            for ft_list in ft_lists:\n                if ft_list[\"id\"] == ftrack_id:\n                    return ft_list\n\n        summary = source_event[\"summary\"]\n        label = summary[\"label\"]\n        match_name = label.lower()\n        for ft_list in ft_lists:\n            ft_name = ft_list[\"name\"].lower()\n            if ft_name == match_name:\n                return ft_list\n        return None\n\n    def _delete_ftrack_list(\n        self,\n        source_event: dict[str, Any],\n        ftrack_project: \"FtrackEntityType\",\n    ) -&gt; None:\n        ft_project_id = ftrack_project[\"id\"]\n        ft_list = self._find_matching_ftrack_list(ft_project_id, source_event)\n        if ft_list is None:\n            return\n\n        summary = source_event[\"summary\"]\n        entity_type = summary[\"entity_type\"]\n        if ft_list.entity_type == \"AssetVersionList\":\n            if entity_type != \"version\":\n                return\n        elif ft_list.entity_type == \"TypedContextList\":\n            list_type_conf = self._session.query(\n                \"select id from CustomAttributeConfiguration\"\n                f\" where key is '{CUST_ATTR_KEY_LIST_TYPE}'\"\n            ).first()\n            if list_type_conf is None:\n                return\n\n            value = None\n            for item in query_custom_attribute_values(\n                self._session,\n                {list_type_conf[\"id\"]},\n                {ft_list[\"id\"]},\n            ):\n                value = item[\"value\"]\n                if value:\n                    break\n\n            if value and isinstance(value, list):\n                value = value[0]\n\n            if value != entity_type:\n                return\n\n        entity_key = collections.OrderedDict(id=ft_list[\"id\"])\n        self._session.recorded_operations.push(\n            ftrack_api.operation.DeleteEntityOperation(\n                \"List\",\n                entity_key\n            )\n        )\n        try:\n            self._session.commit()\n        finally:\n            self._session.recorded_operations.clear()\n\n    def _create_ftrack_list(\n        self,\n        source_event: dict[str, Any],\n        ftrack_project: \"FtrackEntityType\",\n    ) -&gt; None:\n        # For now, it looks like the logic is the same\n        self._update_ftrack_list(source_event, ftrack_project)\n\n    def _update_ftrack_list(\n        self,\n        source_event: dict[str, Any],\n        ftrack_project: \"FtrackEntityType\",\n    ) -&gt; None:\n        summary = source_event[\"summary\"]\n        entity_type = summary[\"entity_type\"]\n        if entity_type not in (\"folder\", \"task\", \"version\"):\n            self._log.warning(\n                \"Unknown AYON list entity type '%s'\", entity_type\n            )\n            return\n\n        project_name = source_event[\"project\"]\n        list_id = summary[\"id\"]\n        entity_list = ayon_api.get_entity_list_by_id(\n            project_name,\n            list_id,\n            fields={\n                \"id\",\n                \"label\",\n                \"entityType\",\n                f\"attrib.{FTRACK_ID_ATTRIB}\",\n                \"items.entityId\",\n            },\n        )\n        label = summary[\"label\"]\n\n        ft_project_id = ftrack_project[\"id\"]\n        match_list = self._find_matching_ftrack_list(\n            ft_project_id, source_event, entity_list\n        )\n        ft_list_label = None\n        if match_list is not None:\n            expected_type = None\n            if entity_type == \"version\":\n                if match_list[\"system_type\"] != \"assetversion\":\n                    expected_type = \"assetversion\"\n            elif entity_type in (\"task\", \"folder\"):\n                if match_list[\"system_type\"] != \"task\":\n                    expected_type = \"task\"\n            else:\n                self._log_warning(f\"Unknown list type '{entity_type}'.\")\n                return\n\n            if expected_type is not None:\n                self._log.warning(\n                    \"Failed to sync list '%s'. List already exists in\"\n                    \" ftrack but with entity type '%s'. Expected '%s'.\",\n                    label, match_list[\"system_type\"], expected_type\n                )\n                return\n\n            ft_list_id = match_list[\"id\"]\n            ft_list_label = match_list[\"name\"]\n\n        else:\n            system_type = \"assetversion\"\n            list_type_value = None\n            if entity_list[\"entityType\"] != \"version\":\n                system_type = \"task\"\n                list_type_value = entity_list[\"entityType\"]\n                list_type_conf = self._session.query(\n                    \"select id from CustomAttributeConfiguration\"\n                    f\" where key is '{CUST_ATTR_KEY_LIST_TYPE}'\"\n                ).first()\n                if list_type_conf is None:\n                    self._log.info(\n                        (\n                            \"Failed to create ftrack list '%s'. AYON list\"\n                            \" entity type is set to '%s' but custom\"\n                            \" attribute '%s' cannot be found.\"\n                        ),\n                        label, list_type_value, CUST_ATTR_KEY_LIST_TYPE\n                    )\n                    return\n\n            ft_list_label = label\n\n            # TODO better way how to determine list category on ftrack\n            list_category = self._session.query(\n                \"select id from ListCategory\"\n            ).first()\n\n            ft_list_id = str(uuid.uuid4())\n\n            ayon_api.update_entity_list(\n                project_name,\n                list_id,\n                attrib={FTRACK_ID_ATTRIB: ft_list_id},\n            )\n            entity_list[\"attrib\"][FTRACK_ID_ATTRIB] = ft_list_id\n\n            entity_key = collections.OrderedDict(id=ft_list_id)\n            op = ftrack_api.operation.CreateEntityOperation(\n                \"List\",\n                entity_key,\n                {\n                    \"id\": ft_list_id,\n                    \"name\": label,\n                    \"is_open\": True,\n                    \"category_id\": list_category[\"id\"],\n                    \"project_id\": ftrack_project[\"id\"],\n                    \"system_type\": system_type,\n                }\n            )\n            self._session.recorded_operations.push(op)\n            if list_type_value is not None:\n                op = self._get_ft_attr_value_operation(\n                    list_type_conf[\"id\"],\n                    ft_list_id,\n                    True,\n                    list_type_value,\n                )\n                self._session.recorded_operations.push(op)\n\n            self._log.info(\n                \"Creating new list '%s' on ftrack.\",\n                label\n            )\n            try:\n                self._session.commit()\n            finally:\n                self._session.recorded_operations.clear()\n\n        if ft_list_label and ft_list_label != label:\n            entity_key = collections.OrderedDict(id=ft_list_id)\n            op = ftrack_api.operation.UpdateEntityOperation(\n                \"List\",\n                entity_key,\n                \"name\",\n                ft_list_label,\n                label\n            )\n            self._session.recorded_operations.push(op)\n            try:\n                self._session.commit()\n            finally:\n                self._session.recorded_operations.clear()\n\n        # ---------------------------\n        # --- Update list objects ---\n        # ---------------------------\n        ft_list_objects = self._session.query(\n            \"select id, entity_id from ListObject\"\n            f\" where list_id is '{ft_list_id}'\"\n        ).all()\n        entity_list_items = entity_list[\"items\"]\n        # Both are empty\n        if not entity_list_items and not ft_list_objects:\n            return\n\n        ayon_ids = {i[\"entityId\"] for i in entity_list_items}\n        ids_mapping = {i: None for i in ayon_ids}\n        if entity_type == \"version\":\n            entities_by_id = {\n                entity[\"id\"]: entity\n                for entity in ayon_api.get_versions(\n                    project_name,\n                    version_ids=ayon_ids,\n                    fields={\"id\", f\"attrib.{FTRACK_ID_ATTRIB}\", \"productId\"}\n                )\n            }\n\n        elif entity_type == \"folder\":\n            entities_by_id = {\n                entity[\"id\"]: entity\n                for entity in ayon_api.get_folders(\n                    project_name,\n                    folder_ids=ayon_ids,\n                    fields={\"id\", f\"attrib.{FTRACK_ID_ATTRIB}\"}\n                )\n            }\n\n        else:\n            entities_by_id = {\n                entity[\"id\"]: entity\n                for entity in ayon_api.get_tasks(\n                    project_name,\n                    task_ids=ayon_ids,\n                    fields={\"id\", f\"attrib.{FTRACK_ID_ATTRIB}\"}\n                )\n            }\n\n        entities_wo_ft = []\n        for entity_id, ay_entity in entities_by_id.items():\n            ftrack_id = ay_entity[\"attrib\"].get(FTRACK_ID_ATTRIB)\n            if ftrack_id:\n                ids_mapping[entity_id] = ftrack_id\n            else:\n                entities_wo_ft.append(ay_entity)\n\n        if entity_type == \"version\":\n            ids_mapping.update(self._find_ftrack_versions(\n                project_name,\n                entities_wo_ft,\n            ))\n\n        ids_to_add = set(ids_mapping.values())\n        ids_to_add.discard(None)\n\n        current_ids = {\n            item[\"entity_id\"]: item[\"id\"]\n            for item in ft_list_objects\n        }\n        ids_to_remove = set(current_ids) - ids_to_add\n        ids_to_add = ids_to_add - set(current_ids)\n\n        ft_cust_attr_ay_ids = []\n        if ids_to_remove:\n            attr_def = self._session.query(\n                 \"select id from CustomAttributeConfiguration\"\n                 f\" where key is '{CUST_ATTR_KEY_SERVER_ID}'\"\n            ).first()\n            if attr_def:\n                ft_cust_attr_ay_ids = query_custom_attribute_values(\n                    self._session,\n                    {attr_def[\"id\"]},\n                    ids_to_remove,\n                )\n\n        # Discard entities that don't have ayon id filled\n        for value_item in ft_cust_attr_ay_ids:\n            entity_id = value_item[\"entity_id\"]\n            if not value_item[\"value\"]:\n                ids_to_remove.discard(entity_id)\n\n        for ftrack_id in ids_to_add:\n            item_id = str(uuid.uuid4())\n            entity_key = collections.OrderedDict(id=item_id)\n            op = ftrack_api.operation.CreateEntityOperation(\n                \"ListObject\",\n                entity_key,\n                {\n                    \"id\": item_id,\n                    \"entity_id\": ftrack_id,\n                    \"list_id\": ft_list_id,\n                }\n            )\n            self._session.recorded_operations.push(op)\n\n        for ftrack_id in ids_to_remove:\n            list_item_id = current_ids[ftrack_id]\n            entity_key = collections.OrderedDict(id=list_item_id)\n            op = ftrack_api.operation.DeleteEntityOperation(\n                \"ListObject\",\n                entity_key\n            )\n            self._session.recorded_operations.push(op)\n\n        self._log.info(\"Changing ftrack list objects to match AYON items\")\n        if self._session.recorded_operations:\n            try:\n                self._session.commit()\n            finally:\n                self._session.recorded_operations.clear()\n\n    def _find_ftrack_versions(\n        self,\n        project_name: str,\n        version_entites: list[dict[str, Any]],\n    ) -&gt; dict[str, Optional[str]]:\n        output = {\n            version_entity[\"id\"]: None\n            for version_entity in version_entites\n        }\n        if not version_entites:\n            return output\n\n        products_by_id = {}\n        folder_ids = set()\n        for product_entity in ayon_api.get_products(\n            project_name,\n            product_ids={\n                version_entity[\"productId\"]\n                for version_entity in version_entites\n            },\n            fields={\"id\", \"name\", \"folderId\"},\n        ):\n            folder_ids.add(product_entity[\"folderId\"])\n            product_id = product_entity[\"id\"]\n            products_by_id[product_id] = product_entity\n\n        ft_ids = set()\n        ftrack_id_by_folder_id = {}\n        for folder_entity in ayon_api.get_folders(\n            project_name,\n            folder_ids=folder_ids,\n            fields={\"id\", f\"attrib.{FTRACK_ID_ATTRIB}\"},\n        ):\n            ftrack_id = folder_entity[\"attrib\"].get(FTRACK_ID_ATTRIB)\n            if not ftrack_id:\n                continue\n            folder_id = folder_entity[\"id\"]\n            ft_ids.add(ftrack_id)\n            ftrack_id_by_folder_id[folder_id] = ftrack_id\n\n        joined_ft_ids = join_filter_values(ft_ids)\n        ft_assets_by_parent_id = {\n            ft_id: []\n            for ft_id in ft_ids\n        }\n        ft_asset_ids = set()\n        for ft_asset in self._session.query(\n            \"select id, name, context_id from Asset\"\n            f\" where context_id in ({joined_ft_ids})\"\n        ).all():\n            parent_id = ft_asset[\"context_id\"]\n            ft_assets_by_parent_id[parent_id].append(ft_asset)\n            ft_asset_ids.add(ft_asset[\"id\"])\n\n        joined_ft_asset_ids = join_filter_values(ft_asset_ids)\n        ft_versions_by_asset_id = {\n            asset_id: []\n            for asset_id in ft_asset_ids\n        }\n        for ft_version in self._session.query(\n            \"select id, asset_id, version from AssetVersion\"\n            f\" where asset_id in ({joined_ft_asset_ids})\"\n        ).all():\n            asset_id = ft_version[\"asset_id\"]\n            ft_versions_by_asset_id[asset_id].append(ft_version)\n\n        for version_entity in version_entites:\n            product_id = version_entity[\"productId\"]\n            product_entity = products_by_id.get(product_id)\n            if not product_entity:\n                continue\n\n            folder_id = product_entity[\"folderId\"]\n            ft_id = ftrack_id_by_folder_id.get(folder_id)\n            if not ft_id:\n                continue\n\n            product_name_low = product_entity[\"name\"].lower()\n            matching_ft_asset = None\n            alternatives = []\n            for ft_asset in ft_assets_by_parent_id[ft_id]:\n                low_name = ft_asset[\"name\"].lower()\n                if low_name == product_name_low:\n                    matching_ft_asset = ft_asset\n                    break\n\n                if product_name_low in low_name:\n                    alternatives.append(ft_asset)\n\n            if matching_ft_asset is None and alternatives:\n                matching_ft_asset = alternatives[0]\n\n            if matching_ft_asset is None:\n                continue\n\n            for version in ft_versions_by_asset_id[matching_ft_asset[\"id\"]]:\n                if version[\"version\"] == version_entity[\"version\"]:\n                    output[version_entity[\"id\"]] = version[\"id\"]\n                    break\n\n        return output\n\n    def _process_entity_event(self, source_event: dict[str, Any]):\n        entity_data: Optional[EntityEventData] = self._convert_entity_event(\n            source_event\n        )\n        if entity_data is None:\n            return\n\n        if entity_data.action == \"updated\":\n            self._handle_update_event(entity_data)\n        else:\n            self._log.info(f\"Unhandled action '{entity_data.action}'\")\n\n    def _convert_entity_event(\n        self, source_event: Dict[str, Any]\n    ) -&gt; Optional[EntityEventData]:\n        # TODO find out if this conversion makes sense?\n        topic: str = source_event[\"topic\"]\n        topic_parts = topic.split(\".\")\n        if len(topic_parts) != 3:\n            self._log.warning(\n                f\"Unexpected topic strucure: '{topic}'.\"\n                \" Expected 'entity.&lt;entity_type&gt;.&lt;change_type&gt;'\",\n            )\n        head, entity_type, change_type = topic_parts\n        if head != \"entity\":\n            self._log.warning(f\"Unexpected topic: {topic}\")\n            return None\n\n        project_name = source_event[\"project\"]\n        entity_id = None\n        if entity_type == \"project\":\n            entity_id = project_name\n        update_key = changes = entity_data = None\n        if change_type == \"created\":\n            action = \"created\"\n            if entity_id is None:\n                entity_id = source_event[\"summary\"][\"entityId\"]\n\n        elif change_type == \"deleted\":\n            action = \"deleted\"\n            entity_data = {}\n            if entity_type != \"project\":\n                entity_data = source_event[\"payload\"][\"entityData\"]\n                entity_id = entity_data[\"id\"]\n\n        else:\n            action = \"updated\"\n            if entity_id is None:\n                entity_id = source_event[\"summary\"][\"entityId\"]\n\n            # NOTE this is special behavior of project changes\n            # - At the moment of this change project changes do trigger only\n            #   'entity.project.changed' topic which does not contain\n            #   information about \"what\" changed.\n            # - There is an issue to trigger 'entity.project.attrib_changed'\n            #   which might make this obsolete.\n            if entity_type == \"project\" and change_type == \"changed\":\n                update_key = \"attrib\"\n                project_entity = _get_entity_by_id(\n                    project_name, entity_type, entity_id, logger=self._log\n                )\n                changes = {\n                    \"old\": {\"attrib\": project_entity[\"attrib\"]},\n                    \"new\": {\"attrib\": project_entity[\"attrib\"]},\n                }\n            else:\n                update_key, changes = self._prepare_update_data(\n                    source_event, change_type, entity_type\n                )\n            if update_key is None or changes is None:\n                return None\n\n        return EntityEventData(\n            action=action,\n            project_name=project_name,\n            entity_type=entity_type,\n            entity_id=entity_id,\n            entity_data=entity_data,\n            update_key=update_key,\n            changes=changes,\n        )\n\n    def _prepare_update_data(self, source_event, change_type, entity_type):\n        if change_type in (\n            \"tags\", \"data\", \"thumbnail\", \"active\",\n        ):\n            return None, None\n\n        payload = source_event[\"payload\"]\n\n        if change_type == \"renamed\":\n            change_type = \"name\"\n        elif change_type.endswith(\"_changed\"):\n            change_type = change_type[:-8]\n\n        if change_type == \"type\":\n            if entity_type == \"folder\":\n                change_type = \"folderType\"\n            elif entity_type == \"task\":\n                change_type = \"taskType\"\n            elif entity_type == \"product\":\n                change_type = \"productType\"\n\n        changes = None\n        if change_type == \"attrib\":\n            changes = {\n                \"old\": {\"attrib\": payload[\"oldValue\"]},\n                \"new\": {\"attrib\": payload[\"newValue\"]},\n            }\n\n        if change_type in (\n            \"name\",\n            \"label\",\n            \"assignees\",\n            \"status\",\n        ):\n            changes = {\n                \"old\": {change_type: payload[\"oldValue\"]},\n                \"new\": {change_type: payload[\"newValue\"]},\n            }\n\n        return change_type, changes\n\n    def _handle_update_event(self, entity_data: EntityEventData):\n        entity_type = entity_data.entity_type\n        self._log.info(\n            f\"Entity {entity_type} &lt;{entity_data.entity_id}&gt; changed\"\n            f\" in project {entity_data.project_name}\"\n        )\n        # TODO implement all entities\n        if entity_type == \"product\":\n            self._log.info(\n                f\"Unhandled change of entity type '{entity_type}'.\"\n            )\n            return\n\n        entity = entity_data.get_ayon_entity()\n        if entity is None:\n            self._log.warning(\n                f\"Entity with id '{entity_data.entity_id}'\"\n                f\" not found in Project '{entity_data.project_name}'\"\n            )\n            return\n\n        project_name = entity_data.project_name\n        project_settings = ayon_api.get_addons_settings(\n            project_name=project_name\n        )\n        if not self._is_project_enabled(\n            project_name,\n            project_settings=project_settings,\n        ):\n            return\n\n        # TODO implement more logic\n        if entity_data.update_key == \"attrib\":\n            self._handle_attrib_change(entity_data, project_settings)\n        elif entity_type == \"project\":\n            self._log.info(\n                \"Unhandled change of project entity\"\n                f\" '{entity_data.update_key}'.\"\n            )\n        elif entity_data.update_key == \"status\":\n            self._handle_status_change(entity_data)\n        elif entity_data.update_key == \"assignees\":\n            if entity_type == \"task\":\n                self._handle_task_assignees_change(entity_data)\n        else:\n            self._log.info(\"Unhandled entity update event\")\n\n    def _find_ftrack_entity(\n        self,\n        project_name: str,\n        entity_type: str,\n        entity_data: Dict[str, Any],\n        fields: Optional[Set[str]] = None,\n    ):\n        ft_entity_type = None\n        type_fields = set()\n        if entity_type == \"project\":\n            ft_entity_type = \"Project\"\n            type_fields = {\"name\", \"full_name\"}\n        elif entity_type == \"version\":\n            ft_entity_type = \"AssetVersion\"\n        elif entity_type in {\"task\", \"folder\"}:\n            ft_entity_type = \"TypedContext\"\n            type_fields = {\"type_id\", \"object_type_id\"}\n\n        if ft_entity_type is None:\n            return None\n\n        if fields is None:\n            fields = {\"id\"}\n        else:\n            fields.add(\"id\")\n\n        fields |= type_fields\n\n        ft_entity = None\n        ftrack_id = entity_data[\"attrib\"].get(FTRACK_ID_ATTRIB)\n        if ftrack_id:\n            joined_fields = \", \".join(fields)\n            ft_entity = self._session.query(\n                f\"select {joined_fields} from {ft_entity_type}\"\n                f\" where id is '{ftrack_id}'\"\n            ).first()\n\n        if ft_entity is not None:\n            return ft_entity\n\n        if entity_type != \"version\":\n            return None\n\n        product_id = entity_data[\"productId\"]\n        product_entity = ayon_api.get_product_by_id(\n            project_name,\n            product_id,\n            fields={\"name\", \"productType\", \"folderId\"},\n        )\n        folder_entity = ayon_api.get_folder_by_id(\n            project_name,\n            product_entity[\"folderId\"],\n            fields={\"attrib\"},\n        )\n        folder_ft_entity = self._find_ftrack_entity(\n            project_name,\n            \"folder\",\n            folder_entity\n        )\n        if folder_ft_entity is None:\n            return None\n\n        product_name = product_entity[\"name\"].lower()\n        folder_id = folder_ft_entity[\"id\"]\n        assets = self._session.query(\n            \"select id, name from Asset\"\n            f\" where context_id is '{folder_id}'\"\n        ).all()\n        matching_asset = None\n        for asset in assets:\n            if asset[\"name\"].lower() == product_name:\n                matching_asset = asset\n                break\n\n        if matching_asset is None:\n            return None\n\n        asset_id = matching_asset[\"id\"]\n\n        joined_fields = \", \".join(fields)\n        version = entity_data[\"version\"]\n        return self._session.query(\n            f\"select {joined_fields} from {ft_entity_type}\"\n            f\" where asset_id is '{asset_id}' and version is {version}\"\n        ).first()\n\n    def _get_ftrack_entity(\n        self,\n        entity_data: EntityEventData,\n        fields: Optional[Set[str]] = None,\n    ):\n        return self._find_ftrack_entity(\n            entity_data.project_name,\n            entity_data.entity_type,\n            entity_data.get_ayon_entity(),\n            fields\n        )\n\n    def _handle_status_change(self, entity_data: EntityEventData):\n        self._log.info(\"Handling status changes.\")\n        # Status on project and product cannot be changed\n        if entity_data.entity_type in {\"project\", \"product\"}:\n            return\n\n        ftrack_project = self._session.query(\n            \"select id, project_schema_id from Project\"\n            f\" where full_name is '{entity_data.project_name}'\"\n        ).first()\n        if not ftrack_project:\n            self._log.info(\n                f\"Project '{entity_data.project_name}' not found in ftrack.\"\n            )\n            return\n\n        new_status = entity_data.changes[\"new\"][\"status\"]\n        status_by_id = {\n            status[\"id\"]: status[\"name\"]\n            for status in self._session.query(\n                \"select id, name from Status\"\n            ).all()\n        }\n        filtered_statuses = {\n            status_id: status_name\n            for status_id, status_name in status_by_id.items()\n            if status_name.lower() == new_status.lower()\n        }\n        if not filtered_statuses:\n            self._log.info(\n                f\"Status '{new_status}' is not found in ftrack.\"\n            )\n            return\n\n        ft_entity = self._get_ftrack_entity(entity_data, {\"status_id\"})\n        if ft_entity is None:\n            self._log.info(\"Entity was not found in ftrack.\")\n            return\n\n        status_id = ft_entity[\"status_id\"]\n        # Status is already set\n        if filtered_statuses.get(status_id):\n            return\n\n        status_ids = self._get_available_ft_statuses(\n            ft_entity, ftrack_project[\"project_schema_id\"]\n        )\n        for status_id in status_ids:\n            if filtered_statuses.get(status_id):\n                self._log.info(\"Setting new status in ftrack.\")\n                ft_entity[\"status_id\"] = status_id\n                self._session.commit()\n                return\n\n        self._log.info(\n            f\"Status '{new_status}' is not available for ftrack entity.\"\n        )\n\n    def _get_available_ft_statuses(\n        self,\n        ft_entity: \"FtrackEntityType\",\n        project_schema_id: str,\n    ) -&gt; Set[str]:\n        is_version = is_folder = False\n        if ft_entity.entity_type.lower() == \"assetversion\":\n            is_version = True\n            fields = {\"asset_version_workflow_schema\"}\n        elif ft_entity.entity_type.lower() == \"task\":\n            fields = {\n                \"task_workflow_schema\",\n                \"task_workflow_schema_overrides\",\n            }\n        else:\n            is_folder = True\n            fields = {\"object_type_schemas\"}\n\n        joined_fields = \", \".join(fields)\n        project_schema = self._session.query(\n            f\"select {joined_fields} from ProjectSchema\"\n            f\" where id is '{project_schema_id}'\"\n        ).first()\n\n        if is_version:\n            av_workflow_schema_id = (\n                project_schema[\"asset_version_workflow_schema\"][\"id\"]\n            )\n            workflow_statuses = self._session.query(\n                \"select status_id\"\n                \" from WorkflowSchemaStatus\"\n                f\" where workflow_schema_id is '{av_workflow_schema_id}'\"\n            ).all()\n            return {\n                workflow[\"status_id\"]\n                for workflow in workflow_statuses\n            }\n\n        if is_folder:\n            object_type_id = ft_entity[\"object_type_id\"]\n            schema_ids = {\n                schema[\"id\"]\n                for schema in project_schema[\"object_type_schemas\"]\n            }\n            joined_ids = join_filter_values(schema_ids)\n            schema = self._session.query(\n                \"select id, object_type_id from Schema\"\n                f\" where id in ({joined_ids})\"\n                f\" and object_type_id is '{object_type_id}'\"\n            ).first()\n            if not schema:\n                return set()\n\n            schema_id = schema[\"id\"]\n            schema_statuses = self._session.query(\n                \"select status_id from SchemaStatus\"\n                f\" where schema_id is '{schema_id}'\"\n            ).all()\n            return {\n                status[\"status_id\"]\n                for status in schema_statuses\n            }\n\n        type_id = ft_entity[\"type_id\"]\n        task_workflow_override_ids = {\n            task_override[\"id\"]\n            for task_override in\n            project_schema[\"task_workflow_schema_overrides\"]\n        }\n        overrides_schema = None\n        if task_workflow_override_ids:\n            joined_ids = join_filter_values(task_workflow_override_ids)\n            overrides_schema = self._session.query(\n                \"select workflow_schema_id\"\n                f\" from ProjectSchemaOverride\"\n                f\" where id in ({joined_ids}) and type_id is '{type_id}'\"\n            ).first()\n\n        workflow_id = project_schema[\"task_workflow_schema\"][\"id\"]\n        if overrides_schema is not None:\n            workflow_id = overrides_schema[\"workflow_schema_id\"]\n        workflow_statuses = self._session.query(\n            \"select status_id\"\n            \" from WorkflowSchemaStatus\"\n            f\" where workflow_schema_id is '{workflow_id}'\"\n        ).all()\n        return {\n            item[\"status_id\"]\n            for item in workflow_statuses\n        }\n\n    def _handle_task_assignees_change(self, entity_data: EntityEventData):\n        self._log.info(\"Handling assignees changes.\")\n        entity = entity_data.get_ayon_entity()\n        # Find ftrack task entity\n        task_ftrack_id = entity[\"attrib\"].get(FTRACK_ID_ATTRIB)\n        # QUESTION try to find entity by path?\n        if not task_ftrack_id:\n            self._log.info(\"Task is not linked to ftrack.\")\n            return\n\n        ft_entity = self._session.query(\n            f\"Task where id is '{task_ftrack_id}'\"\n        ).first()\n        if ft_entity is None:\n            self._log.info(\n                f\"ftack entity with id '{task_ftrack_id}' was not found.\"\n            )\n            return\n\n        changes = entity_data.changes\n        # Split added and removed assignees\n        added_assignees = (\n            set(changes[\"new\"][\"assignees\"])\n            - set(changes[\"old\"][\"assignees\"])\n        )\n        removed_assignees = (\n            set(changes[\"old\"][\"assignees\"])\n            - set(changes[\"new\"][\"assignees\"])\n        )\n\n        ft_users = self._session.query(\n            \"select id, username, email from User\"\n        ).all()\n        ayon_username_by_ft_id = map_ftrack_users_to_ayon_users(ft_users)\n        ft_id_by_ay_username = {\n            ayon_username: ft_user_id\n            for ft_user_id, ayon_username in ayon_username_by_ft_id.items()\n            if ayon_username\n        }\n        # Skip if there is no valid user mapping for changed assignees\n        changed_assignees = added_assignees | removed_assignees\n        if not set(ft_id_by_ay_username) &amp; changed_assignees:\n            self._log.info(\n                \"Changed assignees in AYON don't have\"\n                \" valid mapping to ftrack users.\"\n            )\n            return\n\n        appointments = self._session.query(\n            \"select resource_id, context_id from Appointment\"\n            f\" where context_id is '{task_ftrack_id}'\"\n            \" and type is 'assignment'\"\n        ).all()\n        appointments_by_user_ids = {\n            appointment[\"resource_id\"]: appointment\n            for appointment in appointments\n        }\n        for ayon_username in added_assignees:\n            ftrack_id = ft_id_by_ay_username.get(ayon_username)\n            if not ftrack_id:\n                continue\n\n            if ftrack_id in appointments_by_user_ids:\n                self._log.info(\n                    f\"AYON user '{ayon_username}'\"\n                    f\" is already assigned in ftrack.\"\n                )\n                continue\n\n            self._session.create(\n                \"Appointment\",\n                {\n                    \"resource_id\": ftrack_id,\n                    \"context_id\": task_ftrack_id,\n                    \"type\": \"assignment\",\n                }\n            )\n            self._log.info(\n                f\"Creating assignment of user '{ayon_username}' in ftrack.\"\n            )\n\n        for ayon_username in removed_assignees:\n            ftrack_id = ft_id_by_ay_username.get(ayon_username)\n            if not ftrack_id:\n                continue\n            if ftrack_id not in appointments_by_user_ids:\n                self._log.info(\n                    f\"AYON user '{ayon_username}' is not assigned in ftrack.\"\n                )\n                continue\n            self._session.delete(appointments_by_user_ids[ftrack_id])\n            self._log.info(\n                f\"Removing assignment of user '{ayon_username}' in ftrack.\"\n            )\n\n        if self._session.recorded_operations:\n            self._session.commit()\n\n    def _handle_attrib_change(\n        self, entity_data: EntityEventData, project_settings: Dict[str, Any]\n    ):\n        ft_entity = self._get_ftrack_entity(entity_data)\n        if ft_entity is None:\n            self._log.info(\"Entity was not found in ftrack.\")\n            return\n\n        new_attribs = entity_data.changes[\"new\"][\"attrib\"]\n        new_attrib_names = set(new_attribs)\n        default_keys = {\n            name\n            for name in new_attrib_names\n            if name in DEFAULT_ATTRS_MAPPING\n        }\n\n        default_key_changed = False\n        for name in default_keys:\n            mapped_name = DEFAULT_ATTRS_MAPPING[name]\n            new_value = new_attribs[name]\n            attribute = ft_entity.attributes.get(mapped_name)\n            # Skip if attribute is not mutable or value is the same\n            if (\n                attribute is None\n                or not attribute.mutable\n                or ft_entity[mapped_name] == new_value\n            ):\n                continue\n            ft_entity[mapped_name] = new_value\n            default_key_changed = True\n\n        if default_key_changed:\n            try:\n                self._session.commit()\n            finally:\n                self._session.recorded_operations.clear()\n\n        new_attrib_names -= default_keys\n        if not new_attrib_names:\n            return\n\n        attr_configs = get_all_attr_configs(self._session)\n        attrs_mapping = get_custom_attributes_mapping(\n            self._session,\n            project_settings[\"ftrack\"],\n            attr_configs,\n        )\n        mapped_configs = {}\n        valid_conf_ids = set()\n        for attr_name in new_attrib_names:\n            mapping_item = attrs_mapping.get(attr_name)\n            attr_conf = None\n            if mapping_item is not None:\n                attr_conf = mapping_item.get_attr_conf_for_entity(ft_entity)\n\n            if (\n                attr_conf is not None\n                and self._is_attr_conf_valid(attr_conf, entity_data)\n            ):\n                mapped_configs[attr_name] = attr_conf\n                valid_conf_ids.add(attr_conf[\"id\"])\n\n        missing = new_attrib_names - set(mapped_configs)\n        if missing:\n            joined_missing = \", \".join([f'\"{key}\"' for key in missing])\n            self._log.info(\n                f\"Attributes {joined_missing} not found in ftrack.\"\n            )\n\n        if not attr_configs:\n            return\n\n        value_items = query_custom_attribute_values(\n            self._session,\n            valid_conf_ids,\n            {ft_entity[\"id\"]}\n        )\n        values_by_attr_id = {\n            value_item[\"configuration_id\"]: value_item[\"value\"]\n            for value_item in value_items\n        }\n        ayon_entity = entity_data.get_ayon_entity()\n        any_changed = False\n        for key, attr_conf in mapped_configs.items():\n            new_value = new_attribs[key]\n            attr_id = attr_conf[\"id\"]\n            is_new = attr_id not in values_by_attr_id\n            old_value = values_by_attr_id.get(attr_id)\n            if new_value is None and not attr_conf[\"is_hierarchical\"]:\n                # NOTE Hack, non-hierarchical attributes will be set\n                #   to current value on entity if new value is 'None'\n                new_value = ayon_entity[\"attrib\"][key]\n\n            # Value is already same (or both are unset)\n            if new_value == old_value:\n                continue\n\n            any_changed = True\n            op = self._get_ft_attr_value_operation(\n                attr_id,\n                ft_entity[\"id\"],\n                is_new,\n                new_value,\n                old_value\n            )\n            self._session.recorded_operations.push(op)\n\n        if any_changed:\n            try:\n                self._session.commit()\n            finally:\n                self._session.recorded_operations.clear()\n\n    def _is_attr_conf_valid(self, attr_conf, entity_data):\n        if attr_conf[\"is_hierarchical\"]:\n            return True\n\n        if attr_conf[\"entity_type\"] == \"context\":\n            return entity_data.entity_type in (\"project\", \"folder\", \"task\")\n\n        if attr_conf[\"entity_type\"] == \"show\":\n            return entity_data.entity_type == \"project\"\n\n        if attr_conf[\"entity_type\"] == \"asset\":\n            return entity_data.entity_type == \"product\"\n\n        if attr_conf[\"entity_type\"] == \"assetversion\":\n            return entity_data.entity_type == \"version\"\n\n        if (\n            attr_conf[\"entity_type\"] != \"task\"\n            or entity_data.entity_type not in (\"folder\", \"task\")\n        ):\n            return False\n\n        obj_type_id = attr_conf[\"object_type_id\"]\n        object_type = self._session.query(\n            f\"select id, name from ObjectType where id is '{obj_type_id}'\"\n        ).first()\n        if object_type is None:\n            return False\n\n        obj_name = object_type[\"name\"].lower()\n        if entity_data.entity_type == \"task\":\n            return obj_name == \"task\"\n\n        ayon_entity = entity_data.get_ayon_entity()\n        if ayon_entity:\n            return ayon_entity[\"folderType\"].lower() == obj_name\n        return False\n\n    def _get_ft_attr_value_operation(\n        self,\n        conf_id: str,\n        entity_id: str,\n        is_new: bool,\n        new_value: Any,\n        old_value: Optional[Any] = None,\n    ):\n        entity_key = collections.OrderedDict((\n            (\"configuration_id\", conf_id),\n            (\"entity_id\", entity_id)\n        ))\n        if is_new:\n            return ftrack_api.operation.CreateEntityOperation(\n                \"CustomAttributeValue\",\n                entity_key,\n                {\"value\": new_value}\n            )\n\n        if new_value is None:\n            return ftrack_api.operation.DeleteEntityOperation(\n                \"CustomAttributeValue\",\n                entity_key\n            )\n\n        return ftrack_api.operation.UpdateEntityOperation(\n            \"CustomAttributeValue\",\n            entity_key,\n            \"value\",\n            old_value,\n            new_value\n        )\n\n    def _get_sync_project_names(self):\n        \"\"\"Get project names that are enabled for ftrack sync.\"\"\"\n        ayon_project_names = set(ayon_api.get_project_names())\n        ft_project_names = {\n            project[\"full_name\"]\n            for project in self._session.query(\n                \"select full_name from Project\"\n            ).all()\n        }\n\n        project_names = []\n        for project_name in ayon_project_names &amp; ft_project_names:\n            if self._is_project_enabled(project_name):\n                project_names.append(project_name)\n        return project_names\n\n    def _create_ftrack_note(\n        self, project_name, entity, entity_type, activity, ft_user\n    ):\n        if entity is None:\n            return\n\n        ftrack_entity = self._find_ftrack_entity(\n            project_name,\n            entity_type,\n            entity,\n        )\n        if ftrack_entity is None or \"notes\" not in ftrack_entity:\n            return\n\n        parent_type = \"TypedContext\"\n        if entity_type == \"version\":\n            parent_type = \"AssetVersion\"\n\n        note_id = str(uuid.uuid4())\n        # Use direct call to ftrack without using recorded operations\n        # - skip append note to parent entity, it is causing issues in\n        #   ftrack backend, and looks like it works without it.\n        batch = [\n            {\n                \"action\": \"create\",\n                \"entity_data\": {\n                    \"__entity_type__\": \"Note\",\n                    \"user_id\": ft_user[\"id\"],\n                    \"content\": activity[\"body\"],\n                    \"id\": note_id,\n                    \"is_todo\": False,\n                    \"parent_id\": ftrack_entity[\"id\"],\n                    \"parent_type\": parent_type\n                },\n                \"entity_key\": [note_id],\n                \"entity_type\": \"Note\"\n            }, {\n                \"action\": \"create\",\n                \"entity_data\": {\n                    \"__entity_type__\": \"Metadata\",\n                    \"key\": \"ayon_activity_id\",\n                    \"parent_id\": note_id,\n                    \"parent_type\": \"Note\",\n                    \"value\": activity[\"activityId\"]\n                },\n                \"entity_key\": [note_id, \"ayon_activity_id\"],\n                \"entity_type\": \"Metadata\"\n            }\n        ]\n\n        # Store note id to AYON activity data\n        activity_data = activity[\"activityData\"]\n        ftrack_data = activity_data.setdefault(\"ftrack\", {})\n        ftrack_data[\"id\"] = note_id\n        ayon_api.update_activity(\n            project_name,\n            activity[\"activityId\"],\n            data=activity_data,\n        )\n\n        try:\n            self._session.call(batch)\n\n        except Exception:\n            self._log.warning(\"Failed to create Note\", exc_info=True)\n\n    def _sync_project_comments(\n        self,\n        project_name: str,\n        ft_id_by_ay_username: Dict[Union[str, None], Optional[str]],\n        ft_users_by_id: Dict[str, \"ftrack_api.entity.user.User\"],\n        activities_after_date: arrow.Arrow,\n    ) -&gt; int:\n        project_activities = list(ayon_api.get_activities(\n            project_name,\n            activity_types={\"comment\"},\n            changed_after=activities_after_date.isoformat(),\n        ))\n        if not project_activities:\n            return 0\n\n        entity_ids_by_entity_type = collections.defaultdict(set)\n        for activity in project_activities:\n            entity_id = activity[\"entityId\"]\n            entity_type = activity[\"entityType\"]\n            entity_ids_by_entity_type[entity_type].add(entity_id)\n\n        entities_by_id = {}\n        for entity_type, entity_ids in entity_ids_by_entity_type.items():\n            entities = []\n            if entity_type == \"folder\":\n                entities = ayon_api.get_folders(\n                    project_name, folder_ids=entity_ids\n                )\n            elif entity_type == \"task\":\n                entities = ayon_api.get_tasks(\n                    project_name, task_ids=entity_ids\n                )\n            elif entity_type == \"version\":\n                entities = ayon_api.get_versions(\n                    project_name, version_ids=entity_ids\n                )\n            entities_by_id.update({\n                entity[\"id\"]: entity\n                for entity in entities\n            })\n\n        # NOTE Because we have to wait 1 second between creating notes\n        #   we might want to optimize this in the future to process\n        #   activities per entity, and if comment cannot be created because\n        #   we should wait, then go to other entities until the time comes.\n        # With 5 entities each having 2 new comments during one batch process\n        #   we have to wait total 5 seconds, at least. More entities and\n        #   comments, the bigger wait time is.\n        # With optimization per entity, the wait time would be the biggest\n        #   amount of new comments per entity (entity count is not important).\n        #   That would be 1 second in case above.\n        last_created_by_entity_id = {}\n        for activity in project_activities:\n            activity_data = activity[\"activityData\"]\n            ftrack_data = activity_data.setdefault(\"ftrack\", {})\n            orig_ftrack_id = ftrack_data.get(\"id\")\n            ft_note = None\n            if orig_ftrack_id:\n                ft_note = self._session.query(\n                    \"select id, content, metadata from Note\"\n                    f\" where id is '{orig_ftrack_id}'\"\n                ).first()\n\n            if ft_note is None:\n                entity_id = activity[\"entityId\"]\n                entity = entities_by_id.get(entity_id)\n                entity_type = activity[\"entityType\"]\n                ayon_username = activity[\"author\"][\"name\"]\n                ft_user_id = ft_id_by_ay_username.get(ayon_username)\n                if not ft_user_id:\n                    ft_user_id = ft_id_by_ay_username[None]\n                ft_user = ft_users_by_id[ft_user_id]\n                # Make sure there is at least 1 second difference between\n                #   note creation to keep order of notes in ftrack\n                last_created = last_created_by_entity_id.get(entity_id)\n                diff = time.time() - (last_created or 0)\n                if diff &lt; 1.0:\n                    time.sleep(1.0 - diff)\n                self._create_ftrack_note(\n                    project_name, entity, entity_type, activity, ft_user\n                )\n                last_created_by_entity_id[entity_id] = time.time()\n\n            else:\n                if ft_note[\"content\"] != activity[\"body\"]:\n                    ft_note[\"content\"] = activity[\"body\"]\n\n                activity_id = activity[\"activityId\"]\n                metadata_id = ft_note[\"metadata\"].get(\"ayon_activity_id\")\n                if metadata_id != activity_id:\n                    ft_note[\"metadata\"][\"ayon_activity_id\"] = activity_id\n\n                if orig_ftrack_id != ft_note[\"id\"]:\n                    ftrack_data[\"id\"] = ft_note[\"id\"]\n                    ayon_api.update_activity(\n                        project_name,\n                        activity[\"activityId\"],\n                        data=activity_data,\n                    )\n\n            if self._session.recorded_operations:\n                self._session.commit()\n\n        return len(project_activities)\n</code></pre>"},{"location":"autoapi/services/transmitter/transmitter/logic.html#services.transmitter.transmitter.logic.EventProcessor.soft_cleanup_sync_comment_events","title":"<code>soft_cleanup_sync_comment_events(last_comments_soft_cleanup)</code>","text":"<p>Remove sync comment events that did not sync any comments.</p> <p>These comments are not relevant for any reference. The logic makes sure that last finished event, important for comments sync, is not removed.</p> Source code in <code>services/transmitter/transmitter/logic.py</code> <pre><code>def soft_cleanup_sync_comment_events(\n    self, last_comments_soft_cleanup: int\n) -&gt; bool:\n    \"\"\"Remove sync comment events that did not sync any comments.\n\n    These comments are not relevant for any reference. The logic makes\n    sure that last finished event, important for comments sync, is not\n    removed.\n\n    \"\"\"\n    self._log.debug(\"Soft cleaning up comment sync events.\")\n    any_in_progress = self._cleanup_in_progress_comment_events()\n    if any_in_progress:\n        return False\n\n    last_finished_event = self._get_last_finished_event()\n    last_event_id = None\n    if last_finished_event:\n        last_event_id = last_finished_event[\"id\"]\n\n    older_than = None\n    if last_comments_soft_cleanup:\n        cleanup_date = arrow.utcnow() - datetime.timedelta(\n            seconds=(last_comments_soft_cleanup + 20)\n        )\n        older_than = cleanup_date.isoformat()\n\n    events_to_cleanup = list(ayon_api.get_events(\n        topics={FTRACK_COMMENTS_TOPIC},\n        statuses={\"finished\"},\n        older_than=older_than,\n        fields={\"id\"}\n    ))\n    removed = 0\n    for event in events_to_cleanup:\n        event_id = event[\"id\"]\n        if event_id == last_event_id:\n            continue\n        full_event = ayon_api.get_event(event_id)\n        if not full_event[\"payload\"].get(\"synced_comments\"):\n            removed += 1\n            ayon_api.delete_event(event_id)\n    self._log.debug(f\"Soft cleaned up {removed} events\")\n    return True\n</code></pre>"},{"location":"autoapi/services/transmitter/transmitter/service.html","title":"service","text":""},{"location":"autoapi/services/transmitter/transmitter/structures.html","title":"structures","text":""}]}